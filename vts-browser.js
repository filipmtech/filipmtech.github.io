/*!
 * Copyright (c) 2021 Melown Technologies SE
 *  *  For terms of use, see accompanying vts-browser file.
 *  *  For 3rd party libraries licenses, see 3rdpartylicenses.txt.
 * 
 */
var vts =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/browser/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    var filteredBridge = filterPoints(bridge, bridge.next);
    filterPoints(bridgeReverse, bridgeReverse.next);

    // Check if input node was removed by the filtering
    return outerNode === bridge ? filteredBridge : outerNode;
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "./node_modules/geographiclib/geographiclib.js":
/*!*****************************************************!*\
  !*** ./node_modules/geographiclib/geographiclib.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Geodesic routines from GeographicLib translated to JavaScript.  See
 * https://geographiclib.sourceforge.io/html/js/
 *
 * The algorithms are derived in
 *
 *    Charles F. F. Karney,
 *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013),
 *    https://doi.org/10.1007/s00190-012-0578-z
 *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html
 *
 * This file is the concatenation and compression of the JavaScript files in
 * doc/scripts/GeographicLib in the source tree for GeographicLib.
 *
 * Copyright (c) Charles Karney (2011-2015) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 *
 * Version: 1.52.2
 * File inventory:
 *   Math.js Geodesic.js GeodesicLine.js PolygonArea.js DMS.js
 */

(function(cb) {

/**************** Math.js ****************/
/*
 * Math.js
 * Transcription of Math.hpp, Constants.hpp, and Accumulator.hpp into
 * JavaScript.
 *
 * Copyright (c) Charles Karney (2011-2021) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 */

/**
 * @namespace GeographicLib
 * @description The parent namespace for the following modules:
 * - {@link module:GeographicLib/Geodesic GeographicLib/Geodesic} The main
 *   engine for solving geodesic problems via the
 *   {@link module:GeographicLib/Geodesic.Geodesic Geodesic} class.
 * - {@link module:GeographicLib/GeodesicLine GeographicLib/GeodesicLine}
 *   computes points along a single geodesic line via the
 *   {@link module:GeographicLib/GeodesicLine.GeodesicLine GeodesicLine}
 *   class.
 * - {@link module:GeographicLib/PolygonArea GeographicLib/PolygonArea}
 *   computes the area of a geodesic polygon via the
 *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea}
 *   class.
 * - {@link module:GeographicLib/DMS GeographicLib/DMS} handles the decoding
 *   and encoding of angles in degree, minutes, and seconds, via static
 *   functions in this module.
 * - {@link module:GeographicLib/Constants GeographicLib/Constants} defines
 *   constants specifying the version numbers and the parameters for the WGS84
 *   ellipsoid.
 *
 * The following modules are used internally by the package:
 * - {@link module:GeographicLib/Math GeographicLib/Math} defines various
 *   mathematical functions.
 * - {@link module:GeographicLib/Accumulator GeographicLib/Accumulator}
 *   interally used by
 *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea} (via the
 *   {@link module:GeographicLib/Accumulator.Accumulator Accumulator} class)
 *   for summing the contributions to the area of a polygon.
 */

var GeographicLib = {};
GeographicLib.Constants = {};
GeographicLib.Math = {};
GeographicLib.Accumulator = {};

(function(
  /**
   * @exports GeographicLib/Constants
   * @description Define constants defining the version and WGS84 parameters.
   */
  c) {
  "use strict";

  /**
   * @constant
   * @summary WGS84 parameters.
   * @property {number} a the equatorial radius (meters).
   * @property {number} f the flattening.
   */
  c.WGS84 = { a: 6378137, f: 1/298.257223563 };
  /**
   * @constant
   * @summary an array of version numbers.
   * @property {number} major the major version number.
   * @property {number} minor the minor version number.
   * @property {number} patch the patch number.
   */
  c.version = { major: 1, minor: 52, patch: 2 };
  /**
   * @constant
   * @summary version string
   */
  c.version_string = "1.52.2";
})(GeographicLib.Constants);

(function(
  /**
   * @exports GeographicLib/Math
   * @description Some useful mathematical constants and functions (mainly for
   *   internal use).
   */
  m) {
  "use strict";

  /**
   * @summary The number of digits of precision in floating-point numbers.
   * @constant {number}
   */
  m.digits = 53;
  /**
   * @summary The machine epsilon.
   * @constant {number}
   */
  m.epsilon = Math.pow(0.5, m.digits - 1);
  /**
   * @summary The factor to convert degrees to radians.
   * @constant {number}
   */
  m.degree = Math.PI/180;

  /**
   * @summary Square a number.
   * @param {number} x the number.
   * @returns {number} the square.
   */
  m.sq = function(x) { return x * x; };

  /**
   * @summary The hypotenuse function.
   * @param {number} x the first side.
   * @param {number} y the second side.
   * @returns {number} the hypotenuse.
   */
  m.hypot = function(x, y) {
    // Built in Math.hypot give incorrect results from GeodSolve92.
    return Math.sqrt(x*x + y*y);
  };

  /**
   * @summary Cube root function.
   * @param {number} x the argument.
   * @returns {number} the real cube root.
   */
  m.cbrt = Math.cbrt || function(x) {
    var y = Math.pow(Math.abs(x), 1/3);
    return x > 0 ? y : (x < 0 ? -y : x);
  };

  /**
   * @summary The log1p function.
   * @param {number} x the argument.
   * @returns {number} log(1 + x).
   */
  m.log1p = Math.log1p || function(x) {
    var y = 1 + x,
        z = y - 1;
    // Here's the explanation for this magic: y = 1 + z, exactly, and z
    // approx x, thus log(y)/z (which is nearly constant near z = 0) returns
    // a good approximation to the true log(1 + x)/x.  The multiplication x *
    // (log(y)/z) introduces little additional error.
    return z === 0 ? x : x * Math.log(y) / z;
  };

  /**
   * @summary Inverse hyperbolic tangent.
   * @param {number} x the argument.
   * @returns {number} tanh<sup>&minus;1</sup> x.
   */
  m.atanh = Math.atanh || function(x) {
    var y = Math.abs(x);          // Enforce odd parity
    y = m.log1p(2 * y/(1 - y))/2;
    return x > 0 ? y : (x < 0 ? -y : x);
  };

  /**
   * @summary Copy the sign.
   * @param {number} x gives the magitude of the result.
   * @param {number} y gives the sign of the result.
   * @returns {number} value with the magnitude of x and with the sign of y.
   */
  m.copysign = function(x, y) {
    return Math.abs(x) * (y < 0 || (y === 0 && 1/y < 0) ? -1 : 1);
  };

  /**
   * @summary An error-free sum.
   * @param {number} u
   * @param {number} v
   * @returns {object} sum with sum.s = round(u + v) and sum.t is u + v &minus;
   *   round(u + v)
   */
  m.sum = function(u, v) {
    var s = u + v,
        up = s - v,
        vpp = s - up,
        t;
    up -= u;
    vpp -= v;
    t = -(up + vpp);
    // u + v =       s      + t
    //       = round(u + v) + t
    return {s: s, t: t};
  };

  /**
   * @summary Evaluate a polynomial.
   * @param {integer} N the order of the polynomial.
   * @param {array} p the coefficient array (of size N + 1) (leading
   *   order coefficient first)
   * @param {number} x the variable.
   * @returns {number} the value of the polynomial.
   */
  m.polyval = function(N, p, s, x) {
    var y = N < 0 ? 0 : p[s++];
    while (--N >= 0) y = y * x + p[s++];
    return y;
  };

  /**
   * @summary Coarsen a value close to zero.
   * @param {number} x
   * @returns {number} the coarsened value.
   */
  m.AngRound = function(x) {
    // The makes the smallest gap in x = 1/16 - nextafter(1/16, 0) = 1/2^57 for
    // reals = 0.7 pm on the earth if x is an angle in degrees.  (This is about
    // 1000 times more resolution than we get with angles around 90 degrees.)
    // We use this to avoid having to deal with near singular cases when x is
    // non-zero but tiny (e.g., 1.0e-200).  This converts -0 to +0; however
    // tiny negative numbers get converted to -0.
    if (x === 0) return x;
    var z = 1/16,
        y = Math.abs(x);
    // The compiler mustn't "simplify" z - (z - y) to y
    y = y < z ? z - (z - y) : y;
    return x < 0 ? -y : y;
  };

  /**
   * @summary The remainder function.
   * @param {number} x the numerator of the division
   * @param {number} y the denominator of the division
   * @return {number} the remainder in the range [&minus;y/2, y/2].
   * <p>
   * The range of x is unrestricted; y must be positive.
   */
  m.remainder = function(x, y) {
    x = x % y;
    return x < -y/2 ? x + y : (x < y/2 ? x : x - y);
  };

  /**
   * @summary Normalize an angle.
   * @param {number} x the angle in degrees.
   * @returns {number} the angle reduced to the range (&minus;180&deg;,
   *   180&deg;].
   */
  m.AngNormalize = function(x) {
    // Place angle in (-180, 180].
    x = m.remainder(x, 360);
    return x == -180 ? 180 : x;
  };

  /**
   * @summary Normalize a latitude.
   * @param {number} x the angle in degrees.
   * @returns {number} x if it is in the range [&minus;90&deg;, 90&deg;],
   *   otherwise return NaN.
   */
  m.LatFix = function(x) {
    // Replace angle with NaN if outside [-90, 90].
    return Math.abs(x) > 90 ? Number.NaN : x;
  };

  /**
   * @summary The exact difference of two angles reduced to (&minus;180&deg;,
   *   180&deg;]
   * @param {number} x the first angle in degrees.
   * @param {number} y the second angle in degrees.
   * @return {object} diff the exact difference, y &minus; x.
   *
   * This computes z = y &minus; x exactly, reduced to (&minus;180&deg;,
   * 180&deg;]; and then sets diff.s = d = round(z) and diff.t = e = z &minus;
   * round(z).  If d = &minus;180, then e &gt; 0; If d = 180, then e &le; 0.
   */
  m.AngDiff = function(x, y) {
    // Compute y - x and reduce to [-180,180] accurately.
    var r = m.sum(m.AngNormalize(-x), m.AngNormalize(y)),
        d = m.AngNormalize(r.s),
        t = r.t;
    return m.sum(d === 180 && t > 0 ? -180 : d, t);
  };

  /**
   * @summary Evaluate the sine and cosine function with the argument in
   *   degrees
   * @param {number} x in degrees.
   * @returns {object} r with r.s = sin(x) and r.c = cos(x).
   */
  m.sincosd = function(x) {
    // In order to minimize round-off errors, this function exactly reduces
    // the argument to the range [-45, 45] before converting it to radians.
    var r, q, s, c, sinx, cosx;
    r = x % 360;
    q = 0 + Math.round(r / 90); // If r is NaN this returns NaN
    r -= 90 * q;
    // now abs(r) <= 45
    r *= this.degree;
    // Possibly could call the gnu extension sincos
    s = Math.sin(r); c = Math.cos(r);
    switch (q & 3) {
    case 0:  sinx =  s; cosx =  c; break;
    case 1:  sinx =  c; cosx = -s; break;
    case 2:  sinx = -s; cosx = -c; break;
    default: sinx = -c; cosx =  s; break; // case 3
    }
    if (x !== 0) { sinx += 0; cosx += 0; }
    return {s: sinx, c: cosx};
  };

  /**
   * @summary Evaluate the atan2 function with the result in degrees
   * @param {number} y
   * @param {number} x
   * @returns atan2(y, x) in degrees, in the range (&minus;180&deg;
   *   180&deg;].
   */
  m.atan2d = function(y, x) {
    // In order to minimize round-off errors, this function rearranges the
    // arguments so that result of atan2 is in the range [-pi/4, pi/4] before
    // converting it to degrees and mapping the result to the correct
    // quadrant.
    var q = 0, t, ang;
    if (Math.abs(y) > Math.abs(x)) { t = x; x = y; y = t; q = 2; }
    if (x < 0) { x = -x; ++q; }
    // here x >= 0 and x >= abs(y), so angle is in [-pi/4, pi/4]
    ang = Math.atan2(y, x) / this.degree;
    switch (q) {
      // Note that atan2d(-0.0, 1.0) will return -0.  However, we expect that
      // atan2d will not be called with y = -0.  If need be, include
      //
      //   case 0: ang = 0 + ang; break;
      //
      // and handle mpfr as in AngRound.
    case 1: ang = (y >= 0 ? 180 : -180) - ang; break;
    case 2: ang =  90 - ang; break;
    case 3: ang = -90 + ang; break;
    default: break;
    }
    return ang;
  };
})(GeographicLib.Math);

(function(
  /**
   * @exports GeographicLib/Accumulator
   * @description Accurate summation via the
   *   {@link module:GeographicLib/Accumulator.Accumulator Accumulator} class
   *   (mainly for internal use).
   */
  a, m) {
  "use strict";

  /**
   * @class
   * @summary Accurate summation of many numbers.
   * @classdesc This allows many numbers to be added together with twice the
   *   normal precision.  In the documentation of the member functions, sum
   *   stands for the value currently held in the accumulator.
   * @param {number | Accumulator} [y = 0]  set sum = y.
   */
  a.Accumulator = function(y) {
    this.Set(y);
  };

  /**
   * @summary Set the accumulator to a number.
   * @param {number | Accumulator} [y = 0] set sum = y.
   */
  a.Accumulator.prototype.Set = function(y) {
    if (!y) y = 0;
    if (y.constructor === a.Accumulator) {
      this._s = y._s;
      this._t = y._t;
    } else {
      this._s = y;
      this._t = 0;
    }
  };

  /**
   * @summary Add a number to the accumulator.
   * @param {number} [y = 0] set sum += y.
   */
  a.Accumulator.prototype.Add = function(y) {
    // Here's Shewchuk's solution...
    // Accumulate starting at least significant end
    var u = m.sum(y, this._t),
        v = m.sum(u.s, this._s);
    u = u.t;
    this._s = v.s;
    this._t = v.t;
    // Start is _s, _t decreasing and non-adjacent.  Sum is now (s + t + u)
    // exactly with s, t, u non-adjacent and in decreasing order (except
    // for possible zeros).  The following code tries to normalize the
    // result.  Ideally, we want _s = round(s+t+u) and _u = round(s+t+u -
    // _s).  The follow does an approximate job (and maintains the
    // decreasing non-adjacent property).  Here are two "failures" using
    // 3-bit floats:
    //
    // Case 1: _s is not equal to round(s+t+u) -- off by 1 ulp
    // [12, -1] - 8 -> [4, 0, -1] -> [4, -1] = 3 should be [3, 0] = 3
    //
    // Case 2: _s+_t is not as close to s+t+u as it shold be
    // [64, 5] + 4 -> [64, 8, 1] -> [64,  8] = 72 (off by 1)
    //                    should be [80, -7] = 73 (exact)
    //
    // "Fixing" these problems is probably not worth the expense.  The
    // representation inevitably leads to small errors in the accumulated
    // values.  The additional errors illustrated here amount to 1 ulp of
    // the less significant word during each addition to the Accumulator
    // and an additional possible error of 1 ulp in the reported sum.
    //
    // Incidentally, the "ideal" representation described above is not
    // canonical, because _s = round(_s + _t) may not be true.  For
    // example, with 3-bit floats:
    //
    // [128, 16] + 1 -> [160, -16] -- 160 = round(145).
    // But [160, 0] - 16 -> [128, 16] -- 128 = round(144).
    //
    if (this._s === 0)          // This implies t == 0,
      this._s = u;              // so result is u
    else
      this._t += u;             // otherwise just accumulate u to t.
  };

  /**
   * @summary Return the result of adding a number to sum (but
   *   don't change sum).
   * @param {number} [y = 0] the number to be added to the sum.
   * @return sum + y.
   */
  a.Accumulator.prototype.Sum = function(y) {
    var b;
    if (!y)
      return this._s;
    else {
      b = new a.Accumulator(this);
      b.Add(y);
      return b._s;
    }
  };

  /**
   * @summary Set sum = &minus;sum.
   */
  a.Accumulator.prototype.Negate = function() {
    this._s *= -1;
    this._t *= -1;
  };

  /**
   * @summary Take the remainder
   * @param {number} y the divisor of the remainder operation.
   * @return sum in range [&minus;y/2, y/2].
   */
  a.Accumulator.prototype.Remainder = function(y) {
    this._s = m.remainder(this._s, y);
    this.Add(0);
  };
})(GeographicLib.Accumulator, GeographicLib.Math);

/**************** Geodesic.js ****************/
/*
 * Geodesic.js
 * Transcription of Geodesic.[ch]pp into JavaScript.
 *
 * See the documentation for the C++ class.  The conversion is a literal
 * conversion from C++.
 *
 * The algorithms are derived in
 *
 *    Charles F. F. Karney,
 *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);
 *    https://doi.org/10.1007/s00190-012-0578-z
 *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html
 *
 * Copyright (c) Charles Karney (2011-2021) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 */

// Load AFTER Math.js

GeographicLib.Geodesic = {};
GeographicLib.GeodesicLine = {};
GeographicLib.PolygonArea = {};

(function(
  /**
   * @exports GeographicLib/Geodesic
   * @description Solve geodesic problems via the
   *   {@link module:GeographicLib/Geodesic.Geodesic Geodesic} class.
   */
  g, l, p, m, c) {
  "use strict";

  var GEOGRAPHICLIB_GEODESIC_ORDER = 6,
      nA1_ = GEOGRAPHICLIB_GEODESIC_ORDER,
      nA2_ = GEOGRAPHICLIB_GEODESIC_ORDER,
      nA3_ = GEOGRAPHICLIB_GEODESIC_ORDER,
      nA3x_ = nA3_,
      nC3x_, nC4x_,
      maxit1_ = 20,
      maxit2_ = maxit1_ + m.digits + 10,
      tol0_ = m.epsilon,
      tol1_ = 200 * tol0_,
      tol2_ = Math.sqrt(tol0_),
      tolb_ = tol0_ * tol1_,
      xthresh_ = 1000 * tol2_,
      CAP_NONE = 0,
      CAP_ALL  = 0x1F,
      CAP_MASK = CAP_ALL,
      OUT_ALL  = 0x7F80,
      astroid,
      A1m1f_coeff, C1f_coeff, C1pf_coeff,
      A2m1f_coeff, C2f_coeff,
      A3_coeff, C3_coeff, C4_coeff;

  g.tiny_ = Math.sqrt(Number.MIN_VALUE);
  g.nC1_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  g.nC1p_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  g.nC2_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  g.nC3_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  g.nC4_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  nC3x_ = (g.nC3_ * (g.nC3_ - 1)) / 2;
  nC4x_ = (g.nC4_ * (g.nC4_ + 1)) / 2;
  g.CAP_C1   = 1<<0;
  g.CAP_C1p  = 1<<1;
  g.CAP_C2   = 1<<2;
  g.CAP_C3   = 1<<3;
  g.CAP_C4   = 1<<4;

  g.NONE          = 0;
  g.ARC           = 1<<6;
  g.LATITUDE      = 1<<7  | CAP_NONE;
  g.LONGITUDE     = 1<<8  | g.CAP_C3;
  g.AZIMUTH       = 1<<9  | CAP_NONE;
  g.DISTANCE      = 1<<10 | g.CAP_C1;
  g.STANDARD      = g.LATITUDE | g.LONGITUDE | g.AZIMUTH | g.DISTANCE;
  g.DISTANCE_IN   = 1<<11 | g.CAP_C1 | g.CAP_C1p;
  g.REDUCEDLENGTH = 1<<12 | g.CAP_C1 | g.CAP_C2;
  g.GEODESICSCALE = 1<<13 | g.CAP_C1 | g.CAP_C2;
  g.AREA          = 1<<14 | g.CAP_C4;
  g.ALL           = OUT_ALL| CAP_ALL;
  g.LONG_UNROLL   = 1<<15;
  g.OUT_MASK      = OUT_ALL| g.LONG_UNROLL;

  g.SinCosSeries = function(sinp, sinx, cosx, c) {
    // Evaluate
    // y = sinp ? sum(c[i] * sin( 2*i    * x), i, 1, n) :
    //            sum(c[i] * cos((2*i+1) * x), i, 0, n-1)
    // using Clenshaw summation.  N.B. c[0] is unused for sin series
    // Approx operation count = (n + 5) mult and (2 * n + 2) add
    var k = c.length,           // Point to one beyond last element
        n = k - (sinp ? 1 : 0),
        ar = 2 * (cosx - sinx) * (cosx + sinx), // 2 * cos(2 * x)
        y0 = n & 1 ? c[--k] : 0, y1 = 0;        // accumulators for sum
    // Now n is even
    n = Math.floor(n/2);
    while (n--) {
      // Unroll loop x 2, so accumulators return to their original role
      y1 = ar * y0 - y1 + c[--k];
      y0 = ar * y1 - y0 + c[--k];
    }
    return (sinp ? 2 * sinx * cosx * y0 : // sin(2 * x) * y0
            cosx * (y0 - y1));            // cos(x) * (y0 - y1)
  };

  astroid = function(x, y) {
    // Solve k^4+2*k^3-(x^2+y^2-1)*k^2-2*y^2*k-y^2 = 0 for positive
    // root k.  This solution is adapted from Geocentric::Reverse.
    var k,
        p = m.sq(x),
        q = m.sq(y),
        r = (p + q - 1) / 6,
        S, r2, r3, disc, u, T3, T, ang, v, uv, w;
    if ( !(q === 0 && r <= 0) ) {
      // Avoid possible division by zero when r = 0 by multiplying
      // equations for s and t by r^3 and r, resp.
      S = p * q / 4;            // S = r^3 * s
      r2 = m.sq(r);
      r3 = r * r2;
      // The discriminant of the quadratic equation for T3.  This is
      // zero on the evolute curve p^(1/3)+q^(1/3) = 1
      disc = S * (S + 2 * r3);
      u = r;
      if (disc >= 0) {
        T3 = S + r3;
        // Pick the sign on the sqrt to maximize abs(T3).  This
        // minimizes loss of precision due to cancellation.  The
        // result is unchanged because of the way the T is used
        // in definition of u.
        T3 += T3 < 0 ? -Math.sqrt(disc) : Math.sqrt(disc);    // T3 = (r * t)^3
        // N.B. cbrt always returns the real root.  cbrt(-8) = -2.
        T = m.cbrt(T3);     // T = r * t
        // T can be zero; but then r2 / T -> 0.
        u += T + (T !== 0 ? r2 / T : 0);
      } else {
        // T is complex, but the way u is defined the result is real.
        ang = Math.atan2(Math.sqrt(-disc), -(S + r3));
        // There are three possible cube roots.  We choose the
        // root which avoids cancellation.  Note that disc < 0
        // implies that r < 0.
        u += 2 * r * Math.cos(ang / 3);
      }
      v = Math.sqrt(m.sq(u) + q);       // guaranteed positive
      // Avoid loss of accuracy when u < 0.
      uv = u < 0 ? q / (v - u) : u + v; // u+v, guaranteed positive
      w = (uv - q) / (2 * v);           // positive?
      // Rearrange expression for k to avoid loss of accuracy due to
      // subtraction.  Division by 0 not possible because uv > 0, w >= 0.
      k = uv / (Math.sqrt(uv + m.sq(w)) + w); // guaranteed positive
    } else {                                  // q == 0 && r <= 0
      // y = 0 with |x| <= 1.  Handle this case directly.
      // for y small, positive root is k = abs(y)/sqrt(1-x^2)
      k = 0;
    }
    return k;
  };

  A1m1f_coeff = [
    // (1-eps)*A1-1, polynomial in eps2 of order 3
      +1, 4, 64, 0, 256
  ];

  // The scale factor A1-1 = mean value of (d/dsigma)I1 - 1
  g.A1m1f = function(eps) {
    var p = Math.floor(nA1_/2),
        t = m.polyval(p, A1m1f_coeff, 0, m.sq(eps)) / A1m1f_coeff[p + 1];
    return (t + eps) / (1 - eps);
  };

  C1f_coeff = [
    // C1[1]/eps^1, polynomial in eps2 of order 2
      -1, 6, -16, 32,
    // C1[2]/eps^2, polynomial in eps2 of order 2
      -9, 64, -128, 2048,
    // C1[3]/eps^3, polynomial in eps2 of order 1
      +9, -16, 768,
    // C1[4]/eps^4, polynomial in eps2 of order 1
      +3, -5, 512,
    // C1[5]/eps^5, polynomial in eps2 of order 0
      -7, 1280,
    // C1[6]/eps^6, polynomial in eps2 of order 0
      -7, 2048
  ];

  // The coefficients C1[l] in the Fourier expansion of B1
  g.C1f = function(eps, c) {
    var eps2 = m.sq(eps),
        d = eps,
        o = 0,
        l, p;
    for (l = 1; l <= g.nC1_; ++l) {     // l is index of C1p[l]
      p = Math.floor((g.nC1_ - l) / 2); // order of polynomial in eps^2
      c[l] = d * m.polyval(p, C1f_coeff, o, eps2) / C1f_coeff[o + p + 1];
      o += p + 2;
      d *= eps;
    }
  };

  C1pf_coeff = [
    // C1p[1]/eps^1, polynomial in eps2 of order 2
      +205, -432, 768, 1536,
    // C1p[2]/eps^2, polynomial in eps2 of order 2
      +4005, -4736, 3840, 12288,
    // C1p[3]/eps^3, polynomial in eps2 of order 1
      -225, 116, 384,
    // C1p[4]/eps^4, polynomial in eps2 of order 1
      -7173, 2695, 7680,
    // C1p[5]/eps^5, polynomial in eps2 of order 0
      +3467, 7680,
    // C1p[6]/eps^6, polynomial in eps2 of order 0
      +38081, 61440
  ];

  // The coefficients C1p[l] in the Fourier expansion of B1p
  g.C1pf = function(eps, c) {
    var eps2 = m.sq(eps),
        d = eps,
        o = 0,
        l, p;
    for (l = 1; l <= g.nC1p_; ++l) {     // l is index of C1p[l]
      p = Math.floor((g.nC1p_ - l) / 2); // order of polynomial in eps^2
      c[l] = d * m.polyval(p, C1pf_coeff, o, eps2) / C1pf_coeff[o + p + 1];
      o += p + 2;
      d *= eps;
    }
  };

  A2m1f_coeff = [
    // (eps+1)*A2-1, polynomial in eps2 of order 3
      -11, -28, -192, 0, 256
  ];

  // The scale factor A2-1 = mean value of (d/dsigma)I2 - 1
  g.A2m1f = function(eps) {
    var p = Math.floor(nA2_/2),
        t = m.polyval(p, A2m1f_coeff, 0, m.sq(eps)) / A2m1f_coeff[p + 1];
    return (t - eps) / (1 + eps);
  };

  C2f_coeff = [
    // C2[1]/eps^1, polynomial in eps2 of order 2
      +1, 2, 16, 32,
    // C2[2]/eps^2, polynomial in eps2 of order 2
      +35, 64, 384, 2048,
    // C2[3]/eps^3, polynomial in eps2 of order 1
      +15, 80, 768,
    // C2[4]/eps^4, polynomial in eps2 of order 1
      +7, 35, 512,
    // C2[5]/eps^5, polynomial in eps2 of order 0
      +63, 1280,
    // C2[6]/eps^6, polynomial in eps2 of order 0
      +77, 2048
  ];

  // The coefficients C2[l] in the Fourier expansion of B2
  g.C2f = function(eps, c) {
    var eps2 = m.sq(eps),
        d = eps,
        o = 0,
        l, p;
    for (l = 1; l <= g.nC2_; ++l) {     // l is index of C2[l]
      p = Math.floor((g.nC2_ - l) / 2); // order of polynomial in eps^2
      c[l] = d * m.polyval(p, C2f_coeff, o, eps2) / C2f_coeff[o + p + 1];
      o += p + 2;
      d *= eps;
    }
  };

  /**
   * @class
   * @property {number} a the equatorial radius (meters).
   * @property {number} f the flattening.
   * @summary Initialize a Geodesic object for a specific ellipsoid.
   * @classdesc Performs geodesic calculations on an ellipsoid of revolution.
   *   The routines for solving the direct and inverse problems return an
   *   object with some of the following fields set: lat1, lon1, azi1, lat2,
   *   lon2, azi2, s12, a12, m12, M12, M21, S12.  See {@tutorial 2-interface},
   *   "The results".
   * @example
   * var GeographicLib = require("geographiclib"),
   *     geod = GeographicLib.Geodesic.WGS84;
   * var inv = geod.Inverse(1,2,3,4);
   * console.log("lat1 = " + inv.lat1 + ", lon1 = " + inv.lon1 +
   *             ", lat2 = " + inv.lat2 + ", lon2 = " + inv.lon2 +
   *             ",\nazi1 = " + inv.azi1 + ", azi2 = " + inv.azi2 +
   *             ", s12 = " + inv.s12);
   * @param {number} a the equatorial radius of the ellipsoid (meters).
   * @param {number} f the flattening of the ellipsoid.  Setting f = 0 gives
   *   a sphere (on which geodesics are great circles).  Negative f gives a
   *   prolate ellipsoid.
   * @throws an error if the parameters are illegal.
   */
  g.Geodesic = function(a, f) {
    this.a = a;
    this.f = f;
    this._f1 = 1 - this.f;
    this._e2 = this.f * (2 - this.f);
    this._ep2 = this._e2 / m.sq(this._f1); // e2 / (1 - e2)
    this._n = this.f / ( 2 - this.f);
    this._b = this.a * this._f1;
    // authalic radius squared
    this._c2 = (m.sq(this.a) + m.sq(this._b) *
                (this._e2 === 0 ? 1 :
                 (this._e2 > 0 ? m.atanh(Math.sqrt(this._e2)) :
                  Math.atan(Math.sqrt(-this._e2))) /
                 Math.sqrt(Math.abs(this._e2))))/2;
    // The sig12 threshold for "really short".  Using the auxiliary sphere
    // solution with dnm computed at (bet1 + bet2) / 2, the relative error in
    // the azimuth consistency check is sig12^2 * abs(f) * min(1, 1-f/2) / 2.
    // (Error measured for 1/100 < b/a < 100 and abs(f) >= 1/1000.  For a given
    // f and sig12, the max error occurs for lines near the pole.  If the old
    // rule for computing dnm = (dn1 + dn2)/2 is used, then the error increases
    // by a factor of 2.)  Setting this equal to epsilon gives sig12 = etol2.
    // Here 0.1 is a safety factor (error decreased by 100) and max(0.001,
    // abs(f)) stops etol2 getting too large in the nearly spherical case.
    this._etol2 = 0.1 * tol2_ /
      Math.sqrt( Math.max(0.001, Math.abs(this.f)) *
                 Math.min(1.0, 1 - this.f/2) / 2 );
    if (!(isFinite(this.a) && this.a > 0))
      throw new Error("Equatorial radius is not positive");
    if (!(isFinite(this._b) && this._b > 0))
      throw new Error("Polar semi-axis is not positive");
    this._A3x = new Array(nA3x_);
    this._C3x = new Array(nC3x_);
    this._C4x = new Array(nC4x_);
    this.A3coeff();
    this.C3coeff();
    this.C4coeff();
  };

  A3_coeff = [
    // A3, coeff of eps^5, polynomial in n of order 0
      -3, 128,
    // A3, coeff of eps^4, polynomial in n of order 1
      -2, -3, 64,
    // A3, coeff of eps^3, polynomial in n of order 2
      -1, -3, -1, 16,
    // A3, coeff of eps^2, polynomial in n of order 2
      +3, -1, -2, 8,
    // A3, coeff of eps^1, polynomial in n of order 1
      +1, -1, 2,
    // A3, coeff of eps^0, polynomial in n of order 0
      +1, 1
  ];

  // The scale factor A3 = mean value of (d/dsigma)I3
  g.Geodesic.prototype.A3coeff = function() {
    var o = 0, k = 0,
        j, p;
    for (j = nA3_ - 1; j >= 0; --j) { // coeff of eps^j
      p = Math.min(nA3_ - j - 1, j);  // order of polynomial in n
      this._A3x[k++] = m.polyval(p, A3_coeff, o, this._n) /
        A3_coeff[o + p + 1];
      o += p + 2;
    }
  };

  C3_coeff = [
    // C3[1], coeff of eps^5, polynomial in n of order 0
      +3, 128,
    // C3[1], coeff of eps^4, polynomial in n of order 1
      +2, 5, 128,
    // C3[1], coeff of eps^3, polynomial in n of order 2
      -1, 3, 3, 64,
    // C3[1], coeff of eps^2, polynomial in n of order 2
      -1, 0, 1, 8,
    // C3[1], coeff of eps^1, polynomial in n of order 1
      -1, 1, 4,
    // C3[2], coeff of eps^5, polynomial in n of order 0
      +5, 256,
    // C3[2], coeff of eps^4, polynomial in n of order 1
      +1, 3, 128,
    // C3[2], coeff of eps^3, polynomial in n of order 2
      -3, -2, 3, 64,
    // C3[2], coeff of eps^2, polynomial in n of order 2
      +1, -3, 2, 32,
    // C3[3], coeff of eps^5, polynomial in n of order 0
      +7, 512,
    // C3[3], coeff of eps^4, polynomial in n of order 1
      -10, 9, 384,
    // C3[3], coeff of eps^3, polynomial in n of order 2
      +5, -9, 5, 192,
    // C3[4], coeff of eps^5, polynomial in n of order 0
      +7, 512,
    // C3[4], coeff of eps^4, polynomial in n of order 1
      -14, 7, 512,
    // C3[5], coeff of eps^5, polynomial in n of order 0
      +21, 2560
  ];

  // The coefficients C3[l] in the Fourier expansion of B3
  g.Geodesic.prototype.C3coeff = function() {
    var o = 0, k = 0,
        l, j, p;
    for (l = 1; l < g.nC3_; ++l) {        // l is index of C3[l]
      for (j = g.nC3_ - 1; j >= l; --j) { // coeff of eps^j
        p = Math.min(g.nC3_ - j - 1, j);  // order of polynomial in n
        this._C3x[k++] = m.polyval(p, C3_coeff, o, this._n) /
          C3_coeff[o + p + 1];
        o += p + 2;
      }
    }
  };

  C4_coeff = [
    // C4[0], coeff of eps^5, polynomial in n of order 0
      +97, 15015,
    // C4[0], coeff of eps^4, polynomial in n of order 1
      +1088, 156, 45045,
    // C4[0], coeff of eps^3, polynomial in n of order 2
      -224, -4784, 1573, 45045,
    // C4[0], coeff of eps^2, polynomial in n of order 3
      -10656, 14144, -4576, -858, 45045,
    // C4[0], coeff of eps^1, polynomial in n of order 4
      +64, 624, -4576, 6864, -3003, 15015,
    // C4[0], coeff of eps^0, polynomial in n of order 5
      +100, 208, 572, 3432, -12012, 30030, 45045,
    // C4[1], coeff of eps^5, polynomial in n of order 0
      +1, 9009,
    // C4[1], coeff of eps^4, polynomial in n of order 1
      -2944, 468, 135135,
    // C4[1], coeff of eps^3, polynomial in n of order 2
      +5792, 1040, -1287, 135135,
    // C4[1], coeff of eps^2, polynomial in n of order 3
      +5952, -11648, 9152, -2574, 135135,
    // C4[1], coeff of eps^1, polynomial in n of order 4
      -64, -624, 4576, -6864, 3003, 135135,
    // C4[2], coeff of eps^5, polynomial in n of order 0
      +8, 10725,
    // C4[2], coeff of eps^4, polynomial in n of order 1
      +1856, -936, 225225,
    // C4[2], coeff of eps^3, polynomial in n of order 2
      -8448, 4992, -1144, 225225,
    // C4[2], coeff of eps^2, polynomial in n of order 3
      -1440, 4160, -4576, 1716, 225225,
    // C4[3], coeff of eps^5, polynomial in n of order 0
      -136, 63063,
    // C4[3], coeff of eps^4, polynomial in n of order 1
      +1024, -208, 105105,
    // C4[3], coeff of eps^3, polynomial in n of order 2
      +3584, -3328, 1144, 315315,
    // C4[4], coeff of eps^5, polynomial in n of order 0
      -128, 135135,
    // C4[4], coeff of eps^4, polynomial in n of order 1
      -2560, 832, 405405,
    // C4[5], coeff of eps^5, polynomial in n of order 0
      +128, 99099
  ];

  g.Geodesic.prototype.C4coeff = function() {
    var o = 0, k = 0,
        l, j, p;
    for (l = 0; l < g.nC4_; ++l) {        // l is index of C4[l]
      for (j = g.nC4_ - 1; j >= l; --j) { // coeff of eps^j
        p = g.nC4_ - j - 1;               // order of polynomial in n
        this._C4x[k++] = m.polyval(p, C4_coeff, o, this._n) /
          C4_coeff[o + p + 1];
        o += p + 2;
      }
    }
  };

  g.Geodesic.prototype.A3f = function(eps) {
    // Evaluate A3
    return m.polyval(nA3x_ - 1, this._A3x, 0, eps);
  };

  g.Geodesic.prototype.C3f = function(eps, c) {
    // Evaluate C3 coeffs
    // Elements c[1] thru c[nC3_ - 1] are set
    var mult = 1,
        o = 0,
        l, p;
    for (l = 1; l < g.nC3_; ++l) { // l is index of C3[l]
      p = g.nC3_ - l - 1;          // order of polynomial in eps
      mult *= eps;
      c[l] = mult * m.polyval(p, this._C3x, o, eps);
      o += p + 1;
    }
  };

  g.Geodesic.prototype.C4f = function(eps, c) {
    // Evaluate C4 coeffs
    // Elements c[0] thru c[g.nC4_ - 1] are set
    var mult = 1,
        o = 0,
        l, p;
    for (l = 0; l < g.nC4_; ++l) { // l is index of C4[l]
      p = g.nC4_ - l - 1;          // order of polynomial in eps
      c[l] = mult * m.polyval(p, this._C4x, o, eps);
      o += p + 1;
      mult *= eps;
    }
  };

  // return s12b, m12b, m0, M12, M21
  g.Geodesic.prototype.Lengths = function(eps, sig12,
                                          ssig1, csig1, dn1, ssig2, csig2, dn2,
                                          cbet1, cbet2, outmask,
                                          C1a, C2a) {
    // Return m12b = (reduced length)/_b; also calculate s12b =
    // distance/_b, and m0 = coefficient of secular term in
    // expression for reduced length.
    outmask &= g.OUT_MASK;
    var vals = {},
        m0x = 0, J12 = 0, A1 = 0, A2 = 0,
        B1, B2, l, csig12, t;
    if (outmask & (g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE)) {
      A1 = g.A1m1f(eps);
      g.C1f(eps, C1a);
      if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
        A2 = g.A2m1f(eps);
        g.C2f(eps, C2a);
        m0x = A1 - A2;
        A2 = 1 + A2;
      }
      A1 = 1 + A1;
    }
    if (outmask & g.DISTANCE) {
      B1 = g.SinCosSeries(true, ssig2, csig2, C1a) -
        g.SinCosSeries(true, ssig1, csig1, C1a);
      // Missing a factor of _b
      vals.s12b = A1 * (sig12 + B1);
      if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
        B2 = g.SinCosSeries(true, ssig2, csig2, C2a) -
          g.SinCosSeries(true, ssig1, csig1, C2a);
        J12 = m0x * sig12 + (A1 * B1 - A2 * B2);
      }
    } else if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
      // Assume here that nC1_ >= nC2_
      for (l = 1; l <= g.nC2_; ++l)
        C2a[l] = A1 * C1a[l] - A2 * C2a[l];
      J12 = m0x * sig12 + (g.SinCosSeries(true, ssig2, csig2, C2a) -
                           g.SinCosSeries(true, ssig1, csig1, C2a));
    }
    if (outmask & g.REDUCEDLENGTH) {
      vals.m0 = m0x;
      // Missing a factor of _b.
      // Add parens around (csig1 * ssig2) and (ssig1 * csig2) to ensure
      // accurate cancellation in the case of coincident points.
      vals.m12b = dn2 * (csig1 * ssig2) - dn1 * (ssig1 * csig2) -
        csig1 * csig2 * J12;
    }
    if (outmask & g.GEODESICSCALE) {
      csig12 = csig1 * csig2 + ssig1 * ssig2;
      t = this._ep2 * (cbet1 - cbet2) * (cbet1 + cbet2) / (dn1 + dn2);
      vals.M12 = csig12 + (t * ssig2 - csig2 * J12) * ssig1 / dn1;
      vals.M21 = csig12 - (t * ssig1 - csig1 * J12) * ssig2 / dn2;
    }
    return vals;
  };

  // return sig12, salp1, calp1, salp2, calp2, dnm
  g.Geodesic.prototype.InverseStart = function(sbet1, cbet1, dn1,
                                               sbet2, cbet2, dn2,
                                               lam12, slam12, clam12,
                                               C1a, C2a) {
    // Return a starting point for Newton's method in salp1 and calp1
    // (function value is -1).  If Newton's method doesn't need to be
    // used, return also salp2 and calp2 and function value is sig12.
    // salp2, calp2 only updated if return val >= 0.
    var vals = {},
        // bet12 = bet2 - bet1 in [0, pi); bet12a = bet2 + bet1 in (-pi, 0]
        sbet12 = sbet2 * cbet1 - cbet2 * sbet1,
        cbet12 = cbet2 * cbet1 + sbet2 * sbet1,
        sbet12a, shortline, omg12, sbetm2, somg12, comg12, t, ssig12, csig12,
        x, y, lamscale, betscale, k2, eps, cbet12a, bet12a, m12b, m0, nvals,
        k, omg12a, lam12x;
    vals.sig12 = -1;        // Return value
    // Volatile declaration needed to fix inverse cases
    // 88.202499451857 0 -88.202499451857 179.981022032992859592
    // 89.262080389218 0 -89.262080389218 179.992207982775375662
    // 89.333123580033 0 -89.333123580032997687 179.99295812360148422
    // which otherwise fail with g++ 4.4.4 x86 -O3
    sbet12a = sbet2 * cbet1;
    sbet12a += cbet2 * sbet1;

    shortline = cbet12 >= 0 && sbet12 < 0.5 && cbet2 * lam12 < 0.5;
    if (shortline) {
      sbetm2 = m.sq(sbet1 + sbet2);
      // sin((bet1+bet2)/2)^2
      // =  (sbet1 + sbet2)^2 / ((sbet1 + sbet2)^2 + (cbet1 + cbet2)^2)
      sbetm2 /= sbetm2 + m.sq(cbet1 + cbet2);
      vals.dnm = Math.sqrt(1 + this._ep2 * sbetm2);
      omg12 = lam12 / (this._f1 * vals.dnm);
      somg12 = Math.sin(omg12); comg12 = Math.cos(omg12);
    } else {
      somg12 = slam12; comg12 = clam12;
    }

    vals.salp1 = cbet2 * somg12;
    vals.calp1 = comg12 >= 0 ?
      sbet12 + cbet2 * sbet1 * m.sq(somg12) / (1 + comg12) :
      sbet12a - cbet2 * sbet1 * m.sq(somg12) / (1 - comg12);

    ssig12 = m.hypot(vals.salp1, vals.calp1);
    csig12 = sbet1 * sbet2 + cbet1 * cbet2 * comg12;
    if (shortline && ssig12 < this._etol2) {
      // really short lines
      vals.salp2 = cbet1 * somg12;
      vals.calp2 = sbet12 - cbet1 * sbet2 *
        (comg12 >= 0 ? m.sq(somg12) / (1 + comg12) : 1 - comg12);
      // norm(vals.salp2, vals.calp2);
      t = m.hypot(vals.salp2, vals.calp2); vals.salp2 /= t; vals.calp2 /= t;
      // Set return value
      vals.sig12 = Math.atan2(ssig12, csig12);
    } else if (Math.abs(this._n) > 0.1 || // Skip astroid calc if too eccentric
               csig12 >= 0 ||
               ssig12 >= 6 * Math.abs(this._n) * Math.PI * m.sq(cbet1)) {
      // Nothing to do, zeroth order spherical approximation is OK
    } else {
      // Scale lam12 and bet2 to x, y coordinate system where antipodal
      // point is at origin and singular point is at y = 0, x = -1.
      lam12x = Math.atan2(-slam12, -clam12); // lam12 - pi
      if (this.f >= 0) {       // In fact f == 0 does not get here
        // x = dlong, y = dlat
        k2 = m.sq(sbet1) * this._ep2;
        eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);
        lamscale = this.f * cbet1 * this.A3f(eps) * Math.PI;
        betscale = lamscale * cbet1;

        x = lam12x / lamscale;
        y = sbet12a / betscale;
      } else {                  // f < 0
        // x = dlat, y = dlong
        cbet12a = cbet2 * cbet1 - sbet2 * sbet1;
        bet12a = Math.atan2(sbet12a, cbet12a);
        // In the case of lon12 = 180, this repeats a calculation made
        // in Inverse.
        nvals = this.Lengths(this._n, Math.PI + bet12a,
                             sbet1, -cbet1, dn1, sbet2, cbet2, dn2,
                             cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a);
        m12b = nvals.m12b; m0 = nvals.m0;
        x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);
        betscale = x < -0.01 ? sbet12a / x :
          -this.f * m.sq(cbet1) * Math.PI;
        lamscale = betscale / cbet1;
        y = lam12 / lamscale;
      }

      if (y > -tol1_ && x > -1 - xthresh_) {
        // strip near cut
        if (this.f >= 0) {
          vals.salp1 = Math.min(1, -x);
          vals.calp1 = -Math.sqrt(1 - m.sq(vals.salp1));
        } else {
          vals.calp1 = Math.max(x > -tol1_ ? 0 : -1, x);
          vals.salp1 = Math.sqrt(1 - m.sq(vals.calp1));
        }
      } else {
        // Estimate alp1, by solving the astroid problem.
        //
        // Could estimate alpha1 = theta + pi/2, directly, i.e.,
        //   calp1 = y/k; salp1 = -x/(1+k);  for f >= 0
        //   calp1 = x/(1+k); salp1 = -y/k;  for f < 0 (need to check)
        //
        // However, it's better to estimate omg12 from astroid and use
        // spherical formula to compute alp1.  This reduces the mean number of
        // Newton iterations for astroid cases from 2.24 (min 0, max 6) to 2.12
        // (min 0 max 5).  The changes in the number of iterations are as
        // follows:
        //
        // change percent
        //    1       5
        //    0      78
        //   -1      16
        //   -2       0.6
        //   -3       0.04
        //   -4       0.002
        //
        // The histogram of iterations is (m = number of iterations estimating
        // alp1 directly, n = number of iterations estimating via omg12, total
        // number of trials = 148605):
        //
        //  iter    m      n
        //    0   148    186
        //    1 13046  13845
        //    2 93315 102225
        //    3 36189  32341
        //    4  5396      7
        //    5   455      1
        //    6    56      0
        //
        // Because omg12 is near pi, estimate work with omg12a = pi - omg12
        k = astroid(x, y);
        omg12a = lamscale * ( this.f >= 0 ? -x * k/(1 + k) : -y * (1 + k)/k );
        somg12 = Math.sin(omg12a); comg12 = -Math.cos(omg12a);
        // Update spherical estimate of alp1 using omg12 instead of
        // lam12
        vals.salp1 = cbet2 * somg12;
        vals.calp1 = sbet12a -
          cbet2 * sbet1 * m.sq(somg12) / (1 - comg12);
      }
    }
    // Sanity check on starting guess.  Backwards check allows NaN through.
    if (!(vals.salp1 <= 0.0)) {
      // norm(vals.salp1, vals.calp1);
      t = m.hypot(vals.salp1, vals.calp1); vals.salp1 /= t; vals.calp1 /= t;
    } else {
      vals.salp1 = 1; vals.calp1 = 0;
    }
    return vals;
  };

  // return lam12, salp2, calp2, sig12, ssig1, csig1, ssig2, csig2, eps,
  // domg12, dlam12,
  g.Geodesic.prototype.Lambda12 = function(sbet1, cbet1, dn1,
                                           sbet2, cbet2, dn2,
                                           salp1, calp1, slam120, clam120,
                                           diffp, C1a, C2a, C3a) {
    var vals = {},
        t, salp0, calp0,
        somg1, comg1, somg2, comg2, somg12, comg12, B312, eta, k2, nvals;
    if (sbet1 === 0 && calp1 === 0)
      // Break degeneracy of equatorial line.  This case has already been
      // handled.
      calp1 = -g.tiny_;

    // sin(alp1) * cos(bet1) = sin(alp0)
    salp0 = salp1 * cbet1;
    calp0 = m.hypot(calp1, salp1 * sbet1); // calp0 > 0

    // tan(bet1) = tan(sig1) * cos(alp1)
    // tan(omg1) = sin(alp0) * tan(sig1) = tan(omg1)=tan(alp1)*sin(bet1)
    vals.ssig1 = sbet1; somg1 = salp0 * sbet1;
    vals.csig1 = comg1 = calp1 * cbet1;
    // norm(vals.ssig1, vals.csig1);
    t = m.hypot(vals.ssig1, vals.csig1); vals.ssig1 /= t; vals.csig1 /= t;
    // norm(somg1, comg1); -- don't need to normalize!

    // Enforce symmetries in the case abs(bet2) = -bet1.  Need to be careful
    // about this case, since this can yield singularities in the Newton
    // iteration.
    // sin(alp2) * cos(bet2) = sin(alp0)
    vals.salp2 = cbet2 !== cbet1 ? salp0 / cbet2 : salp1;
    // calp2 = sqrt(1 - sq(salp2))
    //       = sqrt(sq(calp0) - sq(sbet2)) / cbet2
    // and subst for calp0 and rearrange to give (choose positive sqrt
    // to give alp2 in [0, pi/2]).
    vals.calp2 = cbet2 !== cbet1 || Math.abs(sbet2) !== -sbet1 ?
      Math.sqrt(m.sq(calp1 * cbet1) + (cbet1 < -sbet1 ?
                                       (cbet2 - cbet1) * (cbet1 + cbet2) :
                                       (sbet1 - sbet2) * (sbet1 + sbet2))) /
      cbet2 : Math.abs(calp1);
    // tan(bet2) = tan(sig2) * cos(alp2)
    // tan(omg2) = sin(alp0) * tan(sig2).
    vals.ssig2 = sbet2; somg2 = salp0 * sbet2;
    vals.csig2 = comg2 = vals.calp2 * cbet2;
    // norm(vals.ssig2, vals.csig2);
    t = m.hypot(vals.ssig2, vals.csig2); vals.ssig2 /= t; vals.csig2 /= t;
    // norm(somg2, comg2); -- don't need to normalize!

    // sig12 = sig2 - sig1, limit to [0, pi]
    vals.sig12 = Math.atan2(Math.max(0, vals.csig1 * vals.ssig2 -
                                        vals.ssig1 * vals.csig2),
                                        vals.csig1 * vals.csig2 +
                                        vals.ssig1 * vals.ssig2);

    // omg12 = omg2 - omg1, limit to [0, pi]
    somg12 = Math.max(0, comg1 * somg2 - somg1 * comg2);
    comg12 =             comg1 * comg2 + somg1 * somg2;
    // eta = omg12 - lam120
    eta = Math.atan2(somg12 * clam120 - comg12 * slam120,
                     comg12 * clam120 + somg12 * slam120);
    k2 = m.sq(calp0) * this._ep2;
    vals.eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);
    this.C3f(vals.eps, C3a);
    B312 = (g.SinCosSeries(true, vals.ssig2, vals.csig2, C3a) -
            g.SinCosSeries(true, vals.ssig1, vals.csig1, C3a));
    vals.domg12 =  -this.f * this.A3f(vals.eps) * salp0 * (vals.sig12 + B312);
    vals.lam12 = eta + vals.domg12;
    if (diffp) {
      if (vals.calp2 === 0)
        vals.dlam12 = -2 * this._f1 * dn1 / sbet1;
      else {
        nvals = this.Lengths(vals.eps, vals.sig12,
                             vals.ssig1, vals.csig1, dn1,
                             vals.ssig2, vals.csig2, dn2,
                             cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a);
        vals.dlam12 = nvals.m12b;
        vals.dlam12 *= this._f1 / (vals.calp2 * cbet2);
      }
    }
    return vals;
  };

  /**
   * @summary Solve the inverse geodesic problem.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} lat2 the latitude of the second point in degrees.
   * @param {number} lon2 the longitude of the second point in degrees.
   * @param {bitmask} [outmask = STANDARD] which results to include.
   * @returns {object} the requested results
   * @description The lat1, lon1, lat2, lon2, and a12 fields of the result are
   *   always set.  For details on the outmask parameter, see {@tutorial
   *   2-interface}, "The outmask and caps parameters".
   */
  g.Geodesic.prototype.Inverse = function(lat1, lon1, lat2, lon2, outmask) {
    var r, vals;
    if (!outmask) outmask = g.STANDARD;
    if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;
    outmask &= g.OUT_MASK;
    r = this.InverseInt(lat1, lon1, lat2, lon2, outmask);
    vals = r.vals;
    if (outmask & g.AZIMUTH) {
      vals.azi1 = m.atan2d(r.salp1, r.calp1);
      vals.azi2 = m.atan2d(r.salp2, r.calp2);
    }
    return vals;
  };

  g.Geodesic.prototype.InverseInt = function(lat1, lon1, lat2, lon2, outmask) {
    var vals = {},
        lon12, lon12s, lonsign, t, swapp, latsign,
        sbet1, cbet1, sbet2, cbet2, s12x, m12x,
        dn1, dn2, lam12, slam12, clam12,
        sig12, calp1, salp1, calp2, salp2, C1a, C2a, C3a, meridian, nvals,
        ssig1, csig1, ssig2, csig2, eps, omg12, dnm,
        numit, salp1a, calp1a, salp1b, calp1b,
        tripn, tripb, v, dv, dalp1, sdalp1, cdalp1, nsalp1,
        lengthmask, salp0, calp0, alp12, k2, A4, C4a, B41, B42,
        somg12, comg12, domg12, dbet1, dbet2, salp12, calp12, sdomg12, cdomg12;
    // Compute longitude difference (AngDiff does this carefully).  Result is
    // in [-180, 180] but -180 is only for west-going geodesics.  180 is for
    // east-going and meridional geodesics.
    vals.lat1 = lat1 = m.LatFix(lat1); vals.lat2 = lat2 = m.LatFix(lat2);
    // If really close to the equator, treat as on equator.
    lat1 = m.AngRound(lat1);
    lat2 = m.AngRound(lat2);
    lon12 = m.AngDiff(lon1, lon2); lon12s = lon12.t; lon12 = lon12.s;
    if (outmask & g.LONG_UNROLL) {
      vals.lon1 = lon1; vals.lon2 = (lon1 + lon12) + lon12s;
    } else {
      vals.lon1 = m.AngNormalize(lon1); vals.lon2 = m.AngNormalize(lon2);
    }
    // Make longitude difference positive.
    lonsign = lon12 >= 0 ? 1 : -1;
    // If very close to being on the same half-meridian, then make it so.
    lon12 = lonsign * m.AngRound(lon12);
    lon12s = m.AngRound((180 - lon12) - lonsign * lon12s);
    lam12 = lon12 * m.degree;
    t = m.sincosd(lon12 > 90 ? lon12s : lon12);
    slam12 = t.s; clam12 = (lon12 > 90 ? -1 : 1) * t.c;

    // Swap points so that point with higher (abs) latitude is point 1
    // If one latitude is a nan, then it becomes lat1.
    swapp = Math.abs(lat1) < Math.abs(lat2) ? -1 : 1;
    if (swapp < 0) {
      lonsign *= -1;
      t = lat1;
      lat1 = lat2;
      lat2 = t;
      // swap(lat1, lat2);
    }
    // Make lat1 <= 0
    latsign = lat1 < 0 ? 1 : -1;
    lat1 *= latsign;
    lat2 *= latsign;
    // Now we have
    //
    //     0 <= lon12 <= 180
    //     -90 <= lat1 <= 0
    //     lat1 <= lat2 <= -lat1
    //
    // longsign, swapp, latsign register the transformation to bring the
    // coordinates to this canonical form.  In all cases, 1 means no change was
    // made.  We make these transformations so that there are few cases to
    // check, e.g., on verifying quadrants in atan2.  In addition, this
    // enforces some symmetries in the results returned.

    t = m.sincosd(lat1); sbet1 = this._f1 * t.s; cbet1 = t.c;
    // norm(sbet1, cbet1);
    t = m.hypot(sbet1, cbet1); sbet1 /= t; cbet1 /= t;
    // Ensure cbet1 = +epsilon at poles
    cbet1 = Math.max(g.tiny_, cbet1);

    t = m.sincosd(lat2); sbet2 = this._f1 * t.s; cbet2 = t.c;
    // norm(sbet2, cbet2);
    t = m.hypot(sbet2, cbet2); sbet2 /= t; cbet2 /= t;
    // Ensure cbet2 = +epsilon at poles
    cbet2 = Math.max(g.tiny_, cbet2);

    // If cbet1 < -sbet1, then cbet2 - cbet1 is a sensitive measure of the
    // |bet1| - |bet2|.  Alternatively (cbet1 >= -sbet1), abs(sbet2) + sbet1 is
    // a better measure.  This logic is used in assigning calp2 in Lambda12.
    // Sometimes these quantities vanish and in that case we force bet2 = +/-
    // bet1 exactly.  An example where is is necessary is the inverse problem
    // 48.522876735459 0 -48.52287673545898293 179.599720456223079643
    // which failed with Visual Studio 10 (Release and Debug)

    if (cbet1 < -sbet1) {
      if (cbet2 === cbet1)
        sbet2 = sbet2 < 0 ? sbet1 : -sbet1;
    } else {
      if (Math.abs(sbet2) === -sbet1)
        cbet2 = cbet1;
    }

    dn1 = Math.sqrt(1 + this._ep2 * m.sq(sbet1));
    dn2 = Math.sqrt(1 + this._ep2 * m.sq(sbet2));

    // index zero elements of these arrays are unused
    C1a = new Array(g.nC1_ + 1);
    C2a = new Array(g.nC2_ + 1);
    C3a = new Array(g.nC3_);

    meridian = lat1 === -90 || slam12 === 0;
    if (meridian) {

      // Endpoints are on a single full meridian, so the geodesic might
      // lie on a meridian.

      calp1 = clam12; salp1 = slam12; // Head to the target longitude
      calp2 = 1; salp2 = 0;           // At the target we're heading north

      // tan(bet) = tan(sig) * cos(alp)
      ssig1 = sbet1; csig1 = calp1 * cbet1;
      ssig2 = sbet2; csig2 = calp2 * cbet2;

      // sig12 = sig2 - sig1
      sig12 = Math.atan2(Math.max(0, csig1 * ssig2 - ssig1 * csig2),
                                     csig1 * csig2 + ssig1 * ssig2);
      nvals = this.Lengths(this._n, sig12,
                           ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2,
                           outmask | g.DISTANCE | g.REDUCEDLENGTH,
                           C1a, C2a);
      s12x = nvals.s12b;
      m12x = nvals.m12b;
      // Ignore m0
      if (outmask & g.GEODESICSCALE) {
        vals.M12 = nvals.M12;
        vals.M21 = nvals.M21;
      }
      // Add the check for sig12 since zero length geodesics might yield
      // m12 < 0.  Test case was
      //
      //    echo 20.001 0 20.001 0 | GeodSolve -i
      //
      // In fact, we will have sig12 > pi/2 for meridional geodesic
      // which is not a shortest path.
      if (sig12 < 1 || m12x >= 0) {
        // Need at least 2, to handle 90 0 90 180
        if (sig12 < 3 * g.tiny_ ||
            // Prevent negative s12 or m12 for short lines
            (sig12 < tol0_ && (s12x < 0 || m12x < 0)))
          sig12 = m12x = s12x = 0;
        m12x *= this._b;
        s12x *= this._b;
        vals.a12 = sig12 / m.degree;
      } else
        // m12 < 0, i.e., prolate and too close to anti-podal
        meridian = false;
    }

    somg12 = 2;
    if (!meridian &&
        sbet1 === 0 &&           // and sbet2 == 0
        (this.f <= 0 || lon12s >= this.f * 180)) {

      // Geodesic runs along equator
      calp1 = calp2 = 0; salp1 = salp2 = 1;
      s12x = this.a * lam12;
      sig12 = omg12 = lam12 / this._f1;
      m12x = this._b * Math.sin(sig12);
      if (outmask & g.GEODESICSCALE)
        vals.M12 = vals.M21 = Math.cos(sig12);
      vals.a12 = lon12 / this._f1;

    } else if (!meridian) {

      // Now point1 and point2 belong within a hemisphere bounded by a
      // meridian and geodesic is neither meridional or equatorial.

      // Figure a starting point for Newton's method
      nvals = this.InverseStart(sbet1, cbet1, dn1, sbet2, cbet2, dn2,
                                lam12, slam12, clam12, C1a, C2a);
      sig12 = nvals.sig12;
      salp1 = nvals.salp1;
      calp1 = nvals.calp1;

      if (sig12 >= 0) {
        salp2 = nvals.salp2;
        calp2 = nvals.calp2;
        // Short lines (InverseStart sets salp2, calp2, dnm)

        dnm = nvals.dnm;
        s12x = sig12 * this._b * dnm;
        m12x = m.sq(dnm) * this._b * Math.sin(sig12 / dnm);
        if (outmask & g.GEODESICSCALE)
          vals.M12 = vals.M21 = Math.cos(sig12 / dnm);
        vals.a12 = sig12 / m.degree;
        omg12 = lam12 / (this._f1 * dnm);
      } else {

        // Newton's method.  This is a straightforward solution of f(alp1) =
        // lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one
        // root in the interval (0, pi) and its derivative is positive at the
        // root.  Thus f(alp) is positive for alp > alp1 and negative for alp <
        // alp1.  During the course of the iteration, a range (alp1a, alp1b) is
        // maintained which brackets the root and with each evaluation of
        // f(alp) the range is shrunk if possible.  Newton's method is
        // restarted whenever the derivative of f is negative (because the new
        // value of alp1 is then further from the solution) or if the new
        // estimate of alp1 lies outside (0,pi); in this case, the new starting
        // guess is taken to be (alp1a + alp1b) / 2.
        numit = 0;
        // Bracketing range
        salp1a = g.tiny_; calp1a = 1; salp1b = g.tiny_; calp1b = -1;
        for (tripn = false, tripb = false; numit < maxit2_; ++numit) {
          // the WGS84 test set: mean = 1.47, sd = 1.25, max = 16
          // WGS84 and random input: mean = 2.85, sd = 0.60
          nvals = this.Lambda12(sbet1, cbet1, dn1, sbet2, cbet2, dn2,
                                salp1, calp1, slam12, clam12, numit < maxit1_,
                                C1a, C2a, C3a);
          v = nvals.lam12;
          salp2 = nvals.salp2;
          calp2 = nvals.calp2;
          sig12 = nvals.sig12;
          ssig1 = nvals.ssig1;
          csig1 = nvals.csig1;
          ssig2 = nvals.ssig2;
          csig2 = nvals.csig2;
          eps = nvals.eps;
          domg12 = nvals.domg12;
          dv = nvals.dlam12;

          // Reversed test to allow escape with NaNs
          if (tripb || !(Math.abs(v) >= (tripn ? 8 : 1) * tol0_))
            break;
          // Update bracketing values
          if (v > 0 && (numit < maxit1_ || calp1/salp1 > calp1b/salp1b)) {
            salp1b = salp1; calp1b = calp1;
          } else if (v < 0 &&
                     (numit < maxit1_ || calp1/salp1 < calp1a/salp1a)) {
            salp1a = salp1; calp1a = calp1;
          }
          if (numit < maxit1_ && dv > 0) {
            dalp1 = -v/dv;
            sdalp1 = Math.sin(dalp1); cdalp1 = Math.cos(dalp1);
            nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;
            if (nsalp1 > 0 && Math.abs(dalp1) < Math.PI) {
              calp1 = calp1 * cdalp1 - salp1 * sdalp1;
              salp1 = nsalp1;
              // norm(salp1, calp1);
              t = m.hypot(salp1, calp1); salp1 /= t; calp1 /= t;
              // In some regimes we don't get quadratic convergence because
              // slope -> 0.  So use convergence conditions based on epsilon
              // instead of sqrt(epsilon).
              tripn = Math.abs(v) <= 16 * tol0_;
              continue;
            }
          }
          // Either dv was not positive or updated value was outside legal
          // range.  Use the midpoint of the bracket as the next estimate.
          // This mechanism is not needed for the WGS84 ellipsoid, but it does
          // catch problems with more eccentric ellipsoids.  Its efficacy is
          // such for the WGS84 test set with the starting guess set to alp1 =
          // 90deg:
          // the WGS84 test set: mean = 5.21, sd = 3.93, max = 24
          // WGS84 and random input: mean = 4.74, sd = 0.99
          salp1 = (salp1a + salp1b)/2;
          calp1 = (calp1a + calp1b)/2;
          // norm(salp1, calp1);
          t = m.hypot(salp1, calp1); salp1 /= t; calp1 /= t;
          tripn = false;
          tripb = (Math.abs(salp1a - salp1) + (calp1a - calp1) < tolb_ ||
                   Math.abs(salp1 - salp1b) + (calp1 - calp1b) < tolb_);
        }
        lengthmask = outmask |
            (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE) ?
             g.DISTANCE : g.NONE);
        nvals = this.Lengths(eps, sig12,
                             ssig1, csig1, dn1, ssig2, csig2, dn2,
                             cbet1, cbet2,
                             lengthmask, C1a, C2a);
        s12x = nvals.s12b;
        m12x = nvals.m12b;
        // Ignore m0
        if (outmask & g.GEODESICSCALE) {
          vals.M12 = nvals.M12;
          vals.M21 = nvals.M21;
        }
        m12x *= this._b;
        s12x *= this._b;
        vals.a12 = sig12 / m.degree;
        if (outmask & g.AREA) {
          // omg12 = lam12 - domg12
          sdomg12 = Math.sin(domg12); cdomg12 = Math.cos(domg12);
          somg12 = slam12 * cdomg12 - clam12 * sdomg12;
          comg12 = clam12 * cdomg12 + slam12 * sdomg12;
        }
      }
    }

    if (outmask & g.DISTANCE)
      vals.s12 = 0 + s12x;      // Convert -0 to 0

    if (outmask & g.REDUCEDLENGTH)
      vals.m12 = 0 + m12x;      // Convert -0 to 0

    if (outmask & g.AREA) {
      // From Lambda12: sin(alp1) * cos(bet1) = sin(alp0)
      salp0 = salp1 * cbet1;
      calp0 = m.hypot(calp1, salp1 * sbet1); // calp0 > 0
      if (calp0 !== 0 && salp0 !== 0) {
        // From Lambda12: tan(bet) = tan(sig) * cos(alp)
        ssig1 = sbet1; csig1 = calp1 * cbet1;
        ssig2 = sbet2; csig2 = calp2 * cbet2;
        k2 = m.sq(calp0) * this._ep2;
        eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);
        // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0).
        A4 = m.sq(this.a) * calp0 * salp0 * this._e2;
        // norm(ssig1, csig1);
        t = m.hypot(ssig1, csig1); ssig1 /= t; csig1 /= t;
        // norm(ssig2, csig2);
        t = m.hypot(ssig2, csig2); ssig2 /= t; csig2 /= t;
        C4a = new Array(g.nC4_);
        this.C4f(eps, C4a);
        B41 = g.SinCosSeries(false, ssig1, csig1, C4a);
        B42 = g.SinCosSeries(false, ssig2, csig2, C4a);
        vals.S12 = A4 * (B42 - B41);
      } else
        // Avoid problems with indeterminate sig1, sig2 on equator
        vals.S12 = 0;
      if (!meridian && somg12 > 1) {
        somg12 = Math.sin(omg12); comg12 = Math.cos(omg12);
      }
      if (!meridian &&
          comg12 > -0.7071 &&      // Long difference not too big
          sbet2 - sbet1 < 1.75) { // Lat difference not too big
        // Use tan(Gamma/2) = tan(omg12/2)
        // * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))
        // with tan(x/2) = sin(x)/(1+cos(x))
        domg12 = 1 + comg12; dbet1 = 1 + cbet1; dbet2 = 1 + cbet2;
        alp12 = 2 * Math.atan2( somg12 * (sbet1*dbet2 + sbet2*dbet1),
                                domg12 * (sbet1*sbet2 + dbet1*dbet2) );
      } else {
        // alp12 = alp2 - alp1, used in atan2 so no need to normalize
        salp12 = salp2 * calp1 - calp2 * salp1;
        calp12 = calp2 * calp1 + salp2 * salp1;
        // The right thing appears to happen if alp1 = +/-180 and alp2 = 0, viz
        // salp12 = -0 and alp12 = -180.  However this depends on the sign
        // being attached to 0 correctly.  The following ensures the correct
        // behavior.
        if (salp12 === 0 && calp12 < 0) {
          salp12 = g.tiny_ * calp1;
          calp12 = -1;
        }
        alp12 = Math.atan2(salp12, calp12);
      }
      vals.S12 += this._c2 * alp12;
      vals.S12 *= swapp * lonsign * latsign;
      // Convert -0 to 0
      vals.S12 += 0;
    }

    // Convert calp, salp to azimuth accounting for lonsign, swapp, latsign.
    if (swapp < 0) {
      t = salp1;
      salp1 = salp2;
      salp2 = t;
      // swap(salp1, salp2);
      t = calp1;
      calp1 = calp2;
      calp2 = t;
      // swap(calp1, calp2);
      if (outmask & g.GEODESICSCALE) {
        t = vals.M12;
        vals.M12 = vals.M21;
        vals.M21 = t;
        // swap(vals.M12, vals.M21);
      }
    }

    salp1 *= swapp * lonsign; calp1 *= swapp * latsign;
    salp2 *= swapp * lonsign; calp2 *= swapp * latsign;

    return {vals: vals,
            salp1: salp1, calp1: calp1,
            salp2: salp2, calp2: calp2};
  };

  /**
   * @summary Solve the general direct geodesic problem.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   * @param {bool} arcmode is the next parameter an arc length?
   * @param {number} s12_a12 the (arcmode ? arc length : distance) from the
   *   first point to the second in (arcmode ? degrees : meters).
   * @param {bitmask} [outmask = STANDARD] which results to include.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, and a12 fields of the result are always
   *   set; s12 is included if arcmode is false.  For details on the outmask
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  g.Geodesic.prototype.GenDirect = function(lat1, lon1, azi1,
                                            arcmode, s12_a12, outmask) {
    var line;
    if (!outmask) outmask = g.STANDARD;
    else if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;
    // Automatically supply DISTANCE_IN if necessary
    if (!arcmode) outmask |= g.DISTANCE_IN;
    line = new l.GeodesicLine(this, lat1, lon1, azi1, outmask);
    return line.GenPosition(arcmode, s12_a12, outmask);
  };

  /**
   * @summary Solve the direct geodesic problem.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   * @param {number} s12 the distance from the first point to the second in
   *   meters.
   * @param {bitmask} [outmask = STANDARD] which results to include.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, s12, and a12 fields of the result are
   *   always set.  For details on the outmask parameter, see {@tutorial
   *   2-interface}, "The outmask and caps parameters".
   */
  g.Geodesic.prototype.Direct = function(lat1, lon1, azi1, s12, outmask) {
    return this.GenDirect(lat1, lon1, azi1, false, s12, outmask);
  };

  /**
   * @summary Solve the direct geodesic problem with arc length.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   * @param {number} a12 the arc length from the first point to the second in
   *   degrees.
   * @param {bitmask} [outmask = STANDARD] which results to include.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, and a12 fields of the result are
   *   always set.  For details on the outmask parameter, see {@tutorial
   *   2-interface}, "The outmask and caps parameters".
   */
  g.Geodesic.prototype.ArcDirect = function(lat1, lon1, azi1, a12, outmask) {
    return this.GenDirect(lat1, lon1, azi1, true, a12, outmask);
  };

  /**
   * @summary Create a {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   *   degrees.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include.
   * @returns {object} the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object
   * @description For details on the caps parameter, see {@tutorial
   *   2-interface}, "The outmask and caps parameters".
   */
  g.Geodesic.prototype.Line = function(lat1, lon1, azi1, caps) {
    return new l.GeodesicLine(this, lat1, lon1, azi1, caps);
  };

  /**
   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} in terms of the direct geodesic problem specified in terms
   *   of distance.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   *   degrees.
   * @param {number} s12 the distance between point 1 and point 2 (meters); it
   *   can be negative.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include.
   * @returns {object} the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object
   * @description This function sets point 3 of the GeodesicLine to correspond
   *   to point 2 of the direct geodesic problem.  For details on the caps
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  g.Geodesic.prototype.DirectLine = function(lat1, lon1, azi1, s12, caps) {
    return this.GenDirectLine(lat1, lon1, azi1, false, s12, caps);
  };

  /**
   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} in terms of the direct geodesic problem specified in terms
   *   of arc length.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   *   degrees.
   * @param {number} a12 the arc length between point 1 and point 2 (degrees);
   *   it can be negative.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include.
   * @returns {object} the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object
   * @description This function sets point 3 of the GeodesicLine to correspond
   *   to point 2 of the direct geodesic problem.  For details on the caps
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  g.Geodesic.prototype.ArcDirectLine = function(lat1, lon1, azi1, a12, caps) {
    return this.GenDirectLine(lat1, lon1, azi1, true, a12, caps);
  };

  /**
   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} in terms of the direct geodesic problem specified in terms
   *   of either distance or arc length.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   *   degrees.
   * @param {bool} arcmode boolean flag determining the meaning of the
   *   s12_a12.
   * @param {number} s12_a12 if arcmode is false, this is the distance between
   *   point 1 and point 2 (meters); otherwise it is the arc length between
   *   point 1 and point 2 (degrees); it can be negative.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include.
   * @returns {object} the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object
   * @description This function sets point 3 of the GeodesicLine to correspond
   *   to point 2 of the direct geodesic problem.  For details on the caps
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  g.Geodesic.prototype.GenDirectLine = function(lat1, lon1, azi1,
                                                arcmode, s12_a12, caps) {
    var t;
    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;
    // Automatically supply DISTANCE_IN if necessary
    if (!arcmode) caps |= g.DISTANCE_IN;
    t = new l.GeodesicLine(this, lat1, lon1, azi1, caps);
    t.GenSetDistance(arcmode, s12_a12);
    return t;
  };

  /**
   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} in terms of the inverse geodesic problem.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} lat2 the latitude of the second point in degrees.
   * @param {number} lon2 the longitude of the second point in degrees.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include.
   * @returns {object} the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object
   * @description This function sets point 3 of the GeodesicLine to correspond
   *   to point 2 of the inverse geodesic problem.  For details on the caps
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  g.Geodesic.prototype.InverseLine = function(lat1, lon1, lat2, lon2, caps) {
    var r, t, azi1;
    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;
    r = this.InverseInt(lat1, lon1, lat2, lon2, g.ARC);
    azi1 = m.atan2d(r.salp1, r.calp1);
    // Ensure that a12 can be converted to a distance
    if (caps & (g.OUT_MASK & g.DISTANCE_IN)) caps |= g.DISTANCE;
    t = new l.GeodesicLine(this, lat1, lon1, azi1, caps, r.salp1, r.calp1);
    t.SetArc(r.vals.a12);
    return t;
  };

  /**
   * @summary Create a {@link module:GeographicLib/PolygonArea.PolygonArea
   *   PolygonArea} object.
   * @param {bool} [polyline = false] if true the new PolygonArea object
   *   describes a polyline instead of a polygon.
   * @returns {object} the
   *   {@link module:GeographicLib/PolygonArea.PolygonArea
   *   PolygonArea} object
   */
  g.Geodesic.prototype.Polygon = function(polyline) {
    return new p.PolygonArea(this, polyline);
  };

  /**
   * @summary a {@link module:GeographicLib/Geodesic.Geodesic Geodesic} object
   *   initialized for the WGS84 ellipsoid.
   * @constant {object}
   */
  g.WGS84 = new g.Geodesic(c.WGS84.a, c.WGS84.f);
})(GeographicLib.Geodesic, GeographicLib.GeodesicLine,
   GeographicLib.PolygonArea, GeographicLib.Math, GeographicLib.Constants);

/**************** GeodesicLine.js ****************/
/*
 * GeodesicLine.js
 * Transcription of GeodesicLine.[ch]pp into JavaScript.
 *
 * See the documentation for the C++ class.  The conversion is a literal
 * conversion from C++.
 *
 * The algorithms are derived in
 *
 *    Charles F. F. Karney,
 *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);
 *    https://doi.org/10.1007/s00190-012-0578-z
 *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html
 *
 * Copyright (c) Charles Karney (2011-2021) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 */

// Load AFTER GeographicLib/Math.js, GeographicLib/Geodesic.js

(function(
  g,
  /**
   * @exports GeographicLib/GeodesicLine
   * @description Solve geodesic problems on a single geodesic line via the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine GeodesicLine}
   *   class.
   */
  l, m) {
  "use strict";

  /**
   * @class
   * @property {number} a the equatorial radius (meters).
   * @property {number} f the flattening.
   * @property {number} lat1 the initial latitude (degrees).
   * @property {number} lon1 the initial longitude (degrees).
   * @property {number} azi1 the initial azimuth (degrees).
   * @property {number} salp1 the sine of the azimuth at the first point.
   * @property {number} calp1 the cosine the azimuth at the first point.
   * @property {number} s13 the distance to point 3 (meters).
   * @property {number} a13 the arc length to point 3 (degrees).
   * @property {bitmask} caps the capabilities of the object.
   * @summary Initialize a GeodesicLine object.  For details on the caps
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   * @classdesc Performs geodesic calculations along a given geodesic line.
   *   This object is usually instantiated by
   *   {@link module:GeographicLib/Geodesic.Geodesic#Line Geodesic.Line}.
   *   The methods
   *   {@link module:GeographicLib/Geodesic.Geodesic#DirectLine
   *   Geodesic.DirectLine} and
   *   {@link module:GeographicLib/Geodesic.Geodesic#InverseLine
   *   Geodesic.InverseLine} set in addition the position of a reference point
   *   3.
   * @param {object} geod a {@link module:GeographicLib/Geodesic.Geodesic
   *   Geodesic} object.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include; LATITUDE | AZIMUTH are always included.
   */
  l.GeodesicLine = function(geod, lat1, lon1, azi1, caps, salp1, calp1) {
    var t, cbet1, sbet1, eps, s, c;
    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;

    this.a = geod.a;
    this.f = geod.f;
    this._b = geod._b;
    this._c2 = geod._c2;
    this._f1 = geod._f1;
    this.caps = caps | g.LATITUDE | g.AZIMUTH | g.LONG_UNROLL;

    this.lat1 = m.LatFix(lat1);
    this.lon1 = lon1;
    if (typeof salp1 === 'undefined' || typeof calp1 === 'undefined') {
      this.azi1 = m.AngNormalize(azi1);
      t = m.sincosd(m.AngRound(this.azi1)); this.salp1 = t.s; this.calp1 = t.c;
    } else {
      this.azi1 = azi1; this.salp1 = salp1; this.calp1 = calp1;
    }
    t = m.sincosd(m.AngRound(this.lat1)); sbet1 = this._f1 * t.s; cbet1 = t.c;
    // norm(sbet1, cbet1);
    t = m.hypot(sbet1, cbet1); sbet1 /= t; cbet1 /= t;
    // Ensure cbet1 = +epsilon at poles
    cbet1 = Math.max(g.tiny_, cbet1);
    this._dn1 = Math.sqrt(1 + geod._ep2 * m.sq(sbet1));

    // Evaluate alp0 from sin(alp1) * cos(bet1) = sin(alp0),
    this._salp0 = this.salp1 * cbet1; // alp0 in [0, pi/2 - |bet1|]
    // Alt: calp0 = hypot(sbet1, calp1 * cbet1).  The following
    // is slightly better (consider the case salp1 = 0).
    this._calp0 = m.hypot(this.calp1, this.salp1 * sbet1);
    // Evaluate sig with tan(bet1) = tan(sig1) * cos(alp1).
    // sig = 0 is nearest northward crossing of equator.
    // With bet1 = 0, alp1 = pi/2, we have sig1 = 0 (equatorial line).
    // With bet1 =  pi/2, alp1 = -pi, sig1 =  pi/2
    // With bet1 = -pi/2, alp1 =  0 , sig1 = -pi/2
    // Evaluate omg1 with tan(omg1) = sin(alp0) * tan(sig1).
    // With alp0 in (0, pi/2], quadrants for sig and omg coincide.
    // No atan2(0,0) ambiguity at poles since cbet1 = +epsilon.
    // With alp0 = 0, omg1 = 0 for alp1 = 0, omg1 = pi for alp1 = pi.
    this._ssig1 = sbet1; this._somg1 = this._salp0 * sbet1;
    this._csig1 = this._comg1 =
      sbet1 !== 0 || this.calp1 !== 0 ? cbet1 * this.calp1 : 1;
    // norm(this._ssig1, this._csig1); // sig1 in (-pi, pi]
    t = m.hypot(this._ssig1, this._csig1);
    this._ssig1 /= t; this._csig1 /= t;
    // norm(this._somg1, this._comg1); -- don't need to normalize!

    this._k2 = m.sq(this._calp0) * geod._ep2;
    eps = this._k2 / (2 * (1 + Math.sqrt(1 + this._k2)) + this._k2);

    if (this.caps & g.CAP_C1) {
      this._A1m1 = g.A1m1f(eps);
      this._C1a = new Array(g.nC1_ + 1);
      g.C1f(eps, this._C1a);
      this._B11 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C1a);
      s = Math.sin(this._B11); c = Math.cos(this._B11);
      // tau1 = sig1 + B11
      this._stau1 = this._ssig1 * c + this._csig1 * s;
      this._ctau1 = this._csig1 * c - this._ssig1 * s;
      // Not necessary because C1pa reverts C1a
      //    _B11 = -SinCosSeries(true, _stau1, _ctau1, _C1pa);
    }

    if (this.caps & g.CAP_C1p) {
      this._C1pa = new Array(g.nC1p_ + 1);
      g.C1pf(eps, this._C1pa);
    }

    if (this.caps & g.CAP_C2) {
      this._A2m1 = g.A2m1f(eps);
      this._C2a = new Array(g.nC2_ + 1);
      g.C2f(eps, this._C2a);
      this._B21 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C2a);
    }

    if (this.caps & g.CAP_C3) {
      this._C3a = new Array(g.nC3_);
      geod.C3f(eps, this._C3a);
      this._A3c = -this.f * this._salp0 * geod.A3f(eps);
      this._B31 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C3a);
    }

    if (this.caps & g.CAP_C4) {
      this._C4a = new Array(g.nC4_); // all the elements of _C4a are used
      geod.C4f(eps, this._C4a);
      // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0)
      this._A4 = m.sq(this.a) * this._calp0 * this._salp0 * geod._e2;
      this._B41 = g.SinCosSeries(false, this._ssig1, this._csig1, this._C4a);
    }

    this.a13 = this.s13 = Number.NaN;
  };

  /**
   * @summary Find the position on the line (general case).
   * @param {bool} arcmode is the next parameter an arc length?
   * @param {number} s12_a12 the (arcmode ? arc length : distance) from the
   *   first point to the second in (arcmode ? degrees : meters).
   * @param {bitmask} [outmask = STANDARD] which results to include; this is
   *   subject to the capabilities of the object.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, and a12 fields of the result are
   *   always set; s12 is included if arcmode is false.  For details on the
   *   outmask parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  l.GeodesicLine.prototype.GenPosition = function(arcmode, s12_a12,
                                                  outmask) {
    var vals = {},
        sig12, ssig12, csig12, B12, AB1, ssig2, csig2, tau12, s, c, serr,
        omg12, lam12, lon12, E, sbet2, cbet2, somg2, comg2, salp2, calp2, dn2,
        B22, AB2, J12, t, B42, salp12, calp12;
    if (!outmask) outmask = g.STANDARD;
    else if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;
    outmask &= this.caps & g.OUT_MASK;
    vals.lat1 = this.lat1; vals.azi1 = this.azi1;
    vals.lon1 = outmask & g.LONG_UNROLL ?
      this.lon1 : m.AngNormalize(this.lon1);
    if (arcmode)
      vals.a12 = s12_a12;
    else
      vals.s12 = s12_a12;
    if (!( arcmode || (this.caps & g.DISTANCE_IN & g.OUT_MASK) )) {
      // Uninitialized or impossible distance calculation requested
      vals.a12 = Number.NaN;
      return vals;
    }

    // Avoid warning about uninitialized B12.
    B12 = 0; AB1 = 0;
    if (arcmode) {
      // Interpret s12_a12 as spherical arc length
      sig12 = s12_a12 * m.degree;
      t = m.sincosd(s12_a12); ssig12 = t.s; csig12 = t.c;
    } else {
      // Interpret s12_a12 as distance
      tau12 = s12_a12 / (this._b * (1 + this._A1m1));
      s = Math.sin(tau12);
      c = Math.cos(tau12);
      // tau2 = tau1 + tau12
      B12 = -g.SinCosSeries(true,
                            this._stau1 * c + this._ctau1 * s,
                            this._ctau1 * c - this._stau1 * s,
                            this._C1pa);
      sig12 = tau12 - (B12 - this._B11);
      ssig12 = Math.sin(sig12); csig12 = Math.cos(sig12);
      if (Math.abs(this.f) > 0.01) {
        // Reverted distance series is inaccurate for |f| > 1/100, so correct
        // sig12 with 1 Newton iteration.  The following table shows the
        // approximate maximum error for a = WGS_a() and various f relative to
        // GeodesicExact.
        //     erri = the error in the inverse solution (nm)
        //     errd = the error in the direct solution (series only) (nm)
        //     errda = the error in the direct solution
        //             (series + 1 Newton) (nm)
        //
        //       f     erri  errd errda
        //     -1/5    12e6 1.2e9  69e6
        //     -1/10  123e3  12e6 765e3
        //     -1/20   1110 108e3  7155
        //     -1/50  18.63 200.9 27.12
        //     -1/100 18.63 23.78 23.37
        //     -1/150 18.63 21.05 20.26
        //      1/150 22.35 24.73 25.83
        //      1/100 22.35 25.03 25.31
        //      1/50  29.80 231.9 30.44
        //      1/20   5376 146e3  10e3
        //      1/10  829e3  22e6 1.5e6
        //      1/5   157e6 3.8e9 280e6
        ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;
        csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;
        B12 = g.SinCosSeries(true, ssig2, csig2, this._C1a);
        serr = (1 + this._A1m1) * (sig12 + (B12 - this._B11)) -
          s12_a12 / this._b;
        sig12 = sig12 - serr / Math.sqrt(1 + this._k2 * m.sq(ssig2));
        ssig12 = Math.sin(sig12); csig12 = Math.cos(sig12);
        // Update B12 below
      }
    }

    // sig2 = sig1 + sig12
    ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;
    csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;
    dn2 = Math.sqrt(1 + this._k2 * m.sq(ssig2));
    if (outmask & (g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE)) {
      if (arcmode || Math.abs(this.f) > 0.01)
        B12 = g.SinCosSeries(true, ssig2, csig2, this._C1a);
      AB1 = (1 + this._A1m1) * (B12 - this._B11);
    }
    // sin(bet2) = cos(alp0) * sin(sig2)
    sbet2 = this._calp0 * ssig2;
    // Alt: cbet2 = hypot(csig2, salp0 * ssig2);
    cbet2 = m.hypot(this._salp0, this._calp0 * csig2);
    if (cbet2 === 0)
      // I.e., salp0 = 0, csig2 = 0.  Break the degeneracy in this case
      cbet2 = csig2 = g.tiny_;
    // tan(alp0) = cos(sig2)*tan(alp2)
    salp2 = this._salp0; calp2 = this._calp0 * csig2; // No need to normalize

    if (arcmode && (outmask & g.DISTANCE))
      vals.s12 = this._b * ((1 + this._A1m1) * sig12 + AB1);

    if (outmask & g.LONGITUDE) {
      // tan(omg2) = sin(alp0) * tan(sig2)
      somg2 = this._salp0 * ssig2; comg2 = csig2; // No need to normalize
      E = m.copysign(1, this._salp0);
      // omg12 = omg2 - omg1
      omg12 = outmask & g.LONG_UNROLL ?
        E * (sig12 -
             (Math.atan2(ssig2, csig2) -
              Math.atan2(this._ssig1, this._csig1)) +
             (Math.atan2(E * somg2, comg2) -
              Math.atan2(E * this._somg1, this._comg1))) :
        Math.atan2(somg2 * this._comg1 - comg2 * this._somg1,
                     comg2 * this._comg1 + somg2 * this._somg1);
      lam12 = omg12 + this._A3c *
        ( sig12 + (g.SinCosSeries(true, ssig2, csig2, this._C3a) -
                   this._B31));
      lon12 = lam12 / m.degree;
      vals.lon2 = outmask & g.LONG_UNROLL ? this.lon1 + lon12 :
        m.AngNormalize(m.AngNormalize(this.lon1) + m.AngNormalize(lon12));
    }

    if (outmask & g.LATITUDE)
      vals.lat2 = m.atan2d(sbet2, this._f1 * cbet2);

    if (outmask & g.AZIMUTH)
      vals.azi2 = m.atan2d(salp2, calp2);

    if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
      B22 = g.SinCosSeries(true, ssig2, csig2, this._C2a);
      AB2 = (1 + this._A2m1) * (B22 - this._B21);
      J12 = (this._A1m1 - this._A2m1) * sig12 + (AB1 - AB2);
      if (outmask & g.REDUCEDLENGTH)
        // Add parens around (_csig1 * ssig2) and (_ssig1 * csig2) to ensure
        // accurate cancellation in the case of coincident points.
        vals.m12 = this._b * ((      dn2 * (this._csig1 * ssig2) -
                               this._dn1 * (this._ssig1 * csig2)) -
                              this._csig1 * csig2 * J12);
      if (outmask & g.GEODESICSCALE) {
        t = this._k2 * (ssig2 - this._ssig1) * (ssig2 + this._ssig1) /
          (this._dn1 + dn2);
        vals.M12 = csig12 +
          (t * ssig2 - csig2 * J12) * this._ssig1 / this._dn1;
        vals.M21 = csig12 -
          (t * this._ssig1 - this._csig1 * J12) * ssig2 / dn2;
      }
    }

    if (outmask & g.AREA) {
      B42 = g.SinCosSeries(false, ssig2, csig2, this._C4a);
      if (this._calp0 === 0 || this._salp0 === 0) {
        // alp12 = alp2 - alp1, used in atan2 so no need to normalize
        salp12 = salp2 * this.calp1 - calp2 * this.salp1;
        calp12 = calp2 * this.calp1 + salp2 * this.salp1;
      } else {
        // tan(alp) = tan(alp0) * sec(sig)
        // tan(alp2-alp1) = (tan(alp2) -tan(alp1)) / (tan(alp2)*tan(alp1)+1)
        // = calp0 * salp0 * (csig1-csig2) / (salp0^2 + calp0^2 * csig1*csig2)
        // If csig12 > 0, write
        //   csig1 - csig2 = ssig12 * (csig1 * ssig12 / (1 + csig12) + ssig1)
        // else
        //   csig1 - csig2 = csig1 * (1 - csig12) + ssig12 * ssig1
        // No need to normalize
        salp12 = this._calp0 * this._salp0 *
          (csig12 <= 0 ? this._csig1 * (1 - csig12) + ssig12 * this._ssig1 :
           ssig12 * (this._csig1 * ssig12 / (1 + csig12) + this._ssig1));
        calp12 = m.sq(this._salp0) + m.sq(this._calp0) * this._csig1 * csig2;
      }
      vals.S12 = this._c2 * Math.atan2(salp12, calp12) +
        this._A4 * (B42 - this._B41);
    }

    if (!arcmode)
      vals.a12 = sig12 / m.degree;
    return vals;
  };

  /**
   * @summary Find the position on the line given s12.
   * @param {number} s12 the distance from the first point to the second in
   *   meters.
   * @param {bitmask} [outmask = STANDARD] which results to include; this is
   *   subject to the capabilities of the object.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, s12, and a12 fields of the result are
   *   always set; s12 is included if arcmode is false.  For details on the
   *   outmask parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  l.GeodesicLine.prototype.Position = function(s12, outmask) {
    return this.GenPosition(false, s12, outmask);
  };

  /**
   * @summary Find the position on the line given a12.
   * @param {number} a12 the arc length from the first point to the second in
   *   degrees.
   * @param {bitmask} [outmask = STANDARD] which results to include; this is
   *   subject to the capabilities of the object.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, and a12 fields of the result are
   *   always set.  For details on the outmask parameter, see {@tutorial
   *   2-interface}, "The outmask and caps parameters".
   */
  l.GeodesicLine.prototype.ArcPosition = function(a12, outmask) {
    return this.GenPosition(true, a12, outmask);
  };

  /**
   * @summary Specify position of point 3 in terms of either distance or arc
   *   length.
   * @param {bool} arcmode boolean flag determining the meaning of the second
   *   parameter; if arcmode is false, then the GeodesicLine object must have
   *   been constructed with caps |= DISTANCE_IN.
   * @param {number} s13_a13 if arcmode is false, this is the distance from
   *   point 1 to point 3 (meters); otherwise it is the arc length from
   *   point 1 to point 3 (degrees); it can be negative.
   */
  l.GeodesicLine.prototype.GenSetDistance = function(arcmode, s13_a13) {
    if (arcmode)
      this.SetArc(s13_a13);
    else
      this.SetDistance(s13_a13);
  };

  /**
   * @summary Specify position of point 3 in terms distance.
   * @param {number} s13 the distance from point 1 to point 3 (meters); it
   *   can be negative.
   */
  l.GeodesicLine.prototype.SetDistance = function(s13) {
    var r;
    this.s13 = s13;
    r = this.GenPosition(false, this.s13, g.ARC);
    this.a13 = 0 + r.a12;       // the 0+ converts undefined into NaN
  };

  /**
   * @summary Specify position of point 3 in terms of arc length.
   * @param {number} a13 the arc length from point 1 to point 3 (degrees);
   *   it can be negative.
   */
  l.GeodesicLine.prototype.SetArc = function(a13) {
    var r;
    this.a13 = a13;
    r = this.GenPosition(true, this.a13, g.DISTANCE);
    this.s13 = 0 + r.s12;       // the 0+ converts undefined into NaN
  };

})(GeographicLib.Geodesic, GeographicLib.GeodesicLine, GeographicLib.Math);

/**************** PolygonArea.js ****************/
/*
 * PolygonArea.js
 * Transcription of PolygonArea.[ch]pp into JavaScript.
 *
 * See the documentation for the C++ class.  The conversion is a literal
 * conversion from C++.
 *
 * The algorithms are derived in
 *
 *    Charles F. F. Karney,
 *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);
 *    https://doi.org/10.1007/s00190-012-0578-z
 *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html
 *
 * Copyright (c) Charles Karney (2011-2021) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 */

// Load AFTER GeographicLib/Math.js and GeographicLib/Geodesic.js

(function(
  /**
   * @exports GeographicLib/PolygonArea
   * @description Compute the area of geodesic polygons via the
   *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea}
   *   class.
   */
  p, g, m, a) {
  "use strict";

  var transit, transitdirect, AreaReduceA, AreaReduceB;
  transit = function(lon1, lon2) {
    // Return 1 or -1 if crossing prime meridian in east or west direction.
    // Otherwise return zero.
    var lon12, cross;
    // Compute lon12 the same way as Geodesic::Inverse.
    lon1 = m.AngNormalize(lon1);
    lon2 = m.AngNormalize(lon2);
    lon12 = m.AngDiff(lon1, lon2).s;
    cross = lon1 <= 0 && lon2 > 0 && lon12 > 0 ? 1 :
      (lon2 <= 0 && lon1 > 0 && lon12 < 0 ? -1 : 0);
    return cross;
  };

  // an alternate version of transit to deal with longitudes in the direct
  // problem.
  transitdirect = function(lon1, lon2) {
    // We want to compute exactly
    //   int(ceil(lon2 / 360)) - int(ceil(lon1 / 360))
    // Since we only need the parity of the result we can use std::remquo but
    // this is buggy with g++ 4.8.3 and requires C++11.  So instead we do
    lon1 = lon1 % 720.0; lon2 = lon2 % 720.0;
    return ( ((lon2 <= 0 && lon2 > -360) || lon2 > 360 ? 1 : 0) -
             ((lon1 <= 0 && lon1 > -360) || lon1 > 360 ? 1 : 0) );
  };

  // Reduce Accumulator area
  AreaReduceA = function(area, area0, crossings, reverse, sign) {
    area.Remainder(area0);
    if (crossings & 1)
      area.Add( (area.Sum() < 0 ? 1 : -1) * area0/2 );
    // area is with the clockwise sense.  If !reverse convert to
    // counter-clockwise convention.
    if (!reverse)
      area.Negate();
    // If sign put area in (-area0/2, area0/2], else put area in [0, area0)
    if (sign) {
      if (area.Sum() > area0/2)
        area.Add( -area0 );
      else if (area.Sum() <= -area0/2)
        area.Add( +area0 );
    } else {
      if (area.Sum() >= area0)
        area.Add( -area0 );
      else if (area.Sum() < 0)
        area.Add( +area0 );
    }
    return 0 + area.Sum();
  };

  // Reduce double area
  AreaReduceB = function(area, area0, crossings, reverse, sign) {
    area = m.remainder(area, area0);
    if (crossings & 1)
      area += (area < 0 ? 1 : -1) * area0/2;
    // area is with the clockwise sense.  If !reverse convert to
    // counter-clockwise convention.
    if (!reverse)
      area *= -1;
    // If sign put area in (-area0/2, area0/2], else put area in [0, area0)
    if (sign) {
      if (area > area0/2)
        area -= area0;
      else if (area <= -area0/2)
        area += area0;
    } else {
      if (area >= area0)
        area -= area0;
      else if (area < 0)
        area += area0;
    }
    return 0 + area;
  };

  /**
   * @class
   * @property {number} a the equatorial radius (meters).
   * @property {number} f the flattening.
   * @property {bool} polyline whether the PolygonArea object describes a
   *   polyline or a polygon.
   * @property {number} num the number of vertices so far.
   * @property {number} lat the current latitude (degrees).
   * @property {number} lon the current longitude (degrees).
   * @summary Initialize a PolygonArea object.
   * @classdesc Computes the area and perimeter of a geodesic polygon.
   *   This object is usually instantiated by
   *   {@link module:GeographicLib/Geodesic.Geodesic#Polygon Geodesic.Polygon}.
   * @param {object} geod a {@link module:GeographicLib/Geodesic.Geodesic
   *   Geodesic} object.
   * @param {bool} [polyline = false] if true the new PolygonArea object
   *   describes a polyline instead of a polygon.
   */
  p.PolygonArea = function(geod, polyline) {
    this._geod = geod;
    this.a = this._geod.a;
    this.f = this._geod.f;
    this._area0 = 4 * Math.PI * geod._c2;
    this.polyline = !polyline ? false : polyline;
    this._mask = g.LATITUDE | g.LONGITUDE | g.DISTANCE |
          (this.polyline ? g.NONE : g.AREA | g.LONG_UNROLL);
    if (!this.polyline)
      this._areasum = new a.Accumulator(0);
    this._perimetersum = new a.Accumulator(0);
    this.Clear();
  };

  /**
   * @summary Clear the PolygonArea object, setting the number of vertices to
   *   0.
   */
  p.PolygonArea.prototype.Clear = function() {
    this.num = 0;
    this._crossings = 0;
    if (!this.polyline)
      this._areasum.Set(0);
    this._perimetersum.Set(0);
    this._lat0 = this._lon0 = this.lat = this.lon = Number.NaN;
  };

  /**
   * @summary Add the next vertex to the polygon.
   * @param {number} lat the latitude of the point (degrees).
   * @param {number} lon the longitude of the point (degrees).
   * @description This adds an edge from the current vertex to the new vertex.
   */
  p.PolygonArea.prototype.AddPoint = function(lat, lon) {
    var t;
    if (this.num === 0) {
      this._lat0 = this.lat = lat;
      this._lon0 = this.lon = lon;
    } else {
      t = this._geod.Inverse(this.lat, this.lon, lat, lon, this._mask);
      this._perimetersum.Add(t.s12);
      if (!this.polyline) {
        this._areasum.Add(t.S12);
        this._crossings += transit(this.lon, lon);
      }
      this.lat = lat;
      this.lon = lon;
    }
    ++this.num;
  };

  /**
   * @summary Add the next edge to the polygon.
   * @param {number} azi the azimuth at the current the point (degrees).
   * @param {number} s the length of the edge (meters).
   * @description This specifies the new vertex in terms of the edge from the
   *   current vertex.
   */
  p.PolygonArea.prototype.AddEdge = function(azi, s) {
    var t;
    if (this.num) {
      t = this._geod.Direct(this.lat, this.lon, azi, s, this._mask);
      this._perimetersum.Add(s);
      if (!this.polyline) {
        this._areasum.Add(t.S12);
        this._crossings += transitdirect(this.lon, t.lon2);
      }
      this.lat = t.lat2;
      this.lon = t.lon2;
    }
    ++this.num;
  };

  /**
   * @summary Compute the perimeter and area of the polygon.
   * @param {bool} reverse if true then clockwise (instead of
   *   counter-clockwise) traversal counts as a positive area.
   * @param {bool} sign if true then return a signed result for the area if the
   *   polygon is traversed in the "wrong" direction instead of returning the
   *   area for the rest of the earth.
   * @returns {object} r where r.number is the number of vertices, r.perimeter
   *   is the perimeter (meters), and r.area (only returned if polyline is
   *   false) is the area (meters<sup>2</sup>).
   * @description Arbitrarily complex polygons are allowed.  In the case of
   *   self-intersecting polygons the area is accumulated "algebraically",
   *   e.g., the areas of the 2 loops in a figure-8 polygon will partially
   *   cancel.  If the object is a polygon (and not a polyline), the perimeter
   *   includes the length of a final edge connecting the current point to the
   *   initial point.  If the object is a polyline, then area is nan.  More
   *   points can be added to the polygon after this call.
   */
  p.PolygonArea.prototype.Compute = function(reverse, sign) {
    var vals = {number: this.num}, t, tempsum;
    if (this.num < 2) {
      vals.perimeter = 0;
      if (!this.polyline)
        vals.area = 0;
      return vals;
    }
    if (this.polyline) {
      vals.perimeter = this._perimetersum.Sum();
      return vals;
    }
    t = this._geod.Inverse(this.lat, this.lon, this._lat0, this._lon0,
                           this._mask);
    vals.perimeter = this._perimetersum.Sum(t.s12);
    tempsum = new a.Accumulator(this._areasum);
    tempsum.Add(t.S12);
    vals.area = AreaReduceA(tempsum, this._area0,
                            this._crossings + transit(this.lon, this._lon0),
                            reverse, sign);
    return vals;
  };

  /**
   * @summary Compute the perimeter and area of the polygon with a tentative
   *   new vertex.
   * @param {number} lat the latitude of the point (degrees).
   * @param {number} lon the longitude of the point (degrees).
   * @param {bool} reverse if true then clockwise (instead of
   *   counter-clockwise) traversal counts as a positive area.
   * @param {bool} sign if true then return a signed result for the area if the
   *   polygon is traversed in the "wrong" direction instead of returning the
   *   area for the rest of the earth.
   * @returns {object} r where r.number is the number of vertices, r.perimeter
   *   is the perimeter (meters), and r.area (only returned if polyline is
   *   false) is the area (meters<sup>2</sup>).
   * @description A new vertex is *not* added to the polygon.
   */
  p.PolygonArea.prototype.TestPoint = function(lat, lon, reverse, sign) {
    var vals = {number: this.num + 1}, t, tempsum, crossings, i;
    if (this.num === 0) {
      vals.perimeter = 0;
      if (!this.polyline)
        vals.area = 0;
      return vals;
    }
    vals.perimeter = this._perimetersum.Sum();
    tempsum = this.polyline ? 0 : this._areasum.Sum();
    crossings = this._crossings;
    for (i = 0; i < (this.polyline ? 1 : 2); ++i) {
      t = this._geod.Inverse(
       i === 0 ? this.lat : lat, i === 0 ? this.lon : lon,
       i !== 0 ? this._lat0 : lat, i !== 0 ? this._lon0 : lon,
       this._mask);
      vals.perimeter += t.s12;
      if (!this.polyline) {
        tempsum += t.S12;
        crossings += transit(i === 0 ? this.lon : lon,
                               i !== 0 ? this._lon0 : lon);
      }
    }

    if (this.polyline)
      return vals;

    vals.area = AreaReduceB(tempsum, this._area0, crossings, reverse, sign);
    return vals;
  };

  /**
   * @summary Compute the perimeter and area of the polygon with a tentative
   *   new edge.
   * @param {number} azi the azimuth of the edge (degrees).
   * @param {number} s the length of the edge (meters).
   * @param {bool} reverse if true then clockwise (instead of
   *   counter-clockwise) traversal counts as a positive area.
   * @param {bool} sign if true then return a signed result for the area if the
   *   polygon is traversed in the "wrong" direction instead of returning the
   *   area for the rest of the earth.
   * @returns {object} r where r.number is the number of vertices, r.perimeter
   *   is the perimeter (meters), and r.area (only returned if polyline is
   *   false) is the area (meters<sup>2</sup>).
   * @description A new vertex is *not* added to the polygon.
   */
  p.PolygonArea.prototype.TestEdge = function(azi, s, reverse, sign) {
    var vals = {number: this.num ? this.num + 1 : 0}, t, tempsum, crossings;
    if (this.num === 0)
      return vals;
    vals.perimeter = this._perimetersum.Sum() + s;
    if (this.polyline)
      return vals;

    tempsum = this._areasum.Sum();
    crossings = this._crossings;
    t = this._geod.Direct(this.lat, this.lon, azi, s, this._mask);
    tempsum += t.S12;
    crossings += transitdirect(this.lon, t.lon2);
    crossings += transit(t.lon2, this._lon0);
    t = this._geod.Inverse(t.lat2, t.lon2, this._lat0, this._lon0, this._mask);
    vals.perimeter += t.s12;
    tempsum += t.S12;

    vals.area = AreaReduceB(tempsum, this._area0, crossings, reverse, sign);
    return vals;
  };

})(GeographicLib.PolygonArea, GeographicLib.Geodesic,
   GeographicLib.Math, GeographicLib.Accumulator);

/**************** DMS.js ****************/
/*
 * DMS.js
 * Transcription of DMS.[ch]pp into JavaScript.
 *
 * See the documentation for the C++ class.  The conversion is a literal
 * conversion from C++.
 *
 * Copyright (c) Charles Karney (2011-2020) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 */

GeographicLib.DMS = {};

(function(
  /**
   * @exports GeographicLib/DMS
   * @description Decode/Encode angles expressed as degrees, minutes, and
   *   seconds.  This module defines several constants:
   *   - hemisphere indicator (returned by
   *       {@link module:GeographicLib/DMS.Decode Decode}) and a formatting
   *       indicator (used by
   *       {@link module:GeographicLib/DMS.Encode Encode})
   *     - NONE = 0, no designator and format as plain angle;
   *     - LATITUDE = 1, a N/S designator and format as latitude;
   *     - LONGITUDE = 2, an E/W designator and format as longitude;
   *     - AZIMUTH = 3, format as azimuth;
   *   - the specification of the trailing component in
   *       {@link module:GeographicLib/DMS.Encode Encode}
   *     - DEGREE;
   *     - MINUTE;
   *     - SECOND.
   */
  d) {
  "use strict";

  var lookup, zerofill, internalDecode, numMatch,
      hemispheres_ = "SNWE",
      signs_ = "-+",
      digits_ = "0123456789",
      dmsindicators_ = "D'\":",
      // dmsindicatorsu_ = "\u00b0\u2032\u2033"; // Unicode variants
      dmsindicatorsu_ = "\u00b0'\"", // Use degree symbol
      components_ = ["degrees", "minutes", "seconds"];
  lookup = function(s, c) {
    return s.indexOf(c.toUpperCase());
  };
  zerofill = function(s, n) {
    return String("0000").substr(0, Math.max(0, Math.min(4, n-s.length))) +
      s;
  };
  d.NONE = 0;
  d.LATITUDE = 1;
  d.LONGITUDE = 2;
  d.AZIMUTH = 3;
  d.DEGREE = 0;
  d.MINUTE = 1;
  d.SECOND = 2;

  /**
   * @summary Decode a DMS string.
   * @description The interpretation of the string is given in the
   *   documentation of the corresponding function, Decode(string&, flag&)
   *   in the {@link
   *   https://geographiclib.sourceforge.io/html/classGeographicLib_1_1DMS.html
   *   C++ DMS class}
   * @param {string} dms the string.
   * @returns {object} r where r.val is the decoded value (degrees) and r.ind
   *   is a hemisphere designator, one of NONE, LATITUDE, LONGITUDE.
   * @throws an error if the string is illegal.
   */
  d.Decode = function(dms) {
    var dmsa = dms, end,
        v = 0, i = 0, mi, pi, vals,
        ind1 = d.NONE, ind2, p, pa, pb;
    dmsa = dmsa
      .replace(/\u00b0/g, 'd' ) // U+00b0 degree symbol
      .replace(/\u00ba/g, 'd' ) // U+00ba alt symbol
      .replace(/\u2070/g, 'd' ) // U+2070 sup zero
      .replace(/\u02da/g, 'd' ) // U+02da ring above
      .replace(/\u2218/g, 'd' ) // U+2218 compose function
      .replace(/\*/g    , 'd' ) // GRiD symbol for degree

      .replace(/`/g     , 'd' ) // grave accent
      .replace(/\u2032/g, '\'') // U+2032 prime
      .replace(/\u2035/g, '\'') // U+2035 back prime
      .replace(/\u00b4/g, '\'') // U+00b4 acute accent
      .replace(/\u2018/g, '\'') // U+2018 left single quote
      .replace(/\u2019/g, '\'') // U+2019 right single quote
      .replace(/\u201b/g, '\'') // U+201b reversed-9 single quote
      .replace(/\u02b9/g, '\'') // U+02b9 modifier letter prime
      .replace(/\u02ca/g, '\'') // U+02ca modifier letter acute accent
      .replace(/\u02cb/g, '\'') // U+02cb modifier letter grave accent

      .replace(/\u2033/g, '"' ) // U+2033 double prime
      .replace(/\u2036/g, '"' ) // U+2036 reversed double prime
      .replace(/\u02dd/g, '"' ) // U+02dd double acute accent
      .replace(/\u201c/g, '"' ) // U+201d left double quote
      .replace(/\u201d/g, '"' ) // U+201d right double quote
      .replace(/\u201f/g, '"' ) // U+201f reversed-9 double quote
      .replace(/\u02ba/g, '"' ) // U+02ba modifier letter double prime

      .replace(/\u2795/g, '+' ) // U+2795 heavy plus
      .replace(/\u2064/g, '+' ) // U+2064 invisible plus

      .replace(/\u2010/g, '-' ) // U+2010 dash
      .replace(/\u2011/g, '-' ) // U+2011 non-breaking hyphen
      .replace(/\u2013/g, '-' ) // U+2013 en dash
      .replace(/\u2014/g, '-' ) // U+2014 em dash
      .replace(/\u2212/g, '-' ) // U+2212 minus sign
      .replace(/\u2796/g, '-' ) // U+2796 heavy minus

      .replace(/\u00a0/g, ''  ) // U+00a0 non-breaking space
      .replace(/\u2007/g, ''  ) // U+2007 figure space
      .replace(/\u2009/g, ''  ) // U+2009 thin space
      .replace(/\u200a/g, ''  ) // U+200a hair space
      .replace(/\u200b/g, ''  ) // U+200b invisible space
      .replace(/\u202f/g, ''  ) // U+202f narrow space
      .replace(/\u2063/g, ''  ) // U+2063 invisible separator

      .replace(/''/g,     '"' ) // '' -> "

      .trim();

    end = dmsa.length;
    // p is pointer to the next piece that needs decoding
    for (p = 0; p < end; p = pb, ++i) {
      pa = p;
      // Skip over initial hemisphere letter (for i == 0)
      if (i === 0 && lookup(hemispheres_, dmsa.charAt(pa)) >= 0)
        ++pa;
      // Skip over initial sign (checking for it if i == 0)
      if (i > 0 || (pa < end && lookup(signs_, dmsa.charAt(pa)) >= 0))
        ++pa;
      // Find next sign
      mi = dmsa.substr(pa, end - pa).indexOf('-');
      pi = dmsa.substr(pa, end - pa).indexOf('+');
      if (mi < 0) mi = end; else mi += pa;
      if (pi < 0) pi = end; else pi += pa;
      pb = Math.min(mi, pi);
      vals = internalDecode(dmsa.substr(p, pb - p));
      v += vals.val; ind2 = vals.ind;
      if (ind1 === d.NONE)
        ind1 = ind2;
      else if (!(ind2 === d.NONE || ind1 === ind2))
        throw new Error("Incompatible hemisphere specifies in " +
                        dmsa.substr(0, pb));
    }
    if (i === 0)
      throw new Error("Empty or incomplete DMS string " + dmsa);
    return {val: v, ind: ind1};
  };

  internalDecode = function(dmsa) {
    var vals = {}, errormsg = "",
        sign, beg, end, ind1, k,
        ipieces, fpieces, npiece,
        icurrent, fcurrent, ncurrent, p,
        pointseen,
        digcount, intcount,
        x;
    do {                       // Executed once (provides the ability to break)
      sign = 1;
      beg = 0; end = dmsa.length;
      ind1 = d.NONE;
      k = -1;
      if (end > beg && (k = lookup(hemispheres_, dmsa.charAt(beg))) >= 0) {
        ind1 = (k & 2) ? d.LONGITUDE : d.LATITUDE;
        sign = (k & 1) ? 1 : -1;
        ++beg;
      }
      if (end > beg &&
          (k = lookup(hemispheres_, dmsa.charAt(end-1))) >= 0) {
        if (k >= 0) {
          if (ind1 !== d.NONE) {
            if (dmsa.charAt(beg - 1).toUpperCase() ===
                dmsa.charAt(end - 1).toUpperCase())
              errormsg = "Repeated hemisphere indicators " +
              dmsa.charAt(beg - 1) + " in " +
              dmsa.substr(beg - 1, end - beg + 1);
            else
              errormsg = "Contradictory hemisphere indicators " +
              dmsa.charAt(beg - 1) + " and " + dmsa.charAt(end - 1) + " in " +
              dmsa.substr(beg - 1, end - beg + 1);
            break;
          }
          ind1 = (k & 2) ? d.LONGITUDE : d.LATITUDE;
          sign = (k & 1) ? 1 : -1;
          --end;
        }
      }
      if (end > beg && (k = lookup(signs_, dmsa.charAt(beg))) >= 0) {
        if (k >= 0) {
          sign *= k ? 1 : -1;
          ++beg;
        }
      }
      if (end === beg) {
        errormsg = "Empty or incomplete DMS string " + dmsa;
        break;
      }
      ipieces = [0, 0, 0];
      fpieces = [0, 0, 0];
      npiece = 0;
      icurrent = 0;
      fcurrent = 0;
      ncurrent = 0;
      p = beg;
      pointseen = false;
      digcount = 0;
      intcount = 0;
      while (p < end) {
        x = dmsa.charAt(p++);
        if ((k = lookup(digits_, x)) >= 0) {
          ++ncurrent;
          if (digcount > 0) {
            ++digcount;         // Count of decimal digits
          } else {
            icurrent = 10 * icurrent + k;
            ++intcount;
          }
        } else if (x === '.') {
          if (pointseen) {
            errormsg = "Multiple decimal points in " +
              dmsa.substr(beg, end - beg);
            break;
          }
          pointseen = true;
          digcount = 1;
        } else if ((k = lookup(dmsindicators_, x)) >= 0) {
          if (k >= 3) {
            if (p === end) {
              errormsg = "Illegal for colon to appear at the end of " +
                dmsa.substr(beg, end - beg);
              break;
            }
            k = npiece;
          }
          if (k === npiece - 1) {
            errormsg = "Repeated " + components_[k] +
              " component in " + dmsa.substr(beg, end - beg);
            break;
          } else if (k < npiece) {
            errormsg = components_[k] + " component follows " +
              components_[npiece - 1] + " component in " +
              dmsa.substr(beg, end - beg);
            break;
          }
          if (ncurrent === 0) {
            errormsg = "Missing numbers in " + components_[k] +
              " component of " + dmsa.substr(beg, end - beg);
            break;
          }
          if (digcount > 0) {
            fcurrent = parseFloat(dmsa.substr(p - intcount - digcount - 1,
                                              intcount + digcount));
            icurrent = 0;
          }
          ipieces[k] = icurrent;
          fpieces[k] = icurrent + fcurrent;
          if (p < end) {
            npiece = k + 1;
            icurrent = fcurrent = 0;
            ncurrent = digcount = intcount = 0;
          }
        } else if (lookup(signs_, x) >= 0) {
          errormsg = "Internal sign in DMS string " +
            dmsa.substr(beg, end - beg);
          break;
        } else {
          errormsg = "Illegal character " + x + " in DMS string " +
            dmsa.substr(beg, end - beg);
          break;
        }
      }
      if (errormsg.length)
        break;
      if (lookup(dmsindicators_, dmsa.charAt(p - 1)) < 0) {
        if (npiece >= 3) {
          errormsg = "Extra text following seconds in DMS string " +
            dmsa.substr(beg, end - beg);
          break;
        }
        if (ncurrent === 0) {
          errormsg = "Missing numbers in trailing component of " +
            dmsa.substr(beg, end - beg);
          break;
        }
        if (digcount > 0) {
          fcurrent = parseFloat(dmsa.substr(p - intcount - digcount,
                                            intcount + digcount));
          icurrent = 0;
        }
        ipieces[npiece] = icurrent;
        fpieces[npiece] = icurrent + fcurrent;
      }
      if (pointseen && digcount === 0) {
        errormsg = "Decimal point in non-terminal component of " +
          dmsa.substr(beg, end - beg);
        break;
      }
      // Note that we accept 59.999999... even though it rounds to 60.
      if (ipieces[1] >= 60 || fpieces[1] > 60) {
        errormsg = "Minutes " + fpieces[1] + " not in range [0,60)";
        break;
      }
      if (ipieces[2] >= 60 || fpieces[2] > 60) {
        errormsg = "Seconds " + fpieces[2] + " not in range [0,60)";
        break;
      }
      vals.ind = ind1;
      // Assume check on range of result is made by calling routine (which
      // might be able to offer a better diagnostic).
      vals.val = sign *
        ( fpieces[2] ? (60*(60*fpieces[0] + fpieces[1]) + fpieces[2]) / 3600 :
          ( fpieces[1] ? (60*fpieces[0] + fpieces[1]) / 60 : fpieces[0] ) );
      return vals;
    } while (false);
    vals.val = numMatch(dmsa);
    if (vals.val === 0)
      throw new Error(errormsg);
    else
      vals.ind = d.NONE;
    return vals;
  };

  numMatch = function(s) {
    var t, sign, p0, p1;
    if (s.length < 3)
      return 0;
    t = s.toUpperCase().replace(/0+$/, "");
    sign = t.charAt(0) === '-' ? -1 : 1;
    p0 = t.charAt(0) === '-' || t.charAt(0) === '+' ? 1 : 0;
    p1 = t.length - 1;
    if (p1 + 1 < p0 + 3)
      return 0;
    // Strip off sign and trailing 0s
    t = t.substr(p0, p1 + 1 - p0); // Length at least 3
    if (t === "NAN" || t === "1.#QNAN" || t === "1.#SNAN" || t === "1.#IND" ||
        t === "1.#R")
      return Number.NaN;
    else if (t === "INF" || t === "1.#INF")
      return sign * Number.POSITIVE_INFINITY;
    return 0;
  };

  /**
   * @summary Decode two DMS strings interpreting them as a latitude/longitude
   *   pair.
   * @param {string} stra the first string.
   * @param {string} strb the first string.
   * @param {bool} [longfirst = false] if true assume then longitude is given
   *   first (in the absence of any hemisphere indicators).
   * @returns {object} r where r.lat is the decoded latitude and r.lon is the
   *   decoded longitude (both in degrees).
   * @throws an error if the strings are illegal.
   */
  d.DecodeLatLon = function(stra, strb, longfirst) {
    var vals = {},
        valsa = d.Decode(stra),
        valsb = d.Decode(strb),
        a = valsa.val, ia = valsa.ind,
        b = valsb.val, ib = valsb.ind,
        lat, lon;
    if (!longfirst) longfirst = false;
    if (ia === d.NONE && ib === d.NONE) {
      // Default to lat, long unless longfirst
      ia = longfirst ? d.LONGITUDE : d.LATITUDE;
      ib = longfirst ? d.LATITUDE : d.LONGITUDE;
    } else if (ia === d.NONE)
      ia = d.LATITUDE + d.LONGITUDE - ib;
    else if (ib === d.NONE)
      ib = d.LATITUDE + d.LONGITUDE - ia;
    if (ia === ib)
      throw new Error("Both " + stra + " and " + strb + " interpreted as " +
                      (ia === d.LATITUDE ? "latitudes" : "longitudes"));
    lat = ia === d.LATITUDE ? a : b;
    lon = ia === d.LATITUDE ? b : a;
    if (Math.abs(lat) > 90)
      throw new Error("Latitude " + lat + " not in [-90,90]");
    vals.lat = lat;
    vals.lon = lon;
    return vals;
  };

  /**
   * @summary Decode a DMS string interpreting it as an arc length.
   * @param {string} angstr the string (this must not include a hemisphere
   *   indicator).
   * @returns {number} the arc length (degrees).
   * @throws an error if the string is illegal.
   */
  d.DecodeAngle = function(angstr) {
    var vals = d.Decode(angstr),
        ang = vals.val, ind = vals.ind;
    if (ind !== d.NONE)
      throw new Error("Arc angle " + angstr +
                      " includes a hemisphere N/E/W/S");
    return ang;
  };

  /**
   * @summary Decode a DMS string interpreting it as an azimuth.
   * @param {string} azistr the string (this may include an E/W hemisphere
   *   indicator).
   * @returns {number} the azimuth (degrees).
   * @throws an error if the string is illegal.
   */
  d.DecodeAzimuth = function(azistr) {
    var vals = d.Decode(azistr),
        azi = vals.val, ind = vals.ind;
    if (ind === d.LATITUDE)
      throw new Error("Azimuth " + azistr + " has a latitude hemisphere N/S");
    return azi;
  };

  /**
   * @summary Convert angle (in degrees) into a DMS string (using &deg;, ',
   *  and &quot;).
   * @param {number} angle input angle (degrees).
   * @param {number} trailing one of DEGREE, MINUTE, or SECOND to indicate
   *   the trailing component of the string (this component is given as a
   *   decimal number if necessary).
   * @param {number} prec the number of digits after the decimal point for
   *   the trailing component.
   * @param {number} [ind = NONE] a formatting indicator, one of NONE,
   *   LATITUDE, LONGITUDE, AZIMUTH.
   * @returns {string} the resulting string formatted as follows:
   *   * NONE, signed result no leading zeros on degrees except in the units
   *     place, e.g., -8&deg;03'.
   *   * LATITUDE, trailing N or S hemisphere designator, no sign, pad
   *     degrees to 2 digits, e.g., 08&deg;03'S.
   *   * LONGITUDE, trailing E or W hemisphere designator, no sign, pad
   *     degrees to 3 digits, e.g., 008&deg;03'W.
   *   * AZIMUTH, convert to the range [0, 360&deg;), no sign, pad degrees to
   *     3 digits, e.g., 351&deg;57'.
   */
  d.Encode = function(angle, trailing, prec, ind) {
    // Assume check on range of input angle has been made by calling
    // routine (which might be able to offer a better diagnostic).
    var scale = 1, i, sign,
        idegree, fdegree, f, pieces, ip, fp, s;
    if (!ind) ind = d.NONE;
    if (!isFinite(angle))
      return angle < 0 ? String("-inf") :
      (angle > 0 ? String("inf") : String("nan"));

    // 15 - 2 * trailing = ceiling(log10(2^53/90/60^trailing)).
    // This suffices to give full real precision for numbers in [-90,90]
    prec = Math.min(15 - 2 * trailing, prec);
    for (i = 0; i < trailing; ++i)
      scale *= 60;
    for (i = 0; i < prec; ++i)
      scale *= 10;
    if (ind === d.AZIMUTH)
      angle -= Math.floor(angle/360) * 360;
    sign = angle < 0 ? -1 : 1;
    angle *= sign;

    // Break off integer part to preserve precision in manipulation of
    // fractional part.
    idegree = Math.floor(angle);
    fdegree = (angle - idegree) * scale + 0.5;
    f = Math.floor(fdegree);
    // Implement the "round ties to even" rule
    fdegree = (f === fdegree && (f & 1) === 1) ? f - 1 : f;
    fdegree /= scale;

    fdegree = Math.floor((angle - idegree) * scale + 0.5) / scale;
    if (fdegree >= 1) {
      idegree += 1;
      fdegree -= 1;
    }
    pieces = [fdegree, 0, 0];
    for (i = 1; i <= trailing; ++i) {
      ip = Math.floor(pieces[i - 1]);
      fp = pieces[i - 1] - ip;
      pieces[i] = fp * 60;
      pieces[i - 1] = ip;
    }
    pieces[0] += idegree;
    s = "";
    if (ind === d.NONE && sign < 0)
      s += '-';
    switch (trailing) {
    case d.DEGREE:
      s += zerofill(pieces[0].toFixed(prec),
                    ind === d.NONE ? 0 :
                    1 + Math.min(ind, 2) + prec + (prec ? 1 : 0)) +
        dmsindicatorsu_.charAt(0);
      break;
    default:
      s += zerofill(pieces[0].toFixed(0),
                    ind === d.NONE ? 0 : 1 + Math.min(ind, 2)) +
        dmsindicatorsu_.charAt(0);
      switch (trailing) {
      case d.MINUTE:
        s += zerofill(pieces[1].toFixed(prec), 2 + prec + (prec ? 1 : 0)) +
          dmsindicatorsu_.charAt(1);
        break;
      case d.SECOND:
        s += zerofill(pieces[1].toFixed(0), 2) + dmsindicatorsu_.charAt(1);
        s += zerofill(pieces[2].toFixed(prec), 2 + prec + (prec ? 1 : 0)) +
          dmsindicatorsu_.charAt(2);
        break;
      default:
        break;
      }
    }
    if (ind !== d.NONE && ind !== d.AZIMUTH)
      s += hemispheres_.charAt((ind === d.LATITUDE ? 0 : 2) +
                               (sign < 0 ? 0 : 1));
    return s;
  };
})(GeographicLib.DMS);

cb(GeographicLib);

})(function(geo) {
  if ( true && module.exports) {
    /******** support loading with node's require ********/
    module.exports = geo;
  } else if (true) {
    /******** support loading with AMD ********/
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return geo; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/Point.js":
/*!****************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/Point.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var mgrs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mgrs */ "./node_modules/mgrs/mgrs.js");


function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if(typeof x === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }
  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

Point.fromMGRS = function(mgrsStr) {
  return new Point(Object(mgrs__WEBPACK_IMPORTED_MODULE_0__["toPoint"])(mgrsStr));
};
Point.prototype.toMGRS = function(accuracy) {
  return Object(mgrs__WEBPACK_IMPORTED_MODULE_0__["forward"])([this.x, this.y], accuracy);
};
/* harmony default export */ __webpack_exports__["default"] = (Point);


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/Proj.js":
/*!***************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/Proj.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parseCode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseCode */ "./node_modules/melowntech-proj4/lib/parseCode.js");
/* harmony import */ var _extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extend */ "./node_modules/melowntech-proj4/lib/extend.js");
/* harmony import */ var _projections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projections */ "./node_modules/melowntech-proj4/lib/projections.js");
/* harmony import */ var _deriveConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deriveConstants */ "./node_modules/melowntech-proj4/lib/deriveConstants.js");
/* harmony import */ var _constants_Datum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants/Datum */ "./node_modules/melowntech-proj4/lib/constants/Datum.js");
/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./datum */ "./node_modules/melowntech-proj4/lib/datum.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./match */ "./node_modules/melowntech-proj4/lib/match.js");








function Projection(srsCode,callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  callback = callback || function(error){
    if(error){
      throw error;
    }
  };
  var json = Object(_parseCode__WEBPACK_IMPORTED_MODULE_0__["default"])(srsCode);
  if(typeof json !== 'object'){
    callback(srsCode);
    return;
  }
  var ourProj = Projection.projections.get(json.projName);
  if(!ourProj){
    callback(srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = Object(_match__WEBPACK_IMPORTED_MODULE_6__["default"])(_constants_Datum__WEBPACK_IMPORTED_MODULE_4__["default"], json.datumCode);
    if (datumDef) {
      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1.0;
  json.axis = json.axis || 'enu';
  json.ellps = json.ellps || 'wgs84';
  var sphere_ = Object(_deriveConstants__WEBPACK_IMPORTED_MODULE_3__["sphere"])(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = Object(_deriveConstants__WEBPACK_IMPORTED_MODULE_3__["eccentricity"])(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var datumObj = json.datum || Object(_datum__WEBPACK_IMPORTED_MODULE_5__["default"])(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);

  Object(_extend__WEBPACK_IMPORTED_MODULE_1__["default"])(this, json); // transfer everything over from the projection because we don't know what we'll need
  Object(_extend__WEBPACK_IMPORTED_MODULE_1__["default"])(this, ourProj); // transfer all the methods from the projection

  // copy the 4 things over we calulated in deriveConstants.sphere
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;

  // copy the 3 things we calculated in deriveConstants.eccentricity
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;

  // add in the datum object
  this.datum = datumObj;

  // init the projection
  this.init();

  // legecy callback from back in the day when it went to spatialreference.org
  callback(null, this);

}
Projection.projections = _projections__WEBPACK_IMPORTED_MODULE_2__["default"];
Projection.projections.start();
/* harmony default export */ __webpack_exports__["default"] = (Projection);


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/adjust_axis.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/adjust_axis.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(crs, denorm, point) {
  var xin = point.x,
    yin = point.y,
    zin = point.z || 0.0;
  var v, t, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }
    if (i === 0) {
      v = xin;
      t = 'x';
    }
    else if (i === 1) {
      v = yin;
      t = 'y';
    }
    else {
      v = zin;
      t = 'z';
    }
    switch (crs.axis[i]) {
    case 'e':
      out[t] = v;
      break;
    case 'w':
      out[t] = -v;
      break;
    case 'n':
      out[t] = v;
      break;
    case 's':
      out[t] = -v;
      break;
    case 'u':
      if (point[t] !== undefined) {
        out.z = v;
      }
      break;
    case 'd':
      if (point[t] !== undefined) {
        out.z = -v;
      }
      break;
    default:
      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
      return null;
    }
  }
  return out;
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/adjust_lat.js":
/*!****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/adjust_lat.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign */ "./node_modules/melowntech-proj4/lib/common/sign.js");



/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (Math.abs(x) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) ? x : (x - (Object(_sign__WEBPACK_IMPORTED_MODULE_1__["default"])(x) * Math.PI));
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js":
/*!****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/adjust_lon.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign */ "./node_modules/melowntech-proj4/lib/common/sign.js");




/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (Math.abs(x) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]) ? x : (x - (Object(_sign__WEBPACK_IMPORTED_MODULE_1__["default"])(x) * _constants_values__WEBPACK_IMPORTED_MODULE_0__["TWO_PI"]));
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/adjust_zone.js":
/*!*****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/adjust_zone.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");


/* harmony default export */ __webpack_exports__["default"] = (function(zone, lon) {
  if (zone === undefined) {
    zone = Math.floor((Object(_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon) + Math.PI) * 30 / Math.PI) + 1;

    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/asinhy.js":
/*!************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/asinhy.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hypot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hypot */ "./node_modules/melowntech-proj4/lib/common/hypot.js");
/* harmony import */ var _log1py__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log1py */ "./node_modules/melowntech-proj4/lib/common/log1py.js");



/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  var y = Math.abs(x);
  y = Object(_log1py__WEBPACK_IMPORTED_MODULE_1__["default"])(y * (1 + y / (Object(_hypot__WEBPACK_IMPORTED_MODULE_0__["default"])(1, y) + 1)));

  return x < 0 ? -y : y;
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/asinz.js":
/*!***********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/asinz.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  if (Math.abs(x) > 1) {
    x = (x > 1) ? 1 : -1;
  }
  return Math.asin(x);
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/clens.js":
/*!***********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/clens.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;

  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }

  return Math.sin(arg_r) * hr;
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/clens_cmplx.js":
/*!*****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/clens_cmplx.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sinh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sinh */ "./node_modules/melowntech-proj4/lib/common/sinh.js");
/* harmony import */ var _cosh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cosh */ "./node_modules/melowntech-proj4/lib/common/cosh.js");



/* harmony default export */ __webpack_exports__["default"] = (function(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = Object(_sinh__WEBPACK_IMPORTED_MODULE_0__["default"])(arg_i);
  var cosh_arg_i = Object(_cosh__WEBPACK_IMPORTED_MODULE_1__["default"])(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;

  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }

  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;

  return [r * hr - i * hi, r * hi + i * hr];
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/cosh.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/cosh.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/e0fn.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/e0fn.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/e1fn.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/e1fn.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/e2fn.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/e2fn.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (0.05859375 * x * x * (1 + 0.75 * x));
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/e3fn.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/e3fn.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return (x * x * x * (35 / 3072));
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/gN.js":
/*!********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/gN.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/gatg.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/gatg.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;

  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }

  return (B + h * Math.sin(2 * B));
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/hypot.js":
/*!***********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/hypot.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);

  return a * Math.sqrt(1 + Math.pow(b, 2));
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/imlfn.js":
/*!***********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/imlfn.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;

  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
  return NaN;
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/iqsfnz.js":
/*!************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/iqsfnz.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");


/* harmony default export */ __webpack_exports__["default"] = (function(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return (-1 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    }
    else {
      return _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    }
  }
  //var phi = 0.5* q/(1-eccent*eccent);
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
  return NaN;
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/log1py.js":
/*!************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/log1py.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  var y = 1 + x;
  var z = y - 1;

  return z === 0 ? x : x * Math.log(y) / z;
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/mlfn.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/mlfn.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(e0, e1, e2, e3, phi) {
  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/msfnz.js":
/*!***********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/msfnz.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / (Math.sqrt(1 - con * con));
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/phi2z.js":
/*!***********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/phi2z.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");


/* harmony default export */ __webpack_exports__["default"] = (function(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }
  //console.log("phi2z has NoConvergence");
  return -9999;
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/pj_enfn.js":
/*!*************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/pj_enfn.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;

/* harmony default export */ __webpack_exports__["default"] = (function(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/pj_inv_mlfn.js":
/*!*****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/pj_inv_mlfn.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pj_mlfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pj_mlfn */ "./node_modules/melowntech-proj4/lib/common/pj_mlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");



var MAX_ITER = 20;

/* harmony default export */ __webpack_exports__["default"] = (function(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;
    t = (Object(_pj_mlfn__WEBPACK_IMPORTED_MODULE_0__["default"])(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      return phi;
    }
  }
  //..reportError("cass:pj_inv_mlfn: Convergence error");
  return phi;
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/pj_mlfn.js":
/*!*************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/pj_mlfn.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/qsfnz.js":
/*!***********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/qsfnz.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(eccent, sinphi) {
  var con;
  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
  }
  else {
    return (2 * sinphi);
  }
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/sign.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/sign.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x<0 ? -1 : 1;
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/sinh.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/sinh.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/srat.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/srat.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(esinp, exp) {
  return (Math.pow((1 - esinp) / (1 + esinp), exp));
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/toPoint.js":
/*!*************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/toPoint.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (array){
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length>2) {
    out.z = array[2];
  }
  if (array.length>3) {
    out.m = array[3];
  }
  return out;
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/common/tsfnz.js":
/*!***********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/common/tsfnz.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");


/* harmony default export */ __webpack_exports__["default"] = (function(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow(((1 - con) / (1 + con)), com);
  return (Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - phi)) / con);
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/constants/Datum.js":
/*!**************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/constants/Datum.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return exports; });
var exports = {};

exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};

exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};

exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};

exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};

exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};

exports.potsdam = {
  towgs84: "606.0,23.0,413.0",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};

exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};

exports.hermannskogel = {
  towgs84: "653.0,-212.0,449.0",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};

exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};

exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};

exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};

exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};

exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};

exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};

exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};

exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/constants/Ellipsoid.js":
/*!******************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/constants/Ellipsoid.js ***!
  \******************************************************************/
/*! exports provided: default, WGS84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return exports; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WGS84", function() { return WGS84; });
var exports = {};

exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};

exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};

exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};

exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};

exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};

exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};

exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};

exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};

exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};

exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};

exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};

exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};

exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};

exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};

exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};

exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};

exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};

exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};

exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};

exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};

exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};

exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};

exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};

exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};

exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};

exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};

exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};

exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};

exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};

exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};

exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};

exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};

exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};

exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};

exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};

exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};

exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};

exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};

exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};

exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};

exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};

var WGS84 = exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};

exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/constants/PrimeMeridian.js":
/*!**********************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/constants/PrimeMeridian.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return exports; });
var exports = {};


exports.greenwich = 0.0; //"0dE",
exports.lisbon = -9.131906111111; //"9d07'54.862\"W",
exports.paris = 2.337229166667; //"2d20'14.025\"E",
exports.bogota = -74.080916666667; //"74d04'51.3\"W",
exports.madrid = -3.687938888889; //"3d41'16.58\"W",
exports.rome = 12.452333333333; //"12d27'8.4\"E",
exports.bern = 7.439583333333; //"7d26'22.5\"E",
exports.jakarta = 106.807719444444; //"106d48'27.79\"E",
exports.ferro = -17.666666666667; //"17d40'W",
exports.brussels = 4.367975; //"4d22'4.71\"E",
exports.stockholm = 18.058277777778; //"18d3'29.8\"E",
exports.athens = 23.7163375; //"23d42'58.815\"E",
exports.oslo = 10.722916666667; //"10d43'22.5\"E"


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/constants/units.js":
/*!**************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/constants/units.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  ft: {to_meter: 0.3048},
  'us-ft': {to_meter: 1200 / 3937}
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/constants/values.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/constants/values.js ***!
  \***************************************************************/
/*! exports provided: PJD_3PARAM, PJD_7PARAM, PJD_WGS84, PJD_NODATUM, SEC_TO_RAD, HALF_PI, SIXTH, RA4, RA6, EPSLN, D2R, R2D, FORTPI, TWO_PI, SPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_3PARAM", function() { return PJD_3PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_7PARAM", function() { return PJD_7PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_WGS84", function() { return PJD_WGS84; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PJD_NODATUM", function() { return PJD_NODATUM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SEC_TO_RAD", function() { return SEC_TO_RAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HALF_PI", function() { return HALF_PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIXTH", function() { return SIXTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RA4", function() { return RA4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RA6", function() { return RA6; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSLN", function() { return EPSLN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D2R", function() { return D2R; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "R2D", function() { return R2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FORTPI", function() { return FORTPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TWO_PI", function() { return TWO_PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPI", function() { return SPI; });
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_WGS84 = 4; // WGS84 or equivalent
var PJD_NODATUM = 5; // WGS84 or equivalent
var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var HALF_PI = Math.PI/2;
// ellipoid pj_set_ell.c
var SIXTH = 0.1666666666666666667;
/* 1/6 */
var RA4 = 0.04722222222222222222;
/* 17/360 */
var RA6 = 0.02215608465608465608;
var EPSLN = (typeof Number.EPSILON === 'undefined') ? 1.0e-10 : Number.EPSILON;
var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var FORTPI = Math.PI/4;
var TWO_PI = Math.PI * 2;
// SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.
var SPI = 3.14159265359;


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/core.js":
/*!***************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/core.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Proj */ "./node_modules/melowntech-proj4/lib/Proj.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform */ "./node_modules/melowntech-proj4/lib/transform.js");


var wgs84 = Object(_Proj__WEBPACK_IMPORTED_MODULE_0__["default"])('WGS84');

function transformer(from, to, coords) {
  var transformedArray;
  if (Array.isArray(coords)) {
    transformedArray = Object(_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(from, to, coords);
    if (coords.length === 3) {
      return [transformedArray.x, transformedArray.y, transformedArray.z];
    }
    else {
      return [transformedArray.x, transformedArray.y];
    }
  }
  else {
    return Object(_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(from, to, coords);
  }
}

function checkProj(item) {
  if (item instanceof _Proj__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return Object(_Proj__WEBPACK_IMPORTED_MODULE_0__["default"])(item);
}
function proj4(fromProj, toProj, coord, retProj) {
  if(retProj) {
    return fromProj;
  }
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  }
  else {
    obj = {
      forward: function (coords) {
        return transformer(fromProj, toProj, coords);
      },
      inverse: function (coords) {
        return transformer(toProj, fromProj, coords);
      },
      info: function () {
        return {
          "a": toProj.a,
          "b": toProj.b,
          "ra": toProj.R_A,
          "proj-name": toProj.projName
        };
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
/* harmony default export */ __webpack_exports__["default"] = (proj4);

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/datum.js":
/*!****************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/datum.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");


function datum(datumCode, datum_params, a, b, es, ep2) {
  var out = {};

  if (datumCode === undefined || datumCode === 'none') {
    out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_NODATUM"];
  } else {
    out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_WGS84"];
  }

  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"];
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"];
        out.datum_params[3] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"];
        out.datum_params[4] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"];
        out.datum_params[5] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"];
        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
      }
    }
  }

  out.a = a; //datum object also uses these values
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}

/* harmony default export */ __webpack_exports__["default"] = (datum);


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/datumUtils.js":
/*!*********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/datumUtils.js ***!
  \*********************************************************/
/*! exports provided: compareDatums, geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareDatums", function() { return compareDatums; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geodeticToGeocentric", function() { return geodeticToGeocentric; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geocentricToGeodetic", function() { return geocentricToGeodetic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geocentricToWgs84", function() { return geocentricToWgs84; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geocentricFromWgs84", function() { return geocentricFromWgs84; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");


function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false; // false, datums are not equal
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
    // the tolerance for es is to ensure that GRS80 and WGS84
    // are considered identical
    return false;
  } else if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"]) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
  } else if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
  } else {
    return true; // datums are equal
  }
} // cs_compare_datums()

/*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */
function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0; //Z value not always supplied

  var Rn; /*  Earth radius at location  */
  var Sin_Lat; /*  Math.sin(Latitude)  */
  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
  var Cos_Lat; /*  Math.cos(Latitude)  */

  /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */
  if (Latitude < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] && Latitude > -1.001 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) {
    Latitude = -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if (Latitude > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] && Latitude < 1.001 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) {
    Latitude = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if ((Latitude < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) || (Latitude > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"])) {
    /* Latitude out of range */
    //..reportError('geocent:lat out of range:' + Latitude);
    return null;
  }

  if (Longitude > Math.PI) {
    Longitude -= (2 * Math.PI);
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: ((Rn * (1 - es)) + Height) * Sin_Lat
  };
} // cs_geodetic_to_geocentric()

function geocentricToGeodetic(p, es, a, b) {
  /* local defintions and variables */
  /* end-criterium of loop, accuracy of sin(Latitude) */
  var genau = 1e-12;
  var genau2 = (genau * genau);
  var maxiter = 30;

  var P; /* distance between semi-minor axis and location */
  var RR; /* distance between center and location */
  var CT; /* sin of geocentric latitude */
  var ST; /* cos of geocentric latitude */
  var RX;
  var RK;
  var RN; /* Earth radius at location */
  var CPHI0; /* cos of start or old geodetic latitude in iterations */
  var SPHI0; /* sin of start or old geodetic latitude in iterations */
  var CPHI; /* cos of searched geodetic latitude */
  var SPHI; /* sin of searched geodetic latitude */
  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

  var X = p.x;
  var Y = p.y;
  var Z = p.z ? p.z : 0.0; //Z value not always supplied
  var Longitude;
  var Latitude;
  var Height;

  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z * Z);

  /*      special cases for latitude and longitude */
  if (P / a < genau) {

    /*  special case, if P=0. (X=0., Y=0.) */
    Longitude = 0.0;

    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
    if (RR / a < genau) {
      Latitude = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
    Longitude = Math.atan2(Y, X);
  }

  /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */
  CT = Z / RR;
  ST = P / RR;
  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
  CPHI0 = ST * (1.0 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;

  /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
  do {
    iter++;
    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

    /*  ellipsoidal (geodetic) height */
    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

    RK = es * RN / (RN + Height);
    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
    CPHI = ST * (1.0 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  }
  while (SDPHI * SDPHI > genau2 && iter < maxiter);

  /*      ellipsoidal (geodetic) latitude */
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
} // cs_geocentric_to_geodetic()

/****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)


/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
function geocentricToWgs84(p, datum_type, datum_params) {

  if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"]) {
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2],
    };
  } else if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
} // cs_geocentric_to_wgs84

/****************************************************************/
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)
function geocentricFromWgs84(p, datum_type, datum_params) {

  if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"]) {
    //if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2],
    };

  } else if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF;
    //if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  } //cs_geocentric_from_wgs84()
}


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/datum_transform.js":
/*!**************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/datum_transform.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _datumUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datumUtils */ "./node_modules/melowntech-proj4/lib/datumUtils.js");



function checkParams(type) {
  return (type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"] || type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]);
}

/* harmony default export */ __webpack_exports__["default"] = (function(source, dest, point) {
  // Short cut if the datums are identical.
  if (Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["compareDatums"])(source, dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  }

  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
  if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_NODATUM"] || dest.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_NODATUM"]) {
    return point;
  }

  // If this datum requires grid shifts, then apply it to geodetic coordinates.

  // Do we need to go through geocentric coordinates?
  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
    return point;
  }

  // Convert to geocentric coordinates.
  point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geodeticToGeocentric"])(point, source.es, source.a);
  // Convert between datums
  if (checkParams(source.datum_type)) {
    point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geocentricToWgs84"])(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geocentricFromWgs84"])(point, dest.datum_type, dest.datum_params);
  }
  return Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__["geocentricToGeodetic"])(point, dest.es, dest.a, dest.b);

});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/defs.js":
/*!***************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/defs.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global */ "./node_modules/melowntech-proj4/lib/global.js");
/* harmony import */ var _projString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./projString */ "./node_modules/melowntech-proj4/lib/projString.js");
/* harmony import */ var wkt_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wkt-parser */ "./node_modules/wkt-parser/index.js");




function defs(name) {
  /*global console*/
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[name] = Object(_projString__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments[1]);
      }
      else {
        defs[name] = Object(wkt_parser__WEBPACK_IMPORTED_MODULE_2__["default"])(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  }
  else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        }
        else {
          defs(v);
        }
      });
    }
    else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    }
    else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    }
    else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    }
    else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    }
    else {
      console.log(name);
    }
    return;
  }


}
Object(_global__WEBPACK_IMPORTED_MODULE_0__["default"])(defs);
/* harmony default export */ __webpack_exports__["default"] = (defs);


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/deriveConstants.js":
/*!**************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/deriveConstants.js ***!
  \**************************************************************/
/*! exports provided: eccentricity, sphere */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eccentricity", function() { return eccentricity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sphere", function() { return sphere; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants/Ellipsoid */ "./node_modules/melowntech-proj4/lib/constants/Ellipsoid.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./match */ "./node_modules/melowntech-proj4/lib/match.js");




function eccentricity(a, b, rf, R_A) {
  var a2 = a * a; // used in geocentric
  var b2 = b * b; // used in geocentric
  var es = (a2 - b2) / a2; // e ^ 2
  var e = 0;
  if (R_A) {
    a *= 1 - es * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["SIXTH"] + es * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["RA4"] + es * _constants_values__WEBPACK_IMPORTED_MODULE_0__["RA6"]));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es); // eccentricity
  }
  var ep2 = (a2 - b2) / b2; // used in geocentric
  return {
    es: es,
    e: e,
    ep2: ep2
  };
}
function sphere(a, b, rf, ellps, sphere) {
  if (!a) { // do we have an ellipsoid?
    var ellipse = Object(_match__WEBPACK_IMPORTED_MODULE_2__["default"])(_constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__["default"], ellps);
    if (!ellipse) {
      ellipse = _constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__["WGS84"];
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }

  if (rf && !b) {
    b = (1.0 - 1.0 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    sphere = true;
    b = a;
  }
  return {
    a: a,
    b: b,
    rf: rf,
    sphere: sphere
  };
}


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/extend.js":
/*!*****************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/extend.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== undefined) {
      destination[property] = value;
    }
  }
  return destination;
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/global.js":
/*!*****************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/global.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./node_modules/melowntech-proj4/lib/core.js");
/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proj */ "./node_modules/melowntech-proj4/lib/Proj.js");
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Point */ "./node_modules/melowntech-proj4/lib/Point.js");
/* harmony import */ var _common_toPoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common/toPoint */ "./node_modules/melowntech-proj4/lib/common/toPoint.js");
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defs */ "./node_modules/melowntech-proj4/lib/defs.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transform */ "./node_modules/melowntech-proj4/lib/transform.js");
/* harmony import */ var mgrs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mgrs */ "./node_modules/mgrs/mgrs.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./version */ "./node_modules/melowntech-proj4/lib/version.js");
/* harmony import */ var _projs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../projs */ "./node_modules/melowntech-proj4/projs.js");










_core__WEBPACK_IMPORTED_MODULE_0__["default"].defaultDatum = 'WGS84'; //default datum
_core__WEBPACK_IMPORTED_MODULE_0__["default"].Proj = _Proj__WEBPACK_IMPORTED_MODULE_1__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].WGS84 = new _core__WEBPACK_IMPORTED_MODULE_0__["default"].Proj('WGS84');
_core__WEBPACK_IMPORTED_MODULE_0__["default"].Point = _Point__WEBPACK_IMPORTED_MODULE_2__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].toPoint = _common_toPoint__WEBPACK_IMPORTED_MODULE_3__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].defs = _defs__WEBPACK_IMPORTED_MODULE_4__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].transform = _transform__WEBPACK_IMPORTED_MODULE_5__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].mgrs = mgrs__WEBPACK_IMPORTED_MODULE_6__["default"];
_core__WEBPACK_IMPORTED_MODULE_0__["default"].version = _version__WEBPACK_IMPORTED_MODULE_7__["default"];
Object(_projs__WEBPACK_IMPORTED_MODULE_8__["default"])(_core__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (_core__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/match.js":
/*!****************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/match.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return match; });
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, '');
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/parseCode.js":
/*!********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/parseCode.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defs */ "./node_modules/melowntech-proj4/lib/defs.js");
/* harmony import */ var wkt_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wkt-parser */ "./node_modules/wkt-parser/index.js");
/* harmony import */ var _projString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projString */ "./node_modules/melowntech-proj4/lib/projString.js");



function testObj(code){
  return typeof code === 'string';
}
function testDef(code){
  return code in _defs__WEBPACK_IMPORTED_MODULE_0__["default"];
}
 var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS']; 
function testWKT(code){
  return codeWords.some(function (word) {
    return code.indexOf(word) > -1;
  });
}
function testProj(code){
  return code[0] === '+';
}
function parse(code){
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return _defs__WEBPACK_IMPORTED_MODULE_0__["default"][code];
    }
    if (testWKT(code)) {
      return Object(wkt_parser__WEBPACK_IMPORTED_MODULE_1__["default"])(code);
    }
    if (testProj(code)) {
      return Object(_projString__WEBPACK_IMPORTED_MODULE_2__["default"])(code);
    }
  }else{
    return code;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (parse);


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projString.js":
/*!*********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projString.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _constants_PrimeMeridian__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants/PrimeMeridian */ "./node_modules/melowntech-proj4/lib/constants/PrimeMeridian.js");
/* harmony import */ var _constants_units__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants/units */ "./node_modules/melowntech-proj4/lib/constants/units.js");
/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./match */ "./node_modules/melowntech-proj4/lib/match.js");





/* harmony default export */ __webpack_exports__["default"] = (function(defData) {
  var self = {};
  var paramObj = defData.split('+').map(function(v) {
    return v.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(p, a) {
    var split = a.split('=');
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self.lat0 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lat_1: function(v) {
      self.lat1 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lat_2: function(v) {
      self.lat2 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lat_ts: function(v) {
      self.lat_ts = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lon_0: function(v) {
      self.long0 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lon_1: function(v) {
      self.long1 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lon_2: function(v) {
      self.long2 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    alpha: function(v) {
      self.alpha = parseFloat(v) * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    lonc: function(v) {
      self.longc = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    x_0: function(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self.k0 = parseFloat(v);
    },
    k: function(v) {
      self.k0 = parseFloat(v);
    },
    a: function(v) {
      self.a = parseFloat(v);
    },
    b: function(v) {
      self.b = parseFloat(v);
    },
    r_a: function() {
      self.R_A = true;
    },
    zone: function(v) {
      self.zone = parseInt(v, 10);
    },
    south: function() {
      self.utmSouth = true;
    },
    towgs84: function(v) {
      self.datum_params = v.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v) {
      self.to_meter = parseFloat(v);
    },
    units: function(v) {
      self.units = v;
      var unit = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(_constants_units__WEBPACK_IMPORTED_MODULE_2__["default"], v);
      if (unit) {
        self.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v) {
      self.from_greenwich = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    pm: function(v) {
      var pm = Object(_match__WEBPACK_IMPORTED_MODULE_3__["default"])(_constants_PrimeMeridian__WEBPACK_IMPORTED_MODULE_1__["default"], v);
      self.from_greenwich = (pm ? pm : parseFloat(v)) * _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    },
    nadgrids: function(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      }
      else {
        self.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params) {
      paramOutname = params[paramName];
      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      }
      else {
        self[paramOutname] = paramVal;
      }
    }
    else {
      self[paramName] = paramVal;
    }
  }
  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
    self.datumCode = self.datumCode.toLowerCase();
  }
  return self;
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections.js":
/*!**********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections.js ***!
  \**********************************************************/
/*! exports provided: add, get, start, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "start", function() { return start; });
/* harmony import */ var _projections_merc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./projections/merc */ "./node_modules/melowntech-proj4/lib/projections/merc.js");
/* harmony import */ var _projections_longlat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./projections/longlat */ "./node_modules/melowntech-proj4/lib/projections/longlat.js");


var projs = [_projections_merc__WEBPACK_IMPORTED_MODULE_0__["default"], _projections_longlat__WEBPACK_IMPORTED_MODULE_1__["default"]];
var names = {};
var projStore = [];

function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    names[n.toLowerCase()] = len;
  });
  return this;
}



function get(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
    return projStore[names[n]];
  }
}

function start() {
  projs.forEach(add);
}
/* harmony default export */ __webpack_exports__["default"] = ({
  start: start,
  add: add,
  get: get
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/aea.js":
/*!**************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/aea.js ***!
  \**************************************************************/
/*! exports provided: init, forward, inverse, phi1z, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "phi1z", function() { return phi1z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/melowntech-proj4/lib/common/msfnz.js");
/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ "./node_modules/melowntech-proj4/lib/common/qsfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/melowntech-proj4/lib/common/asinz.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");






function init() {

  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);

  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e3, this.sin_po, this.cos_po);
  this.qs1 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e3, this.sin_po, this.cos_po);
  this.qs2 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_po, this.cos_po);

  if (Math.abs(this.lat1 - this.lat2) > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  }
  else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}

/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/
function forward(p) {

  var lon = p.x;
  var lat = p.y;

  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);

  var qs = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var rh1, qs, con, theta, lon, lat;

  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  }
  else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}

/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_3__["default"])(0.5 * qs);
  if (eccent < _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    return phi;
  }

  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}

var names = ["Albers_Conic_Equal_Area", "Albers", "aea"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  phi1z: phi1z
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/aeqd.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/aeqd.js ***!
  \***************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/mlfn */ "./node_modules/melowntech-proj4/lib/common/mlfn.js");
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e0fn */ "./node_modules/melowntech-proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/e1fn */ "./node_modules/melowntech-proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/e2fn */ "./node_modules/melowntech-proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/e3fn */ "./node_modules/melowntech-proj4/lib/common/e3fn.js");
/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/gN */ "./node_modules/melowntech-proj4/lib/common/gN.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/melowntech-proj4/lib/common/asinz.js");
/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../common/imlfn */ "./node_modules/melowntech-proj4/lib/common/imlfn.js");














function init() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //North Pole case
      p.x = this.x0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] - lat) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //South Pole case
      p.x = this.x0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] + lat) * Math.cos(dlon);
      return p;
    }
    else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c / Math.sin(c);
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  }
  else {
    e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
    e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_4__["default"])(this.es);
    e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.es);
    e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.es);
    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //North Pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      Ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //South Pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      Ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    }
    else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__["default"])(this.a, this.e, this.sin_p12);
      Nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__["default"])(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else if (Math.abs(Math.abs(Az) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }


}

function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > (2 * _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"] * this.a)) {
      return;
    }
    z = rh / this.a;

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      lat = this.lat0;
    }
    else {
      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_8__["default"])(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
      con = Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"];
      if (Math.abs(con) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
        if (this.lat0 >= 0) {
          lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 - Math.atan2(-p.x, p.y));
        }
      }
      else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
    e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_4__["default"])(this.es);
    e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.es);
    e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.es);
    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //North pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_9__["default"])(M / this.a, e0, e1, e2, e3);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, - 1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      //South pole case
      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;

      lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_9__["default"])(M / this.a, e0, e1, e2, e3);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__["default"])(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }

}

var names = ["Azimuthal_Equidistant", "aeqd"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/cass.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/cass.js ***!
  \***************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/mlfn */ "./node_modules/melowntech-proj4/lib/common/mlfn.js");
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e0fn */ "./node_modules/melowntech-proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e1fn */ "./node_modules/melowntech-proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e2fn */ "./node_modules/melowntech-proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/e3fn */ "./node_modules/melowntech-proj4/lib/common/e3fn.js");
/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/gN */ "./node_modules/melowntech-proj4/lib/common/gN.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/adjust_lat */ "./node_modules/melowntech-proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/imlfn */ "./node_modules/melowntech-proj4/lib/common/imlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");











function init() {
  if (!this.sphere) {
    this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.es);
    this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
    this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
    this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_4__["default"])(this.es);
    this.ml0 = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}

/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function forward(p) {

  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  }
  else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_5__["default"])(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e0, this.e1, this.e2, this.e3, phi);

    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  }
  else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_8__["default"])(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - _constants_values__WEBPACK_IMPORTED_MODULE_9__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_9__["EPSLN"]) {
      p.x = this.long0;
      p.y = _constants_values__WEBPACK_IMPORTED_MODULE_9__["HALF_PI"];
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_5__["default"])(this.a, this.e, Math.sin(phi1));

    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

  }

  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(lam + this.long0);
  p.y = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__["default"])(phi);
  return p;

}

var names = ["Cassini", "Cassini_Soldner", "cass"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/cea.js":
/*!**************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/cea.js ***!
  \**************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ "./node_modules/melowntech-proj4/lib/common/qsfnz.js");
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/melowntech-proj4/lib/common/msfnz.js");
/* harmony import */ var _common_iqsfnz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/iqsfnz */ "./node_modules/melowntech-proj4/lib/common/iqsfnz.js");





/*
  reference:
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/
function init() {
  //no-op
  if (!this.sphere) {
    this.k0 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}

/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  }
  else {
    var qs = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
}

/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
  }
  else {
    lat = Object(_common_iqsfnz__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, 2 * p.y * this.k0 / this.a);
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["cea"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/eqc.js":
/*!**************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/eqc.js ***!
  \**************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lat */ "./node_modules/melowntech-proj4/lib/common/adjust_lat.js");



function init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

  this.rc = Math.cos(this.lat_ts);
}

// forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {

  var lon = p.x;
  var lat = p.y;

  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var dlat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__["default"])(lat - this.lat0);
  p.x = this.x0 + (this.a * dlon * this.rc);
  p.y = this.y0 + (this.a * dlat);
  return p;
}

// inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {

  var x = p.x;
  var y = p.y;

  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + ((x - this.x0) / (this.a * this.rc)));
  p.y = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__["default"])(this.lat0 + ((y - this.y0) / (this.a)));
  return p;
}

var names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/eqdc.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/eqdc.js ***!
  \***************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/e0fn */ "./node_modules/melowntech-proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e1fn */ "./node_modules/melowntech-proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e2fn */ "./node_modules/melowntech-proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e3fn */ "./node_modules/melowntech-proj4/lib/common/e3fn.js");
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/melowntech-proj4/lib/common/msfnz.js");
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/mlfn */ "./node_modules/melowntech-proj4/lib/common/mlfn.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/adjust_lat */ "./node_modules/melowntech-proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/imlfn */ "./node_modules/melowntech-proj4/lib/common/imlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");











function init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_9__["EPSLN"]) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.es);
  this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.es);
  this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
  this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);

  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);

  this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, this.sinphi, this.cosphi);
  this.ml1 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_9__["EPSLN"]) {
    this.ns = this.sinphi;
  }
  else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, this.sinphi, this.cosphi);
    this.ml2 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}

/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;

  /* Forward equations
      -----------------*/
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  }
  else {
    var ml = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__["default"])(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(this.long0 + theta / this.ns);
    lat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__["default"])(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    var ml = this.g - rh1 / this.a;
    lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_8__["default"])(ml, this.e0, this.e1, this.e2, this.e3);
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }

}

var names = ["Equidistant_Conic", "eqdc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/etmerc.js":
/*!*****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/etmerc.js ***!
  \*****************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_sinh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/sinh */ "./node_modules/melowntech-proj4/lib/common/sinh.js");
/* harmony import */ var _common_hypot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/hypot */ "./node_modules/melowntech-proj4/lib/common/hypot.js");
/* harmony import */ var _common_asinhy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/asinhy */ "./node_modules/melowntech-proj4/lib/common/asinhy.js");
/* harmony import */ var _common_gatg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/gatg */ "./node_modules/melowntech-proj4/lib/common/gatg.js");
/* harmony import */ var _common_clens__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/clens */ "./node_modules/melowntech-proj4/lib/common/clens.js");
/* harmony import */ var _common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/clens_cmplx */ "./node_modules/melowntech-proj4/lib/common/clens_cmplx.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
// Heavily based on this etmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js









function init() {
  if (this.es === undefined || this.es <= 0) {
    throw new Error('incorrect elliptical usage');
  }

  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];

  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;

  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);

  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);

  var Z = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__["default"])(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z + Object(_common_clens__WEBPACK_IMPORTED_MODULE_4__["default"])(this.gtu, 2 * Z));
}

function forward(p) {
  var Ce = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(p.x - this.long0);
  var Cn = p.y;

  Cn = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__["default"])(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);

  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, Object(_common_hypot__WEBPACK_IMPORTED_MODULE_1__["default"])(sin_Cn, cos_Cn * cos_Ce));
  Ce = Object(_common_asinhy__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.tan(Ce));

  var tmp = Object(_common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__["default"])(this.gtu, 2 * Cn, 2 * Ce);

  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];

  var x;
  var y;

  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  }
  else {
    x = Infinity;
    y = Infinity;
  }

  p.x = x;
  p.y = y;

  return p;
}

function inverse(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);

  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;

  var lon;
  var lat;

  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = Object(_common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__["default"])(this.utg, 2 * Cn, 2 * Ce);

    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(Object(_common_sinh__WEBPACK_IMPORTED_MODULE_0__["default"])(Ce));

    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);

    Cn = Math.atan2(sin_Cn * cos_Ce, Object(_common_hypot__WEBPACK_IMPORTED_MODULE_1__["default"])(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__["default"])(Ce + this.long0);
    lat = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__["default"])(this.cgb, Cn);
  }
  else {
    lon = Infinity;
    lat = Infinity;
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var names = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/gauss.js":
/*!****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/gauss.js ***!
  \****************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_srat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/srat */ "./node_modules/melowntech-proj4/lib/common/srat.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");

var MAX_ITER = 20;


function init() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]) / (Math.pow(Math.tan(0.5 * this.lat0 + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]), this.C) * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e * sphi, this.ratexp));
}

function forward(p) {
  var lon = p.x;
  var lat = p.y;

  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]), this.C) * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e * Math.sin(lat), this.ratexp)) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"];
  p.x = this.C * lon;
  return p;
}

function inverse(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + _constants_values__WEBPACK_IMPORTED_MODULE_1__["FORTPI"]) / this.K, 1 / this.C);
  for (var i = MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e * Math.sin(p.y), - 0.5 * this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"];
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  /* convergence failed */
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["gauss"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/geocent.js":
/*!******************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/geocent.js ***!
  \******************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
function init() {
  this.isGeocent = true;
}

function identity(pt) {
  return pt;
}


var names = ["geocent"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: identity,
  inverse: identity,
  names: names
});

/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/gnom.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/gnom.js ***!
  \***************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/melowntech-proj4/lib/common/asinz.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");




/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */
function init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  // Approximation for projecting points to the horizon (infinity)
  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
}

/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"])) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  }
  else {

    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project
    // to infinity, on a bearing
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that
    // straddle the horizon.

    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

  }
  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var rh; /* Rho */
  var sinc, cosc;
  var c;
  var lon, lat;

  /* Inverse equations
      -----------------*/
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;

  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);

    lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__["default"])(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + lon);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["gnom"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/krovak.js":
/*!*****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/krovak.js ***!
  \*****************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");


function init() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448; /* 45 */
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}

/* ellipsoid */
/* calculate xy from lat/lon */
/* Constants, identical to inverse transform function */
function forward(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  /* Transformation */
  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return (p);
}

/* calculate lat/lon from xy */
function inverse(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;

  /* Transformation */
  /* revert y, x*/
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }

  return (p);
}

var names = ["Krovak", "krovak"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/laea.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/laea.js ***!
  \***************************************************************/
/*! exports provided: S_POLE, N_POLE, EQUIT, OBLIQ, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S_POLE", function() { return S_POLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "N_POLE", function() { return N_POLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EQUIT", function() { return EQUIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OBLIQ", function() { return OBLIQ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ "./node_modules/melowntech-proj4/lib/common/qsfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");






/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

var S_POLE = 1;

var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;

/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/
function init() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  }
  else if (Math.abs(t) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    this.mode = this.EQUIT;
  }
  else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;

    this.qp = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
    case this.N_POLE:
      this.dd = 1;
      break;
    case this.S_POLE:
      this.dd = 1;
      break;
    case this.EQUIT:
      this.rq = Math.sqrt(0.5 * this.qp);
      this.dd = 1 / this.rq;
      this.xmf = 1;
      this.ymf = 0.5 * this.qp;
      break;
    case this.OBLIQ:
      this.rq = Math.sqrt(0.5 * this.qp);
      sinphi = Math.sin(this.lat0);
      this.sinb1 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, sinphi) / this.qp;
      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
      this.ymf = (this.xmf = this.rq) / this.dd;
      this.xmf *= this.dd;
      break;
    }
  }
  else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}

/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function forward(p) {

  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;

  lam = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.phi0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        return null;
      }
      y = _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] - phi * 0.5;
      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  }
  else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
    case this.OBLIQ:
      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
      break;
    case this.EQUIT:
      b = 1 + cosb * coslam;
      break;
    case this.N_POLE:
      b = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + phi;
      q = this.qp - q;
      break;
    case this.S_POLE:
      b = phi - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
      q = this.qp + q;
      break;
    }
    if (Math.abs(b) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      return null;
    }
    switch (this.mode) {
    case this.OBLIQ:
    case this.EQUIT:
      b = Math.sqrt(2 / b);
      if (this.mode === this.OBLIQ) {
        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
      }
      else {
        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
      }
      x = this.xmf * b * cosb * sinlam;
      break;
    case this.N_POLE:
    case this.S_POLE:
      if (q >= 0) {
        x = (b = Math.sqrt(q)) * sinlam;
        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
      }
      else {
        x = y = 0;
      }
      break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;
  if (this.sphere) {
    var cosz = 0,
      rh, sinz = 0;

    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
    case this.EQUIT:
      phi = (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) ? 0 : Math.asin(y * sinz / rh);
      x *= sinz;
      y = cosz * rh;
      break;
    case this.OBLIQ:
      phi = (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
      x *= sinz * this.cosph0;
      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
      break;
    case this.N_POLE:
      y = -y;
      phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - phi;
      break;
    case this.S_POLE:
      phi -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
      break;
    }
    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
  }
  else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= (sCe = Math.sin(sCe));
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      }
      else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = (x * x + y * y);
      if (!q) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }

  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__["default"])(this.long0 + lam);
  p.y = phi;
  return p;
}

/* determine latitude from authalic latitude */
var P00 = 0.33333333333333333333;

var P01 = 0.17222222222222222222;
var P02 = 0.10257936507936507936;
var P10 = 0.06388888888888888888;
var P11 = 0.06640211640211640211;
var P20 = 0.01641501294219154443;

function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}

function authlat(beta, APA) {
  var t = beta + beta;
  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
}

var names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  S_POLE: S_POLE,
  N_POLE: N_POLE,
  EQUIT: EQUIT,
  OBLIQ: OBLIQ
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/lcc.js":
/*!**************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/lcc.js ***!
  \**************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/melowntech-proj4/lib/common/msfnz.js");
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/tsfnz */ "./node_modules/melowntech-proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/sign */ "./node_modules/melowntech-proj4/lib/common/sign.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/phi2z */ "./node_modules/melowntech-proj4/lib/common/phi2z.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");






function init() {

  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
  //double c_lat;                   /* center latitude                      */
  //double c_lon;                   /* center longitude                     */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */

  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);

  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, sin1, cos1);
  var ts1 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, this.lat1, sin1);

  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, sin2, cos2);
  var ts2 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, this.lat2, sin2);

  var ts0 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  }
  else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}

// Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {

  var lon = p.x;
  var lat = p.y;

  // singular cases :
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    lat = Object(_common_sign__WEBPACK_IMPORTED_MODULE_2__["default"])(lat) * (_constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"] - 2 * _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]);
  }

  var con = Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"]);
  var ts, rh1;
  if (con > _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
    ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__["default"])(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  }
  else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

  return p;
}

// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {

  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = (this.rh - (p.y - this.y0) / this.k0);
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2((con * x), (con * y));
  }
  if ((rh1 !== 0) || (this.ns > 0)) {
    con = 1 / this.ns;
    ts = Math.pow((rh1 / (this.a * this.f0)), con);
    lat = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  else {
    lat = -_constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"];
  }
  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(theta / this.ns + this.long0);

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/longlat.js":
/*!******************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/longlat.js ***!
  \******************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
function init() {
  //no-op for longlat
}

function identity(pt) {
  return pt;
}


var names = ["longlat", "identity"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: identity,
  inverse: identity,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/merc.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/merc.js ***!
  \***************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/melowntech-proj4/lib/common/msfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/tsfnz */ "./node_modules/melowntech-proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/phi2z */ "./node_modules/melowntech-proj4/lib/common/phi2z.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");






function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if(!('x0' in this)){
    this.x0 = 0;
  }
  if(!('y0' in this)){
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    }
    else {
      this.k0 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }
  else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      }
      else {
        this.k0 = 1;
      }
    }
  }
}

/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  // convert to radians
  if (lat * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] > 90 && lat * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] < -90 && lon * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] > 180 && lon * _constants_values__WEBPACK_IMPORTED_MODULE_4__["R2D"] < -180) {
    return null;
  }

  var x, y;
  if (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
    return null;
  }
  else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(_constants_values__WEBPACK_IMPORTED_MODULE_4__["FORTPI"] + 0.5 * lat));
    }
    else {
      var sinphi = Math.sin(lat);
      var ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
}

/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/
function inverse(p) {

  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"] - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  }
  else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long0 + x / (this.a * this.k0));

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/mill.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/mill.js ***!
  \***************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");


/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */


/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/
function init() {
  //no-op
}

/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

  p.x = x;
  p.y = y;
  return p;
}

/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;

  var lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Miller_Cylindrical", "mill"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/moll.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/moll.js ***!
  \***************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");

function init() {}

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/
function forward(p) {

  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;

  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);

  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/
  for (var i = 0; true; i++) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
      break;
    }
  }
  theta /= 2;

  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/
  if (Math.PI / 2 - Math.abs(lat) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var theta;
  var arg;

  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);

  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
  if (lon < (-Math.PI)) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Mollweide", "moll"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/nzmg.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/nzmg.js ***!
  \***************************************************************/
/*! exports provided: iterations, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iterations", function() { return iterations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");


/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */
var iterations = 1;

function init() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;

  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;

  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;

  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
}

/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */
function forward(p) {
  var n;
  var lon = p.x;
  var lat = p.y;

  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;

  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
  var d_phi = delta_lat / _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"] * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }

  // 2. Calculate theta
  var th_re = d_psi;
  var th_im = d_lambda;

  // 3. Calculate z
  var th_n_re = 1;
  var th_n_im = 0; // theta^0
  var th_n_re1;
  var th_n_im1;

  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }

  // 4. Calculate easting and northing
  p.x = (z_im * this.a) + this.x0;
  p.y = (z_re * this.a) + this.y0;

  return p;
}

/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */
function inverse(p) {
  var n;
  var x = p.x;
  var y = p.y;

  var delta_x = x - this.x0;
  var delta_y = y - this.y0;

  // 1. Calculate z
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;

  // 2a. Calculate theta - first approximation gives km accuracy
  var z_n_re = 1;
  var z_n_im = 0; // z^0
  var z_n_re1;
  var z_n_im1;

  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }

  // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;

    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    // Complex division
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }

  // 3. Calculate d_phi              ...                                    // and d_lambda
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }

  // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
  var lat = this.lat0 + (d_phi * _constants_values__WEBPACK_IMPORTED_MODULE_0__["SEC_TO_RAD"] * 1E5);
  var lon = this.long0 + d_lambda;

  p.x = lon;
  p.y = lat;

  return p;
}

var names = ["New_Zealand_Map_Grid", "nzmg"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/omerc.js":
/*!****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/omerc.js ***!
  \****************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/tsfnz */ "./node_modules/melowntech-proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/phi2z */ "./node_modules/melowntech-proj4/lib/common/phi2z.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");





/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/
function init() {
  this.no_off = this.no_off || false;
  this.no_rot = this.no_rot || false;

  if (isNaN(this.k0)) {
    this.k0 = 1;
  }
  var sinlat = Math.sin(this.lat0);
  var coslat = Math.cos(this.lat0);
  var con = this.e * sinlat;

  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
  var t0 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, this.lat0, sinlat);
  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
  if (dl * dl < 1) {
    dl = 1;
  }
  var fl;
  var gl;
  if (!isNaN(this.longc)) {
    //Central point and azimuth method

    if (this.lat0 >= 0) {
      fl = dl + Math.sqrt(dl * dl - 1);
    }
    else {
      fl = dl - Math.sqrt(dl * dl - 1);
    }
    this.el = fl * Math.pow(t0, this.bl);
    gl = 0.5 * (fl - 1 / fl);
    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

  }
  else {
    //2 points method
    var t1 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, this.lat1, Math.sin(this.lat1));
    var t2 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, this.lat2, Math.sin(this.lat2));
    if (this.lat0 >= 0) {
      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    else {
      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    var hl = Math.pow(t1, this.bl);
    var ll = Math.pow(t2, this.bl);
    fl = this.el / hl;
    gl = 0.5 * (fl - 1 / fl);
    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
    var pl = (ll - hl) / (ll + hl);
    var dlon12 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long1 - this.long2);
    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
    this.long0 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long0);
    var dlon10 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long1 - this.long0);
    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
  }

  if (this.no_off) {
    this.uc = 0;
  }
  else {
    if (this.lat0 >= 0) {
      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
    else {
      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
  }

}

/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(lon - this.long0);
  var us, vs;
  var con;
  if (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
    if (lat > 0) {
      con = -1;
    }
    else {
      con = 1;
    }
    vs = this.al / this.bl * Math.log(Math.tan(_constants_values__WEBPACK_IMPORTED_MODULE_3__["FORTPI"] + con * this.gamma0 * 0.5));
    us = -1 * con * _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"] * this.al / this.bl;
  }
  else {
    var t = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__["default"])(this.e, lat, Math.sin(lat));
    var ql = this.el / Math.pow(t, this.bl);
    var sl = 0.5 * (ql - 1 / ql);
    var tl = 0.5 * (ql + 1 / ql);
    var vl = Math.sin(this.bl * (dlon));
    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
    if (Math.abs(Math.abs(ul) - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
      vs = Number.POSITIVE_INFINITY;
    }
    else {
      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
    }
    if (Math.abs(Math.cos(this.bl * (dlon))) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
      us = this.al * this.bl * (dlon);
    }
    else {
      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
    }
  }

  if (this.no_rot) {
    p.x = this.x0 + us;
    p.y = this.y0 + vs;
  }
  else {

    us -= this.uc;
    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
  }
  return p;
}

function inverse(p) {
  var us, vs;
  if (this.no_rot) {
    vs = p.y - this.y0;
    us = p.x - this.x0;
  }
  else {
    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
    us += this.uc;
  }
  var qp = Math.exp(-1 * this.bl * vs / this.al);
  var sp = 0.5 * (qp - 1 / qp);
  var tp = 0.5 * (qp + 1 / qp);
  var vp = Math.sin(this.bl * us / this.al);
  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
  if (Math.abs(up - 1) < _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
    p.x = this.long0;
    p.y = _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"];
  }
  else if (Math.abs(up + 1) < _constants_values__WEBPACK_IMPORTED_MODULE_3__["EPSLN"]) {
    p.x = this.long0;
    p.y = -1 * _constants_values__WEBPACK_IMPORTED_MODULE_3__["HALF_PI"];
  }
  else {
    p.y = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, ts);
    p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
  }
  return p;
}

var names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/ortho.js":
/*!****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/ortho.js ***!
  \****************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/melowntech-proj4/lib/common/asinz.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");




function init() {
  //double temp;      /* temporary variable    */

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}

/* Orthographic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"])) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var rh; /* height above ellipsoid      */
  var z; /* angle          */
  var sinz, cosz; /* sin of z and cos of z      */
  var con;
  var lon, lat;
  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__["default"])(rh / this.a);

  sinz = Math.sin(z);
  cosz = Math.cos(z);

  lon = this.long0;
  if (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"]) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }
  lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__["default"])(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
  con = Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_2__["HALF_PI"];
  if (Math.abs(con) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__["EPSLN"]) {
    if (this.lat0 >= 0) {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2(p.x, - p.y));
    }
    else {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 - Math.atan2(-p.x, p.y));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["ortho"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/poly.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/poly.js ***!
  \***************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/e0fn */ "./node_modules/melowntech-proj4/lib/common/e0fn.js");
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e1fn */ "./node_modules/melowntech-proj4/lib/common/e1fn.js");
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e2fn */ "./node_modules/melowntech-proj4/lib/common/e2fn.js");
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e3fn */ "./node_modules/melowntech-proj4/lib/common/e3fn.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/adjust_lat */ "./node_modules/melowntech-proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/mlfn */ "./node_modules/melowntech-proj4/lib/common/mlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/gN */ "./node_modules/melowntech-proj4/lib/common/gN.js");










var MAX_ITER = 20;

function init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
  this.e = Math.sqrt(this.es);
  this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.es);
  this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.es);
  this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
  this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_3__["default"])(this.es);
  this.ml0 = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
}

/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    }
    else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_5__["default"])(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  }
  else {
    if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    }
    else {
      var nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_8__["default"])(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }

  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(x / this.a + this.long0);
      lat = 0;
    }
    else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
          lat = phi;
          break;
        }
      }
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
    }
  }
  else {
    if (Math.abs(y + this.ml0) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
      lat = 0;
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(this.long0 + x / this.a);
    }
    else {

      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__["default"])(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__["EPSLN"]) {
          lat = phi;
          break;
        }
      }

      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__["default"])(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Polyconic", "poly"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/qsc.js":
/*!**************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/qsc.js ***!
  \**************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
// QSC projection rewritten from the original PROJ4
// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c



/* constants */
var FACE_ENUM = {
    FRONT: 1,
    RIGHT: 2,
    BACK: 3,
    LEFT: 4,
    TOP: 5,
    BOTTOM: 6
};

var AREA_ENUM = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4
};

function init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";

  /* Determine the cube face from the center of projection. */
  if (this.lat0 >= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] / 2.0) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] / 2.0)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }

  /* Fill in useful values for the ellipsoid <-> sphere shift
   * described in [LK12]. */
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}

// QSC forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {
  var xy = {x: 0, y: 0};
  var lat, lon;
  var theta, phi;
  var t, mu;
  /* nu; */
  var area = {value: 0};

  // move lon according to projection's lon
  p.x -= this.long0;

  /* Convert the geodetic latitude to a geocentric latitude.
   * This corresponds to the shift from the ellipsoid to the sphere
   * described in [LK12]. */
  if (this.es !== 0) {//if (P->es != 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }

  /* Convert the input lat, lon into theta, phi as used by QSC.
   * This depends on the cube face and the area on it.
   * For the top and bottom face, we can compute theta and phi
   * directly from phi, lam. For the other faces, we must use
   * unit sphere cartesian coordinates as an intermediate step. */
  lon = p.x; //lon = lp.lam;
  if (this.face === FACE_ENUM.TOP) {
    phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - lat;
    if (lon >= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (lon > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] || lon <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) {
      area.value = AREA_ENUM.AREA_1;
      theta = (lon > 0.0 ? lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else if (lon > -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) && lon <= -_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + lat;
    if (lon >= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (lon < _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon >= -_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && lon >= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = (lon > 0.0 ? -lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : -lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;

    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;

    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      /* Impossible */
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }

  /* Compute mu and nu for the area of definition.
   * For mu, see Eq. (3-21) in [OL76], but note the typos:
   * compare with Eq. (3-14). For nu, see Eq. (3-38). */
  mu = Math.atan((12 / _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]) * (theta + Math.acos(Math.sin(theta) * Math.cos(_constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

  /* Apply the result to the real area. */
  if (area.value === AREA_ENUM.AREA_1) {
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"];
  }

  /* Now compute x, y from mu and nu */
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;

  p.x = xy.x;
  p.y = xy.y;
  return p;
}

// QSC inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {
  var lp = {lam: 0, phi: 0};
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = {value: 0};

  /* de-offset */
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  /* Convert the input x, y to the mu and nu angles as used by QSC.
   * This depends on the area of the cube face. */
  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);
  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = (mu < 0.0 ? mu + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : mu - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
  }

  /* Compute phi and theta for the area of definition.
   * The inverse projection is not described in the original paper, but some
   * good hints can be found here (as of 2011-12-14):
   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
  t = (_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] / 12) * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > +1) {
    cosphi = +1;
  }

  /* Apply the result to the real area on the cube face.
   * For the top and bottom face, we can compute phi and lam directly.
   * For the other faces, we must use unit sphere cartesian coordinates
   * as an intermediate step. */
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = (theta < 0.0 ? theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = (theta < 0.0 ? -theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : -theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    }
  } else {
    /* Compute phi and lam via cartesian unit sphere coordinates. */
    var q, r, s;
    q = cosphi;
    t = q * q;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    /* Rotate q,r,s into the correct area. */
    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    /* Rotate q,r,s into the correct cube face. */
    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    /* Now compute phi and lam from the unit sphere coordinates. */
    lp.phi = Math.acos(-s) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    lp.lam = Math.atan2(r, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"]);
    }
  }

  /* Apply the shift from the sphere to the ellipsoid as described
   * in [LK12]. */
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = (lp.phi < 0 ? 1 : 0);
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }

  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}

/* Helper function for forward projection: compute the theta angle
 * and determine the area number. */
function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;
  if (phi < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0.0;
  } else {
    theta = Math.atan2(y, x);
    if (Math.abs(theta) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] && theta <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"]) {
      area.value = AREA_ENUM.AREA_1;
      theta -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    } else if (theta > _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"] || theta <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__["FORTPI"])) {
      area.value = AREA_ENUM.AREA_2;
      theta = (theta >= 0.0 ? theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"] : theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]);
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    }
  }
  return theta;
}

/* Helper function: shift the longitude. */
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]) {
    slon += _constants_values__WEBPACK_IMPORTED_MODULE_0__["TWO_PI"];
  } else if (slon > +_constants_values__WEBPACK_IMPORTED_MODULE_0__["SPI"]) {
    slon -= _constants_values__WEBPACK_IMPORTED_MODULE_0__["TWO_PI"];
  }
  return slon;
}

var names = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});



/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/sinu.js":
/*!***************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/sinu.js ***!
  \***************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lat */ "./node_modules/melowntech-proj4/lib/common/adjust_lat.js");
/* harmony import */ var _common_pj_enfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/pj_enfn */ "./node_modules/melowntech-proj4/lib/common/pj_enfn.js");
/* harmony import */ var _common_pj_mlfn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/pj_mlfn */ "./node_modules/melowntech-proj4/lib/common/pj_mlfn.js");
/* harmony import */ var _common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/pj_inv_mlfn */ "./node_modules/melowntech-proj4/lib/common/pj_inv_mlfn.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/melowntech-proj4/lib/common/asinz.js");



var MAX_ITER = 20;







function init() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/


  if (!this.sphere) {
    this.en = Object(_common_pj_enfn__WEBPACK_IMPORTED_MODULE_2__["default"])(this.es);
  }
  else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }

}

/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/
function forward(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/
  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    }
    else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;
        if (Math.abs(V) < _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;

  }
  else {

    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_3__["default"])(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var lat, temp, lon, s;

  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_6__["default"])((this.m * lat + Math.sin(lat)) / this.n);
    }
    else if (this.n !== 1) {
      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_6__["default"])(Math.sin(lat) / this.n);
    }
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon + this.long0);
    lat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__["default"])(lat);
  }
  else {
    lat = Object(_common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__["default"])(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < _constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"]) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(temp);
    }
    else if ((s - _constants_values__WEBPACK_IMPORTED_MODULE_5__["EPSLN"]) < _constants_values__WEBPACK_IMPORTED_MODULE_5__["HALF_PI"]) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Sinusoidal", "sinu"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/somerc.js":
/*!*****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/somerc.js ***!
  \*****************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme à axe oblique et pour la transformation entre
    des systèmes de référence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */

function init() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}

function forward(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;

  // spheric latitude
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

  // spheric longitude
  var I = this.alpha * (p.x - this.lambda0);

  // psoeudo equatorial rotation
  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}

function inverse(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;

  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

  var lambda = this.lambda0 + I / this.alpha;

  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    }
    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
}

var names = ["somerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/stere.js":
/*!****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/stere.js ***!
  \****************************************************************/
/*! exports provided: ssfn_, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssfn_", function() { return ssfn_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/sign */ "./node_modules/melowntech-proj4/lib/common/sign.js");
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/msfnz */ "./node_modules/melowntech-proj4/lib/common/msfnz.js");
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/tsfnz */ "./node_modules/melowntech-proj4/lib/common/tsfnz.js");
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/phi2z */ "./node_modules/melowntech-proj4/lib/common/phi2z.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");








function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return (Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
}

function init() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      this.k0 = 0.5 * (1 + Object(_common_sign__WEBPACK_IMPORTED_MODULE_1__["default"])(this.lat0) * Math.sin(this.lat_ts));
    }
  }
  else {
    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      }
      else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      this.k0 = 0.5 * this.cons * Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__["default"])(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}

// Stereographic forward equations--mapping lat,long to x,y
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"] && Math.abs(lat + this.lat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  }
  else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"];
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_3__["default"])(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      //trace(p.toString());
      return p;
    }
    else if (Math.abs(this.sinlat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    }
    else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A * cosX * Math.sin(dlon) + this.x0;
  }
  //trace(p.toString());
  return p;
}

//* Stereographic inverse equations--mapping x,y to lat/long
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      if (this.lat0 > 0) {
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x, p.y));
      }
    }
    else {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
      if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        //trace(p.toString());
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, ts);
      lon = this.con * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
    }
    else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__["EPSLN"]) {
        Chi = this.X0;
      }
      else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__["default"])(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__["default"])(this.e, Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__["HALF_PI"] + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;

  //trace(p.toString());
  return p;

}

var names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  ssfn_: ssfn_
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/sterea.js":
/*!*****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/sterea.js ***!
  \*****************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _gauss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gauss */ "./node_modules/melowntech-proj4/lib/projections/gauss.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");



function init() {
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}

function forward(p) {
  var sinc, cosc, cosl, k;
  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(p.x - this.long0);
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}

function inverse(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;
  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].inverse.apply(this, [p]);
  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__["default"])(p.x + this.long0);
  return p;
}

var names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/tmerc.js":
/*!****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/tmerc.js ***!
  \****************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_pj_enfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/pj_enfn */ "./node_modules/melowntech-proj4/lib/common/pj_enfn.js");
/* harmony import */ var _common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/pj_mlfn */ "./node_modules/melowntech-proj4/lib/common/pj_mlfn.js");
/* harmony import */ var _common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/pj_inv_mlfn */ "./node_modules/melowntech-proj4/lib/common/pj_inv_mlfn.js");
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/sign */ "./node_modules/melowntech-proj4/lib/common/sign.js");
// Heavily based on this tmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js









function init() {
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  if (this.es) {
    this.en = Object(_common_pj_enfn__WEBPACK_IMPORTED_MODULE_0__["default"])(this.es);
    this.ml0 = Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__["default"])(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}

/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */
function forward(p) {
  var lon = p.x;
  var lat = p.y;

  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);

    if ((Math.abs(Math.abs(b) - 1)) < _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
      return (93);
    }
    else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);

      if (b >= 1) {
        if ((b - 1) > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"]) {
          return (93);
        }
        else {
          y = 0;
        }
      }
      else {
        y = Math.acos(y);
      }

      if (lat < 0) {
        y = -y;
      }

      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  }
  else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"] ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__["default"])(lat, sin_phi, cos_phi, this.en);

    x = this.a * (this.k0 * al * (1 +
      als / 6 * (1 - t + c +
      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
      this.x0;

    y = this.a * (this.k0 * (ml - this.ml0 +
      sin_phi * delta_lon * al / 2 * (1 +
      als / 12 * (5 - t + 9 * c + 4 * cs +
      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
      this.y0;
  }

  p.x = x;
  p.y = y;

  return p;
}

/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */
function inverse(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);

  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);

    if (y < 0) {
      lat = -lat;
    }

    if ((g === 0) && (h === 0)) {
      lon = 0;
    }
    else {
      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(Math.atan2(g, h) + this.long0);
    }
  }
  else { // ellipsoidal form
    con = this.ml0 + y / this.k0;
    phi = Object(_common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_2__["default"])(con, this.es, this.en);

    if (Math.abs(phi) < _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"]) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > _constants_values__WEBPACK_IMPORTED_MODULE_4__["EPSLN"] ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;

      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__["default"])(this.long0 + (d * (1 -
        ds / 6 * (1 + 2 * t + c -
        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
    }
    else {
      lat = _constants_values__WEBPACK_IMPORTED_MODULE_4__["HALF_PI"] * Object(_common_sign__WEBPACK_IMPORTED_MODULE_5__["default"])(y);
      lon = 0;
    }
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/utm.js":
/*!**************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/utm.js ***!
  \**************************************************************/
/*! exports provided: dependsOn, init, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dependsOn", function() { return dependsOn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_zone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_zone */ "./node_modules/melowntech-proj4/lib/common/adjust_zone.js");
/* harmony import */ var _etmerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./etmerc */ "./node_modules/melowntech-proj4/lib/projections/etmerc.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");


var dependsOn = 'etmerc';



function init() {
  var zone = Object(_common_adjust_zone__WEBPACK_IMPORTED_MODULE_0__["default"])(this.zone, this.long0);
  if (zone === undefined) {
    throw new Error('unknown utm zone');
  }
  this.lat0 = 0;
  this.long0 =  ((6 * Math.abs(zone)) - 183) * _constants_values__WEBPACK_IMPORTED_MODULE_2__["D2R"];
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;

  _etmerc__WEBPACK_IMPORTED_MODULE_1__["default"].init.apply(this);
  this.forward = _etmerc__WEBPACK_IMPORTED_MODULE_1__["default"].forward;
  this.inverse = _etmerc__WEBPACK_IMPORTED_MODULE_1__["default"].inverse;
}

var names = ["Universal Transverse Mercator System", "utm"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  names: names,
  dependsOn: dependsOn
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/projections/vandg.js":
/*!****************************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/projections/vandg.js ***!
  \****************************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "names", function() { return names; });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ "./node_modules/melowntech-proj4/lib/common/adjust_lon.js");
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/asinz */ "./node_modules/melowntech-proj4/lib/common/asinz.js");






/* Initialize the Van Der Grinten projection
  ----------------------------------------*/
function init() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
}

function forward(p) {

  var lon = p.x;
  var lat = p.y;

  /* Forward equations
    -----------------*/
  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_2__["default"])(2 * Math.abs(lat / Math.PI));
  if ((Math.abs(dlon) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) || (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_1__["HALF_PI"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"])) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    }
    else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
    //  return(OK);
  }
  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);

  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  //con = Math.abs(con / (Math.PI * this.R));
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  }
  else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
}

/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/
function inverse(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;

  /* inverse equations
    -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = ((3 * d) / a1) / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    }
    else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < _constants_values__WEBPACK_IMPORTED_MODULE_1__["EPSLN"]) {
    lon = this.long0;
  }
  else {
    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__["default"])(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/transform.js":
/*!********************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/transform.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ "./node_modules/melowntech-proj4/lib/constants/values.js");
/* harmony import */ var _datum_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datum_transform */ "./node_modules/melowntech-proj4/lib/datum_transform.js");
/* harmony import */ var _datumUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./datumUtils */ "./node_modules/melowntech-proj4/lib/datumUtils.js");
/* harmony import */ var _adjust_axis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./adjust_axis */ "./node_modules/melowntech-proj4/lib/adjust_axis.js");
/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Proj */ "./node_modules/melowntech-proj4/lib/Proj.js");
/* harmony import */ var _common_toPoint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common/toPoint */ "./node_modules/melowntech-proj4/lib/common/toPoint.js");






function checkNotWGS(source, dest) {
  return ((source.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"] || source.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_3PARAM"] || dest.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__["PJD_7PARAM"]) && source.datumCode !== 'WGS84');
}

function transform(source, dest, point) {
  var wgs84;
  if (Array.isArray(point)) {
    point = Object(_common_toPoint__WEBPACK_IMPORTED_MODULE_5__["default"])(point);
  }

  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs84 = new _Proj__WEBPACK_IMPORTED_MODULE_4__["default"]('WGS84');
    point = transform(source, wgs84, point);
    source = wgs84;
  }
  // DGR, 2010/11/12
  if (source.axis !== 'enu') {
    point = Object(_adjust_axis__WEBPACK_IMPORTED_MODULE_3__["default"])(source, false, point);
  }
  // Transform source points to long/lat, if they aren't already.
  if (source.projName === 'longlat') {
    point.x *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
    point.y *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["D2R"];
  }
  else {
    if (source.isGeocent) {
      if (source.to_meter) {
        point.x *= source.to_meter;
        point.y *= source.to_meter;
        point.z *= source.to_meter;
      }
      // originally dest.datum.geocentric_to_geodetic_noniter(point);
      point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_2__["geocentricToGeodetic"])(point, dest.es, dest.a, dest.b);
    } else {
      if (source.to_meter) {
        point.x *= source.to_meter;
        point.y *= source.to_meter;
      }
      point = source.inverse(point); // Convert Cartesian to longlat
    }
  }
// Adjust for the prime meridian if necessary
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }

// Convert datums if needed, and if possible.
  point = Object(_datum_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(source.datum, dest.datum, point);

// Adjust for the prime meridian if necessary
  if (dest.from_greenwich) {
    point.x -= dest.from_greenwich;
  }

  if (dest.projName === 'longlat') {
    // convert radians to decimal degrees
    point.x *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["R2D"];
    point.y *= _constants_values__WEBPACK_IMPORTED_MODULE_0__["R2D"];
  } else { // else project
    if (dest.isGeocent) {
      point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_2__["geodeticToGeocentric"])(point, dest.es, dest.a);
      if (dest.to_meter) {
        point.x /= dest.to_meter;
        point.y /= dest.to_meter;
        point.z /= dest.to_meter;
      }
    } else {
      dest.forward(point);
      if (dest.to_meter) {
        point.x /= dest.to_meter;
        point.y /= dest.to_meter;
      }
    }
  }

// DGR, 2010/11/12
  if (dest.axis !== 'enu') {
    return Object(_adjust_axis__WEBPACK_IMPORTED_MODULE_3__["default"])(dest, true, point);
  }

  return point;
}


/***/ }),

/***/ "./node_modules/melowntech-proj4/lib/version.js":
/*!******************************************************!*\
  !*** ./node_modules/melowntech-proj4/lib/version.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json */ "./node_modules/melowntech-proj4/package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./node_modules/melowntech-proj4/package.json", 1);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _package_json__WEBPACK_IMPORTED_MODULE_0__["version"]; });




/***/ }),

/***/ "./node_modules/melowntech-proj4/package.json":
/*!****************************************************!*\
  !*** ./node_modules/melowntech-proj4/package.json ***!
  \****************************************************/
/*! exports provided: name, version, description, main, module, directories, scripts, repository, author, license, devDependencies, dependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"melowntech-proj4\",\"version\":\"2.4.5\",\"description\":\"Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.\",\"main\":\"dist/proj4-src.js\",\"module\":\"lib/index.js\",\"directories\":{\"test\":\"test\",\"doc\":\"docs\"},\"scripts\":{\"build\":\"grunt\",\"build:tmerc\":\"grunt build:tmerc\",\"test\":\"npm run build && istanbul test _mocha test/test.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git:https://github.com/melown/proj4js.git\"},\"author\":\"\",\"license\":\"MIT\",\"devDependencies\":{\"chai\":\"~1.8.1\",\"curl\":\"git://github.com/cujojs/curl.git\",\"grunt\":\"^0.4.5\",\"grunt-cli\":\"~0.1.13\",\"grunt-contrib-connect\":\"~0.6.0\",\"grunt-contrib-jshint\":\"~1.1.0\",\"grunt-contrib-uglify\":\"~0.11.1\",\"grunt-mocha-phantomjs\":\"~0.4.0\",\"grunt-rollup\":\"^1.0.1\",\"istanbul\":\"~0.2.4\",\"mocha\":\"~1.17.1\",\"rollup\":\"^0.41.4\",\"rollup-plugin-json\":\"^2.0.1\",\"rollup-plugin-node-resolve\":\"^2.0.0\",\"tin\":\"~0.4.0\"},\"dependencies\":{\"mgrs\":\"1.0.0\",\"wkt-parser\":\"^1.1.3\"}}");

/***/ }),

/***/ "./node_modules/melowntech-proj4/projs.js":
/*!************************************************!*\
  !*** ./node_modules/melowntech-proj4/projs.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_projections_tmerc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/projections/tmerc */ "./node_modules/melowntech-proj4/lib/projections/tmerc.js");
/* harmony import */ var _lib_projections_etmerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/projections/etmerc */ "./node_modules/melowntech-proj4/lib/projections/etmerc.js");
/* harmony import */ var _lib_projections_utm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/projections/utm */ "./node_modules/melowntech-proj4/lib/projections/utm.js");
/* harmony import */ var _lib_projections_sterea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/projections/sterea */ "./node_modules/melowntech-proj4/lib/projections/sterea.js");
/* harmony import */ var _lib_projections_stere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/projections/stere */ "./node_modules/melowntech-proj4/lib/projections/stere.js");
/* harmony import */ var _lib_projections_somerc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/projections/somerc */ "./node_modules/melowntech-proj4/lib/projections/somerc.js");
/* harmony import */ var _lib_projections_omerc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/projections/omerc */ "./node_modules/melowntech-proj4/lib/projections/omerc.js");
/* harmony import */ var _lib_projections_lcc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/projections/lcc */ "./node_modules/melowntech-proj4/lib/projections/lcc.js");
/* harmony import */ var _lib_projections_krovak__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/projections/krovak */ "./node_modules/melowntech-proj4/lib/projections/krovak.js");
/* harmony import */ var _lib_projections_cass__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/projections/cass */ "./node_modules/melowntech-proj4/lib/projections/cass.js");
/* harmony import */ var _lib_projections_laea__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/projections/laea */ "./node_modules/melowntech-proj4/lib/projections/laea.js");
/* harmony import */ var _lib_projections_aea__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/projections/aea */ "./node_modules/melowntech-proj4/lib/projections/aea.js");
/* harmony import */ var _lib_projections_gnom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/projections/gnom */ "./node_modules/melowntech-proj4/lib/projections/gnom.js");
/* harmony import */ var _lib_projections_cea__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/projections/cea */ "./node_modules/melowntech-proj4/lib/projections/cea.js");
/* harmony import */ var _lib_projections_eqc__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/projections/eqc */ "./node_modules/melowntech-proj4/lib/projections/eqc.js");
/* harmony import */ var _lib_projections_poly__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/projections/poly */ "./node_modules/melowntech-proj4/lib/projections/poly.js");
/* harmony import */ var _lib_projections_nzmg__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/projections/nzmg */ "./node_modules/melowntech-proj4/lib/projections/nzmg.js");
/* harmony import */ var _lib_projections_mill__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lib/projections/mill */ "./node_modules/melowntech-proj4/lib/projections/mill.js");
/* harmony import */ var _lib_projections_sinu__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./lib/projections/sinu */ "./node_modules/melowntech-proj4/lib/projections/sinu.js");
/* harmony import */ var _lib_projections_moll__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./lib/projections/moll */ "./node_modules/melowntech-proj4/lib/projections/moll.js");
/* harmony import */ var _lib_projections_eqdc__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lib/projections/eqdc */ "./node_modules/melowntech-proj4/lib/projections/eqdc.js");
/* harmony import */ var _lib_projections_vandg__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./lib/projections/vandg */ "./node_modules/melowntech-proj4/lib/projections/vandg.js");
/* harmony import */ var _lib_projections_aeqd__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lib/projections/aeqd */ "./node_modules/melowntech-proj4/lib/projections/aeqd.js");
/* harmony import */ var _lib_projections_ortho__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lib/projections/ortho */ "./node_modules/melowntech-proj4/lib/projections/ortho.js");
/* harmony import */ var _lib_projections_geocent__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./lib/projections/geocent */ "./node_modules/melowntech-proj4/lib/projections/geocent.js");
/* harmony import */ var _lib_projections_qsc__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lib/projections/qsc */ "./node_modules/melowntech-proj4/lib/projections/qsc.js");


























/* harmony default export */ __webpack_exports__["default"] = (function(proj4){
  proj4.Proj.projections.add(_lib_projections_tmerc__WEBPACK_IMPORTED_MODULE_0__["default"]);
  proj4.Proj.projections.add(_lib_projections_etmerc__WEBPACK_IMPORTED_MODULE_1__["default"]);
  proj4.Proj.projections.add(_lib_projections_utm__WEBPACK_IMPORTED_MODULE_2__["default"]);
  proj4.Proj.projections.add(_lib_projections_sterea__WEBPACK_IMPORTED_MODULE_3__["default"]);
  proj4.Proj.projections.add(_lib_projections_stere__WEBPACK_IMPORTED_MODULE_4__["default"]);
  proj4.Proj.projections.add(_lib_projections_somerc__WEBPACK_IMPORTED_MODULE_5__["default"]);
  proj4.Proj.projections.add(_lib_projections_omerc__WEBPACK_IMPORTED_MODULE_6__["default"]);
  proj4.Proj.projections.add(_lib_projections_lcc__WEBPACK_IMPORTED_MODULE_7__["default"]);
  proj4.Proj.projections.add(_lib_projections_krovak__WEBPACK_IMPORTED_MODULE_8__["default"]);
  proj4.Proj.projections.add(_lib_projections_cass__WEBPACK_IMPORTED_MODULE_9__["default"]);
  proj4.Proj.projections.add(_lib_projections_laea__WEBPACK_IMPORTED_MODULE_10__["default"]);
  proj4.Proj.projections.add(_lib_projections_aea__WEBPACK_IMPORTED_MODULE_11__["default"]);
  proj4.Proj.projections.add(_lib_projections_gnom__WEBPACK_IMPORTED_MODULE_12__["default"]);
  proj4.Proj.projections.add(_lib_projections_cea__WEBPACK_IMPORTED_MODULE_13__["default"]);
  proj4.Proj.projections.add(_lib_projections_eqc__WEBPACK_IMPORTED_MODULE_14__["default"]);
  proj4.Proj.projections.add(_lib_projections_poly__WEBPACK_IMPORTED_MODULE_15__["default"]);
  proj4.Proj.projections.add(_lib_projections_nzmg__WEBPACK_IMPORTED_MODULE_16__["default"]);
  proj4.Proj.projections.add(_lib_projections_mill__WEBPACK_IMPORTED_MODULE_17__["default"]);
  proj4.Proj.projections.add(_lib_projections_sinu__WEBPACK_IMPORTED_MODULE_18__["default"]);
  proj4.Proj.projections.add(_lib_projections_moll__WEBPACK_IMPORTED_MODULE_19__["default"]);
  proj4.Proj.projections.add(_lib_projections_eqdc__WEBPACK_IMPORTED_MODULE_20__["default"]);
  proj4.Proj.projections.add(_lib_projections_vandg__WEBPACK_IMPORTED_MODULE_21__["default"]);
  proj4.Proj.projections.add(_lib_projections_aeqd__WEBPACK_IMPORTED_MODULE_22__["default"]);
  proj4.Proj.projections.add(_lib_projections_ortho__WEBPACK_IMPORTED_MODULE_23__["default"]);
  proj4.Proj.projections.add(_lib_projections_geocent__WEBPACK_IMPORTED_MODULE_24__["default"]);
  proj4.Proj.projections.add(_lib_projections_qsc__WEBPACK_IMPORTED_MODULE_25__["default"]);
});

/***/ }),

/***/ "./node_modules/mgrs/mgrs.js":
/*!***********************************!*\
  !*** ./node_modules/mgrs/mgrs.js ***!
  \***********************************/
/*! exports provided: default, forward, inverse, toPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward", function() { return forward; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toPoint", function() { return toPoint; });



/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;

/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

var A = 65; // A
var I = 73; // I
var O = 79; // O
var V = 86; // V
var Z = 90; // Z
/* harmony default export */ __webpack_exports__["default"] = ({
  forward: forward,
  inverse: inverse,
  toPoint: toPoint
});
/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */
function forward(ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
};

/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */
function inverse(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
};

function toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
};
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */
function degToRad(deg) {
  return (deg * (Math.PI / 180.0));
}

/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */
function radToDeg(rad) {
  return (180.0 * (rad / Math.PI));
}

/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  // (int)
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

  //Make sure the longitude 180.00 is in Zone 60
  if (Long === 180) {
    ZoneNumber = 60;
  }

  // Special zone for Norway
  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  }

  // Special zones for Svalbard
  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    }
    else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    }
    else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    }
    else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone
  LongOriginRad = degToRad(LongOrigin);

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}

/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */
function UTMtoLL(utm) {

  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  // check the ZoneNummber is valid
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;

  // remove 500,000 meter offset for longitude
  var x = UTMEasting - 500000.0;
  var y = UTMNorthing;

  // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly
  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  }

  // There are 60 zones with zone 1 being at West -180 to -174
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
  // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);

  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);

  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);

  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  }
  else {
    result = {
      lat: lat,
      lon: lon
    };
  }
  return result;
}

/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */
function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if ((84 >= lat) && (lat >= 72)) {
    LetterDesignator = 'X';
  }
  else if ((72 > lat) && (lat >= 64)) {
    LetterDesignator = 'W';
  }
  else if ((64 > lat) && (lat >= 56)) {
    LetterDesignator = 'V';
  }
  else if ((56 > lat) && (lat >= 48)) {
    LetterDesignator = 'U';
  }
  else if ((48 > lat) && (lat >= 40)) {
    LetterDesignator = 'T';
  }
  else if ((40 > lat) && (lat >= 32)) {
    LetterDesignator = 'S';
  }
  else if ((32 > lat) && (lat >= 24)) {
    LetterDesignator = 'R';
  }
  else if ((24 > lat) && (lat >= 16)) {
    LetterDesignator = 'Q';
  }
  else if ((16 > lat) && (lat >= 8)) {
    LetterDesignator = 'P';
  }
  else if ((8 > lat) && (lat >= 0)) {
    LetterDesignator = 'N';
  }
  else if ((0 > lat) && (lat >= -8)) {
    LetterDesignator = 'M';
  }
  else if ((-8 > lat) && (lat >= -16)) {
    LetterDesignator = 'L';
  }
  else if ((-16 > lat) && (lat >= -24)) {
    LetterDesignator = 'K';
  }
  else if ((-24 > lat) && (lat >= -32)) {
    LetterDesignator = 'J';
  }
  else if ((-32 > lat) && (lat >= -40)) {
    LetterDesignator = 'H';
  }
  else if ((-40 > lat) && (lat >= -48)) {
    LetterDesignator = 'G';
  }
  else if ((-48 > lat) && (lat >= -56)) {
    LetterDesignator = 'F';
  }
  else if ((-56 > lat) && (lat >= -64)) {
    LetterDesignator = 'E';
  }
  else if ((-64 > lat) && (lat >= -72)) {
    LetterDesignator = 'D';
  }
  else if ((-72 > lat) && (lat >= -80)) {
    LetterDesignator = 'C';
  }
  return LetterDesignator;
}

/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */
function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
    snorthing = "00000" + utm.northing;

  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}

/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}

/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}

/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */
function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

  // colInt and rowInt are the letters to build to return
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }

  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
    colInt++;
  }

  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  }
  else {
    rollover = false;
  }

  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
    rowInt++;
  }

  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}

/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */
function decode(mgrsString) {

  if (mgrsString && mgrsString.length === 0) {
    throw ("MGRSPoint coverting from nothing");
  }

  var length = mgrsString.length;

  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;

  // get Zone number
  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }
    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw ("MGRSPoint bad conversion from: " + mgrsString);
  }

  var zoneLetter = mgrsString.charAt(i++);

  // Should we check the zone letter here? Why not.
  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
  }

  hunK = mgrsString.substring(i, i += 2);

  var set = get100kSetForZone(zoneNumber);

  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);

  // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  }

  // calculate the char index for easting/northing separator
  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
  }

  var sep = remainder / 2;

  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;

  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}

/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */
function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw ("Bad character: " + e);
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 100000.0;
  }

  return eastingValue;
}

/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */
function getNorthingFromChar(n, set) {

  if (n > 'V') {
    throw ("MGRSPoint given invalid Northing " + n);
  }

  // rowOrigin is the letter at the origin of the set for the
  // column
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character
    if (curRow > V) {
      if (rewindMarker) { // making sure that this loop ends
        throw ("Bad character: " + n);
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 100000.0;
  }

  return northingValue;
}

/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
  case 'C':
    northing = 1100000.0;
    break;
  case 'D':
    northing = 2000000.0;
    break;
  case 'E':
    northing = 2800000.0;
    break;
  case 'F':
    northing = 3700000.0;
    break;
  case 'G':
    northing = 4600000.0;
    break;
  case 'H':
    northing = 5500000.0;
    break;
  case 'J':
    northing = 6400000.0;
    break;
  case 'K':
    northing = 7300000.0;
    break;
  case 'L':
    northing = 8200000.0;
    break;
  case 'M':
    northing = 9100000.0;
    break;
  case 'N':
    northing = 0.0;
    break;
  case 'P':
    northing = 800000.0;
    break;
  case 'Q':
    northing = 1700000.0;
    break;
  case 'R':
    northing = 2600000.0;
    break;
  case 'S':
    northing = 3500000.0;
    break;
  case 'T':
    northing = 4400000.0;
    break;
  case 'U':
    northing = 5300000.0;
    break;
  case 'V':
    northing = 6200000.0;
    break;
  case 'W':
    northing = 7000000.0;
    break;
  case 'X':
    northing = 7900000.0;
    break;
  default:
    northing = -1.0;
  }
  if (northing >= 0.0) {
    return northing;
  }
  else {
    throw ("Invalid zone letter: " + zoneLetter);
  }

}


/***/ }),

/***/ "./node_modules/wkt-parser/index.js":
/*!******************************************!*\
  !*** ./node_modules/wkt-parser/index.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser */ "./node_modules/wkt-parser/parser.js");
/* harmony import */ var _process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./process */ "./node_modules/wkt-parser/process.js");
var D2R = 0.01745329251994329577;





function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];
  if (!(outName in obj) && (inName in obj)) {
    obj[outName] = obj[inName];
    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  } else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === 'object') {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = '';
    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
      if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
        axisOrder += 'n';
      } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
        axisOrder += 's';
      } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
        axisOrder += 'e';
      } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
        axisOrder += 'w';
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += 'u';
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === 'GEOGCS') {
    geogcs = wkt;
  }
  if (geogcs) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }
    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }
      wkt.datumCode = 'wgs84';
    }
    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, - 6);
    }
    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, - 8);
    }
    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = 'rnb72';
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
        wkt.ellps = 'intl';
      }

      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }

    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = 'osgb36';
    }
    if (~wkt.datumCode.indexOf('osni_1952')) {
      wkt.datumCode = 'osni52';
    }
    if (~wkt.datumCode.indexOf('tm65')
      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
      wkt.datumCode = 'ire65';
    }
    if (wkt.datumCode === 'ch1903+') {
      wkt.datumCode = 'ch1903';
    }
    if (~wkt.datumCode.indexOf('israel')) {
      wkt.datumCode = 'isr93';
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ['standard_parallel_1', 'Standard_Parallel_1'],
    ['standard_parallel_1', 'Latitude of 1st standard parallel'],
    ['standard_parallel_2', 'Standard_Parallel_2'],
    ['standard_parallel_2', 'Latitude of 2nd standard parallel'],
    ['false_easting', 'False_Easting'],
    ['false_easting', 'False easting'],
    ['false-easting', 'Easting at false origin'],
    ['false_northing', 'False_Northing'],
    ['false_northing', 'False northing'],
    ['false_northing', 'Northing at false origin'],
    ['central_meridian', 'Central_Meridian'],
    ['central_meridian', 'Longitude of natural origin'],
    ['central_meridian', 'Longitude of false origin'],
    ['latitude_of_origin', 'Latitude_Of_Origin'],
    ['latitude_of_origin', 'Central_Parallel'],
    ['latitude_of_origin', 'Latitude of natural origin'],
    ['latitude_of_origin', 'Latitude of false origin'],
    ['scale_factor', 'Scale_Factor'],
    ['k0', 'scale_factor'],
    ['latitude_of_center', 'Latitude_Of_Center'],
    ['latitude_of_center', 'Latitude_of_center'],
    ['lat0', 'latitude_of_center', d2r],
    ['longitude_of_center', 'Longitude_Of_Center'],
    ['longitude_of_center', 'Longitude_of_center'],
    ['longc', 'longitude_of_center', d2r],
    ['x0', 'false_easting', toMeter],
    ['y0', 'false_northing', toMeter],
    ['long0', 'central_meridian', d2r],
    ['lat0', 'latitude_of_origin', d2r],
    ['lat0', 'standard_parallel_1', d2r],
    ['lat1', 'standard_parallel_1', d2r],
    ['lat2', 'standard_parallel_2', d2r],
    ['azimuth', 'Azimuth'],
    ['alpha', 'azimuth', d2r],
    ['srsCode', 'name']
  ];
  list.forEach(renamer);
  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  }
}
/* harmony default export */ __webpack_exports__["default"] = (function(wkt) {
  var lisp = Object(_parser__WEBPACK_IMPORTED_MODULE_0__["default"])(wkt);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  var obj = {};
  Object(_process__WEBPACK_IMPORTED_MODULE_1__["sExpr"])(lisp, obj);
  cleanWKT(obj);
  return obj;
});


/***/ }),

/***/ "./node_modules/wkt-parser/parser.js":
/*!*******************************************!*\
  !*** ./node_modules/wkt-parser/parser.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (parseString);

var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
// const ignoredChar = /[\s_\-\/\(\)]/g;
function Parser(text) {
  if (typeof text !== 'string') {
    throw new Error('not a string');
  }
  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char)
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(char) {
  if (char === ',') {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === ']') {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }

    return;
  }
};
Parser.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === '[') {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = '';
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
};

function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}


/***/ }),

/***/ "./node_modules/wkt-parser/process.js":
/*!********************************************!*\
  !*** ./node_modules/wkt-parser/process.js ***!
  \********************************************/
/*! exports provided: sExpr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sExpr", function() { return sExpr; });


function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;

  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj
  }, thing);
  if (key) {
    obj[key] = out;
  }
}

function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  var key = v.shift();
  if (key === 'PARAMETER') {
    key = v.shift();
  }
  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }
    obj[key] = v[0];
    return;
  }
  if (!v.length) {
    obj[key] = true;
    return;
  }
  if (key === 'TOWGS84') {
    obj[key] = v;
    return;
  }
  if (key === 'AXIS') {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }

  var i;
  switch (key) {
    case 'UNIT':
    case 'PRIMEM':
    case 'VERT_DATUM':
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };
      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }
      return;
    case 'SPHEROID':
    case 'ELLIPSOID':
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };
      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }
      return;
    case 'PROJECTEDCRS':
    case 'PROJCRS':
    case 'GEOGCS':
    case 'GEOCCS':
    case 'PROJCS':
    case 'LOCAL_CS':
    case 'GEODCRS':
    case 'GEODETICCRS':
    case 'GEODETICDATUM':
    case 'EDATUM':
    case 'ENGINEERINGDATUM':
    case 'VERT_CS':
    case 'VERTCRS':
    case 'VERTICALCRS':
    case 'COMPD_CS':
    case 'COMPOUNDCRS':
    case 'ENGINEERINGCRS':
    case 'ENGCRS':
    case 'FITTED_CS':
    case 'LOCAL_DATUM':
    case 'DATUM':
      v[0] = ['name', v[0]];
      mapit(obj, key, v);
      return;
    default:
      i = -1;
      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj[key]);
        }
      }
      return mapit(obj, key, v);
  }
}


/***/ }),

/***/ "./node_modules/worker-loader/dist/cjs.js?inline&fallback=false!./src/core/map/geodata-processor/worker-main.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js?inline&fallback=false!./src/core/map/geodata-processor/worker-main.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/*!\n * Copyright (c) 2021 Melown Technologies SE\n *  *  For terms of use, see accompanying main file.\n *  *  For 3rd party libraries licenses, see 3rdpartylicenses.txt.\n * \n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/core/map/geodata-processor/worker-main.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/core/map/geodata-processor/worker-bidi.js\":\n/*!*******************************************************!*\\\n  !*** ./src/core/map/geodata-processor/worker-bidi.js ***!\n  \\*******************************************************/\n/*! exports provided: bidi */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bidi\", function() { return bidi; });\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Character types for symbols from 0000 to 00FF.\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\nconst baseTypes = [\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'S', 'B', 'S',\n  'WS', 'B', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN',\n  'BN', 'BN', 'BN', 'BN', 'B', 'B', 'B', 'S', 'WS', 'ON', 'ON', 'ET',\n  'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'ON', 'ES', 'CS', 'ES', 'CS', 'CS',\n  'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'CS', 'ON',\n  'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON',\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'B', 'BN', 'BN', 'BN', 'BN', 'BN',\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN',\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'CS', 'ON', 'ET',\n  'ET', 'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'L', 'ON', 'ON', 'BN', 'ON',\n  'ON', 'ET', 'ET', 'EN', 'EN', 'ON', 'L', 'ON', 'ON', 'ON', 'EN', 'L',\n  'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L'\n];\n\n// Character types for symbols from 0600 to 06FF.\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n// Note that 061D does not exist in the Unicode standard (see\n// http://unicode.org/charts/PDF/U0600.pdf), so we replace it with an\n// empty string and issue a warning if we encounter this character. The\n// empty string is required to properly index the items after it.\nconst arabicTypes = [\n  'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'ON', 'ON', 'AL', 'ET', 'ET', 'AL',\n  'CS', 'AL', 'ON', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\n  'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', '', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\n  'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\n  'NSM', 'NSM', 'NSM', 'NSM', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN',\n  'AN', 'AN', 'AN', 'ET', 'AN', 'AN', 'AL', 'AL', 'AL', 'NSM', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AN',\n  'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'NSM', 'NSM',\n  'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'EN', 'EN', 'EN', 'EN',\n  'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL'\n];\n\nfunction isOdd(i) {\n  return (i & 1) !== 0;\n}\n\nfunction isEven(i) {\n  return (i & 1) === 0;\n}\n\nfunction findUnequal(arr, start, value) {\n  let j, jj;\n  for (j = start, jj = arr.length; j < jj; ++j) {\n    if (arr[j] !== value) {\n      return j;\n    }\n  }\n  return j;\n}\n\nfunction setValues(arr, start, end, value) {\n  for (let j = start; j < end; ++j) {\n    arr[j] = value;\n  }\n}\n\nfunction reverseValues(arr, arr2, start, end) {\n  for (let i = start, j = end - 1; i < j; ++i, --j) {\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    temp = arr2[i];\n    arr2[i] = arr2[j];\n    arr2[j] = temp;\n  }\n}\n\nfunction createBidiText(str, isLTR, vertical) {\n  return {\n    str: str,\n    indices: indices,\n    types : types,\n    dir: (vertical ? 'ttb' : (isLTR ? 'ltr' : 'rtl')),\n  };\n}\n\n// These are used in bidi(), which is called frequently. We re-use them on\n// each call to avoid unnecessary allocations.\nvar chars = [];\nvar types = [];\nvar indices = [];\n\nfunction bidi(str, startLevel, vertical) {\n  let isLTR = true;\n  let strLength = str.length;\n  if (strLength === 0 || vertical) {\n    return createBidiText(str, isLTR, vertical);\n  }\n\n  // Get types and fill arrays\n  chars.length = strLength;\n  types.length = strLength;\n  let numBidi = 0;\n\n  let i, ii;\n  for (i = 0; i < strLength; ++i) {\n    chars[i] = str.charAt(i);\n    indices[i] = i;\n\n    let charCode = str.charCodeAt(i);\n    let charType = 'L';\n    if (charCode <= 0x00ff) {\n      charType = baseTypes[charCode];\n    } else if (0x0590 <= charCode && charCode <= 0x05f4) {\n      charType = 'R';\n    } else if (0x0600 <= charCode && charCode <= 0x06ff) {\n      charType = arabicTypes[charCode & 0xff];\n      if (!charType) {\n        //console.log('Bidi: invalid Unicode character ' + charCode.toString(16));\n      }\n    } else if (0x0700 <= charCode && charCode <= 0x08AC) {\n      charType = 'AL';\n    }\n    if (charType === 'R' || charType === 'AL' || charType === 'AN') {\n      numBidi++;\n    }\n    types[i] = charType;\n  }\n\n  // Detect the bidi method\n  // - If there are no rtl characters then no bidi needed\n  // - If less than 30% chars are rtl then string is primarily ltr\n  // - If more than 30% chars are rtl then string is primarily rtl\n  if (numBidi === 0) {\n    isLTR = true;\n    return createBidiText(str, isLTR);\n  }\n\n  if (startLevel === -1) {\n    if ((numBidi / strLength) < 0.3) {\n      isLTR = true;\n      startLevel = 0;\n    } else {\n      isLTR = false;\n      startLevel = 1;\n    }\n  }\n\n  let levels = [];\n  for (i = 0; i < strLength; ++i) {\n    levels[i] = startLevel;\n  }\n\n  /*\n   X1-X10: skip most of this, since we are NOT doing the embeddings.\n   */\n  let e = (isOdd(startLevel) ? 'R' : 'L');\n  let sor = e;\n  let eor = sor;\n\n  /*\n   W1. Examine each non-spacing mark (NSM) in the level run, and change the\n   type of the NSM to the type of the previous character. If the NSM is at the\n   start of the level run, it will get the type of sor.\n   */\n  let lastType = sor;\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'NSM') {\n      types[i] = lastType;\n    } else {\n      lastType = types[i];\n    }\n  }\n\n  /*\n   W2. Search backwards from each instance of a European number until the\n   first strong type (R, L, AL, or sor) is found.  If an AL is found, change\n   the type of the European number to Arabic number.\n   */\n  lastType = sor;\n  let t;\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'EN') {\n      types[i] = (lastType === 'AL') ? 'AN' : 'EN';\n    } else if (t === 'R' || t === 'L' || t === 'AL') {\n      lastType = t;\n    }\n  }\n\n  /*\n   W3. Change all ALs to R.\n   */\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'AL') {\n      types[i] = 'R';\n    }\n  }\n\n  /*\n   W4. A single European separator between two European numbers changes to a\n   European number. A single common separator between two numbers of the same\n   type changes to that type:\n   */\n  for (i = 1; i < strLength - 1; ++i) {\n    if (types[i] === 'ES' && types[i - 1] === 'EN' && types[i + 1] === 'EN') {\n      types[i] = 'EN';\n    }\n    if (types[i] === 'CS' &&\n        (types[i - 1] === 'EN' || types[i - 1] === 'AN') &&\n        types[i + 1] === types[i - 1]) {\n      types[i] = types[i - 1];\n    }\n  }\n\n  /*\n   W5. A sequence of European terminators adjacent to European numbers changes\n   to all European numbers:\n   */\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'EN') {\n      // do before\n      let j;\n      for (j = i - 1; j >= 0; --j) {\n        if (types[j] !== 'ET') {\n          break;\n        }\n        types[j] = 'EN';\n      }\n      // do after\n      for (j = i + 1; j < strLength; ++j) {\n        if (types[j] !== 'ET') {\n          break;\n        }\n        types[j] = 'EN';\n      }\n    }\n  }\n\n  /*\n   W6. Otherwise, separators and terminators change to Other Neutral:\n   */\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'WS' || t === 'ES' || t === 'ET' || t === 'CS') {\n      types[i] = 'ON';\n    }\n  }\n\n  /*\n   W7. Search backwards from each instance of a European number until the\n   first strong type (R, L, or sor) is found. If an L is found,  then change\n   the type of the European number to L.\n   */\n  lastType = sor;\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'EN') {\n      types[i] = ((lastType === 'L') ? 'L' : 'EN');\n    } else if (t === 'R' || t === 'L') {\n      lastType = t;\n    }\n  }\n\n  /*\n   N1. A sequence of neutrals takes the direction of the surrounding strong\n   text if the text on both sides has the same direction. European and Arabic\n   numbers are treated as though they were R. Start-of-level-run (sor) and\n   end-of-level-run (eor) are used at level run boundaries.\n   */\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'ON') {\n      let end = findUnequal(types, i + 1, 'ON');\n      let before = sor;\n      if (i > 0) {\n        before = types[i - 1];\n      }\n\n      let after = eor;\n      if (end + 1 < strLength) {\n        after = types[end + 1];\n      }\n      if (before !== 'L') {\n        before = 'R';\n      }\n      if (after !== 'L') {\n        after = 'R';\n      }\n      if (before === after) {\n        setValues(types, i, end, before);\n      }\n      i = end - 1; // reset to end (-1 so next iteration is ok)\n    }\n  }\n\n  /*\n   N2. Any remaining neutrals take the embedding direction.\n   */\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'ON') {\n      types[i] = e;\n    }\n  }\n\n  /*\n   I1. For all characters with an even (left-to-right) embedding direction,\n   those of type R go up one level and those of type AN or EN go up two\n   levels.\n   I2. For all characters with an odd (right-to-left) embedding direction,\n   those of type L, EN or AN go up one level.\n   */\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (isEven(levels[i])) {\n      if (t === 'R') {\n        levels[i] += 1;\n      } else if (t === 'AN' || t === 'EN') {\n        levels[i] += 2;\n      }\n    } else { // isOdd\n      if (t === 'L' || t === 'AN' || t === 'EN') {\n        levels[i] += 1;\n      }\n    }\n  }\n\n  /*\n   L1. On each line, reset the embedding level of the following characters to\n   the paragraph embedding level:\n\n   segment separators,\n   paragraph separators,\n   any sequence of whitespace characters preceding a segment separator or\n   paragraph separator, and any sequence of white space characters at the end\n   of the line.\n   */\n\n  // don't bother as text is only single line\n\n  /*\n   L2. From the highest level found in the text to the lowest odd level on\n   each line, reverse any contiguous sequence of characters that are at that\n   level or higher.\n   */\n\n  // find highest level & lowest odd level\n  let highestLevel = -1;\n  let lowestOddLevel = 99;\n  let level;\n  for (i = 0, ii = levels.length; i < ii; ++i) {\n    level = levels[i];\n    if (highestLevel < level) {\n      highestLevel = level;\n    }\n    if (lowestOddLevel > level && isOdd(level)) {\n      lowestOddLevel = level;\n    }\n  }\n\n  // now reverse between those limits\n  for (level = highestLevel; level >= lowestOddLevel; --level) {\n    // find segments to reverse\n    let start = -1;\n    for (i = 0, ii = levels.length; i < ii; ++i) {\n      if (levels[i] < level) {\n        if (start >= 0) {\n          reverseValues(chars, indices, start, i);\n          start = -1;\n        }\n      } else if (start < 0) {\n        start = i;\n      }\n    }\n    if (start >= 0) {\n      reverseValues(chars, indices, start, levels.length);\n    }\n  }\n\n  /*\n   L3. Combining marks applied to a right-to-left base character will at this\n   point precede their base character. If the rendering engine expects them to\n   follow the base characters in the final display process, then the ordering\n   of the marks and the base character must be reversed.\n   */\n\n  // don't bother for now\n\n  /*\n   L4. A character that possesses the mirrored property as specified by\n   Section 4.7, Mirrored, must be depicted by a mirrored glyph if the resolved\n   directionality of that character is R.\n   */\n\n  // don't mirror as characters are already mirrored in the pdf\n\n  // Finally, return string\n  for (i = 0, ii = chars.length; i < ii; ++i) {\n    let ch = chars[i];\n    if (ch === '<' || ch === '>') {\n      chars[i] = '';\n    }\n  }\n  return createBidiText(chars.join(''), isLTR);\n}\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/map/geodata-processor/worker-font.js\":\n/*!*******************************************************!*\\\n  !*** ./src/core/map/geodata-processor/worker-font.js ***!\n  \\*******************************************************/\n/*! exports provided: Typr */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Typr\", function() { return Typr; });\n/* harmony import */ var _worker_bidi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-bidi.js */ \"./src/core/map/geodata-processor/worker-bidi.js\");\n\n\n\n\n//get rid of compiler mess\nconst bidi = _worker_bidi_js__WEBPACK_IMPORTED_MODULE_0__[\"bidi\"];\n\n\nconst Typr = {};\n\nTypr.parse = function(buff) {\n    const bin = Typr._bin;\n    const data = new Uint8Array(buff);\n    let offset = 0;\n\n    // eslint-disable-next-line\n    const sfnt_version = bin.readFixed(data, offset);\n    offset += 4;\n    const numTables = bin.readUshort(data, offset);\n    offset += 2;\n    // eslint-disable-next-line\n    const searchRange = bin.readUshort(data, offset);\n    offset += 2;\n    // eslint-disable-next-line\n    const entrySelector = bin.readUshort(data, offset);\n    offset += 2;\n    // eslint-disable-next-line\n    const rangeShift = bin.readUshort(data, offset);\n    offset += 2;\n\n    const tags = [\n        \"cmap\",\n        \"head\",\n        \"hhea\",\n        \"maxp\",\n        \"hmtx\",\n        //\"name\",\n        //\"OS/2\",\n        //\"post\",\n\n        //\"cvt\",\n        //\"fpgm\",\n        //\"loca\",\n        //\"glyf\",\n        \"kern\",\n\n        //\"prep\"\n        //\"gasp\"\n\n        \"GPOS\",\n        \"GSUB\"\n        //\"VORG\",\n        ];\n\n    const obj = {_data:data};\n    //console.log(sfnt_version, numTables, searchRange, entrySelector, rangeShift);\n\n    const tabs = {};\n    let tablesOffset = 0;\n\n    for(let i=0; i<numTables; i++) {\n        const tag = bin.readASCII(data, offset, 4);   offset += 4;\n        // eslint-disable-next-line\n        const checkSum = bin.readUint(data, offset);  offset += 4;\n        const toffset = bin.readUint(data, offset);   offset += 4;\n        const length = bin.readUint(data, offset);    offset += 4;\n        tabs[tag] = {offset:toffset, length:length};\n        tablesOffset = toffset + length;\n        //if(tags.indexOf(tag)==-1) console.log(\"unknown tag\", tag);\n    }\n\n    for(let i=0; i< tags.length; i++) {\n        const t = tags[i];\n        //console.log(t);\n        //if(tabs[t]) console.log(t, tabs[t].offset, tabs[t].length);\n        if(tabs[t]) obj[t.trim()] = Typr[t.trim()].parse(data, tabs[t].offset, tabs[t].length, obj);\n    }\n\n    obj._tabs = tabs;\n\n    Typr._processGlyphs(data, tablesOffset, tabs, obj);\n\n    //get tables\n    const gsub = obj['GSUB'];\n    if (gsub) {\n        const llist = gsub.lookupList, flist = gsub.featureList;\n\n        obj.gsubIsolTable = [];\n        obj.gsubInitTable = [];\n        obj.gsubFinaTable = [];\n        obj.gsubMediTable = [];\n\n        obj.gsubRligLigaTable = [];\n\n        for(let fi = 0; fi < flist.length; fi++) {\n            const tag = flist[fi].tag;\n\n            switch (tag) {\n                case 'isol':\n                case 'init':\n                case 'fina':\n                case 'medi':\n\n                    for(let ti = 0; ti < flist[fi].tab.length; ti++) {\n                        const tab = llist[flist[fi].tab[ti]];\n\n                        if(tab.ltype == 1) {\n                            switch (tag) {\n                                case 'isol': obj.gsubIsolTable.push(tab.tabs); break;\n                                case 'init': obj.gsubInitTable.push(tab.tabs); break;\n                                case 'fina': obj.gsubFinaTable.push(tab.tabs); break;\n                                case 'medi': obj.gsubMediTable.push(tab.tabs); break;\n                            }\n                        }\n                    }\n\n                    break;\n\n                case 'rlig':\n                case 'liga':\n\n                    for(let ti = 0; ti < flist[fi].tab.length; ti++) {\n                        const tab = llist[flist[fi].tab[ti]];\n\n                        if(tab.ltype == 4) {\n                            obj.gsubRligLigaTable.push(tab.tabs);\n                        }\n                    }\n\n                    break;\n            }\n\n        }\n    }\n\n    return obj;\n}\n\nTypr._processGlyphs = function(data, index, tabs, obj) {\n    const version = data[index]; index += 1;\n    const textureLX = (data[index] << 8) | (data[index+1]); index += 2;\n    const textureLY = (data[index] << 8) | (data[index+1]); index += 2;\n    const size = data[index]; index += 1;\n    const flags = data[index]; index += 1;\n\n    obj.version = version;\n    obj.textureLX = textureLX;\n    obj.textureLY = textureLY;\n    obj.size = size;\n    obj.cly = size * 1.5;\n    obj.flags = flags;\n\n    const glyphs = new Array(obj.maxp.numGlyphs);\n    const fx = 1.0 / textureLX, fy = 1.0 / textureLY;\n    const step = (textureLX > 256) ? 7 : 6;\n\n    let filesIndicesIndex = index + obj.maxp.numGlyphs * step;\n    const filesIndicesCount = (data[filesIndicesIndex] << 8) | data[filesIndicesIndex+1];\n    const files = new Array(filesIndicesCount);\n\n    filesIndicesIndex += 2;\n\n    for (let i = 0, li = filesIndicesCount; i < li; i++) {\n        files[i] = (data[filesIndicesIndex+i*2] << 8) | data[filesIndicesIndex+i*2+1];\n    }\n\n    let fileIndex = 0;\n\n    for (let i = 0, li = obj.maxp.numGlyphs; i < li; i++) {\n        if (i == files[fileIndex]) {\n            fileIndex++;\n        }\n\n        glyphs[i] = Typr._processGlyph(data, index, fx, fy, textureLX, obj, i, fileIndex);\n        index += step;\n    }\n\n    obj.glyphs = glyphs;\n}\n\nTypr._processGlyph = function(data, index, fx, fy, textureLX, font, glyphIndex, fileIndex) {\n    let value = (data[index] << 24) | (data[index+1] << 16) | (data[index+2] << 8) | (data[index+3]);\n\n    // w 6bit | h 6bit | sx sign 1bit | abs sx 6bit | sy sign 1bit | abs sy 6bit | plane 2bit\n    const w = (value >> 22) & 63;\n    const h = (value >> 16) & 63;\n    const sx = ((value >> 9) & 63) * (((value >> 15) & 1) ? -1 : 1);\n    const sy = -((value >> 2) & 63) * (((value >> 8) & 1) ? -1 : 1);\n    const plane = (value & 3) + (fileIndex * 4);\n\n    if (textureLX > 256) {\n        value = (data[index+4] << 16) | (data[index+5] << 8) | (data[index+6]);\n    } else {\n        value = (data[index+4] << 8) | (data[index+5]);\n    }\n\n    const scale = ((font.size/0.75) / font.head.unitsPerEm) * 0.75;\n    let x, y, step = font.hmtx.aWidth[glyphIndex] * scale;\n\n    //store glyph position\n    switch (textureLX) {\n        case 2048: // x 11bit | y 11bit\n            x = ((value >> 11) & 2047), y = (value & 2047); break;\n\n        case 1024: // x 10bit | y 10bit\n            x = ((value >> 10) & 1023), y = (value & 1023); break;\n\n        case 512:  // x 9bit | y 9bit\n            x = ((value >> 9) & 511), y = (value & 511); break;\n\n        default:   // x 8bit | y 8bit\n            x = ((value >> 8) & 255), y = (value & 255); break;\n    }\n\n    return {\n        u1 : (x) * fx,\n        v1 : (y * fy) + plane,\n        u2 : (x + w) * fx,\n        v2 : ((y + h) * fy) + plane,\n        lx : w,\n        ly : h,\n        sx : sx,\n        sy : sy,\n        step : (step),\n        plane: plane\n    };\n}\n\nTypr._tabOffset = function(data, tab) {\n    const bin = Typr._bin;\n    const numTables = bin.readUshort(data, 4);\n    let offset = 12;\n    for(let i=0; i<numTables; i++) {\n        const tag = bin.readASCII(data, offset, 4);   offset += 4;\n        // eslint-disable-next-line\n        const checkSum = bin.readUint(data, offset);  offset += 4;\n        const toffset = bin.readUint(data, offset);   offset += 4;\n        // eslint-disable-next-line\n        const length = bin.readUint(data, offset);    offset += 4;\n        if(tag==tab) return toffset;\n    }\n    return 0;\n}\n\n\n\n\nTypr._bin = {\n    readFixed : function(data, o) {\n        return ((data[o]<<8) | data[o+1]) +  (((data[o+2]<<8)|data[o+3])/(256*256+4));\n    },\n\n    readF2dot14 : function(data, o) {\n        const num = Typr._bin.readShort(data, o);\n        return num / 16384;\n\n        // eslint-disable-next-line\n        const intg = (num >> 14), frac = ((num & 0x3fff)/(0x3fff+1));\n        return (intg>0) ? (intg+frac) : (intg-frac);\n    },\n\n    readInt : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        const a = Typr._bin.t.uint8;\n        a[0] = buff[p+3];\n        a[1] = buff[p+2];\n        a[2] = buff[p+1];\n        a[3] = buff[p];\n        return Typr._bin.t.int32[0];\n    },\n\n    readInt8 : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        const a = Typr._bin.t.uint8;\n        a[0] = buff[p];\n        return Typr._bin.t.int8[0];\n    },\n\n    readShort : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        const a = Typr._bin.t.uint8;\n        a[1] = buff[p]; a[0] = buff[p+1];\n        return Typr._bin.t.int16[0];\n    },\n\n    readUshort : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        return (buff[p]<<8) | buff[p+1];\n    },\n\n    readUshorts : function(buff, p, len) {\n        const arr = [];\n        for(let i=0; i<len; i++) arr.push(Typr._bin.readUshort(buff, p+i*2));\n        return arr;\n    },\n\n    readUint : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        const a = Typr._bin.t.uint8;\n        a[3] = buff[p];  a[2] = buff[p+1];  a[1] = buff[p+2];  a[0] = buff[p+3];\n        return Typr._bin.t.uint32[0];\n    },\n\n    readUint64 : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        return (Typr._bin.readUint(buff, p)*(0xffffffff+1)) + Typr._bin.readUint(buff, p+4);\n    },\n\n    readASCII : function(buff, p, l) {   // l : length in Characters (not Bytes)\n        //if(p>=buff.length) throw \"error\";\n        let s = \"\";\n        for(let i = 0; i < l; i++) s += String.fromCharCode(buff[p+i]);\n        return s;\n    },\n\n    readUnicode : function(buff, p, l) {\n        //if(p>=buff.length) throw \"error\";\n        let s = \"\";\n        for(let i = 0; i < l; i++)\n        {\n            const c = (buff[p++]<<8) | buff[p++];\n            s += String.fromCharCode(c);\n        }\n        return s;\n    },\n\n    readBytes : function(buff, p, l) {\n        //if(p>=buff.length) throw \"error\";\n        const arr = [];\n        for(let i=0; i<l; i++) arr.push(buff[p+i]);\n        return arr;\n    },\n\n    readASCIIArray : function(buff, p, l) {  // l : length in Characters (not Bytes)\n        //if(p>=buff.length) throw \"error\";\n        const s = [];\n        for(let i = 0; i < l; i++)\n            s.push(String.fromCharCode(buff[p+i]));\n        return s;\n    }\n};\n\nTypr._bin.t = {\n    buff: new ArrayBuffer(8),\n};\nTypr._bin.t.int8   = new Int8Array  (Typr._bin.t.buff);\nTypr._bin.t.uint8  = new Uint8Array (Typr._bin.t.buff);\nTypr._bin.t.int16  = new Int16Array (Typr._bin.t.buff);\nTypr._bin.t.uint16 = new Uint16Array(Typr._bin.t.buff);\nTypr._bin.t.int32  = new Int32Array (Typr._bin.t.buff);\nTypr._bin.t.uint32 = new Uint32Array(Typr._bin.t.buff);\n\n\n\n\n\n// OpenType Layout Common Table Formats\n\nTypr._lctf = {};\n\nTypr._lctf.parse = function(data, offset, length, font, subt) {\n    const bin = Typr._bin;\n    const obj = {};\n    const offset0 = offset;\n    // eslint-disable-next-line\n    const tableVersion = bin.readFixed(data, offset);  offset += 4;\n\n    const offScriptList  = bin.readUshort(data, offset);  offset += 2;\n    const offFeatureList = bin.readUshort(data, offset);  offset += 2;\n    const offLookupList  = bin.readUshort(data, offset);  offset += 2;\n\n    obj.scriptList  = Typr._lctf.readScriptList (data, offset0 + offScriptList);\n    obj.featureList = Typr._lctf.readFeatureList(data, offset0 + offFeatureList);\n    obj.lookupList  = Typr._lctf.readLookupList (data, offset0 + offLookupList, subt);\n\n    return obj;\n}\n\nTypr._lctf.readLookupList = function(data, offset, subt) {\n    const bin = Typr._bin;\n    const offset0 = offset;\n    const obj = [];\n    const count = bin.readUshort(data, offset);  offset+=2;\n\n    for(let i=0; i<count; i++)\n    {\n        const noff = bin.readUshort(data, offset);  offset+=2;\n        const lut = Typr._lctf.readLookupTable(data, offset0 + noff, subt);\n        obj.push(lut);\n    }\n    return obj;\n}\n\nTypr._lctf.readLookupTable = function(data, offset, subt) {\n    //console.log(\"Parsing lookup table\", offset);\n    const bin = Typr._bin;\n    const offset0 = offset;\n    const obj = {tabs:[]};\n\n    obj.ltype = bin.readUshort(data, offset);  offset+=2;\n    obj.flag  = bin.readUshort(data, offset);  offset+=2;\n    const cnt   = bin.readUshort(data, offset);  offset+=2;\n\n    for(let i=0; i<cnt; i++) {\n        const noff = bin.readUshort(data, offset);  offset+=2;\n        const tab = subt(data, obj.ltype, offset0 + noff);\n        //console.log(obj.type, tab);\n        obj.tabs.push(tab);\n    }\n    return obj;\n}\n\nTypr._lctf.numOfOnes = function(n) {\n    let num = 0;\n    for(let i=0; i<32; i++) if(((n>>>i)&1) != 0) num++;\n    return num;\n}\n\nTypr._lctf.readClassDef = function(data, offset) {\n    const bin = Typr._bin;\n    const obj = { start:[], end:[], class:[] };\n    const format = bin.readUshort(data, offset);  offset+=2;\n\n    if(format==1) {\n        const startGlyph  = bin.readUshort(data, offset);  offset+=2;\n        const glyphCount  = bin.readUshort(data, offset);  offset+=2;\n        for(let i=0; i<glyphCount; i++) {\n            obj.start.push(startGlyph+i);\n            obj.end  .push(startGlyph+i);\n            obj.class.push(bin.readUshort(data, offset));  offset+=2;\n        }\n    }\n\n    if(format==2) {\n        const count = bin.readUshort(data, offset);  offset+=2;\n        for(let i=0; i<count; i++) {\n            obj.start.push(bin.readUshort(data, offset));  offset+=2;\n            obj.end  .push(bin.readUshort(data, offset));  offset+=2;\n            obj.class.push(bin.readUshort(data, offset));  offset+=2;\n        }\n    }\n    return obj;\n}\n\nTypr._lctf.readValueRecord = function(data, offset, valFmt) {\n    const bin = Typr._bin;\n    const arr = [];\n    arr.push( (valFmt&1) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&1) ? 2 : 0;\n    arr.push( (valFmt&2) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&2) ? 2 : 0;\n    arr.push( (valFmt&4) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&4) ? 2 : 0;\n    arr.push( (valFmt&8) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&8) ? 2 : 0;\n    return arr;\n}\n\nTypr._lctf.readCoverage = function(data, offset) {\n    const bin = Typr._bin;\n    const cvg = {};\n    cvg.fmt   = bin.readUshort(data, offset);  offset+=2;\n    const count = bin.readUshort(data, offset);  offset+=2;\n    //console.log(\"parsing coverage\", offset-4, format, count);\n    if(cvg.fmt==1) cvg.tab = bin.readUshorts(data, offset, count);\n    if(cvg.fmt==2) cvg.tab = bin.readUshorts(data, offset, count*3);\n\n    //get min,max\n\n    let min = Number.POSITIVE_INFINITY, max = 0;\n    const tab = cvg.tab;\n\n    if(cvg.fmt==1) {\n\n        for(let i=0; i<tab.length; i++) {\n            let v = tab[i];\n            if (v > max) max = v;\n            if (v < min) min = v;\n        }\n    }\n\n    if(cvg.fmt==2) {\n        for(let i=0; i<tab.length; i+=3) {\n            let start = tab[i], end = tab[i+1];\n            if (start > max) max = start;\n            if (start < min) min = start;\n            if (end > max) max = end;\n            if (end < min) min = end;\n        }\n    }\n\n    cvg.min = min;\n    cvg.max = max;\n\n    return cvg;\n}\n\nTypr._lctf.coverageIndex = function(cvg, val) {\n    if (val < cvg.min || val > cvg.max) {\n        return -1;\n    }\n\n    const tab = cvg.tab;\n    if(cvg.fmt==1) return tab.indexOf(val);\n\n    for(let i=0; i<tab.length; i+=3) {\n        const start = tab[i], end = tab[i+1], index = tab[i+2];\n        if(start<=val && val<=end) return index + (val-start);\n    }\n    return -1;\n}\n\nTypr._lctf.readFeatureList = function(data, offset) {\n    const bin = Typr._bin;\n    const offset0 = offset;\n    const obj = [];\n\n    const count = bin.readUshort(data, offset);  offset+=2;\n\n    for(let i=0; i<count; i++) {\n        const tag = bin.readASCII(data, offset, 4);  offset+=4;\n        const noff = bin.readUshort(data, offset);  offset+=2;\n        obj.push({tag: tag.trim(), tab:Typr._lctf.readFeatureTable(data, offset0 + noff)});\n    }\n    return obj;\n}\n\nTypr._lctf.readFeatureTable = function(data, offset) {\n    const bin = Typr._bin;\n\n    // eslint-disable-next-line\n    const featureParams = bin.readUshort(data, offset);  offset+=2;   // = 0\n    const lookupCount = bin.readUshort(data, offset);  offset+=2;\n\n    const indices = [];\n    for(let i=0; i<lookupCount; i++) indices.push(bin.readUshort(data, offset+2*i));\n    return indices;\n}\n\n\nTypr._lctf.readScriptList = function(data, offset) {\n    const bin = Typr._bin;\n    const offset0 = offset;\n    const obj = {};\n\n    const count = bin.readUshort(data, offset);  offset+=2;\n\n    for(let i=0; i<count; i++) {\n        const tag = bin.readASCII(data, offset, 4);  offset+=4;\n        const noff = bin.readUshort(data, offset);  offset+=2;\n        obj[tag.trim()] = Typr._lctf.readScriptTable(data, offset0 + noff);\n    }\n    return obj;\n}\n\nTypr._lctf.readScriptTable = function(data, offset) {\n    const bin = Typr._bin;\n    const offset0 = offset;\n    const obj = {};\n\n    const defLangSysOff = bin.readUshort(data, offset);  offset+=2;\n    obj.default = Typr._lctf.readLangSysTable(data, offset0 + defLangSysOff);\n\n    let langSysCount = bin.readUshort(data, offset);  offset+=2;\n\n    for(let i=0; i<langSysCount; i++) {\n        const tag = bin.readASCII(data, offset, 4);  offset+=4;\n        const langSysOff = bin.readUshort(data, offset);  offset+=2;\n        obj[tag.trim()] = Typr._lctf.readLangSysTable(data, offset0 + langSysOff);\n    }\n    return obj;\n}\n\nTypr._lctf.readLangSysTable = function(data, offset) {\n    const bin = Typr._bin;\n    const obj = {};\n\n    // eslint-disable-next-line\n    const lookupOrder = bin.readUshort(data, offset);  offset+=2;\n    //if(lookupOrder!=0)  throw \"lookupOrder not 0\";\n    obj.reqFeature = bin.readUshort(data, offset);  offset+=2;\n    //if(obj.reqFeature != 0xffff) throw \"reqFeatureIndex != 0xffff\";\n\n    //console.log(lookupOrder, obj.reqFeature);\n\n    const featureCount = bin.readUshort(data, offset);  offset+=2;\n    obj.features = bin.readUshorts(data, offset, featureCount);\n    return obj;\n}\n\n\nTypr.cmap = {};\nTypr.cmap.parse = function(data, offset, length) {\n    data = new Uint8Array(data.buffer, offset, length);\n    offset = 0;\n\n    // eslint-disable-next-line\n    const offset0 = offset;\n    const bin = Typr._bin;\n    const obj = {};\n    // eslint-disable-next-line\n    const version   = bin.readUshort(data, offset);  offset += 2;\n    const numTables = bin.readUshort(data, offset);  offset += 2;\n\n    //console.log(version, numTables);\n\n    let offs = [];\n    obj.tables = [];\n\n\n    for(let i=0; i<numTables; i++) {\n        const platformID = bin.readUshort(data, offset);  offset += 2;\n        const encodingID = bin.readUshort(data, offset);  offset += 2;\n        const noffset = bin.readUint(data, offset);       offset += 4;\n\n        const id = \"p\"+platformID+\"e\"+encodingID;\n\n        //console.log(\"cmap subtable\", platformID, encodingID, noffset);\n\n        let tind = offs.indexOf(noffset);\n\n        if(tind==-1) {\n            tind = obj.tables.length;\n            let subt;\n            offs.push(noffset);\n            const format = bin.readUshort(data, noffset);\n            if     (format== 0) subt = Typr.cmap.parse0(data, noffset);\n            else if(format== 4) subt = Typr.cmap.parse4(data, noffset);\n            else if(format== 6) subt = Typr.cmap.parse6(data, noffset);\n            else if(format==12) subt = Typr.cmap.parse12(data,noffset);\n            else console.log(\"unknown format: \"+format, platformID, encodingID, noffset);\n            obj.tables.push(subt);\n        }\n\n        if(obj[id]!=null) throw \"multiple tables for one platform+encoding\";\n        obj[id] = tind;\n    }\n    return obj;\n}\n\nTypr.cmap.parse0 = function(data, offset) {\n    const bin = Typr._bin;\n    const obj = {};\n    obj.format = bin.readUshort(data, offset);  offset += 2;\n    const len    = bin.readUshort(data, offset);  offset += 2;\n    // eslint-disable-next-line\n    const lang   = bin.readUshort(data, offset);  offset += 2;\n    obj.map = [];\n    for(let i=0; i<len-6; i++) obj.map.push(data[offset+i]);\n    return obj;\n}\n\nTypr.cmap.parse4 = function(data, offset) {\n    const bin = Typr._bin;\n    const offset0 = offset;\n    const obj = {};\n\n    obj.format = bin.readUshort(data, offset);  offset+=2;\n    const length = bin.readUshort(data, offset);  offset+=2;\n    // eslint-disable-next-line\n    const language = bin.readUshort(data, offset);  offset+=2;\n    const segCountX2 = bin.readUshort(data, offset);  offset+=2;\n    const segCount = segCountX2/2;\n    obj.searchRange = bin.readUshort(data, offset);  offset+=2;\n    obj.entrySelector = bin.readUshort(data, offset);  offset+=2;\n    obj.rangeShift = bin.readUshort(data, offset);  offset+=2;\n    obj.endCount   = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n    offset+=2;\n    obj.startCount = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n    obj.idDelta = [];\n    for(let i=0; i<segCount; i++) {obj.idDelta.push(bin.readShort(data, offset));  offset+=2;}\n    obj.idRangeOffset = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n    obj.glyphIdArray = [];\n    while(offset< offset0+length) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\n    return obj;\n}\n\nTypr.cmap.parse6 = function(data, offset) {\n    const bin = Typr._bin;\n    // eslint-disable-next-line\n    const offset0 = offset;\n    const obj = {};\n\n    obj.format = bin.readUshort(data, offset);  offset+=2;\n    // eslint-disable-next-line\n    const length = bin.readUshort(data, offset);  offset+=2;\n    // eslint-disable-next-line\n    const language = bin.readUshort(data, offset);  offset+=2;\n    obj.firstCode = bin.readUshort(data, offset);  offset+=2;\n    const entryCount = bin.readUshort(data, offset);  offset+=2;\n    obj.glyphIdArray = [];\n    for(let i=0; i<entryCount; i++) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\n\n    return obj;\n}\n\nTypr.cmap.parse12 = function(data, offset) {\n    const bin = Typr._bin;\n    // eslint-disable-next-line\n    const offset0 = offset;\n    const obj = {};\n\n    obj.format = bin.readUshort(data, offset);  offset+=2;\n    offset += 2;\n    // eslint-disable-next-line\n    const length = bin.readUint(data, offset);  offset+=4;\n    // eslint-disable-next-line\n    const lang   = bin.readUint(data, offset);  offset+=4;\n    const nGroups= bin.readUint(data, offset);  offset+=4;\n    obj.groups = [];\n\n    for(let i=0; i<nGroups; i++) {\n        const off = offset + i * 12;\n        const startCharCode = bin.readUint(data, off+0);\n        const endCharCode   = bin.readUint(data, off+4);\n        const startGlyphID  = bin.readUint(data, off+8);\n        obj.groups.push([  startCharCode, endCharCode, startGlyphID  ]);\n    }\n    return obj;\n}\n\n\n\nTypr.GPOS = {};\nTypr.GPOS.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GPOS.subt);  }\n\n\n\nTypr.GPOS.subt = function(data, ltype, offset) { // lookup type\n    if(ltype!=2) return null;\n\n    const bin = Typr._bin, offset0 = offset, tab = {};\n\n    tab.format  = bin.readUshort(data, offset);  offset+=2;\n    const covOff  = bin.readUshort(data, offset);  offset+=2;\n    tab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);\n    tab.valFmt1 = bin.readUshort(data, offset);  offset+=2;\n    tab.valFmt2 = bin.readUshort(data, offset);  offset+=2;\n    const ones1 = Typr._lctf.numOfOnes(tab.valFmt1);\n    const ones2 = Typr._lctf.numOfOnes(tab.valFmt2);\n\n    if(tab.format==1) {\n        tab.pairsets = [];\n        const count = bin.readUshort(data, offset);  offset+=2;\n\n        for(let i=0; i<count; i++) {\n            let psoff = bin.readUshort(data, offset);  offset+=2;\n            psoff += offset0;\n            const pvcount = bin.readUshort(data, psoff);  psoff+=2;\n            const arr = [];\n\n            for(let j=0; j<pvcount; j++) {\n                const gid2 = bin.readUshort(data, psoff);  psoff+=2;\n                let value1, value2;\n                if(tab.valFmt1!=0) {  value1 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt1);  psoff+=ones1*2;  }\n                if(tab.valFmt2!=0) {  value2 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt2);  psoff+=ones2*2;  }\n                arr.push({gid2:gid2, val1:value1, val2:value2});\n            }\n            tab.pairsets.push(arr);\n        }\n    }\n\n    if(tab.format==2) {\n        const classDef1 = bin.readUshort(data, offset);  offset+=2;\n        const classDef2 = bin.readUshort(data, offset);  offset+=2;\n        const class1Count = bin.readUshort(data, offset);  offset+=2;\n        const class2Count = bin.readUshort(data, offset);  offset+=2;\n\n        tab.classDef1 = Typr._lctf.readClassDef(data, offset0 + classDef1);\n        tab.classDef2 = Typr._lctf.readClassDef(data, offset0 + classDef2);\n\n        tab.matrix = [];\n        for(let i=0; i<class1Count; i++) {\n            const row = [];\n            for(let j=0; j<class2Count; j++) {\n                let value1 = null, value2 = null;\n                if(tab.valFmt1!=0) { value1 = Typr._lctf.readValueRecord(data, offset, tab.valFmt1);  offset+=ones1*2; }\n                if(tab.valFmt2!=0) { value2 = Typr._lctf.readValueRecord(data, offset, tab.valFmt2);  offset+=ones2*2; }\n                row.push({val1:value1, val2:value2});\n            }\n            tab.matrix.push(row);\n        }\n    }\n    return tab;\n}\n\nTypr.GSUB = {};\nTypr.GSUB.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GSUB.subt);  }\n\n\nTypr.GSUB.subt = function(data, ltype, offset) { // lookup type\n    const bin = Typr._bin, offset0 = offset, tab = {};\n\n    if(ltype!=1 && ltype!=4) return null;\n\n    tab.fmt  = bin.readUshort(data, offset);  offset+=2;\n    const covOff  = bin.readUshort(data, offset);  offset+=2;\n    tab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);   // not always is coverage here\n\n    // eslint-disable-next-line\n    if(false) {}\n    else if(ltype==1) {\n        if(tab.fmt==1) {\n            tab.delta = bin.readShort(data, offset);  offset+=2;\n        }\n        else if(tab.fmt==2) {\n            const cnt = bin.readUshort(data, offset);  offset+=2;\n            tab.newg = bin.readUshorts(data, offset, cnt);  offset+=tab.newg.length*2;\n        }\n    }\n    else if(ltype==4) {\n        tab.vals = [];\n        const cnt = bin.readUshort(data, offset);  offset+=2;\n        for(let i=0; i<cnt; i++) {\n            const loff = bin.readUshort(data, offset);  offset+=2;\n            tab.vals.push(Typr.GSUB.readLigatureSet(data, offset0+loff));\n        }\n        //console.log(tab.coverage);\n        //console.log(tab.vals);\n    }\n\n    return tab;\n}\n\nTypr.GSUB.readChainSubClassSet = function(data, offset) {\n    const bin = Typr._bin, offset0 = offset, lset = [];\n    const cnt = bin.readUshort(data, offset);  offset+=2;\n    for(let i=0; i<cnt; i++) {\n        const loff = bin.readUshort(data, offset);  offset+=2;\n        lset.push(Typr.GSUB.readChainSubClassRule(data, offset0+loff));\n    }\n    return lset;\n}\n\nTypr.GSUB.readChainSubClassRule= function(data, offset) {\n    // eslint-disable-next-line\n    const bin = Typr._bin, offset0 = offset, rule = {};\n    const pps = [\"backtrack\", \"input\", \"lookahead\"];\n    for(let pi=0; pi<pps.length; pi++) {\n        let cnt = bin.readUshort(data, offset);  offset+=2;  if(pi==1) cnt--;\n        rule[pps[pi]]=bin.readUshorts(data, offset, cnt);  offset+= rule[pps[pi]].length*2;\n    }\n    const cnt = bin.readUshort(data, offset);  offset+=2;\n    rule.subst = bin.readUshorts(data, offset, cnt*2);  offset += rule.subst.length*2;\n    return rule;\n}\n\nTypr.GSUB.readLigatureSet = function(data, offset) {\n    const bin = Typr._bin, offset0 = offset, lset = [];\n    const lcnt = bin.readUshort(data, offset);  offset+=2;\n    for(let j=0; j<lcnt; j++) {\n        const loff = bin.readUshort(data, offset);  offset+=2;\n        lset.push(Typr.GSUB.readLigature(data, offset0+loff));\n    }\n    return lset;\n}\n\nTypr.GSUB.readLigature = function(data, offset) {\n    const bin = Typr._bin, lig = {chain:[]};\n    lig.nglyph = bin.readUshort(data, offset);  offset+=2;\n    const ccnt = bin.readUshort(data, offset);  offset+=2;\n    for(let k=0; k<ccnt-1; k++) {  lig.chain.push(bin.readUshort(data, offset));  offset+=2;  }\n    return lig;\n}\n\n\n\nTypr.head = {};\n// eslint-disable-next-line\nTypr.head.parse = function(data, offset, length) {\n    const bin = Typr._bin;\n    const obj = {};\n    // eslint-disable-next-line\n    const tableVersion = bin.readFixed(data, offset);  offset += 4;\n    obj.fontRevision = bin.readFixed(data, offset);  offset += 4;\n    // eslint-disable-next-line\n    const checkSumAdjustment = bin.readUint(data, offset);  offset += 4;\n    // eslint-disable-next-line\n    const magicNumber = bin.readUint(data, offset);  offset += 4;\n    obj.flags = bin.readUshort(data, offset);  offset += 2;\n    obj.unitsPerEm = bin.readUshort(data, offset);  offset += 2;\n    obj.created  = bin.readUint64(data, offset);  offset += 8;\n    obj.modified = bin.readUint64(data, offset);  offset += 8;\n    obj.xMin = bin.readShort(data, offset);  offset += 2;\n    obj.yMin = bin.readShort(data, offset);  offset += 2;\n    obj.xMax = bin.readShort(data, offset);  offset += 2;\n    obj.yMax = bin.readShort(data, offset);  offset += 2;\n    obj.macStyle = bin.readUshort(data, offset);  offset += 2;\n    obj.lowestRecPPEM = bin.readUshort(data, offset);  offset += 2;\n    obj.fontDirectionHint = bin.readShort(data, offset);  offset += 2;\n    obj.indexToLocFormat  = bin.readShort(data, offset);  offset += 2;\n    obj.glyphDataFormat   = bin.readShort(data, offset);  offset += 2;\n    return obj;\n}\n\n\nTypr.hhea = {};\n// eslint-disable-next-line\nTypr.hhea.parse = function(data, offset, length) {\n    const bin = Typr._bin;\n    const obj = {};\n    // eslint-disable-next-line\n    const tableVersion = bin.readFixed(data, offset);  offset += 4;\n    obj.ascender  = bin.readShort(data, offset);  offset += 2;\n    obj.descender = bin.readShort(data, offset);  offset += 2;\n    obj.lineGap = bin.readShort(data, offset);  offset += 2;\n\n    obj.advanceWidthMax = bin.readUshort(data, offset);  offset += 2;\n    obj.minLeftSideBearing  = bin.readShort(data, offset);  offset += 2;\n    obj.minRightSideBearing = bin.readShort(data, offset);  offset += 2;\n    obj.xMaxExtent = bin.readShort(data, offset);  offset += 2;\n\n    obj.caretSlopeRise = bin.readShort(data, offset);  offset += 2;\n    obj.caretSlopeRun  = bin.readShort(data, offset);  offset += 2;\n    obj.caretOffset    = bin.readShort(data, offset);  offset += 2;\n\n    offset += 4*2;\n\n    obj.metricDataFormat = bin.readShort (data, offset);  offset += 2;\n    obj.numberOfHMetrics = bin.readUshort(data, offset);  offset += 2;\n    return obj;\n}\n\n\nTypr.hmtx = {};\nTypr.hmtx.parse = function(data, offset, length, font) {\n     const bin = Typr._bin;\n     const obj = {};\n\n    obj.aWidth = [];\n    obj.lsBearing = [];\n\n    let aw = 0, lsb = 0;\n\n    for(let i=0; i<font.maxp.numGlyphs; i++) {\n        if(i<font.hhea.numberOfHMetrics) {  aw=bin.readUshort(data, offset);  offset += 2;  lsb=bin.readShort(data, offset);  offset+=2;  }\n        obj.aWidth.push(aw);\n        obj.lsBearing.push(lsb);\n    }\n\n    return obj;\n}\n\n\nTypr.kern = {};\nTypr.kern.parse = function(data, offset, length, font) {\n    const bin = Typr._bin;\n\n    const version = bin.readUshort(data, offset);  offset+=2;\n    if(version==1) return Typr.kern.parseV1(data, offset-2, length, font);\n    const nTables = bin.readUshort(data, offset);  offset+=2;\n\n    const map = {glyph1: [], rval:[]};\n    for(let i=0; i<nTables; i++) {\n        offset+=2;  // skip version\n        // eslint-disable-next-line\n        const length  = bin.readUshort(data, offset);  offset+=2;\n        const coverage = bin.readUshort(data, offset);  offset+=2;\n        let format = coverage>>>8;\n        /* I have seen format 128 once, that's why I do */ format &= 0xf;\n        if(format==0) offset = Typr.kern.readFormat0(data, offset, map);\n        else throw \"unknown kern table format: \"+format;\n    }\n    return map;\n}\n\n// eslint-disable-next-line\nTypr.kern.parseV1 = function(data, offset, length, font) {\n    const bin = Typr._bin;\n\n    // eslint-disable-next-line\n    const version = bin.readFixed(data, offset);  offset+=4;\n    const nTables = bin.readUint(data, offset);  offset+=4;\n\n    const map = {glyph1: [], rval:[]};\n    for(let i=0; i<nTables; i++) {\n        // eslint-disable-next-line\n        const length = bin.readUint(data, offset);   offset+=4;\n        const coverage = bin.readUshort(data, offset);  offset+=2;\n        // eslint-disable-next-line\n        const tupleIndex = bin.readUshort(data, offset);  offset+=2;\n        let format = coverage>>>8;\n        /* I have seen format 128 once, that's why I do */ format &= 0xf;\n        if(format==0) offset = Typr.kern.readFormat0(data, offset, map);\n        else throw \"unknown kern table format: \"+format;\n    }\n    return map;\n}\n\nTypr.kern.readFormat0 = function(data, offset, map) {\n    const bin = Typr._bin;\n    let pleft = -1;\n    const nPairs        = bin.readUshort(data, offset);  offset+=2;\n    // eslint-disable-next-line\n    const searchRange   = bin.readUshort(data, offset);  offset+=2;\n    // eslint-disable-next-line\n    const entrySelector = bin.readUshort(data, offset);  offset+=2;\n    // eslint-disable-next-line\n    const rangeShift    = bin.readUshort(data, offset);  offset+=2;\n    for(let j=0; j<nPairs; j++) {\n        const left  = bin.readUshort(data, offset);  offset+=2;\n        const right = bin.readUshort(data, offset);  offset+=2;\n        const value = bin.readShort (data, offset);  offset+=2;\n        if(left!=pleft) { map.glyph1.push(left);  map.rval.push({ glyph2:[], vals:[] }) }\n        const rval = map.rval[map.rval.length-1];\n        rval.glyph2.push(right);   rval.vals.push(value);\n        pleft = left;\n    }\n    return offset;\n}\n\n\n\nTypr.maxp = {};\n// eslint-disable-next-line\nTypr.maxp.parse = function(data, offset, length) {\n    //console.log(data.length, offset, length);\n\n    const bin = Typr._bin;\n    const obj = {};\n\n    // both versions 0.5 and 1.0\n    const ver = bin.readUint(data, offset); offset += 4;\n    obj.numGlyphs = bin.readUshort(data, offset);  offset += 2;\n\n    // only 1.0\n    if(ver == 0x00010000) {\n        obj.maxPoints             = bin.readUshort(data, offset);  offset += 2;\n        obj.maxContours           = bin.readUshort(data, offset);  offset += 2;\n        obj.maxCompositePoints    = bin.readUshort(data, offset);  offset += 2;\n        obj.maxCompositeContours  = bin.readUshort(data, offset);  offset += 2;\n        obj.maxZones              = bin.readUshort(data, offset);  offset += 2;\n        obj.maxTwilightPoints     = bin.readUshort(data, offset);  offset += 2;\n        obj.maxStorage            = bin.readUshort(data, offset);  offset += 2;\n        obj.maxFunctionDefs       = bin.readUshort(data, offset);  offset += 2;\n        obj.maxInstructionDefs    = bin.readUshort(data, offset);  offset += 2;\n        obj.maxStackElements      = bin.readUshort(data, offset);  offset += 2;\n        obj.maxSizeOfInstructions = bin.readUshort(data, offset);  offset += 2;\n        obj.maxComponentElements  = bin.readUshort(data, offset);  offset += 2;\n        obj.maxComponentDepth     = bin.readUshort(data, offset);  offset += 2;\n    }\n\n    return obj;\n}\n\n\nTypr.U = {};\n\nTypr.U.codeToGlyph = function(font, code) {\n    const cmap = font.cmap;\n\n\n    let tind = -1;\n    if(cmap.p0e4!=null) tind = cmap.p0e4;\n    else if(cmap.p3e1!=null) tind = cmap.p3e1;\n    else if(cmap.p1e0!=null) tind = cmap.p1e0;\n\n    if(tind==-1) throw \"no familiar platform and encoding!\";\n\n    const tab = cmap.tables[tind];\n\n    if (tab.format==0) {\n        if(code>=tab.map.length) return 0;\n        return tab.map[code];\n    } else if(tab.format==4) {\n        let sind = -1;\n        for(let i=0; i<tab.endCount.length; i++)   if(code<=tab.endCount[i]){  sind=i;  break;  }\n        if(sind==-1) return 0;\n        if(tab.startCount[sind]>code) return 0;\n\n        let gli = 0;\n        if(tab.idRangeOffset[sind]!=0) gli = tab.glyphIdArray[(code-tab.startCount[sind]) + (tab.idRangeOffset[sind]>>1) - (tab.idRangeOffset.length-sind)];\n        else                           gli = code + tab.idDelta[sind];\n        return gli & 0xFFFF;\n    } else if(tab.format==12) {\n        if(code>tab.groups[tab.groups.length-1][1]) return 0;\n        for(let i=0; i<tab.groups.length; i++) {\n            const grp = tab.groups[i];\n            if(grp[0]<=code && code<=grp[1]) return grp[2] + (code-grp[0]);\n        }\n        return 0;\n    }\n    else throw \"unknown cmap table format \"+tab.format;\n}\n\n\nTypr.U._getGlyphClass = function(g, cd) {\n    for(let i=0; i<cd.start.length; i++)\n        if(cd.start[i]<=g && cd.end[i]>=g) return cd.class[i];\n    return 0;\n}\n\nTypr.U.getPairAdjustment = function(font, g1, g2) {\n    if(font.GPOS) {\n        let ltab = null;\n        for(let i = 0; i < font.GPOS.featureList.length; i++) {\n            const fl = font.GPOS.featureList[i];\n            if (fl.tag==\"kern\")\n                for(let j=0; j<fl.tab.length; j++)\n                    if(font.GPOS.lookupList[fl.tab[j]].ltype==2) ltab=font.GPOS.lookupList[fl.tab[j]];\n        }\n        if(ltab) {\n            for(let i = 0; i < ltab.tabs.length; i++) {\n                const tab = ltab.tabs[i];\n                let ind = Typr._lctf.coverageIndex(tab.coverage, g1);\n                if (ind==-1) continue;\n                let adj = 0;\n                if (tab.format==1) {\n                    const right = tab.pairsets[ind];\n                    for (let j=0; j<right.length; j++) if (right[j].gid2==g2) adj = right[j];\n                    if (adj==null) continue;\n                } else if (tab.format==2) {\n                    const c1 = Typr.U._getGlyphClass(g1, tab.classDef1);\n                    const c2 = Typr.U._getGlyphClass(g2, tab.classDef2);\n                    adj = tab.matrix[c1][c2];\n                }\n                return adj.val1[2];\n            }\n        }\n    }\n    if(font.kern) {\n        let ind1 = font.kern.glyph1.indexOf(g1);\n        if(ind1!=-1) {\n            let ind2 = font.kern.rval[ind1].glyph2.indexOf(g2);\n            if(ind2!=-1) return font.kern.rval[ind1].vals[ind2];\n        }\n    }\n\n    return 0;\n}\n\n/*\nTypr.U.isRTL = function(str) {\n    let weakChars       = '\\u0000-\\u0040\\u005B-\\u0060\\u007B-\\u00BF\\u00D7\\u00F7\\u02B9-\\u02FF\\u2000-\\u2BFF\\u2010-\\u2029\\u202C\\u202F-\\u2BFF',\n        rtlChars        = '\\u0591-\\u07FF\\u200F\\u202B\\u202E\\uFB1D-\\uFDFD\\uFE70-\\uFEFC',\n        rtlDirCheck     = new RegExp('^['+weakChars+']*['+rtlChars+']');\n\n    return rtlDirCheck.test(str);\n};*/\n\n// let wsep = \"\\n\\t\\\" ,.:;!?()  ،\";\n//Typr.U.WSepTable = [9, 10, 32, 33, 34, 40, 41, 44, 46, 58, 59, 63, 1548]\n\n//let L = \"ꡲ્૗\";\n//Typr.U.LTable = [ 2765, 2775, 43122 ]\n\n//let R = \"آأؤإاةدذرزوٱٲٳٵٶٷڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙۀۃۄۅۆۇۈۉۊۋۍۏےۓەۮۯܐܕܖܗܘܙܞܨܪܬܯݍݙݚݛݫݬݱݳݴݸݹࡀࡆࡇࡉࡔࡧࡩࡪࢪࢫࢬࢮࢱࢲࢹૅેૉ૊૎૏ૐ૑૒૝ૡ૤૯஁ஃ஄அஉ஌எஏ஑னப஫஬\";\nTypr.U.RTable = [\n    1570, 1571, 1572, 1573, 1575, 1577, 1583, 1584, 1585, 1586,\n    1608, 1649, 1650, 1651, 1653, 1654, 1655, 1672, 1673, 1674,\n    1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684,\n    1685, 1686, 1687, 1688, 1689, 1728, 1731, 1732, 1733, 1734,\n    1735, 1736, 1737, 1738, 1739, 1741, 1743, 1746, 1747, 1749,\n    1774, 1775, 1808, 1813, 1814, 1815, 1816, 1817, 1822, 1832,\n    1834, 1836, 1839, 1869, 1881, 1882, 1883, 1899, 1900, 1905,\n    1907, 1908, 1912, 1913, 2112, 2118, 2119, 2121, 2132, 2151,\n    2153, 2154, 2218, 2219, 2220, 2222, 2225, 2226, 2233, 2757,\n    2759, 2761, 2762, 2766, 2767, 2768, 2769, 2770, 2781, 2785,\n    2788, 2799, 2945, 2947, 2948, 2949, 2953, 2956, 2958, 2959,\n    2961, 2985, 2986, 2987, 2988 ];\n\n\nTypr.U.stringToGlyphs = function(fonts, str) {\n    let gls = [], g, i, li, j, lj, k, ti, c, c2, gsub, font, /*llist, flist, t,*/ gsubTable;\n    let gl, gfonts = [], codes = [], scodes = [], scodesType = [];//, str2 = '';\n\n    let bidiResult = bidi(str, -1, false);\n\n    let rtable = Typr.U.RTable;\n\n    for (i = 0, li = str.length; i < li; i++) {\n        c = str.charCodeAt(i);\n        scodes.push(c);\n        scodesType.push(0);\n\n        //types wsep = 1, L = 2, R = 3\n\n        if (c == 2765 || c == 2775 || c == 43122) { // L\n            scodesType[i] = 2;\n        } else if (c == 1548) { // wsep\n            scodesType[i] = 1;\n        } else if (c <= 63) { // wsep\n            if (c == 9 || c == 10 || c == 32 || c == 33 || c == 34 || c == 40 || c == 41 || c == 44 || c == 46 || c == 58 || c == 59 || c == 63) {\n                scodesType[i] = 1;\n            }\n        } else if (c >= 1570 && c <= 2988) { // R\n            if (rtable.indexOf(c) != -1) {\n                scodesType[i] = 3;\n            }\n        }\n    }\n\n    //basic shaping\n    for (i = 0, li = str.length; i < li; i++) {\n        c = scodes[i];\n\n        if (scodesType[i] != 1) { //not wsep\n            if (i < li - 2) {\n                c2 = scodes[i+1];\n\n                //myanmar\n                if (c2 == 0x103c) { //medial ra - prebase substitution\n                    scodes[i] = c2;\n                    scodes[i+1] = c;\n                    i++;\n                    continue;\n                }\n            }\n        }\n    }\n\n    //get glyphs and fonts for codes\n    for (i = 0, li = str.length; i < li; i++) {\n        c = scodes[i];\n\n        for (j = 0, lj = fonts.length; j < lj; j++) {\n            font = fonts[j];\n            g = Typr.U.codeToGlyph(font, c);\n            if (g) {\n                break;\n            }\n        }\n\n        gls.push(g);\n        gfonts.push(g ? j : 0);\n    }\n\n    codes = scodes;\n    font = null;\n\n\n    for(let ci = 0; ci < gls.length; ci++) {\n        gl = gls[ci];\n\n        if (font != gfonts[ci]) {\n            font = fonts[gfonts[ci]];\n            gsub = font['GSUB'];\n        }\n\n        if(!gsub) {\n            continue;\n        }\n\n        let t1 = scodesType[ci-1], t2 = scodesType[ci], t3 = scodesType[ci+1];\n\n        let slft = (ci==0) || (t1 == 1);\n        let srgt = (ci==gls.length-1) || (t3 == 1);\n\n        if(!slft && (t1 == 3)) slft=true;\n        if(!srgt && (t2 == 3)) srgt=true;\n\n        if(!srgt && (t3 == 2)) srgt=true;\n        if(!slft && (t2 == 2)) slft=true;\n\n        gsubTable = null;\n        if (slft) {\n            gsubTable = srgt ? font.gsubIsolTable : font.gsubInitTable;\n        } else {\n            gsubTable = srgt ? font.gsubFinaTable : font.gsubMediTable;\n        }\n\n        if (gsubTable) {\n            for(ti = 0; ti < gsubTable.length; ti++) {\n                let tab = gsubTable[ti];\n\n                for(j = 0; j < tab.length; j++) {\n                    let ttab = tab[j];\n                    let ind = Typr._lctf.coverageIndex(ttab.coverage,gl);\n                    if(ind == -1) continue;\n\n                    if(ttab.fmt == 0) {\n                        gls[ci] = ind+ttab.delta;\n                    } else {\n                        if (!ttab.newg) {\n                            gls[ci] = gl;\n                            console.log(ci, gl, 'subst-error', ' original:', str);\n                        } else {\n                            gls[ci] = ttab.newg[ind];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    font = null;\n\n    for(let ci=0; ci<gls.length; ci++) {\n        gl = gls[ci];\n\n        if (font != gfonts[ci]) {\n            font = fonts[gfonts[ci]];\n            gsub = font['GSUB'];\n        }\n\n        if(!gsub) {\n            continue;\n        }\n\n        gsubTable = font.gsubRligLigaTable;\n\n        if (gsubTable) {\n            let rlim = Math.min(3, gls.length-ci-1);\n\n            for(ti = 0; ti < gsubTable.length; ti++) {\n                let tab = gsubTable[ti];\n\n                for(j = 0; j < tab.length; j++) {\n                    let ttab = tab[j];\n                    let ind = Typr._lctf.coverageIndex(ttab.coverage, gl);\n                    if(ind==-1) continue;\n\n                    let vals = ttab.vals[ind];\n\n                    for(k=0; k<vals.length; k++) {\n                        let lig = vals[k], rl = lig.chain.length;  if(rl>rlim) continue;\n                        let good = true;\n                        for(let l=0; l<rl; l++) if(lig.chain[l]!=gls[ci+(1+l)]) good=false;\n                        if(!good) continue;\n                        gls[ci]=lig.nglyph;\n                        for(let l=0; l<rl; l++) gls[ci+l+1]=-1;\n                        //console.log(\"lig\", fl.tag,  gl, lig.chain, lig.nglyph);\n                    }\n                }\n            }\n        }\n    }\n\n    const indices = bidiResult.indices;\n    const gls2 = gls.slice();\n    const codes2 = codes.slice();\n    const gfonts2 = gfonts.slice();\n\n    for (i = 0, li = gls.length; i < li; i++) {\n        c = indices[i];\n        gls2[i] = gls[c];\n        codes2[i] = codes[c];\n        gfonts2[i] = gfonts[c];\n    }\n\n    return [gls2, gfonts2, codes2];\n}\n\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/map/geodata-processor/worker-globals.js\":\n/*!**********************************************************!*\\\n  !*** ./src/core/map/geodata-processor/worker-globals.js ***!\n  \\**********************************************************/\n/*! exports provided: globals, clamp, vec3Normalize, vec3Length, vec3Cross, simpleFmtCall, getHash, stringToUint8Array, unint8ArrayToString, Utf8ArrayToStr */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"globals\", function() { return globals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clamp\", function() { return clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vec3Normalize\", function() { return vec3Normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vec3Length\", function() { return vec3Length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vec3Cross\", function() { return vec3Cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"simpleFmtCall\", function() { return simpleFmtCall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHash\", function() { return getHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringToUint8Array\", function() { return stringToUint8Array; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unint8ArrayToString\", function() { return unint8ArrayToString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utf8ArrayToStr\", function() { return Utf8ArrayToStr; });\n\nconst globals = {\n    stylesheetData : {},\n    stylesheetLayers : {},\n    stylesheetBitmaps : {},\n    stylesheetFonts : {},\n    stylesheetConstants : {},\n    stylesheetVariables : {},\n    insidePack : false,\n    directPoints : [],\n    directPoint : null,\n    fonts : {},\n    fontsMap : {},\n    fontsStorage : {},\n    forceOrigin : false,\n    forceScale : [1,1,1],\n    bboxMin : [0,0,0],\n    bboxMax : [1,1,1],\n    geocent : false,\n    tileX : 0,\n    tileY : 0,\n    tileLod : 0,\n    tileIX : 0,\n    tileIY : 0,\n    tileSize : 1,\n    hitState : 0,\n    pixelFactor : 1,\n    alwaysEventInfo : true,\n    metricUnits : true,\n    language : 'en',\n    groupOptimize : true,\n    groupOrigin : [0,0,0],\n    messageBuffer : new Array(65536),\n    messageBufferIndex : 0,\n    messageBufferSize : 65536,\n    messagePackSize : 0,\n    signatureCounter : 0,\n    autoLod : false,\n    featureType : null,\n    groupId : null,\n    disableLog : false,\n    reduceMode : 'scr-count4',\n    reduceParams : null,\n    processLineLabel : false,\n    useLineLabel2 : true,\n    lineLabelPass : 0\n};\n\n\nfunction clamp(value, min, max) {\n    if (value < min) {\n        value = min;\n    }\n\n    if (value > max) {\n        value = max;\n    }\n\n    return value;\n}\n\n\nfunction vec3Normalize(a, b) {\n    b || (b = a);\n    let c = a[0],\n        d = a[1],\n        e = a[2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n    return b;\n}\n\n\nfunction vec3Length(a) {\n    let b = a[0],\n        c = a[1];\n    a = a[2];\n    return Math.sqrt(b * b + c * c + a * a);\n}\n\n\nfunction vec3Cross(a, b, c) {\n    c || (c = a);\n    let d = a[0],\n        e = a[1];\n    a = a[2];\n    let g = b[0],\n        f = b[1];\n    b = b[2];\n    c[0] = e * b - a * f;\n    c[1] = a * g - d * b;\n    c[2] = d * f - e * g;\n    return c;\n}\n\n\nfunction getHash(str) {\n    if (!str || str.length === 0) {\n        return 0;\n    }\n\n    let hash = 0, c;\n    for (let i = 0, li = str.length; i < li; i++) {\n        c   = str.charCodeAt(i);\n        hash  = ((hash << 5) - hash) + c;\n        hash |= 0; // Convert to 32bit integer\n    }\n\n    return hash;\n}\n\n\nfunction simpleFmtCall(str, call) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    let i = str.indexOf('{'), li, str2;\n\n    if (i == -1) {\n        return str;\n    } else {\n        str2 = i > 0 ? str.substring(0, i) : '';\n    }\n\n    let counter = 0;\n    let begin = -1;\n\n    for (li = str.length; i < li; i++) {\n        let c = str.charAt(i);\n\n        if (c == '{') {\n            if (counter == 0) {\n                begin = i;\n            }\n\n            counter++;\n        } else if (c == '}') {\n            counter--;\n\n            if (counter == 0) {\n                str2 += call(str.substring(begin+1, i));\n            }\n\n        } else if (counter == 0) {\n            str2 += c;\n        }\n    }\n\n    return str2;\n}\n\n/*\nfunction copyArrayToBuffer(view, index, array) {\n    for (let i = 0, li = array.length; i < li; i++) {\n        view.setFloat32(index, array[i]); index += 4;\n    }\n\n    return index;\n}\n\nfunction copyDynamicArrayToBuffer(view, index, array) {\n    if (array) {\n        view.setUint8(index, array.length); index += 1;\n\n        for (let i = 0, li = array.length; i < li; i++) {\n            view.setFloat32(index, array[i]); index += 4;\n        }\n    } else {\n        view.setUint8(index, 0); index += 1;\n    }\n\n    return index;\n}\n\nfunction copyDynamicArrayOfArraysToBuffer(view, index, array) {\n    if (array) {\n        view.setUint16(index, array.length); index += 2;\n\n        for (let i = 0, li = array.length; i < li; i++) {\n            const subarray = array[i];\n\n            for (let j = 0, lj = array.length; j < lj; j++) {\n                view.setUint16(index, subarray[j]); index += 2;\n            }\n        }\n    } else {\n        view.setUint16(index, 0); index += 2;\n    }\n\n    return index;\n}\n\nfunction getSizeOfArrayOfArrays(array) {\n    let size = 0;\n\n    for (let i = 0, li = array.length; i < li; i++) {\n        size += array[i].length;\n    }\n\n    return size;\n}\n*/\n\n//const textEncoderUtf8 = null; //(typeof TextEncoder !== 'undefined') ? (new TextEncoder('utf-8')) : null;\nconst textEncoderUtf8 = (typeof TextEncoder !== 'undefined') ? (new TextEncoder('utf-8')) : null;\n\nfunction stringToUint8Array(str) {\n    if (textEncoderUtf8) {\n        return textEncoderUtf8.encode(str);\n    } else {\n\n        /*\n        console.log('' + (str.length * 2));\n\n        const buffer = new ArrayBuffer(str.length * 2);\n        const view = new Uint16Array(buffer);\n        for (let i = 0, li = str.length; i < li; i++) {\n            view[i] = str.charCodeAt(i);\n        }\n        return new Uint8Array(buffer);\n        */\n\n\n        // 1. Let S be the DOMString value.\n        const s = String(str);\n\n        // 2. Let n be the length of S.\n        const n = s.length;\n\n        // 3. Initialize i to 0.\n        let i = 0;\n\n        // 4. Initialize U to be an empty sequence of Unicode characters.\n        const u = [];\n\n        // 5. While i < n:\n        while (i < n) {\n\n          // 1. Let c be the code unit in S at index i.\n          const c = s.charCodeAt(i);\n\n          // 2. Depending on the value of c:\n\n          // c < 0xD800 or c > 0xDFFF\n          if (c < 0xD800 || c > 0xDFFF) {\n            // Append to U the Unicode character with code point c.\n            u.push(c);\n          }\n\n          // 0xDC00 ≤ c ≤ 0xDFFF\n          else if (0xDC00 <= c && c <= 0xDFFF) {\n            // Append to U a U+FFFD REPLACEMENT CHARACTER.\n            u.push(0xFFFD);\n          }\n\n          // 0xD800 ≤ c ≤ 0xDBFF\n          else if (0xD800 <= c && c <= 0xDBFF) {\n            // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n            // CHARACTER.\n            if (i === n - 1) {\n              u.push(0xFFFD);\n            }\n            // 2. Otherwise, i < n−1:\n            else {\n              // 1. Let d be the code unit in S at index i+1.\n              const d = s.charCodeAt(i + 1);\n\n              // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n              if (0xDC00 <= d && d <= 0xDFFF) {\n                // 1. Let a be c & 0x3FF.\n                const a = c & 0x3FF;\n\n                // 2. Let b be d & 0x3FF.\n                const b = d & 0x3FF;\n\n                // 3. Append to U the Unicode character with code point\n                // 2^16+2^10*a+b.\n                u.push(0x10000 + (a << 10) + b);\n\n                // 4. Set i to i+1.\n                i += 1;\n              }\n\n              // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n              // U+FFFD REPLACEMENT CHARACTER.\n              else  {\n                u.push(0xFFFD);\n              }\n            }\n          }\n\n          // 3. Set i to i+1.\n          i += 1;\n        }\n\n        // 6. Return U.\n        return new Uint8Array((new Uint32Array(u)).buffer);\n    }\n}\n\n/*\nconst textDecoderUtf8 = TextEncoder ? (new TextDecoder('utf-8')) : null;\n\nfunction unint8ArrayToString(array) {\n    if (textDecoderUtf8) {\n        return textDecoderUtf8.decode(array);\n    } else {\n        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));\n    }\n}\n*/\n\n\nconst textDecoderUtf8 = (typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\n\nfunction unint8ArrayToString(array, skip) {\n    if (textDecoderUtf8 && !skip) {\n        return textDecoderUtf8.decode(array);\n    } else {\n        // return String.fromCharCode.apply(null, new Uint8Array(array.buffer)); //works only for small strings\n\n        let s = '';\n        //const code_points2 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        const code_points2 = new Uint8Array(array.byteLength);\n        code_points2.set(array);\n        const code_points = new Uint32Array(code_points2.buffer);\n\n        for (let i = 0, li = code_points.length; i < li; ++i) {\n          let cp = code_points[i];\n          if (cp <= 0xFFFF) {\n            s += String.fromCharCode(cp);\n          } else {\n            cp -= 0x10000;\n            s += String.fromCharCode((cp >> 10) + 0xD800,\n                                     (cp & 0x3FF) + 0xDC00);\n          }\n        }\n        return s;\n\n    }\n}\n\n\nfunction Utf8ArrayToStr(array, skip) {  //more universal\n    if (textDecoderUtf8 && !skip) {\n        return textDecoderUtf8.decode(array);\n    } else {\n\n        let out, i, len, c;\n        let char2, char3;\n\n        array = new Uint8Array(array);\n\n        out = \"\";\n        len = array.length;\n        i = 0;\n\n        while(i < len) {\n            c = array[i++];\n\n            switch(c >> 4) {\n              case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n                // 0xxxxxxx\n                out += String.fromCharCode(c);\n                break;\n              case 12: case 13:\n                // 110x xxxx   10xx xxxx\n                char2 = array[i++];\n                out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\n                break;\n              case 14:\n                // 1110 xxxx  10xx xxxx  10xx xxxx\n                char2 = array[i++];\n                char3 = array[i++];\n                out += String.fromCharCode(((c & 0x0F) << 12) |\n                               ((char2 & 0x3F) << 6) |\n                               ((char3 & 0x3F) << 0));\n                break;\n            }\n        }\n\n        return out;\n    }\n}\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/map/geodata-processor/worker-linestring.js\":\n/*!*************************************************************!*\\\n  !*** ./src/core/map/geodata-processor/worker-linestring.js ***!\n  \\*************************************************************/\n/*! exports provided: processLineStringPass, processLineLabel, processLineStringGeometry */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processLineStringPass\", function() { return processLineStringPass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processLineLabel\", function() { return processLineLabel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processLineStringGeometry\", function() { return processLineStringGeometry; });\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \"./src/core/map/geodata-processor/worker-globals.js\");\n/* harmony import */ var _worker_style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-style.js */ \"./src/core/map/geodata-processor/worker-style.js\");\n/* harmony import */ var _worker_text_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker-text.js */ \"./src/core/map/geodata-processor/worker-text.js\");\n/* harmony import */ var _worker_message_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./worker-message.js */ \"./src/core/map/geodata-processor/worker-message.js\");\n/* harmony import */ var _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./worker-pointarray.js */ \"./src/core/map/geodata-processor/worker-pointarray.js\");\n\n\n\n\n\n\n\n//get rid of compiler mess\nconst globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"globals\"], vec3Normalize = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3Normalize\"],\n      vec3Cross = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3Cross\"];\nconst getLayerPropertyValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\"getLayerPropertyValue\"],\n      getLayerExpresionValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\"getLayerExpresionValue\"], hasLayerProperty = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\"hasLayerProperty\"];\nconst addStreetTextOnPath = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"addStreetTextOnPath\"], areTextCharactersAvailable = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"areTextCharactersAvailable\"],\n      getCharVerticesCount = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"getCharVerticesCount\"], getFonts = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"getFonts\"], getFontsStorage = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"getFontsStorage\"];\nconst postGroupMessageFast = _worker_message_js__WEBPACK_IMPORTED_MODULE_3__[\"postGroupMessageFast\"], getTextGlyphs = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"getTextGlyphs\"];\nconst checkDPoints = _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__[\"checkDPoints\"];\n\n\n/*const getLineInfo = function(lineString, lod, style, featureIndex, zIndex, eventInfo) {\n};*/\n\nfunction processLineStringPass(lineString, lod, style, featureIndex, zIndex, eventInfo) {\n\n    checkDPoints(lineString);\n\n    const lines = lineString['lines'];\n\n    if (!lines || lines.length == 0) {\n        return;\n    }\n\n    const line = getLayerPropertyValue(style, 'line', lineString, lod);\n    const lineLabel = getLayerPropertyValue(style, 'line-label', lineString, lod);\n\n    if (!line && !lineLabel) {\n        return;\n    }\n\n    const hoverEvent = getLayerPropertyValue(style, 'hover-event', lineString, lod);\n    const clickEvent = getLayerPropertyValue(style, 'click-event', lineString, lod);\n    const drawEvent = getLayerPropertyValue(style, 'draw-event', lineString, lod);\n    const enterEvent = getLayerPropertyValue(style, 'enter-event', lineString, lod);\n    const leaveEvent = getLayerPropertyValue(style, 'leave-event', lineString, lod);\n    const advancedHit = getLayerPropertyValue(style, 'advanced-hit', lineString, lod);\n\n    const zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', lineString, lod);\n    let lineFlat;\n\n    // eslint-disable-next-line\n    if (hasLayerProperty(style,'line-type')) {\n\n    } else {\n        lineFlat = getLayerPropertyValue(style, 'line-flat', lineString, lod);\n    }\n\n    let lineWidth = 0.5 * getLayerPropertyValue(style, 'line-width', lineString, lod);\n    const lineColor = getLayerPropertyValue(style, 'line-color', lineString, lod);\n    const lineWidthUnits = getLayerPropertyValue(style, 'line-width-units', lineString, lod);\n\n    const lineStyle = getLayerPropertyValue(style, 'line-style', lineString, lod);\n    const lineStyleTexture = getLayerPropertyValue(style, 'line-style-texture', lineString, lod);\n    const lineStyleBackground = getLayerPropertyValue(style, 'line-style-background', lineString, lod);\n\n    const lineLabelSize = getLayerPropertyValue(style, 'line-label-size', lineString, lod);\n\n    const texturedLine = (lineStyle != 'solid');\n    const widthByRatio = (lineWidthUnits == 'ratio');\n\n    if (lineWidthUnits == 'points') {\n        lineWidth *= globals.pixelFactor / ((1 / 72) * (96));\n    }\n\n    let index = 0, index2 = 0, index3 = 0;\n    let skipJoins = false;\n\n    if (widthByRatio) {\n        skipJoins = (!lineFlat && ((lineWidth/* *globals.invPixelFactor*/)*1080) < 2.1);\n    } else {\n        skipJoins = (!lineFlat && (lineWidth/* *globals.invPixelFactor*/) < 2.1);\n    }\n\n    let ii, i, li, p2, v, vv, l, n, nn, p1, p, elementIndex, elementBase = 0;\n    let circleBuffer, circleBuffer2, circleSides;\n\n    if (!skipJoins) {\n        circleBuffer = [];\n        circleBuffer2 = [];\n        circleSides = 8;//Math.max(8, (14 - lod) * 8);\n\n        let angle = 0, step = (2.0*Math.PI) / circleSides;\n\n        for (i = 0; i < circleSides; i++) {\n            circleBuffer[i] = [-Math.sin(angle), Math.cos(angle)];\n            circleBuffer2[i] = angle;\n            angle += step;\n        }\n\n        circleBuffer[circleSides] = [0, 1.0];\n        circleBuffer2[circleSides] = 0;\n    }\n\n    let totalPoints = 0;\n\n    for (ii = 0; ii < lines.length; ii++) {\n        if (Array.isArray(lines[ii])) {\n            totalPoints += lines[ii].length;\n        }\n    }\n\n    if (totalPoints <= 1) {\n        return;\n    }\n\n    if (lineFlat) {\n        circleSides = 2;\n    }\n\n    //allocate buffers\n    const lineVertices = ((texturedLine || (widthByRatio)) || !lineFlat ? 4 : 3) * 3 * 2;\n    const joinVertices = skipJoins ? 0 : (circleSides * ((texturedLine || (widthByRatio)) || !lineFlat? 4 : 3) * 3);\n    const vertexBuffer = new Float32Array((totalPoints-1) * lineVertices + totalPoints * joinVertices);\n    let elementBuffer;\n\n    if (advancedHit) {\n        elementBuffer = new Float32Array((totalPoints-1) * (3 * 2) + totalPoints * (skipJoins ? 0 : circleSides) * 3);\n    }\n\n    let lineNormals, joinNormals, normalBuffer;\n\n    if (!(lineFlat && !texturedLine && !widthByRatio)) {\n        lineNormals = 3 * 4 * 2;\n        joinNormals = skipJoins ? 0 : (circleSides * 3 * 4);\n        normalBuffer = new Float32Array((totalPoints-1) * lineNormals + totalPoints * joinNormals);\n    }\n\n    let center = [0,0,0];\n    let lineLabelStack = [];\n    const forceOrigin = globals.forceOrigin;\n    const bboxMin = globals.bboxMin;\n    const geocent = globals.geocent;\n    const tileX = globals.tileX;\n    const tileY = globals.tileY;\n    const forceScale = globals.forceScale;\n    let vstart = [1,0,0], vend = [-1,0,0];\n    let lineLabelPoints, lineLabelPoints2;\n\n    for (ii = 0; ii < lines.length; ii++) {\n        if (!Array.isArray(lines[ii]) || !lines[ii].length) {\n            continue;\n        }\n\n        const points = lines[ii];\n\n        if (lineLabel) {\n            lineLabelPoints = new Array(points.length);\n            lineLabelPoints2 = new Array(points.length);\n\n            lineLabelStack.push({points: lineLabelPoints, points2 :lineLabelPoints2});\n        }\n\n        p = points[0];\n        p1 = [p[0], p[1], p[2]];\n\n        if (forceOrigin) {\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n        }\n\n        if (forceScale != null) {\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n        }\n\n        let distance = 0.001;\n        let distance2 = 0.001;\n        /*let ln = null;*/\n        let vertexBase = index;\n        let normalBase = index2;\n\n        //add lines\n        for (i = 0, li = points.length - 1; i < li; i++) {\n\n            p1 = points[i];\n            p2 = points[i+1];\n\n            if (forceOrigin) {\n                p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n                p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n            }\n\n            if (forceScale != null) {\n                p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n                p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n            }\n\n            if (advancedHit) {\n                elementIndex = elementBase + i;\n\n                elementBuffer[index3] = elementIndex;\n                elementBuffer[index3+1] = elementIndex;\n                elementBuffer[index3+2] = elementIndex;\n\n                //add polygon\n                elementBuffer[index3+3] = elementIndex;\n                elementBuffer[index3+4] = elementIndex;\n                elementBuffer[index3+5] = elementIndex;\n\n                index3 += 6;\n            }\n\n            if (lineFlat && !texturedLine && !widthByRatio) {\n\n                //normalize vector to line width and rotate 90 degrees\n                if (geocent) {\n                    //direction vector\n                    v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n                    //get line length\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n                    distance2 += l;\n\n                    l = (l != 0) ? (1 / l) : 0;\n\n                    vv = [v[0]*l, v[1]*l, v[2]*l];\n                    n = [0,0,0];\n                    nn = [0,0,0];\n\n                    vec3Normalize(bboxMin, nn);\n                    vec3Cross(nn, vv, n);\n\n                    if (i == 0) {\n                        vstart = vv;\n                    }\n\n                    if (i == (li - 1)) {\n                        vend = vv;\n                    }\n\n                    n = [n[0] * lineWidth, n[1] * lineWidth, n[2] * lineWidth];\n                } else {\n                    //direction vector\n                    v = [p2[0] - p1[0], p2[1] - p1[1], 0];\n\n                    //get line length\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\n                    distance2 += l;\n\n                    l = (l != 0) ? (lineWidth / l) : 0;\n\n                    n = [-v[1]*l, v[0]*l, 0];\n\n                    if (i == 0) {\n                        vstart = [v[0]*l, v[1]*l, 0];\n                    }\n\n                    if (i == (li - 1)) {\n                        vend = [v[0]*l, v[1]*l, 0];\n                    }\n                }\n\n                //add polygon\n                vertexBuffer[index] = p1[0] + n[0];\n                vertexBuffer[index+1] = p1[1] + n[1];\n                vertexBuffer[index+2] = p1[2] + n[2];\n\n                vertexBuffer[index+3] = p1[0] - n[0];\n                vertexBuffer[index+4] = p1[1] - n[1];\n                vertexBuffer[index+5] = p1[2] - n[2];\n\n                vertexBuffer[index+6] = p2[0] + n[0];\n                vertexBuffer[index+7] = p2[1] + n[1];\n                vertexBuffer[index+8] = p2[2] + n[2];\n\n                //add polygon\n                vertexBuffer[index+9] = p1[0] - n[0];\n                vertexBuffer[index+10] = p1[1] - n[1];\n                vertexBuffer[index+11] = p1[2] - n[2];\n\n                vertexBuffer[index+12] = p2[0] - n[0];\n                vertexBuffer[index+13] = p2[1] - n[1];\n                vertexBuffer[index+14] = p2[2] - n[2];\n\n                vertexBuffer[index+15] = p2[0] + n[0];\n                vertexBuffer[index+16] = p2[1] + n[1];\n                vertexBuffer[index+17] = p2[2] + n[2];\n\n                index += 18;\n\n            } else {\n\n\n                //console.log(\"distance(\"+i+\"): \" + distance + \" \" + distance2);\n\n                if (lineFlat) {\n\n                    /*\n                    //normalize vector to line width and rotate 90 degrees\n                    l = (l != 0) ? (lineWidth / l) : 0;\n                    n = [-v[1]*l, v[0]*l,0];\n\n                    if (joinParams != null) {\n                        joinParams[i] = (l != 0) ? Math.atan2(v[0], v[1]) + Math.PI *0.5 : 0;\n                    }*/\n\n                    //normalize vector to line width and rotate 90 degrees\n                    if (geocent) {\n                        //direction vector\n                        v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n                        //get line length\n                        l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n                        distance2 += l;\n\n                        l = (l != 0) ? (1 / l) : 0;\n\n                        vv = [v[0]*l, v[1]*l, v[2]*l];\n                        n = [0,0,0];\n                        nn = [0,0,0];\n\n                        if (i == 0) {\n                            vstart = vv;\n                        }\n\n                        if (i == (li - 1)) {\n                            vend = vv;\n                        }\n\n                        vec3Normalize(bboxMin, nn);\n                        vec3Cross(nn, vv, n);\n\n                        //n = [n[0] * lineWidth, n[1] * lineWidth, n[2] * lineWidth];\n                        n = [n[0], n[1], n[2]];\n                    } else {\n                        //direction vector\n                        v = [p2[0] - p1[0], p2[1] - p1[1], 0];\n\n                        //get line length\n                        l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\n                        distance2 += l;\n\n                        l = (l != 0) ? (lineWidth / l) : 0;\n\n                        n = [-v[1], v[0], 0];\n\n                        if (i == 0) {\n                            vstart = [v[0]*l, v[1]*l, 0];\n                        }\n\n                        if (i == (li - 1)) {\n                            vend = [v[0]*l, v[1]*l, 0];\n                        }\n                    }\n\n                    //add polygon\n                    vertexBuffer[index] = p1[0];\n                    vertexBuffer[index+1] = p1[1];\n                    vertexBuffer[index+2] = p1[2];\n                    vertexBuffer[index+3] = distance;\n                    normalBuffer[index2] = n[0];\n                    normalBuffer[index2+1] = n[1];\n                    normalBuffer[index2+2] = n[2];\n                    normalBuffer[index2+3] = lineWidth;\n\n                    vertexBuffer[index+4] = p1[0];\n                    vertexBuffer[index+5] = p1[1];\n                    vertexBuffer[index+6] = p1[2];\n                    vertexBuffer[index+7] = -distance;\n                    normalBuffer[index2+4] = -n[0];\n                    normalBuffer[index2+5] = -n[1];\n                    normalBuffer[index2+6] = -n[2];\n                    normalBuffer[index2+7] = lineWidth;\n\n                    vertexBuffer[index+8] = p2[0];\n                    vertexBuffer[index+9] = p2[1];\n                    vertexBuffer[index+10] = p2[2];\n                    vertexBuffer[index+11] = distance2;\n                    normalBuffer[index2+8] = n[0];\n                    normalBuffer[index2+9] = n[1];\n                    normalBuffer[index2+10] = n[2];\n                    normalBuffer[index2+11] = lineWidth;\n\n                    //add polygon\n                    vertexBuffer[index+12] = p1[0];\n                    vertexBuffer[index+13] = p1[1];\n                    vertexBuffer[index+14] = p1[2];\n                    vertexBuffer[index+15] = -distance;\n                    normalBuffer[index2+12] = -n[0];\n                    normalBuffer[index2+13] = -n[1];\n                    normalBuffer[index2+14] = -n[2];\n                    normalBuffer[index2+15] = lineWidth;\n\n                    vertexBuffer[index+16] = p2[0];\n                    vertexBuffer[index+17] = p2[1];\n                    vertexBuffer[index+18] = p2[2];\n                    vertexBuffer[index+19] = -distance2;\n                    normalBuffer[index2+16] = -n[0];\n                    normalBuffer[index2+17] = -n[1];\n                    normalBuffer[index2+18] = -n[2];\n                    normalBuffer[index2+19] = lineWidth;\n\n                    vertexBuffer[index+20] = p2[0];\n                    vertexBuffer[index+21] = p2[1];\n                    vertexBuffer[index+22] = p2[2];\n                    vertexBuffer[index+23] = distance2;\n                    normalBuffer[index2+20] = n[0];\n                    normalBuffer[index2+21] = n[1];\n                    normalBuffer[index2+22] = n[2];\n                    normalBuffer[index2+23] = lineWidth;\n\n                    index += 24;\n                    index2 += 24;\n\n                } else {\n\n                    //direction vector\n                    v = [p2[0] - p1[0], p2[1] - p1[1], 0];\n\n                    //get line length\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\n                    distance2 += l;\n\n                    //add polygon\n                    vertexBuffer[index] = p1[0];\n                    vertexBuffer[index+1] = p1[1];\n                    vertexBuffer[index+2] = p1[2];\n                    vertexBuffer[index+3] = distance;\n                    normalBuffer[index2] = p2[0];\n                    normalBuffer[index2+1] = p2[1];\n                    normalBuffer[index2+2] = p2[2];\n                    normalBuffer[index2+3] = lineWidth;\n\n                    vertexBuffer[index+4] = p1[0];\n                    vertexBuffer[index+5] = p1[1];\n                    vertexBuffer[index+6] = p1[2];\n                    vertexBuffer[index+7] = -distance;\n                    normalBuffer[index2+4] = p2[0];\n                    normalBuffer[index2+5] = p2[1];\n                    normalBuffer[index2+6] = p2[2];\n                    normalBuffer[index2+7] = -lineWidth;\n\n                    vertexBuffer[index+8] = p2[0];\n                    vertexBuffer[index+9] = p2[1];\n                    vertexBuffer[index+10] = p2[2];\n                    vertexBuffer[index+11] = -distance2;\n                    normalBuffer[index2+8] = p1[0];\n                    normalBuffer[index2+9] = p1[1];\n                    normalBuffer[index2+10] = p1[2];\n                    normalBuffer[index2+11] = lineWidth;\n\n                    //add polygon\n                    vertexBuffer[index+12] = p1[0];\n                    vertexBuffer[index+13] = p1[1];\n                    vertexBuffer[index+14] = p1[2];\n                    vertexBuffer[index+15] = distance;\n                    normalBuffer[index2+12] = p2[0];\n                    normalBuffer[index2+13] = p2[1];\n                    normalBuffer[index2+14] = p2[2];\n                    normalBuffer[index2+15] = lineWidth;\n\n                    vertexBuffer[index+16] = p2[0];\n                    vertexBuffer[index+17] = p2[1];\n                    vertexBuffer[index+18] = p2[2];\n                    vertexBuffer[index+19] = -distance2;\n                    normalBuffer[index2+16] = p1[0];\n                    normalBuffer[index2+17] = p1[1];\n                    normalBuffer[index2+18] = p1[2];\n                    normalBuffer[index2+19] = lineWidth;\n\n                    vertexBuffer[index+20] = p2[0];\n                    vertexBuffer[index+21] = p2[1];\n                    vertexBuffer[index+22] = p2[2];\n                    vertexBuffer[index+23] = distance2;\n                    normalBuffer[index2+20] = p1[0];\n                    normalBuffer[index2+21] = p1[1];\n                    normalBuffer[index2+22] = p1[2];\n                    normalBuffer[index2+23] = -lineWidth;\n\n                    index += 24;\n                    index2 += 24;\n                }\n            }\n\n            distance = distance2;\n            p1 = p2; //only for dlines\n        }\n\n        p1 = [p[0], p[1], p[2]];\n\n        //add joins\n        for (i = 0, li = points.length; i < li; i++) {\n\n            if (forceOrigin) {\n                p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n            }\n\n            if (forceScale != null) {\n                p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n            }\n\n            center[0] += p1[0];\n            center[1] += p1[1];\n            center[2] += p1[2];\n\n            if (!skipJoins) {\n                let angleShift = 0;//(joinParams != null) ? joinParams[i] : 0;\n                /*let dx, dy;*/\n\n                if (lineFlat) {\n\n                    if (advancedHit) {\n                        elementIndex = elementBase + ((i != (li-1)) ? i : (i -1));\n\n                        elementBuffer[index3] = elementIndex;\n                        elementBuffer[index3+1] = elementIndex;\n                        elementBuffer[index3+2] = elementIndex;\n\n                        //add polygon\n                        elementBuffer[index3+3] = elementIndex;\n                        elementBuffer[index3+4] = elementIndex;\n                        elementBuffer[index3+5] = elementIndex;\n\n                        index3 += 6;\n                    }\n\n                    let lineIndex, lineIndex2;\n\n                    if (!(texturedLine || widthByRatio)) {\n\n                        if (i != (li-1)) {\n                            lineIndex = vertexBase + i * lineVertices;\n                        } else {\n                            lineIndex = vertexBase + (i - 1) * lineVertices;\n                        }\n\n                        if (i > 0) {\n                            lineIndex2 = vertexBase + (i - 1) * lineVertices;\n                        } else {\n                            lineIndex2 = vertexBase + lineIndex;\n                        }\n\n                        if (i == 0) { //start cap\n                            //add polygon\n                            vertexBuffer[index] = p1[0];\n                            vertexBuffer[index+1] = p1[1];\n                            vertexBuffer[index+2] = p1[2];\n\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex];\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+1];\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+2];\n\n                            vertexBuffer[index+6] = p1[0] - vstart[0] * lineWidth;\n                            vertexBuffer[index+7] = p1[1] - vstart[1] * lineWidth;\n                            vertexBuffer[index+8] = p1[2] - vstart[2] * lineWidth;\n\n                            //add polygon\n                            vertexBuffer[index+9] = p1[0];\n                            vertexBuffer[index+9+1] = p1[1];\n                            vertexBuffer[index+9+2] = p1[2];\n\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+3];\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+4];\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+5];\n\n                            vertexBuffer[index+9+6] = p1[0] - vstart[0] * lineWidth;\n                            vertexBuffer[index+9+7] = p1[1] - vstart[1] * lineWidth;\n                            vertexBuffer[index+9+8] = p1[2] - vstart[2] * lineWidth;\n                        } else if (i == (li - 1)) {  //end cap\n                            //add polygon\n                            vertexBuffer[index] = p1[0];\n                            vertexBuffer[index+1] = p1[1];\n                            vertexBuffer[index+2] = p1[2];\n\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex+15];\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+16];\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+17];\n\n                            vertexBuffer[index+6] = p1[0] + vend[0] * lineWidth;\n                            vertexBuffer[index+7] = p1[1] + vend[1] * lineWidth;\n                            vertexBuffer[index+8] = p1[2] + vend[2] * lineWidth;\n\n                            //add polygon\n                            vertexBuffer[index+9] = p1[0];\n                            vertexBuffer[index+9+1] = p1[1];\n                            vertexBuffer[index+9+2] = p1[2];\n\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+12];\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+13];\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+14];\n\n                            vertexBuffer[index+9+6] = p1[0] + vend[0] * lineWidth;\n                            vertexBuffer[index+9+7] = p1[1] + vend[1] * lineWidth;\n                            vertexBuffer[index+9+8] = p1[2] + vend[2] * lineWidth;\n                        } else {\n                            //add polygon\n                            vertexBuffer[index] = p1[0];\n                            vertexBuffer[index+1] = p1[1];\n                            vertexBuffer[index+2] = p1[2];\n\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex];\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+1];\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+2];\n\n                            vertexBuffer[index+6] = vertexBuffer[lineIndex2 + 15];\n                            vertexBuffer[index+7] = vertexBuffer[lineIndex2 + 16];\n                            vertexBuffer[index+8] = vertexBuffer[lineIndex2 + 17];\n\n                            //add polygon\n                            vertexBuffer[index+9] = p1[0];\n                            vertexBuffer[index+9+1] = p1[1];\n                            vertexBuffer[index+9+2] = p1[2];\n\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+3];\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+4];\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+5];\n\n                            vertexBuffer[index+9+6] = vertexBuffer[lineIndex2 + 12];\n                            vertexBuffer[index+9+7] = vertexBuffer[lineIndex2 + 13];\n                            vertexBuffer[index+9+8] = vertexBuffer[lineIndex2 + 14];\n                        }\n\n                        index += 18;\n\n                    } else {\n\n                        if (i != (li-1)) {\n                            distance = vertexBuffer[i * lineVertices + 3];\n                        } else {\n                            distance = vertexBuffer[(i - 1) * lineVertices + 11];\n                        }\n\n                        if (i != (li-1)) {\n                            lineIndex = normalBase + i * lineVertices;\n                        } else {\n                            lineIndex = normalBase + (i - 1) * lineVertices + 8;\n                        }\n\n                        if (i > 0) {\n                            lineIndex2 = normalBase + (i - 1) * lineVertices + 8;\n                        } else {\n                            lineIndex2 = normalBase + lineIndex;\n                        }\n\n                        //add polygon\n                        vertexBuffer[index] = p1[0];\n                        vertexBuffer[index+1] = p1[1];\n                        vertexBuffer[index+2] = p1[2];\n                        vertexBuffer[index+3] = distance;\n\n                        vertexBuffer[index+4] = p1[0];\n                        vertexBuffer[index+5] = p1[1];\n                        vertexBuffer[index+6] = p1[2];\n                        vertexBuffer[index+7] = distance;\n\n                        vertexBuffer[index+8] = p1[0];\n                        vertexBuffer[index+9] = p1[1];\n                        vertexBuffer[index+10] = p1[2];\n                        vertexBuffer[index+11] = distance;\n\n                        //add polygon\n                        vertexBuffer[index+12] = p1[0];\n                        vertexBuffer[index+1+12] = p1[1];\n                        vertexBuffer[index+2+12] = p1[2];\n                        vertexBuffer[index+3+12] = distance;\n\n                        vertexBuffer[index+4+12] = p1[0];\n                        vertexBuffer[index+5+12] = p1[1];\n                        vertexBuffer[index+6+12] = p1[2];\n                        vertexBuffer[index+7+12] = -distance;\n\n                        vertexBuffer[index+8+12] = p1[0];\n                        vertexBuffer[index+9+12] = p1[1];\n                        vertexBuffer[index+10+12] = p1[2];\n                        vertexBuffer[index+11+12] = -distance;\n\n                        if (i == 0) { //start cap\n                            //first polygon\n                            normalBuffer[index2] = 0;\n                            normalBuffer[index2+1] = 0;\n                            normalBuffer[index2+2] = 0;\n                            normalBuffer[index2+3] = -lineWidth;\n\n                            normalBuffer[index2+4] = normalBuffer[lineIndex];\n                            normalBuffer[index2+5] = normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6] = normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7] = lineWidth;\n\n                            normalBuffer[index2+8] = -vstart[0];\n                            normalBuffer[index2+9] = -vstart[1];\n                            normalBuffer[index2+10] = -vstart[2];\n                            normalBuffer[index2+11] = -lineWidth;\n\n                            //second polygon\n                            normalBuffer[index2+12] = 0;\n                            normalBuffer[index2+1+12] = 0;\n                            normalBuffer[index2+2+12] = 0;\n                            normalBuffer[index2+3+12] = -lineWidth;\n\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex];\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7+12] = lineWidth;\n\n                            normalBuffer[index2+8+12] = -vstart[0];\n                            normalBuffer[index2+9+12] = -vstart[1];\n                            normalBuffer[index2+10+12] = -vstart[2];\n                            normalBuffer[index2+11+12] = -lineWidth;\n                        } else if (i == (li - 1)) {  //end cap\n                            //first polygon\n                            normalBuffer[index2] = 0;\n                            normalBuffer[index2+1] = 0;\n                            normalBuffer[index2+2] = 0;\n                            normalBuffer[index2+3] = -lineWidth;\n\n                            normalBuffer[index2+4] = normalBuffer[lineIndex2];\n                            normalBuffer[index2+5] = normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+6] = normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+7] = lineWidth;\n\n                            normalBuffer[index2+8] = vend[0];\n                            normalBuffer[index2+9] = vend[1];\n                            normalBuffer[index2+10] = vend[2];\n                            normalBuffer[index2+11] = -lineWidth;\n\n                            //second polygon\n                            normalBuffer[index2+12] = 0;\n                            normalBuffer[index2+1+12] = 0;\n                            normalBuffer[index2+2+12] = 0;\n                            normalBuffer[index2+3+12] = -lineWidth;\n\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex2];\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+7+12] = lineWidth;\n\n                            normalBuffer[index2+8+12] = vend[0];\n                            normalBuffer[index2+9+12] = vend[1];\n                            normalBuffer[index2+10+12] = vend[2];\n                            normalBuffer[index2+11+12] = -lineWidth;\n                        } else {\n                            normalBuffer[index2] = 0;\n                            normalBuffer[index2+1] = 0;\n                            normalBuffer[index2+2] = 0;\n                            normalBuffer[index2+3] = -lineWidth;\n\n                            normalBuffer[index2+4] = normalBuffer[lineIndex];\n                            normalBuffer[index2+5] = normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6] = normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7] = lineWidth;\n\n                            normalBuffer[index2+8] = normalBuffer[lineIndex2];\n                            normalBuffer[index2+9] = normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+10] = normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+11] = lineWidth;\n\n                            //add polygon\n                            normalBuffer[index2+12] = 0;\n                            normalBuffer[index2+1+12] = 0;\n                            normalBuffer[index2+2+12] = 0;\n                            normalBuffer[index2+3+12] = -lineWidth;\n\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex];\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7+12] = lineWidth;\n\n                            normalBuffer[index2+8+12] = -normalBuffer[lineIndex2];\n                            normalBuffer[index2+9+12] = -normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+10+12] = -normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+11+12] = lineWidth;\n                        }\n\n                        index += 24;\n                        index2 += 24;\n\n                    }\n\n                } else {\n\n                    const segmentIndex = (i != (li-1)) ? i : (i - 1);\n\n                    for (let j = 0; j < circleSides; j++) {\n\n                        if (advancedHit) {\n                            elementIndex = elementBase + segmentIndex;\n                            elementBuffer[index3] = elementIndex;\n                            elementBuffer[index3+1] = elementIndex;\n                            elementBuffer[index3+2] = elementIndex;\n                            index3 += 3;\n                        }\n\n                        distance = vertexBuffer[segmentIndex * lineVertices + 3];\n\n                        //add polygon\n                        vertexBuffer[index] = p1[0];\n                        vertexBuffer[index+1] = p1[1];\n                        vertexBuffer[index+2] = p1[2];\n                        vertexBuffer[index+3] = distance;\n                        normalBuffer[index2] = 0;\n                        normalBuffer[index2+1] = 0;\n                        normalBuffer[index2+2] = 0;\n                        normalBuffer[index2+3] = 0;\n\n                        vertexBuffer[index+4] = p1[0];\n                        vertexBuffer[index+5] = p1[1];\n                        vertexBuffer[index+6] = p1[2];\n                        vertexBuffer[index+7] = distance;\n                        normalBuffer[index2+4] = circleBuffer[j][0] * lineWidth;\n                        normalBuffer[index2+5] = circleBuffer[j][1] * lineWidth;\n                        normalBuffer[index2+6] = circleBuffer2[j] + angleShift;\n                        normalBuffer[index2+7] = 0;\n\n                        vertexBuffer[index+8] = p1[0];\n                        vertexBuffer[index+9] = p1[1];\n                        vertexBuffer[index+10] = p1[2];\n                        vertexBuffer[index+11] = distance;\n                        normalBuffer[index2+8] = circleBuffer[j+1][0] * lineWidth;\n                        normalBuffer[index2+9] = circleBuffer[j+1][1] * lineWidth;\n                        normalBuffer[index2+10] = circleBuffer2[j+1] + angleShift;\n                        normalBuffer[index2+11] = 0;\n\n                        index += 12;\n                        index2 += 12;\n                    }\n                }\n            }\n\n            if (lineLabel) {\n                p = [p1[0], p1[1], p1[2] + lineLabelSize*0.1];\n                lineLabelPoints[i] = p;\n                lineLabelPoints2[li - i - 1] = p;\n            }\n\n            if ((i + 1) < li) {\n                p1 = points[i+1];\n            }\n        }\n\n        elementBase += points.length;\n    }\n\n    if (totalPoints > 0) {\n        center[0] /= totalPoints;\n        center[1] /= totalPoints;\n        center[2] /= totalPoints;\n    }\n\n    center[0] += globals.groupOrigin[0];\n    center[1] += globals.groupOrigin[1];\n    center[2] += globals.groupOrigin[2];\n\n    const hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\n    let type;\n\n    if (line) {\n        //console.log('totalPoints:' + totalPoints + ' vbuff-l:' + (vertexBuffer ? vertexBuffer.length : '??'));\n\n        const messageData = {\n            'color':lineColor, 'z-index':zIndex, 'center': center, 'advancedHit': advancedHit, 'totalPoints': totalPoints,\n            'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'width-units': lineWidthUnits,\n            'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n            'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\n            'line-width':lineWidth*2, 'lod':(globals.autoLod ? null : globals.tileLod) };\n\n        if (lineFlat) {\n            type = texturedLine ? 8 : (widthByRatio ? 7 : 6);\n        } else {\n            type = texturedLine ? 10 : 9;\n        }\n\n        if (texturedLine) {\n            if (lineStyleTexture != null) {\n                messageData['texture'] = [globals.stylesheetBitmaps[lineStyleTexture[0]], lineStyleTexture[1], lineStyleTexture[2]];\n                messageData['background'] = lineStyleBackground;\n            }\n        }\n\n        const signature = JSON.stringify({\n            type: 'T'+type,\n            color : lineColor,\n            zIndex : zIndex,\n            zOffset : zbufferOffset,\n            state : globals.hitState\n        });\n\n        const buffers = (normalBuffer) ? [vertexBuffer, normalBuffer] : [vertexBuffer];\n\n        if (advancedHit) {\n            buffers.push(elementBuffer);\n        }\n\n        postGroupMessageFast(5, type, messageData, buffers, signature);\n    }\n\n    if (lineLabel) {\n        for (i = 0, li = lineLabelStack.length; i < li; i++) {\n            processLineLabel(lineLabelStack[i].points, lineLabelStack[i].points2, lineString, center, lod, style, featureIndex, zIndex, eventInfo);\n        }\n    }\n\n}\n\nfunction processLineLabel(lineLabelPoints, lineLabelPoints2, lineString, center, lod, style, featureIndex, zIndex, eventInfo) {\n    const labelType = getLayerPropertyValue(style, 'line-label-type', lineString, lod);\n    const labelColor = getLayerPropertyValue(style, 'line-label-color', lineString, lod);\n    const labelColor2 = getLayerPropertyValue(style, 'line-label-color2', lineString, lod);\n    const labelOutline = getLayerPropertyValue(style, 'line-label-outline', lineString, lod);\n    const labelSource = getLayerPropertyValue(style, 'line-label-source', lineString, lod);\n    const labelSpacing = getLayerPropertyValue(style, 'line-label-spacing', lineString, lod);\n    //const labelLineHeight = getLayerPropertyValue(style, 'line-label-line-height', lineString, lod);\n    const labelOffset = getLayerPropertyValue(style, 'line-label-offset', lineString, lod);\n    const labelReduce =  getLayerPropertyValue(style, 'dynamic-reduce', lineString, lod);\n    const labelOverlap = getLayerPropertyValue(style, 'line-label-no-overlap', lineString, lod);\n    const labelOverlapFactor = getLayerPropertyValue(style, 'line-label-no-overlap-factor', lineString, lod);\n    const labelOverlapMargin = getLayerPropertyValue(style, 'line-label-no-overlap-margin', lineString, lod);\n    let labelSize = getLayerPropertyValue(style, 'line-label-size', lineString, lod);\n\n    if (Math.abs(labelSize) < 0.0001) {\n        return;\n    }\n\n    let labelText = getLayerExpresionValue(style, labelSource, lineString, lod, labelSource);\n    labelText = labelText ? labelText.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n    const fontNames = getLayerPropertyValue(style, 'line-label-font', lineString, lod);\n    const fonts = getFonts(fontNames);\n    const fontsStorage = getFontsStorage(fontNames);\n    let glyphsRes = getTextGlyphs(labelText, fonts);\n\n    if (labelSource == '$name') {\n        if (!areTextCharactersAvailable(labelText, fonts, glyphsRes)) {\n            let labelText2 = getLayerExpresionValue(style, '$name:en', lineString, lod, labelSource);\n            labelText2 = labelText2 ? labelText2.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n            let glyphsRes2 = getTextGlyphs(labelText, fonts);\n\n            if (areTextCharactersAvailable(labelText2, fonts, glyphsRes2)) {\n                labelText = labelText2;\n                glyphsRes = glyphsRes2;\n            }\n        }\n    }\n\n    if (!labelText || labelText == '') {\n        return;\n    }\n\n    const hoverEvent = getLayerPropertyValue(style, 'hover-event', lineString, lod);\n    const clickEvent = getLayerPropertyValue(style, 'click-event', lineString, lod);\n    const drawEvent = getLayerPropertyValue(style, 'draw-event', lineString, lod);\n    const enterEvent = getLayerPropertyValue(style, 'enter-event', lineString, lod);\n    const leaveEvent = getLayerPropertyValue(style, 'leave-event', lineString, lod);\n    const advancedHit = getLayerPropertyValue(style, 'advanced-hit', lineString, lod);\n\n    const zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', lineString, lod);\n\n    let bufferSize, vertexBuffer, texcoordsBuffer, singleBuffer, singleBuffer2;\n\n    globals.useLineLabel2 = (labelType != 'flat');\n\n    if (globals.useLineLabel2) {\n        bufferSize = 12 * labelText.length;\n        singleBuffer = new Float32Array(bufferSize);\n        singleBuffer2 = new Float32Array(bufferSize);\n    } else {\n        bufferSize = getCharVerticesCount() * labelText.length * 2;\n        vertexBuffer = new Float32Array(bufferSize);\n        texcoordsBuffer = new Float32Array(bufferSize);\n    }\n\n    let planes = {};\n    const hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\n    const originalLabelSize = labelSize;\n\n    globals.lineLabelPass = 0;\n    globals.lineLabelPoints = [];\n    let index = addStreetTextOnPath(lineLabelPoints, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, planes, glyphsRes, singleBuffer);\n    let labelPoints = globals.lineLabelPoints;\n\n    globals.lineLabelPoints = [];\n    index = addStreetTextOnPath(lineLabelPoints2, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, globals.useLineLabel2 ? 0 : index, null, glyphsRes, singleBuffer2);\n    let labelPoints2 = globals.lineLabelPoints;\n\n    if (!index) {\n\n        //label is bigger than path\n        if (globals.useLineLabel2) {\n\n            // eslint-disable-next-line\n            while(true) {\n\n                //reduce size until is label smaler than path\n                labelSize *= 0.5;\n\n                globals.lineLabelPass = 0;\n                globals.lineLabelPoints = [];\n                index = addStreetTextOnPath(lineLabelPoints, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, planes, glyphsRes, singleBuffer);\n                labelPoints = globals.lineLabelPoints;\n\n                globals.lineLabelPoints = [];\n                index = addStreetTextOnPath(lineLabelPoints2, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, globals.useLineLabel2 ? 0 : index, null, glyphsRes, singleBuffer2);\n                labelPoints2 = globals.lineLabelPoints;\n\n                if (index || labelSize < 0.05) {\n                    break;\n                }\n            }\n        }\n\n        if (!index) {\n            return;\n        }\n    }\n\n    const visibility = getLayerPropertyValue(style, 'visibility-rel', lineString, lod) ||\n                     getLayerPropertyValue(style, 'visibility-abs', lineString, lod) ||\n                     getLayerPropertyValue(style, 'visibility', lineString, lod);\n    const culling = getLayerPropertyValue(style, 'culling', lineString, lod);\n    const hysteresis = getLayerPropertyValue(style, 'hysteresis', lineString, lod);\n\n\n    let bboxMin = globals.bboxMin, p, i, li, labelsPack = [], labelIndex = 0;\n    //let originalLabelOffset = labelOffset;\n\n    if (globals.useLineLabel2) {\n        for (i = 0, li = labelPoints.length; i < li; i++) {\n            p = labelPoints[i];\n            p[0] += bboxMin[0];\n            p[1] += bboxMin[1];\n            p[2] += bboxMin[2];\n            p = labelPoints2[i];\n            p[0] += bboxMin[0];\n            p[1] += bboxMin[1];\n            p[2] += bboxMin[2];\n        }\n\n        labelsPack.push([labelSize, globals.textVector, labelPoints, labelPoints2]);\n        globals.lineLabelPass = 1;\n\n        //bigger labels\n        // eslint-disable-next-line\n        while(true) {\n\n            labelSize *= 2;\n\n            globals.lineLabelPoints = [];\n            index = addStreetTextOnPath(lineLabelPoints, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, planes, glyphsRes, singleBuffer);\n            labelPoints = globals.lineLabelPoints;\n\n            if (!index) {\n                break;\n            }\n\n            globals.lineLabelPoints = [];\n            index = addStreetTextOnPath(lineLabelPoints2, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, globals.useLineLabel2 ? 0 : index, null, glyphsRes, singleBuffer2);\n            labelPoints2 = globals.lineLabelPoints;\n\n            for (i = 0, li = labelPoints.length; i < li; i++) {\n                p = labelPoints[i];\n                p[0] += bboxMin[0];\n                p[1] += bboxMin[1];\n                p[2] += bboxMin[2];\n                p = labelPoints2[i];\n                p[0] += bboxMin[0];\n                p[1] += bboxMin[1];\n                p[2] += bboxMin[2];\n            }\n\n            labelsPack.push([labelSize, globals.textVector, labelPoints, labelPoints2]);\n        }\n\n        labelSize = originalLabelSize;\n\n        //smaller labels\n        // eslint-disable-next-line\n        while(true) {\n\n            labelSize *= 0.5;\n\n            globals.lineLabelPoints = [];\n            index = addStreetTextOnPath(lineLabelPoints, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, planes, glyphsRes, singleBuffer);\n            labelPoints = globals.lineLabelPoints;\n\n            if (globals.textLength < 2) {\n                break;\n            }\n\n            globals.lineLabelPoints = [];\n            index = addStreetTextOnPath(lineLabelPoints2, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, null, glyphsRes, singleBuffer2);\n            labelPoints2 = globals.lineLabelPoints;\n\n            for (i = 0, li = labelPoints.length; i < li; i++) {\n                p = labelPoints[i];\n                p[0] += bboxMin[0];\n                p[1] += bboxMin[1];\n                p[2] += bboxMin[2];\n                p = labelPoints2[i];\n                p[0] += bboxMin[0];\n                p[1] += bboxMin[1];\n                p[2] += bboxMin[2];\n            }\n\n            labelsPack.unshift([labelSize, globals.textVector, labelPoints, labelPoints2]);\n            labelIndex++;\n        }\n\n        center = globals.textCenter;\n        center[0] += bboxMin[0];\n        center[1] += bboxMin[1];\n        center[2] += bboxMin[2];\n    }\n\n\n    //let fonts = labelData.fonts;\n    let labelFiles = new Array(fonts.length);\n\n    for (i = 0, li= fonts.length; i < li; i++) {\n        labelFiles[i] = [];\n    }\n\n    for (let key in planes) {\n        const fontIndex = parseInt(key);\n        const planes2 = planes[key];\n\n        const files = [];\n\n        for (let key2 in planes2) {\n            const plane = parseInt(key2) - (fontIndex*4000);\n            const file = Math.round((plane - (plane % 4)) / 4);\n\n            if (files.indexOf(file) == -1) {\n                files.push(file);\n            }\n        }\n\n        labelFiles[fontIndex] = files;\n    }\n\n    const signature = JSON.stringify({\n        type: 'line-label',\n        color : labelColor,\n        color2 : labelColor2,\n        outline : labelOutline,\n        fonts : fontNames,\n        zIndex : zIndex,\n        zOffset : zbufferOffset\n    });\n\n    let noOverlap;\n\n    if (labelOverlap) {\n        let factorType = null, factorValue = null;\n\n        if (labelOverlapFactor !== null) {\n            switch(labelOverlapFactor[0]) {\n                case 'direct':      factorType = 0;      break;\n                case 'div-by-dist': factorType = 1; break;\n            }\n\n            factorValue = labelOverlapFactor[1];\n        }\n\n        noOverlap = [labelOverlapMargin, factorType, factorValue];\n    }\n\n    postGroupMessageFast(5, globals.useLineLabel2 ? 12 : 11, {\n        'color':labelColor, 'color2':labelColor2, 'outline':labelOutline, 'textVector':globals.textVector, 'labelPoints': globals.useLineLabel2 ? labelsPack : [],\n        'visibility': visibility, 'culling': culling, 'hysteresis' : hysteresis, 'z-index':zIndex,\n        'center': center, 'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent,\n        'reduce':labelReduce, 'noOverlap': (labelOverlap ? noOverlap : null), 'files': labelFiles, 'enter-event':enterEvent,\n        'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'advancedHit': advancedHit, 'labelIndex': labelIndex, 'labelSize': originalLabelSize,\n        'fonts': fontsStorage, 'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n        'lod':(globals.autoLod ? null : globals.tileLod) }, globals.useLineLabel2 ? [singleBuffer, singleBuffer2] : [vertexBuffer, texcoordsBuffer], signature);\n}\n\n\nfunction processLineStringGeometry(lineString) {\n\n    checkDPoints(lineString);\n\n    const lines = lineString['lines'];\n\n    if (lines || lines.length == 0) {\n        return;\n    }\n\n    //debugger\n    let totalPoints = 0;\n    const indicesBuffer = new Uint32Array(lines.length);\n\n    for (let i = 0; i < lines.length; i++) {\n        indicesBuffer[i] = totalPoints;\n\n        if (Array.isArray(lines[i])) {\n            totalPoints += lines[i].length;\n        }\n    }\n\n    const geometryBuffer = new Float64Array(totalPoints * 3);\n\n    /*let forceOrigin = globals.forceOrigin;\n    let tileX = globals.tileX;\n    let tileY = globals.tileY;*/\n    const forceScale = globals.forceScale;\n    let index = 0, p1, pp, p;\n\n    for (let i = 0; i < lines.length; i++) {\n        if (!Array.isArray(lines[i]) || !lines[i].length) {\n            continue;\n        }\n\n        const points = lines[i];\n\n        p = points[0];\n        p1 = [p[0], p[1], p[2]];\n\n        //add lines\n        for (let j = 0, lj = points.length; j < lj; j++) {\n\n            /*if (forceOrigin) {\n                pp = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n            }*/\n\n            if (forceScale != null) {\n                pp = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n            }\n\n            geometryBuffer[index] = pp[0];\n            geometryBuffer[index+1] = pp[1];\n            geometryBuffer[index+2] = pp[2];\n            index += 3;\n\n            if (j == (lj - 1)) {\n                break;\n            }\n\n            p1 = points[j+1];\n        }\n    }\n\n    globals.signatureCounter++;\n\n    postGroupMessageFast(5, 14, {\n        'id':lineString['id'] }, [geometryBuffer, indicesBuffer], (\"\"+globals.signatureCounter));\n}\n\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/map/geodata-processor/worker-main.js\":\n/*!*******************************************************!*\\\n  !*** ./src/core/map/geodata-processor/worker-main.js ***!\n  \\*******************************************************/\n/*! no exports provided */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \"./src/core/map/geodata-processor/worker-globals.js\");\n/* harmony import */ var _worker_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-text.js */ \"./src/core/map/geodata-processor/worker-text.js\");\n/* harmony import */ var _worker_style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker-style.js */ \"./src/core/map/geodata-processor/worker-style.js\");\n/* harmony import */ var _worker_linestring_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./worker-linestring.js */ \"./src/core/map/geodata-processor/worker-linestring.js\");\n/* harmony import */ var _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./worker-pointarray.js */ \"./src/core/map/geodata-processor/worker-pointarray.js\");\n/* harmony import */ var _worker_polygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./worker-polygon.js */ \"./src/core/map/geodata-processor/worker-polygon.js\");\n/* harmony import */ var _worker_message_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./worker-message.js */ \"./src/core/map/geodata-processor/worker-message.js\");\n\n\n\n\n\n\n\n\n\n\n//get rid of compiler mess\nconst globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"globals\"];\nconst setFont = _worker_text_js__WEBPACK_IMPORTED_MODULE_1__[\"setFont\"];\nconst /*unint8ArrayToString = unint8ArrayToString_,*/ Utf8ArrayToStr = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"Utf8ArrayToStr\"];\nconst setFontMap = _worker_text_js__WEBPACK_IMPORTED_MODULE_1__[\"setFontMap\"], makeFasterFilter = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\"makeFasterFilter\"];\nconst getLayer = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\"getLayer\"], getLayerPropertyValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\"getLayerPropertyValue\"],\n      processStylesheet = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\"processStylesheet\"], getFilterResult = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\"getFilterResult\"];\nconst processLineStringPass = _worker_linestring_js__WEBPACK_IMPORTED_MODULE_3__[\"processLineStringPass\"];\nconst processPointArrayPass = _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__[\"processPointArrayPass\"];\nconst processPointArrayVSwitchPass = _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__[\"processPointArrayVSwitchPass\"];\nconst processPolygonPass = _worker_polygon_js__WEBPACK_IMPORTED_MODULE_5__[\"processPolygonPass\"];\nconst processLineStringGeometry = _worker_linestring_js__WEBPACK_IMPORTED_MODULE_3__[\"processLineStringGeometry\"];\nconst processPointArrayGeometry = _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__[\"processPointArrayGeometry\"],\n      postGroupMessageLite = _worker_message_js__WEBPACK_IMPORTED_MODULE_6__[\"postGroupMessageLite\"], optimizeGroupMessages = _worker_message_js__WEBPACK_IMPORTED_MODULE_6__[\"optimizeGroupMessages\"];\nconst postGroupMessageFast = _worker_message_js__WEBPACK_IMPORTED_MODULE_6__[\"postGroupMessageFast\"], postPackedMessage = _worker_message_js__WEBPACK_IMPORTED_MODULE_6__[\"postPackedMessage\"], postPackedMessages = _worker_message_js__WEBPACK_IMPORTED_MODULE_6__[\"postPackedMessages\"];\nconst getLayerPropertyValueInner = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\"getLayerPropertyValueInner\"];\n\nvar exportedGeometries = [];\nvar featureCache = new Array(1024), featureCacheIndex = 0, finalFeatureCache = new Array(1024), finalFeatureCacheIndex = 0, finalFeatureCacheIndex2 = 0;\n\nfunction processLayerFeaturePass(type, feature, lod, layer, featureIndex, zIndex, eventInfo) {\n\n    globals.stylesheetLocals = {};\n\n    switch(type) {\n    case 'line-string':\n        if (getLayerPropertyValue(layer, 'point', feature, lod) ||\n            getLayerPropertyValue(layer, 'label', feature, lod)) {\n            processPointArrayPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        }\n\n        processLineStringPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        break;\n\n    case 'point-array':\n        processPointArrayPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        break;\n\n    case 'polygon':\n        processPolygonPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        break;\n    }\n\n}\n\nfunction processFeatures(type, features, lod, featureType, group) {\n    const reduceParams = globals.reduceParams;\n\n    //loop layers\n    for (let key in globals.stylesheetLayers) {\n        const layer = globals.stylesheetLayers[key];\n\n        if (type == 'point-array') {\n            let importance = layer['importance-source'];\n            //\n\n            if ((typeof importance === 'undefined' || importance === null) && features[0] && features[0]['importance']) {\n                importance = '$importance';\n            }\n\n            if (!(typeof importance === 'undefined' || importance === null)) {\n                //importance = '$importance';\n                switch (globals.reduceMode) {\n                    case 'scr-count1':\n                    case 'scr-count2':\n                        layer['reduce'] = ['top',100,importance];\n                        layer['dynamic-reduce'] = ['scr-count2', reduceParams[0], reduceParams[1]];\n                        break;\n                    case 'scr-count4':\n                        layer['dynamic-reduce'] = ['scr-count4',importance];\n                        break;\n                    case 'scr-count5':\n                        layer['dynamic-reduce'] = ['scr-count5',importance];\n                        break;\n                    case 'scr-count6':\n                    case 'scr-count7':\n                    case 'scr-count8':\n                        {\n                            const ppi = globals.reduceMode == 'scr-count8' ? reduceParams[6] : reduceParams[5];\n                            layer['dynamic-reduce'] = [globals.reduceMode,importance, (typeof layer['importance-weight'] !== 'undefined') ? layer['importance-weight'] : 1 ];\n                            layer['label-no-overlap-margin'] = [reduceParams[0]*ppi, reduceParams[0]*ppi];\n                            layer['icon-no-overlap-margin'] = [reduceParams[0]*ppi, reduceParams[0]*ppi];\n                            layer['label-no-overlap-factor'] = [\"div-by-dist\",importance];\n                        }\n                        break;\n                }\n            }\n        }\n\n        let filter =  layer['filter'];\n        let reduce =  layer['reduce'], i, li, feature;\n\n        if (filter) {\n            filter = layer['#filter'];\n            if (!filter) {\n                layer['#filter'] = makeFasterFilter(layer['filter']);\n                filter = layer['#filter'];\n            }\n        }\n\n        featureCacheIndex = 0, finalFeatureCacheIndex = 0, finalFeatureCacheIndex2 = 0;\n\n        for (i = 0, li = features.length; i < li; i++) {\n            feature = features[i];\n            feature.properties = feature['properties'] || {};\n\n            if (feature['id']) {\n                feature.properties['#id'] = feature['id'];\n            }\n\n            if (!filter || getFilterResult(filter, feature, featureType, group, layer, 'filter', lod, 0, true)) {\n                if (reduce) {\n                    featureCache[featureCacheIndex] = feature;\n                    featureCacheIndex++;\n                } else {\n                    processLayerFeature(type, feature, lod, layer, i);\n                }\n            }\n        }\n\n        if (reduce) {\n\n            let count = reduce[1];\n            let property = reduce[2];\n\n            switch (reduce[0]) {\n                case 'top':\n                case 'bottom':\n\n                    if (typeof property === 'string' && property.charAt(0) == '@') {\n                        property = globals.stylesheetConstants[property];\n\n                        if (typeof property === 'undefined') {\n                            break;\n                        }\n                    }\n\n                    if ((typeof property === 'string' && property.charAt(0) == '$') || (typeof property === 'object')) {\n                        const complexProperty = (typeof property === 'object');\n\n                        if (!complexProperty) {\n                            property = property.substr(1);\n                        }\n\n                        if (count > featureCacheIndex) {\n                            count = featureCacheIndex;\n                        }\n\n                        let top = (reduce[0] == 'top'), value;\n                        let currentIndex = 0;\n                        let currentValue2 = top ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n                        do {\n                            let currentValue = top ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n                            finalFeatureCacheIndex2 = finalFeatureCacheIndex;\n\n                            for (i = 0, li = featureCacheIndex; i < li; i++) {\n                                feature = featureCache[i];\n\n                                if (!currentIndex) {\n                                    if (!complexProperty) {\n                                        value = parseFloat(feature.properties[property]);\n                                    } else {\n                                        value = getLayerPropertyValueInner(layer, null, feature, lod, property, 0);\n                                    }\n                                    feature.tmp = value;\n                                } else {\n                                    value = feature.tmp;\n                                }\n\n                                if (!isNaN(value) && ((top && value >= currentValue && value < currentValue2) || (value <= currentValue && value > currentValue2)) ) {\n                                    if (currentValue != value) {\n                                        finalFeatureCacheIndex = finalFeatureCacheIndex2;\n                                    }\n\n                                    finalFeatureCache[finalFeatureCacheIndex] = feature;\n                                    finalFeatureCacheIndex++;\n                                    currentValue = value;\n                                }\n                            }\n\n                            currentValue2 = currentValue;\n                            currentIndex++;\n\n                        } while(currentIndex < count);\n                    }\n\n                    break;\n\n                case 'odd':\n                case 'even':\n\n                    for (i = (reduce[0] == 'odd') ? 1 : 0, li = featureCacheIndex; i < li; i+=2) {\n                        feature = featureCache[i];\n                        finalFeatureCache[finalFeatureCacheIndex] = feature;\n                        finalFeatureCacheIndex++;\n                    }\n\n                    break;  //???\n\n                case 'every':\n\n                    if (count > featureCacheIndex) {\n                        count = featureCacheIndex;\n                    }\n\n                    for (i = 0, li = featureCacheIndex; i < li; i += count) {\n                        feature = featureCache[i];\n                        finalFeatureCache[finalFeatureCacheIndex] = feature;\n                        finalFeatureCacheIndex++;\n                    }\n\n                    break;\n            }\n\n            //process reduced features\n            for (i = 0, li = finalFeatureCacheIndex; i < li; i++) {\n                feature = finalFeatureCache[i];\n                processLayerFeature(type, finalFeatureCache[i], lod, layer, i);\n            }\n\n        }\n\n    }\n}\n\n\nfunction processLayerFeatureMultipass(type, feature, lod, layer, featureIndex, eventInfo) {\n    const multiPass = getLayerPropertyValue(layer, 'next-pass', feature, lod);\n\n    let mylayer;\n\n    if (multiPass != null) {\n        for (let i = 0, li = multiPass.length; i < li; i++) {\n            const zIndex = multiPass[i][0];\n            mylayer = getLayer(multiPass[i][1], type, featureIndex);\n\n            if (!getLayerPropertyValue(mylayer, 'visible', feature, lod)) {\n                continue;\n            }\n\n            const selectedLayerId = getLayerPropertyValue(mylayer, 'selected-layer', feature, lod);\n            const selectedLayer = (selectedLayerId != '') ? getLayer(selectedLayerId, type, featureIndex) : null;\n\n            const selectedHoverLayerId = getLayerPropertyValue(mylayer, 'selected-hover-layer', feature, lod);\n            const selectedHoverLayer = (selectedHoverLayerId != '') ? getLayer(selectedHoverLayerId, type, featureIndex) : null;\n\n            const hoverLayerId = getLayerPropertyValue(mylayer, 'hover-layer', feature, lod);\n            const hoverLayer = (hoverLayerId != '') ? getLayer(hoverLayerId, type, featureIndex) : null;\n\n            const flags =  ((hoverLayer != null) ? (1<<8) : 0) | ((selectedLayer != null) ? (1<<9) : 0) | ((selectedHoverLayer != null) ? (1<<10) : 0);\n\n            const lastHitState = globals.hitState;\n\n            if (selectedLayer != null) {\n                globals.hitState = flags | 2;\n                processLayerFeaturePass(type, feature, lod, selectedLayer, featureIndex, zIndex, eventInfo);\n            }\n\n            if (selectedHoverLayer != null) {\n                globals.hitState = flags | 3;\n                processLayerFeaturePass(type, feature, lod, selectedHoverLayer, featureIndex, zIndex, eventInfo);\n            }\n\n            if (hoverLayer != null) {\n                globals.hitState = flags | 1;\n                processLayerFeaturePass(type, feature, lod, hoverLayer, featureIndex, zIndex, eventInfo);\n            }\n\n            //globals.hitState = flags | 0;\n            processLayerFeaturePass(type, feature, lod, mylayer, featureIndex, zIndex, eventInfo);\n\n            globals.hitState = lastHitState;\n        }\n    }\n}\n\n\nfunction processLayerFeature(type, feature, lod, layer, featureIndex, skipPack) {\n    if (!getLayerPropertyValue(layer, 'visible', feature, lod)) {\n        return;\n    }\n\n    if (type == 'point-array') {\n        if (layer['visibility-switch']) {\n            postGroupMessageLite(5, 17);\n            //postGroupMessage({'command':'addRenderJob', 'type':'vswitch-begin'});\n            const zIndex = getLayerPropertyValue(layer, 'z-index', feature, lod);\n            const eventInfo = feature.properties;\n            processPointArrayVSwitchPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n\n            const vswitch = layer['visibility-switch'];\n            for (let i = 0, li = vswitch.length; i <li; i++) {\n                if (vswitch[i][1]) {\n                    const slayer = getLayer(vswitch[i][1], type, featureIndex);\n                    processLayerFeature(type, feature, lod, slayer, featureIndex);\n                }\n                postGroupMessageLite(5, 18, vswitch[i][0]);\n            }\n\n            postGroupMessageLite(5, 19);\n            return;\n        }\n    }\n\n    if (!skipPack && layer['pack'] == true) {\n        globals.directPoints = [];\n\n        postGroupMessageLite(5, 15);\n        processLayerFeature(type, feature, lod, layer, featureIndex, true);\n        postGroupMessageLite(5, 16);\n\n        if (globals.directPoints)  //????????????????? FIXME\n\n        return;\n    }\n\n    const zIndex = getLayerPropertyValue(layer, 'z-index', feature, lod);\n\n    if (getLayerPropertyValue(layer, 'export-geometry', feature, lod) && (typeof feature['id'] !== 'undefined')) {\n        if (!exportedGeometries[feature]) {\n\n            switch(type) {\n            case 'line-string':\n                processLineStringGeometry(feature);\n                break;\n\n            case 'point-array':\n                processPointArrayGeometry(feature);\n                break;\n\n            case 'polygon':\n                break;\n            }\n\n            exportedGeometries[feature] = true;\n        }\n    }\n\n    const eventInfo = feature.properties;\n\n    const selectedLayerId = getLayerPropertyValue(layer, 'selected-layer', feature, lod);\n    const selectedLayer = (selectedLayerId != '') ? getLayer(selectedLayerId, type, featureIndex) : null;\n\n    const selectedHoverLayerId = getLayerPropertyValue(layer, 'selected-hover-layer', feature, lod);\n    const selectedHoverLayer = (selectedHoverLayerId != '') ? getLayer(selectedHoverLayerId, type, featureIndex) : null;\n\n    const hoverLayerId = getLayerPropertyValue(layer, 'hover-layer', feature, lod);\n    const hoverLayer = (hoverLayerId != '') ? getLayer(hoverLayerId, type, featureIndex) : null;\n\n    const flags =  ((hoverLayer != null) ? (1<<8) : 0) | ((selectedLayer != null) ? (1<<9) : 0) | ((selectedHoverLayer != null) ? (1<<10) : 0);\n\n    if (selectedLayer != null) {\n        globals.hitState = flags | 2;\n        processLayerFeaturePass(type, feature, lod, selectedLayer, featureIndex, zIndex, eventInfo);\n        processLayerFeatureMultipass(type, feature, lod, selectedLayer, featureIndex, eventInfo);\n    }\n\n    if (selectedHoverLayer != null) {\n        globals.hitState = flags | 3;\n        processLayerFeaturePass(type, feature, lod, selectedHoverLayer, featureIndex, zIndex, eventInfo);\n        processLayerFeatureMultipass(type, feature, lod, selectedHoverLayer, featureIndex, eventInfo);\n    }\n\n    if (hoverLayer != null) {\n        globals.hitState = flags | 1;\n        processLayerFeaturePass(type, feature, lod, hoverLayer, featureIndex, zIndex, eventInfo);\n        processLayerFeatureMultipass(type, feature, lod, hoverLayer, featureIndex, eventInfo);\n    }\n\n    globals.hitState = flags | 0;\n    processLayerFeaturePass(type, feature, lod, layer, featureIndex, zIndex, eventInfo);\n    processLayerFeatureMultipass(type, feature, lod, layer, featureIndex, eventInfo);\n}\n\nfunction processGroup(group, lod) {\n    //let i, li;\n    const groupId = group['id'] || '';\n    globals.groupId = groupId;\n\n    const bbox = group['bbox'];\n    if (!bbox) {\n        return;\n    }\n\n    const bboxMin = bbox[0];\n    const bboxMax = bbox[1];\n    globals.bboxMin = bboxMin;\n    globals.bboxMax = bboxMax;\n\n    const bboxDelta = [bbox[1][0] - bbox[0][0],\n        bbox[1][1] - bbox[0][1],\n        bbox[1][2] - bbox[0][2]];\n    const bboxResolution = group['resolution'] || 4096;\n\n    globals.groupOrigin = [0,0,0];\n    globals.forceScale = [bboxDelta[0] / bboxResolution,\n        bboxDelta[1] / bboxResolution,\n        bboxDelta[2] / bboxResolution];\n\n    postGroupMessageFast(9, 0, {'id': group['id'], 'bbox': [bboxMin, bboxMax], 'origin': bboxMin}, [], \"\");\n\n    //process points\n    const points = group['points'] || [];\n    globals.featureType = 'point';\n    processFeatures('point-array', points, lod, 'point', groupId);\n\n    //process lines\n    const lines = group['lines'] || [];\n    globals.featureType = 'line';\n    processFeatures('line-string', lines, lod, 'line', groupId);\n\n    //process polygons\n    const polygons = group['polygons'] || [];\n    globals.featureType = 'polygon';\n    processFeatures('polygon', polygons, lod, 'polygon', groupId);\n\n    postGroupMessageLite(10, 0);\n\n    if (globals.groupOptimize) {\n        optimizeGroupMessages();\n    }\n}\n\n\nfunction processNode(node, lod) {\n    let i, li;\n\n    //TODO: get volume\n\n    postGroupMessageFast(5, 21, {'volume': node.volume, 'precision': node.precision, 'tileset': node.tileset }, [], \"\");\n\n    const meshes = node['meshes'] || [];\n\n    //loop elements\n    for (i = 0, li = meshes.length; i < li; i++) {\n\n        const signature = meshes[i];\n\n        postGroupMessageFast(5, 23, { 'path':meshes[i] }, [], signature);\n    }\n\n    const nodes = node['nodes'] || [];\n\n    for (i = 0, li = nodes.length; i < li; i++) {\n        processNode(nodes[i], lod);\n    }\n\n    postGroupMessageFast(5, 22, {}, [], \"\");\n}\n\nfunction processGeodata(data, lod) {\n    //console.log(\"processGeodata\");\n\n    let geodata;\n\n    //create object from JSON\n    if ((typeof data) == 'string') {\n        try {\n            geodata = JSON.parse(data);\n        } catch (e) {\n            geodata = null;\n        }\n    } else {\n        geodata = data;\n    }\n\n    if (geodata) {\n\n        const groups = geodata['groups'] || [];\n\n        //process layers\n        for (let i = 0, li = groups.length; i < li; i++) {\n            processGroup(groups[i], lod);\n        }\n\n        const nodes = geodata['nodes'] || [];\n\n        for (let i = 0, li = nodes.length; i < li; i++) {\n            postGroupMessageFast(9, 0, {}, [], \"\");\n            processNode(nodes[i], lod);\n            postGroupMessageLite(10, 0);\n        }\n    }\n\n    //console.log(\"processGeodata-ready\");\n}\n\nself.onmessage = function (e) {\n    const message = e.data;\n    const command = message['command'];\n    let data = message['data'];\n    let dataRaw = null;\n    let geodata2 = false;\n\n    //console.log(\"workeronmessage: \" + command);\n\n    switch(command) {\n\n    case 'config':\n        globals.config = data;\n        break;\n\n    case 'setStylesheet':\n        if (data) {\n            globals.geocent = data['geocent'];\n            globals.metricUnits = data['metric'];\n            globals.reduceMode = data['reduceMode'];\n            globals.reduceParams = data['reduceParams'];\n            globals.log = data['log'];\n            globals.language = data['language'];\n            processStylesheet(data['data']);\n        }\n        //postMessage({'command' : 'ready'});\n        break;\n\n    case 'setFont':\n        setFont(data);\n        //postMessage({'command' : 'ready'});\n        break;\n\n    case 'setFontMap':\n        setFontMap(data);\n        postMessage({'command' : 'styleDone'});\n        postMessage({'command' : 'ready'});\n        break;\n\n    case 'processGeodataRaw':\n        dataRaw = data;\n\n        //test geodata2\n        if (data.length > 2) {\n            const dataView = new DataView(data);\n\n            let magic = '';\n            magic += String.fromCharCode(dataView.getUint8(0, true));\n            magic += String.fromCharCode(dataView.getUint8(1, true));\n\n            if (magic != 'GE') {\n                geodata2 = true;\n            }\n        }\n\n        data = Utf8ArrayToStr(data);\n\n        //break; //????\n\n    case 'processGeodata':\n        globals.tileLod = message['lod'] || 0;\n        globals.tileIX = message['ix'] || 0;\n        globals.tileIY = message['iy'] || 0;\n        globals.tileSize = message['tileSize'] || 1;\n        globals.pixelSize = message['pixelSize'] || 1;\n        globals.pixelFactor = message['dpr'] || 1;\n        globals.invPixelFactor = 1.0 / globals.pixelFactor;\n        globals.pixelsPerMM = (globals.pixelFactor / 96) / 2.54;\n        globals.invPixelsPerMM = 1.0 / globals.pixelsPerMM;\n        exportedGeometries = [];\n\n        // eslint-disable-next-line\n        if (geodata2) {\n            //processGeodata2(dataView, globals.tileLod);\n        } else {\n            data = JSON.parse(data);\n            processGeodata(data, globals.tileLod);\n        }\n\n        postGroupMessageLite(7, 0);\n\n        if (globals.groupOptimize) {  //we need send all processed message\n            optimizeGroupMessages();\n        }\n\n        //postMessage({'command' : 'allProcessed'});\n\n        if (dataRaw) {\n            postPackedMessage({'command' : 'ready', 'geodata': dataRaw}, [dataRaw]);\n        } else {\n            postPackedMessage({'command' : 'ready'});\n        }\n\n        if (globals.config.mapPackLoaderEvents) {\n            postPackedMessages();\n        }\n\n        break;\n\n    //case 'tick':\n      //  postPackedMessages();\n        //break;\n\n    }\n};\n\n\n/***/ }),\n\n/***/ \"./src/core/map/geodata-processor/worker-message.js\":\n/*!**********************************************************!*\\\n  !*** ./src/core/map/geodata-processor/worker-message.js ***!\n  \\**********************************************************/\n/*! exports provided: optimizeGroupMessages, postGroupMessageFast, postGroupMessageLite, postPackedMessage, postPackedMessages */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"optimizeGroupMessages\", function() { return optimizeGroupMessages; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postGroupMessageFast\", function() { return postGroupMessageFast; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postGroupMessageLite\", function() { return postGroupMessageLite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postPackedMessage\", function() { return postPackedMessage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"postPackedMessages\", function() { return postPackedMessages; });\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \"./src/core/map/geodata-processor/worker-globals.js\");\n\n\n\n//get rid of compiler mess\nconst globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"globals\"], stringToUint8Array = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"stringToUint8Array\"];\nvar tmpVertexBuffer = new Uint8Array(65536*4*4*4*4);\nvar tmpVertexBuffer2 = new Uint8Array(65536*4*4*4*4);\nvar packedEvents = [];\nvar packedTransferables = [];\n\n\nfunction postPackedMessage(message, transferables) {\n\n    if (globals.config.mapPackLoaderEvents) {\n\n        packedEvents.push(message);\n\n        if (transferables) {\n            packedTransferables = packedTransferables.concat(transferables);\n        }\n\n    } else {\n\n        if (transferables) {\n            postMessage(message, transferables);\n        } else {\n            postMessage(message);\n        }\n    }\n}\n\n\nfunction postGroupMessageFast(command, type, message, buffers, signature) {\n\n    const message2 = stringToUint8Array(JSON.stringify(message));\n    let messageSize = 1+1+4+message2.byteLength;\n\n    for (let i = 0, li = buffers.length; i < li; i++) {\n        messageSize += 4+buffers[i].byteLength;\n    }\n\n    const buff = new Uint8Array(messageSize);\n    const view = new DataView(buff.buffer);\n    let index = 0, index2 = 0;\n\n    view.setUint8(index, command); index += 1;\n    view.setUint8(index, type); index += 1;\n    view.setUint32(index, message2.byteLength); index += 4;\n    buff.set(message2, index); index += message2.byteLength;\n    index2 = index;\n\n    for (let i = 0, li = buffers.length; i < li; i++) {\n        view.setUint32(index, buffers[i].length); index += 4;\n        buff.set( new Uint8Array(buffers[i].buffer), index); index += buffers[i].byteLength;\n    }\n\n    postGroupMessageDirect(command, type, buff.buffer, index2, signature, message['hitable'], message['totalPoints'], (type == 11) ? message : null);\n}\n\n\nfunction postGroupMessageLite(command, type, number) {\n    const messageSize = 1+1+4;\n    let index = 0;\n\n    const buff = new ArrayBuffer(messageSize);\n    const view = new DataView(buff);\n\n    view.setUint8(index, command); index += 1;\n    view.setUint8(index, type); index += 1;\n    view.setUint32(index, (number ? number : 0)); index += 4;\n\n    postGroupMessageDirect(command, type, buff, index, \"\");\n}\n\n\nfunction postGroupMessageDirect(command, type, message, buffersIndex, signature, hitable, totalPoints, job2) {\n\n    if (globals.messageBufferIndex >= globals.messageBufferSize) {\n        const oldBuffer = globals.messageBuffer;\n        globals.messageBufferSize += 65536;\n        globals.messageBuffer = new Array(globals.messageBufferSize);\n\n        for (let i = 0, li = globals.messageBufferIndex; i < li; i++) {\n            globals.messageBuffer[i] = oldBuffer[i];\n        }\n    }\n\n    globals.messageBuffer[globals.messageBufferIndex] = { command: command, type: type, job : message, buffersIndex: buffersIndex, signature: signature, hitable: hitable, totalPoints: totalPoints, job2: job2 };\n    globals.messageBufferIndex++;\n    globals.messagePackSize += message.byteLength;\n}\n\n\nfunction setToTmpBuffer(index, buffer2, offset) {\n    let buffer = (index == 1) ? tmpVertexBuffer2 : tmpVertexBuffer;\n\n    if (buffer.byteLength <= buffer2.byteLength + offset) {\n        const buffer3 = new Uint8Array(buffer.byteLength * 2);\n        buffer3.set(buffer, 0);\n        buffer = buffer3;\n\n        if (index == 1) {\n            tmpVertexBuffer2 = buffer;\n        } else {\n            tmpVertexBuffer = buffer;\n        }\n    }\n\n    buffer.set(buffer2, offset);\n}\n\n\nfunction optimizeGroupMessages() {\n\n    //loop messages\n    const messages = globals.messageBuffer;\n    let j, lk, k, message2, bufferSize, buffer, view, length, index, count, totalVertices;\n\n\n    for (let i = 0, li = globals.messageBufferIndex; i < li; i++) {\n        const message = messages[i];\n        //const job = message.job;\n        const type = message.type;\n        const signature = message.signature;\n\n        //console.log('command: ' + message.command + ' type:' + message.type);\n\n        if (!message.hitable && !message.reduced &&\n            (type >= 6 && type <= 13)) {\n\n            switch(type) {\n            case 13:\n            case 6:\n                count = 0;\n\n                //get message vertices length and copy vertices to buffer\n                length = (new DataView(message.job)).getUint32(message.buffersIndex) * 4;\n\n                //tmpVertexBuffer.set(new Uint8Array(message.job, message.buffersIndex+4, length), 0);\n                setToTmpBuffer(0, new Uint8Array(message.job, message.buffersIndex+4, length), 0);\n                bufferSize = length;\n\n                for (j = i + 1; j < li; j++) {\n                    message2 = messages[j];\n\n                    if (message2.signature == signature) {\n                        message2.reduced = true;\n                        count++;\n\n                        //get message2 vertices length\n                        length = (new DataView(message2.job)).getUint32(message2.buffersIndex) * 4;\n\n                        // copy vertices to buffer\n                        //tmpVertexBuffer.set(new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\n                        setToTmpBuffer(0, new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\n                        bufferSize += length;\n                    }\n                }\n\n                if (count > 0) {\n\n                    //create new message with merged vertices\n                    buffer = new Uint8Array(message.buffersIndex+2*(4+bufferSize));\n                    view = new DataView(buffer.buffer);\n                    buffer.set(new Uint8Array(message.job, 0, message.buffersIndex), 0);\n\n                    view.setUint32(message.buffersIndex, bufferSize / 4);\n                    buffer.set(new Uint8Array(tmpVertexBuffer.buffer, 0, bufferSize), message.buffersIndex + 4);\n\n                    globals.messagePackSize -= message.job.byteLength;\n                    globals.messagePackSize += buffer.byteLength;\n                    message.job = buffer.buffer;\n                }\n\n                break;\n\n            case 9:\n            case 11:\n            case 7:\n\n                count = 0;\n                totalVertices = 0;\n\n                //get message vertices length and copy vertices to buffer\n                length = (new DataView(message.job)).getUint32(message.buffersIndex);\n                //console.log('count: ' + count + ' totalPoints:' + message.totalPoints + ' length: ' + length);\n                length *= 4;\n                totalVertices += length;\n\n\n                //tmpVertexBuffer.set(new Uint8Array(message.job, message.buffersIndex+4, length), 0);\n                //tmpVertexBuffer2.set(new Uint8Array(message.job, message.buffersIndex+4+length+4, length), 0);\n                setToTmpBuffer(0, new Uint8Array(message.job, message.buffersIndex+4, length), 0);\n                setToTmpBuffer(1, new Uint8Array(message.job, message.buffersIndex+4+length+4, length), 0);\n                bufferSize = length;\n\n                for (j = i + 1; j < li; j++) {\n                    message2 = messages[j];\n\n                    if (message2.signature == signature) {\n                        message2.reduced = true;\n                        globals.messagePackSize -= message2.job.byteLength;\n                        count++;\n\n                        //get message2 vertices length\n                        length = (new DataView(message2.job)).getUint32(message2.buffersIndex);\n                        //console.log('count:' + count + ' totalPoints:' + message2.totalPoints + ' length:' + length + ' jobl:' + message2.job.byteLength + ' remaning:' + (message2.job.byteLength - (message2.buffersIndex+4)) + ' bufferSize:' + bufferSize + ' totalVertices:' + totalVertices);\n                        length *= 4;\n\n                        // eslint-disable-next-line\n                        totalVertices += length;\n\n\n                        // copy vertices to buffer\n                        //tmpVertexBuffer.set(new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\n                        setToTmpBuffer(0, new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\n\n                        // copy normals to buffer\n                        //tmpVertexBuffer2.set(new Uint8Array(message2.job, message2.buffersIndex+4+length+4, length), bufferSize);\n                        setToTmpBuffer(1, new Uint8Array(message2.job, message2.buffersIndex+4+length+4, length), bufferSize);\n                        bufferSize += length;\n\n                        if (type == 11) {\n                            const files = message.job2['files'];\n                            const files2 = message2.job2['files'];\n\n                            for (k = 0, lk = files2.length; k < lk; k++) {\n                                if (!files[k]) {\n                                    files[k] = [];\n                                }\n\n                                for (let m = 0, lm = files2[k].length; m < lm; m++) {\n                                    if (files[k].indexOf(files2[k][m]) == -1) {\n                                        files[k].push(files2[k][m]);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (count > 0) {\n\n                    //create new message with merged vertices\n\n                    if (type == 11) { //we have to rebuild header\n                        const buffjob = stringToUint8Array(JSON.stringify(message.job2));\n\n                        buffer = new Uint8Array(1+1+4+buffjob.byteLength+2*(4+bufferSize));\n                        view = new DataView(buffer.buffer), index = 0;\n\n                        view.setUint8(index, message.command); index += 1;\n                        view.setUint8(index, type); index += 1;\n                        view.setUint32(index, buffjob.byteLength); index += 4;\n                        buffer.set(buffjob, index); index += buffjob.byteLength;\n\n                        message.buffersIndex = index;\n                    } else {\n                        buffer = new Uint8Array(message.buffersIndex+2*(4+bufferSize));\n                        view = new DataView(buffer.buffer);\n                        buffer.set(new Uint8Array(message.job, 0, message.buffersIndex), 0);\n                    }\n\n                    view.setUint32(message.buffersIndex, bufferSize / 4);\n                    buffer.set(new Uint8Array(tmpVertexBuffer.buffer, 0, bufferSize), message.buffersIndex + 4);\n\n                    view.setUint32(message.buffersIndex + 4 + bufferSize, bufferSize / 4);\n                    buffer.set(new Uint8Array(tmpVertexBuffer2.buffer, 0, bufferSize), message.buffersIndex + 4 + bufferSize + 4 );\n\n                    globals.messagePackSize -= message.job.byteLength;\n                    globals.messagePackSize += buffer.byteLength;\n                    message.job = buffer.buffer;\n\n                }\n\n                break;\n            }\n\n        }\n    }\n\n    buffer = new Uint8Array(globals.messagePackSize);\n    index = 0;\n\n    for (let i = 0, li = globals.messageBufferIndex; i < li; i++) {\n        const message = globals.messageBuffer[i];\n\n        if (!message.reduced) {\n            buffer.set(new Uint8Array(message.job), index);\n            index += globals.messageBuffer[i].job.byteLength;\n        }\n    }\n\n    //console.log('send:' + buffer.length);\n\n    postPackedMessage({'command' : 'addPackedCommands', 'buffer': buffer}, [buffer.buffer]);\n\n    globals.messageBufferIndex = 0;\n    globals.messagePackSize = 0;\n}\n\n\nfunction postPackedMessages() {\n    if (packedEvents.length > 0) {\n        if (packedTransferables.length > 0) {\n            postMessage({'command': 'packed-events', 'messages':packedEvents}, packedTransferables);\n        } else {\n            postMessage({'command': 'packed-events', 'messages':packedEvents});\n        }\n\n        packedEvents = [];\n        packedTransferables = [];\n    }\n}\n\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/map/geodata-processor/worker-pointarray.js\":\n/*!*************************************************************!*\\\n  !*** ./src/core/map/geodata-processor/worker-pointarray.js ***!\n  \\*************************************************************/\n/*! exports provided: processPointArrayPass, processPointArrayGeometry, processPointArrayVSwitchPass, checkDPoints */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processPointArrayPass\", function() { return processPointArrayPass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processPointArrayGeometry\", function() { return processPointArrayGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processPointArrayVSwitchPass\", function() { return processPointArrayVSwitchPass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkDPoints\", function() { return checkDPoints; });\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \"./src/core/map/geodata-processor/worker-globals.js\");\n/* harmony import */ var _worker_style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-style.js */ \"./src/core/map/geodata-processor/worker-style.js\");\n/* harmony import */ var _worker_text_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker-text.js */ \"./src/core/map/geodata-processor/worker-text.js\");\n/* harmony import */ var _worker_message_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./worker-message.js */ \"./src/core/map/geodata-processor/worker-message.js\");\n\n\n\n\n\n\n//get rid of compiler mess\nconst globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"globals\"], clamp = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"clamp\"];\nconst getLayerPropertyValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\"getLayerPropertyValue\"], getLayerExpresionValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\"getLayerExpresionValue\"];\nconst addText = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"addText\"], getSplitIndex = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"getSplitIndex\"], getTextGlyphs = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"getTextGlyphs\"],\n    getTextLength = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"getTextLength\"], getFonts = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"getFonts\"], getFontsStorage = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"getFontsStorage\"],\n    areTextCharactersAvailable = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"areTextCharactersAvailable\"], getCharVerticesCount = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"getCharVerticesCount\"], getLineHeight = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\"getLineHeight\"];\nconst postGroupMessageFast = _worker_message_js__WEBPACK_IMPORTED_MODULE_3__[\"postGroupMessageFast\"];\n\n\nfunction checkDPoints(pointArray) {\n    let pointsGroups = [];\n    let i, li, g, gl, points, p, pp;\n\n    if (pointArray['d-points'] || pointArray['d-lines']) {  //converty d-lines/points to lines/points\n        pointsGroups = pointArray['d-points'] || pointArray['d-lines'];\n\n        if (Array.isArray(pointsGroups) && points.length > 0) {\n\n            for (g = 0, gl = pointsGroups; g < gl; g++) {\n                points = pointsGroups[g];\n\n                if (Array.isArray(points) && points.length > 0) {\n                    p = points[0];\n\n                    p[0] = (p[0] >> 1) ^ (-(p[0] & 1));\n                    p[1] = (p[1] >> 1) ^ (-(p[1] & 1));\n                    p[2] = (p[2] >> 1) ^ (-(p[2] & 1));\n\n                    for (i = 1, li = points.length; i < li; i++) {\n                        p = points[i-1];\n                        pp = points[i];\n\n                        pp[0] = ((pp[0] >> 1) ^ (-(pp[0] & 1))) + p[0];\n                        pp[1] = ((pp[1] >> 1) ^ (-(pp[1] & 1))) + p[1];\n                        pp[2] = ((pp[2] >> 1) ^ (-(pp[2] & 1))) + p[2];\n                    }\n                }\n            }\n        }\n\n        if (pointArray['d-points']) {\n            pointArray['points'] = pointArray['d-points'];\n            delete pointArray['d-points'];\n        } else {\n            pointArray['lines'] = pointArray['d-lines'];\n            delete pointArray['d-lines'];\n        }\n    }\n}\n\n\nfunction processPointArrayPass(pointArray, lod, style, featureIndex, zIndex, eventInfo) {\n    let pointsGroups = [];\n    let i, li, g, gl, points, p, pp;\n\n    checkDPoints(pointArray);\n\n    if (pointArray['lines']) {  //use lines as points\n        pointsGroups = pointArray['lines'];\n    } else {\n        pointsGroups = [pointArray['points']];\n    }\n\n    if (!pointsGroups || pointsGroups.length == 0) {\n        return;\n    }\n\n    let visibility = getLayerPropertyValue(style, 'visibility-rel', pointArray, lod) ||\n                     getLayerPropertyValue(style, 'visibility-abs', pointArray, lod) ||\n                     getLayerPropertyValue(style, 'visibility', pointArray, lod);\n    const culling = getLayerPropertyValue(style, 'culling', pointArray, lod);\n    const hoverEvent = getLayerPropertyValue(style, 'hover-event', pointArray, lod);\n    const clickEvent = getLayerPropertyValue(style, 'click-event', pointArray, lod);\n    const drawEvent = getLayerPropertyValue(style, 'draw-event', pointArray, lod);\n    const enterEvent = getLayerPropertyValue(style, 'enter-event', pointArray, lod);\n    const leaveEvent = getLayerPropertyValue(style, 'leave-event', pointArray, lod);\n    const advancedHit = getLayerPropertyValue(style, 'advanced-event', pointArray, lod);\n    const linePoints = getLayerPropertyValue(style, 'line-points', pointArray, lod);\n\n    const zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', pointArray, lod);\n\n    const point = getLayerPropertyValue(style, 'point', pointArray, lod);\n    const pointFlat = getLayerPropertyValue(style, 'point-flat', pointArray, lod);\n    const pointColor = getLayerPropertyValue(style, 'point-color', pointArray, lod);\n    const pointRadius = 0.5 * getLayerPropertyValue(style, 'point-radius', pointArray, lod);\n\n    let source, bufferSize, bufferSize2, totalPoints = 0, noOverlap;\n    let labelData, iconData;\n\n    //zIndex = (zIndex !== null) ? zIndex : getLayerPropertyValue(style, \"z-index\", pointArray, lod);\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n        if (Array.isArray(points) && points.length > 0) {\n            totalPoints += points.length;\n        }\n    }\n\n    let icon = getLayerPropertyValue(style, 'icon', pointArray, lod);\n    if (icon) {\n        source = getLayerPropertyValue(style, 'icon-source', pointArray, lod);\n\n        if (source) {\n            bufferSize = getCharVerticesCount() * totalPoints;\n            bufferSize2 = getCharVerticesCount(true) * totalPoints;\n\n            iconData = {\n                color : getLayerPropertyValue(style, 'icon-color', pointArray, lod),\n                scale : getLayerPropertyValue(style, 'icon-scale', pointArray, lod),\n                offset : getLayerPropertyValue(style, 'icon-offset', pointArray, lod),\n                stick : getLayerPropertyValue(style, 'icon-stick', pointArray, lod),\n                reduce : getLayerPropertyValue(style, 'dynamic-reduce', pointArray, lod),\n                origin : getLayerPropertyValue(style, 'icon-origin', pointArray, lod),\n                source : getLayerPropertyValue(style, 'icon-source', pointArray, lod),\n                noOverlap : getLayerPropertyValue(style, 'icon-no-overlap', pointArray, lod),\n                noOverlapMargin : getLayerPropertyValue(style, 'icon-no-overlap-margin', pointArray, lod),\n                noOverlapFactor : getLayerPropertyValue(style, 'icon-no-overlap-factor', pointArray, lod),\n                index : 0,\n                index2 : 0\n            };\n\n            if (totalPoints > 1) {\n                iconData.vertexBuffer = new Float32Array(bufferSize);\n                iconData.originBuffer = new Float32Array(bufferSize2);\n                iconData.texcoordsBuffer = new Float32Array(bufferSize);\n            } else {\n                iconData.singleBuffer = new Float32Array(16);\n            }\n\n        } else {\n            icon = false;\n        }\n    }\n\n    let label = getLayerPropertyValue(style, 'label', pointArray, lod);\n    if (label) {\n        source = getLayerPropertyValue(style, 'label-source', pointArray, lod);\n\n        let text = getLayerExpresionValue(style, source, pointArray, lod, source);\n        text = text ? text.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n        const size = getLayerPropertyValue(style, 'label-size', pointArray, lod);\n        const fontNames = getLayerPropertyValue(style, 'label-font', pointArray, lod);\n        const fonts = getFonts(fontNames);\n        let glyphsRes = getTextGlyphs(text, fonts);\n\n        if (source == '$name') {\n            if (!areTextCharactersAvailable(text, fonts, glyphsRes)) {\n                let text2 = getLayerExpresionValue(style, '$name:en', pointArray, lod, source);\n                text2 = text2 ? text2.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n                const glyphsRes2 = getTextGlyphs(text2, fonts);\n\n                if (areTextCharactersAvailable(text2, fonts)) {\n                    text = text2;\n                    glyphsRes = glyphsRes2;\n                }\n            }\n        }\n        if (text && text != '' && Math.abs(size) > 0.0001) {\n            noOverlap = getLayerPropertyValue(style, 'label-no-overlap', pointArray, lod);\n            bufferSize = getCharVerticesCount() * text.length * (noOverlap ? 1 : totalPoints);\n            bufferSize2 = getCharVerticesCount(true) * text.length * (noOverlap ? 1 : totalPoints);\n\n            const useSingleBuffer = (totalPoints == 1);\n\n            let factor = 1;\n            if (getLayerPropertyValue(style, 'label-size-units', pointArray, lod) == 'points') {\n                factor = globals.pixelFactor / ((1 / 72) * (96));\n            }\n\n            labelData = {\n                color : getLayerPropertyValue(style, 'label-color', pointArray, lod),\n                color2 : getLayerPropertyValue(style, 'label-color2', pointArray, lod),\n                outline : getLayerPropertyValue(style, 'label-outline', pointArray, lod),\n                reduce : getLayerPropertyValue(style, 'dynamic-reduce', pointArray, lod),\n                size : size * factor,\n                spacing: getLayerPropertyValue(style, 'label-spacing', pointArray, lod),\n                lineHeight: getLayerPropertyValue(style, 'label-line-height', pointArray, lod),\n                offset : getLayerPropertyValue(style, 'label-offset', pointArray, lod),\n                stick : getLayerPropertyValue(style, 'label-stick', pointArray, lod),\n                origin : getLayerPropertyValue(style, 'label-origin', pointArray, lod),\n                align : getLayerPropertyValue(style, 'label-align', pointArray, lod),\n                fonts : fonts,\n                fontsStorage : getFontsStorage(fontNames),\n                text : text,\n                hysteresis : getLayerPropertyValue(style, 'hysteresis', pointArray, lod),\n                width : factor * getLayerPropertyValue(style, 'label-width', pointArray, lod),\n                noOverlap : noOverlap,\n                noOverlapMargin : getLayerPropertyValue(style, 'label-no-overlap-margin', pointArray, lod),\n                noOverlapFactor : getLayerPropertyValue(style, 'label-no-overlap-factor', pointArray, lod),\n                vertexBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize)),\n                originBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize2)),\n                texcoordsBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize)),\n                singleBuffer : (useSingleBuffer) ? (new Float32Array(text.length * 4 * 2)) : null,\n                index : 0,\n                index2 : 0,\n                glyphsRes : glyphsRes\n            };\n\n            if (labelData.stick) {\n                labelData.stick = labelData.stick.slice();\n                labelData.stick[2] *= factor;\n                //labelData.stick[7] *= factor;\n            }\n\n        } else {\n            label = false;\n        }\n    }\n\n    let index = 0;\n    let index2 = 0;\n\n    let center = [0,0,0];\n    const forceOrigin = globals.forceOrigin;\n    const bboxMin = globals.bboxMin;\n    const tileX = globals.tileX;\n    const tileY = globals.tileY;\n    const forceScale = globals.forceScale;\n    let labelBBox, iconBBox, p1, p2, pp2;\n\n    let circleBuffer = [];\n    let circleSides = clamp(pointRadius * 8 * 0.5, 8, 32);\n\n    // eslint-disable-next-line\n    const generatePoint = (function(pindex) {\n\n        if (icon && (!iconData.noOverlap)) {\n            iconBBox = processIcon(pp, iconData) ;//, pointArray, lod, style, zIndex);\n        }\n\n        if (label && (!labelData.noOverlap)) {\n            labelBBox = processLabel(pp, labelData); //, pointArray, lod, style, zIndex);\n        }\n\n        if (point) {\n\n            for (let j = 0; j < circleSides; j++) {\n\n                if (pointFlat) {\n\n                    //add polygon\n                    vertexBuffer[index] = pp[0];\n                    vertexBuffer[index+1] = pp[1];\n                    vertexBuffer[index+2] = pp[2];\n\n                    vertexBuffer[index+3] = pp[0] + circleBuffer[j][0] * pointRadius;\n                    vertexBuffer[index+4] = pp[1] + circleBuffer[j][1] * pointRadius;\n                    vertexBuffer[index+5] = pp[2];\n\n                    vertexBuffer[index+6] = pp[0] + circleBuffer[j+1][0] * pointRadius;\n                    vertexBuffer[index+7] = pp[1] + circleBuffer[j+1][1] * pointRadius;\n                    vertexBuffer[index+8] = pp[2];\n\n                    index += 9;\n\n                } else {\n\n                    //add polygon\n                    vertexBuffer[index] = pp[0];\n                    vertexBuffer[index+1] = pp[1];\n                    vertexBuffer[index+2] = pp[2];\n                    vertexBuffer[index+3] = 0;\n                    normalBuffer[index2] = 0;\n                    normalBuffer[index2+1] = 0;\n                    normalBuffer[index2+2] = 0;\n                    normalBuffer[index2+3] = 0;\n\n                    vertexBuffer[index+4] = pp[0];\n                    vertexBuffer[index+5] = pp[1];\n                    vertexBuffer[index+6] = pp[2];\n                    vertexBuffer[index+7] = 0;\n                    normalBuffer[index2+4] = circleBuffer[j][0] * pointRadius;\n                    normalBuffer[index2+5] = circleBuffer[j][1] * pointRadius;\n                    normalBuffer[index2+6] = 0;\n                    normalBuffer[index2+7] = 0;\n\n                    vertexBuffer[index+8] = pp[0];\n                    vertexBuffer[index+9] = pp[1];\n                    vertexBuffer[index+10] = pp[2];\n                    vertexBuffer[index+11] = 0;\n                    normalBuffer[index2+8] = circleBuffer[j+1][0] * pointRadius;\n                    normalBuffer[index2+9] = circleBuffer[j+1][1] * pointRadius;\n                    normalBuffer[index2+10] = 0;\n                    normalBuffer[index2+11] = 0;\n\n                    index += 12;\n                    index2 += 12;\n                }\n            }\n        }\n    });\n\n\n    const getLinePoint = (function(length) {\n\n        let l1 = 0, l2 = 0;\n\n        p = points[0];\n        p1 = [p[0], p[1], p[2]];\n\n        if (forceOrigin) {\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n        }\n\n        if (forceScale != null) {\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n        }\n\n        if (length == 0) {\n            return p1;\n        }\n\n        for (let k = 0, lk = points.length - 1; k < lk; k++) {\n            p = points[k+1];\n            p2 = [p[0], p[1], p[2]];\n\n            if (forceOrigin) {\n                p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n            }\n\n            if (forceScale != null) {\n                p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n            }\n\n            const dx = p2[0] - p1[0], dy = p2[1] - p1[1], dz = p2[2] - p1[2];\n            const l = Math.sqrt(dx*dx+dy*dy+dz*dz);\n\n            l1 = l2;\n            l2 += l;\n\n            if (length >= l1 && length <= l2) {\n                const d = (length - l1) / l;\n\n                return [p1[0] + dx * d,  p1[1] + dy * d, p1[2] + dz * d];\n            }\n\n            p1 = p2;\n        }\n\n    });\n\n    const pointsBuffer = new Array(2048);\n    let pointsBufferLength = 0;\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n\n        if (Array.isArray(points) && points.length > 0) {\n\n            let totalLength = 0, lengths = null;\n\n            if (linePoints[0] != 'vertices') {\n                lengths = new Array(points.length);\n                lengths[0] = 0;\n            }\n\n            //add ponints\n            for (i = 0, li = points.length; i < li; i++) {\n                p = points[i];\n                p1 = [p[0], p[1], p[2]];\n\n                if (forceOrigin) {\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n                }\n\n                if (forceScale != null) {\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n                }\n\n                if (i + 1 < li) {\n                    p = points[i+1];\n                    p2 = [p[0], p[1], p[2]];\n\n                    if (forceOrigin) {\n                        p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n                    }\n\n                    if (forceScale != null) {\n                        p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n                    }\n\n                    const dx = p2[0] - p1[0], dy = p2[1] - p1[1], dz = p2[2] - p1[2];\n                    const l = Math.sqrt(dx*dx+dy*dy+dz*dz);\n\n                    if (lengths) {\n                        lengths[i] = l;\n                    }\n\n                    totalLength += l;\n                }\n\n                center[0] += p1[0];\n                center[1] += p1[1];\n                center[2] += p1[2];\n\n                if (linePoints[0] == 'vertices') {\n                    pointsBuffer[pointsBufferLength] = p1;\n                    pointsBufferLength++;\n                }\n            }\n\n            if (linePoints[0] == 'by-length' || linePoints[0] == 'by-ratio') {\n                let period = linePoints[1];\n                let offset = linePoints[2] || 0;\n\n                if (linePoints[0] == 'by-ratio') {\n                    period *= totalLength;\n                    offset *= totalLength;\n                }\n\n                if (period <= 0) {\n                    pointsBuffer[pointsBufferLength] = getLinePoint(offset);\n                    if (pointsBuffer[pointsBufferLength]) {\n                        pointsBufferLength++;\n                    }\n                } else {\n                    for (i = offset; i < totalLength; i += period) {\n                        pointsBuffer[pointsBufferLength] = getLinePoint(i);\n                        if (pointsBuffer[pointsBufferLength]) {\n                            pointsBufferLength++;\n                        }\n                    }\n                }\n            }\n\n            if (linePoints[0] == 'start') {\n                pointsBuffer[pointsBufferLength] = getLinePoint(0);\n                pointsBufferLength++;\n            }\n\n            if (linePoints[0] == 'end') {\n                pointsBuffer[pointsBufferLength] = getLinePoint(totalLength);\n                pointsBufferLength++;\n            }\n\n            if (linePoints[0] == 'endpoints') {\n                pointsBuffer[pointsBufferLength] = getLinePoint(0);\n                pointsBufferLength++;\n                pointsBuffer[pointsBufferLength] = getLinePoint(totalLength);\n                pointsBufferLength++;\n            }\n\n            if (linePoints[0] == 'middle' || linePoints[0] == 'midpoint') {\n                pointsBuffer[pointsBufferLength] = getLinePoint(totalLength * 0.5);\n                pointsBufferLength++;\n            }\n        }\n    }\n\n    let pointsVertices, vertexBuffer, pointsNormals, normalBuffer, bufferPoints = pointsBufferLength;\n\n    if (point) {\n        circleBuffer = [];\n        circleSides = clamp(pointRadius * 8 * 0.5, 8, 32);\n\n        let angle = 0, step = (2.0*Math.PI) / circleSides;\n\n        for (i = 0; i < circleSides; i++) {\n            circleBuffer[i] = [-Math.sin(angle), Math.cos(angle)];\n            angle += step;\n        }\n\n        circleBuffer[circleSides] = [0, 1.0];\n\n        //allocate buffers\n        if (!pointFlat) {\n            pointsVertices = circleSides * 3 * 4;\n            vertexBuffer = new Float32Array(bufferPoints * pointsVertices);\n            pointsNormals = circleSides * 3 * 4;\n            normalBuffer = new Float32Array(bufferPoints * pointsNormals);\n        } else {\n            pointsVertices = circleSides * 3 * 3;\n            vertexBuffer = new Float32Array(bufferPoints * pointsVertices);\n        }\n    }\n\n    if (!pointsBufferLength) {\n        return;\n    }\n\n    //if (pointsBufferLength > 1) {\n      //  globals.directPoints = pointsBuffer.slice(1,pointsBufferLength);\n    //}\n\n    globals.directPoints = pointsBuffer.slice(0,pointsBufferLength);\n\n    for (i = 0; i < pointsBufferLength; i++) {\n        pp = pointsBuffer[i];\n        generatePoint(i);\n    }\n\n    if (totalPoints > 0) {\n        center[0] /= totalPoints;\n        center[1] /= totalPoints;\n        center[2] /= totalPoints;\n    }\n\n    center[0] += bboxMin[0];//groupOrigin[0];\n    center[1] += bboxMin[1];//groupOrigin[1];\n    center[2] += bboxMin[2];//groupOrigin[2];\n\n    const hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\n    //let message, messageSize;\n\n    globals.signatureCounter++;\n    let signature = (\"\"+globals.signatureCounter);\n\n    if (visibility && !Array.isArray(visibility)) {\n        visibility = [visibility];\n    }\n\n    if (point) {\n        if (pointFlat) {\n            postGroupMessageFast(5, 6, {\n                'color':pointColor, 'z-index':zIndex, 'visibility': visibility, 'center': center,\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'advancedHit': advancedHit,\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n                'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer], signature);\n        } else {\n            postGroupMessageFast(5, 9, {\n                'color':pointColor, 'z-index':zIndex, 'visibility': visibility, 'center': center,\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent,\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n                'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer, normalBuffer], signature);\n        }\n    }\n\n    const sendIconMessage = (function(){\n\n        if (icon) {\n\n            globals.signatureCounter++;\n            signature = (\"\"+globals.signatureCounter);\n\n            let noOverlap;\n\n            if (iconData.noOverlap) {\n                const margin = iconData.noOverlapMargin;\n                let factorType = null, factorValue = null;\n\n                if (iconData.noOverlapFactor !== null) {\n                    switch(iconData.noOverlapFactor[0]) {\n                        case 'direct':      factorType = 0;      break;\n                        case 'div-by-dist': factorType = 1; break;\n                    }\n\n                    factorValue = iconData.noOverlapFactor[1];\n                }\n\n                noOverlap = [iconBBox[0]-margin[0], iconBBox[1]-margin[1], iconBBox[2]+margin[0], iconBBox[3]+margin[1], factorType, factorValue];\n            }\n\n            if ((iconData.singleBuffer && iconData.singleBuffer.length > 0) || (iconData.vertexBuffer && iconData.vertexBuffer.length > 0)) {\n\n                postGroupMessageFast(5, (iconData.singleBuffer) ? 3 : 4, {\n                    'icon':globals.stylesheetBitmaps[iconData.source[0]], 'color':iconData.color, 'z-index':zIndex,\n                    'visibility': visibility, 'culling': culling, 'center': pp2, 'stick': iconData.stick,\n                    'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'advancedHit': advancedHit,\n                    'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'noOverlap' : (iconData.noOverlap ? noOverlap: null),\n                    'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n                    'index': featureIndex, 'reduce': iconData.reduce, 'lod':(globals.autoLod ? null : globals.tileLod) },\n                    (iconData.singleBuffer) ? [iconData.singleBuffer] : [iconData.vertexBuffer, iconData.originBuffer, iconData.texcoordsBuffer],\n                    signature);\n            }\n        }\n\n    });\n\n    const sendLabelMessage = (function(){\n\n        if (label) {\n            globals.signatureCounter++;\n            signature = (\"\"+globals.signatureCounter);\n\n            let noOverlap;\n\n            if (labelData.noOverlap) {\n                const margin = labelData.noOverlapMargin;\n                let factorType = null, factorValue = null;\n\n                if (labelData.noOverlapFactor !== null) {\n                    switch(labelData.noOverlapFactor[0]) {\n                        case 'direct':      factorType = 0;      break;\n                        case 'div-by-dist': factorType = 1; break;\n                    }\n\n                    factorValue = labelData.noOverlapFactor[1];\n                }\n\n                noOverlap = [labelBBox[0]-margin[0], labelBBox[1]-margin[1], labelBBox[2]+margin[0], labelBBox[3]+margin[1], factorType, factorValue];\n            }\n\n            if ((labelData.singleBuffer && labelData.singleBuffer.length > 0) || (labelData.vertexBuffer && labelData.vertexBuffer.length > 0)) {\n\n                postGroupMessageFast(5, (labelData.singleBuffer) ? 1 : 2, {\n                    'size':labelData.size, 'origin':labelData.pos, 'color':labelData.color,\n                    'color2':labelData.color2, 'outline':labelData.outline, 'z-index':zIndex, 'visibility': visibility,\n                    'culling': culling, 'center': pp2, 'stick': labelData.stick, 'noOverlap' : (labelData.noOverlap ? noOverlap: null),\n                    'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'files':labelData.files, 'index': featureIndex,\n                    'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'fonts': labelData.fontsStorage,\n                    'hitable':hitable, 'state':globals.hitState, 'advancedHit': advancedHit, 'reduce': labelData.reduce, 'hysteresis': labelData.hysteresis,\n                    'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, 'lod':(globals.autoLod ? null : globals.tileLod) },\n                    (labelData.singleBuffer) ? [labelData.singleBuffer] : [labelData.vertexBuffer, labelData.originBuffer, labelData.texcoordsBuffer],\n                    signature);\n            }\n        }\n\n    });\n\n    if (icon && (!iconData.noOverlap)) {\n        pp2 = center;\n        sendIconMessage();\n    }\n\n    if (label && (!labelData.noOverlap)) {\n        pp2 = center;\n        sendLabelMessage();\n    }\n\n    for (i = 0, li = globals.insidePack ? 1 : globals.directPoints.length; i < li; i++) {\n        pp = globals.directPoints[i];\n        pp2 = [pp[0] + bboxMin[0], pp[1] + bboxMin[1], pp[2] + bboxMin[2]];\n\n        if (icon && (iconData.noOverlap)) {\n            iconBBox = processIcon(pp, iconData, iconBBox) ;//, pointArray, lod, style, zIndex);\n            sendIconMessage();\n        }\n\n        if (label && (labelData.noOverlap)) {\n            labelBBox = processLabel(pp, labelData, labelBBox); //, pointArray, lod, style, zIndex);\n            sendLabelMessage();\n        }\n    }\n\n}\n\n// eslint-disable-next-line\nfunction processPointArrayVSwitchPass(pointArray, lod, style, featureIndex, zIndex, eventInfo) {\n    let pointsGroups = [];\n    let i, li;\n\n    checkDPoints(pointArray);\n\n    if (pointArray['lines']) {  //use lines as points\n        pointsGroups = pointArray['lines'];\n    } else {\n        pointsGroups = [pointArray['points']];\n    }\n\n    if (!pointsGroups || pointsGroups.length == 0) {\n        return;\n    }\n\n\n    const visibility = getLayerPropertyValue(style, 'visibility-rel', pointArray, lod) ||\n                     getLayerPropertyValue(style, 'visibility-abs', pointArray, lod) ||\n                     getLayerPropertyValue(style, 'visibility', pointArray, lod);\n    const culling = getLayerPropertyValue(style, 'culling', pointArray, lod);\n    const hysteresis = getLayerPropertyValue(style, 'hysteresis', pointArray, lod);\n\n    let points, g, gl, totalPoints = 0;\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n        if (Array.isArray(points) && points.length > 0) {\n            totalPoints += points.length;\n        }\n    }\n\n    let center = [0,0,0];\n    const forceOrigin = globals.forceOrigin;\n    const bboxMin = globals.bboxMin;\n    const tileX = globals.tileX;\n    const tileY = globals.tileY;\n    const forceScale = globals.forceScale;\n    let p, p1;\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n\n        if (Array.isArray(points) && points.length > 0) {\n\n            //add ponints\n            for (i = 0, li = points.length; i < li; i++) {\n                p = points[i];\n                p1 = [p[0], p[1], p[2]];\n\n                if (forceOrigin) {\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n                }\n\n                if (forceScale != null) {\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n                }\n\n                center[0] += p1[0];\n                center[1] += p1[1];\n                center[2] += p1[2];\n            }\n        }\n    }\n\n    if (totalPoints > 0) {\n        center[0] /= totalPoints;\n        center[1] /= totalPoints;\n        center[2] /= totalPoints;\n    }\n\n    center[0] += bboxMin[0];//groupOrigin[0];\n    center[1] += bboxMin[1];//groupOrigin[1];\n    center[2] += bboxMin[2];//groupOrigin[2];\n\n    globals.signatureCounter++;\n    const signature = (\"\"+globals.signatureCounter);\n\n    postGroupMessageFast(5, 20, {\n        'z-index':zIndex, 'hysteresis' : hysteresis,\n        'visibility': visibility, 'culling': culling, 'center': center, 'eventInfo': {} /*(globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}*/,\n         'index': featureIndex, 'lod':(globals.autoLod ? null : globals.tileLod) }, [], signature);\n}\n\n\nfunction getOriginOffset(origin, width, height) { //TODO: fix pixel units\n    switch(origin) {\n    case 'top-left':        return [0, 0];\n    case 'top-right':       return [-width, 0];\n    case 'top-center':      return [-width*0.5, 0];\n    case 'center-left':     return [0, -height*0.5];\n    case 'center-right':    return [-width, -height*0.5];\n    case 'center-center':   return [-width*0.5, -height*0.5];\n    case 'bottom-left':     return [0, -height];\n    case 'bottom-right':    return [-width, -height];\n    case 'bottom-center':   return [-width*0.5, -height];\n    }\n}\n\n\nfunction processIcon(point, iconData, cloneBuffers) {\n\n    if (cloneBuffers) {\n        iconData.index = 0;\n        iconData.index2 = 0;\n        iconData.vertexBuffer = iconData.vertexBuffer ?  (new Float32Array(iconData.vertexBuffer.length)) : null;\n        iconData.originBuffer = iconData.originBuffer ?  (new Float32Array(iconData.originBuffer.length)) : null;\n        iconData.singleBuffer = iconData.singleBuffer ?  (new Float32Array(iconData.singleBuffer.length)) : null;\n    }\n\n    const icon = iconData.source;\n    let index = iconData.index;\n    let index2 = iconData.index2;\n    let lastIndex = index;\n\n    const width = Math.abs(icon[3] * iconData.scale * 0.5);\n    const height = Math.abs(icon[4] * iconData.scale * 0.5);\n\n    //get offset\n    const originOffset = getOriginOffset(iconData.origin, width, height);\n    const offsetX = originOffset[0] + iconData.offset[0];\n    const offsetY = originOffset[1] + iconData.offset[1];\n\n    if (iconData.singleBuffer) {\n        const b = iconData.singleBuffer;\n\n        b[0] = offsetX; b[1] = offsetY;\n        b[2] = icon[1];\n        b[3] = icon[2];\n\n        b[4] = width + offsetX; b[5] = offsetY;\n        b[6] = icon[1]+icon[3];\n        b[7] = icon[2];\n\n        b[8] = width + offsetX; b[9] = height + offsetY;\n        b[10] = icon[1]+icon[3];\n        b[11] = icon[2]+icon[4];\n\n        b[12] = offsetX; b[13] = height + offsetY;\n        b[14] = icon[1];\n        b[15] = icon[2]+icon[4];\n\n        return [offsetX * 0.5, offsetY * 0.5, (offsetX + width) * 0.5 + 1, (offsetY + height) *0.5];\n    }\n\n    const vertexBuffer = iconData.vertexBuffer;\n    const texcoordsBuffer = iconData.texcoordsBuffer;\n    const originBuffer = iconData.originBuffer;\n\n    //add polygon\n    vertexBuffer[index] = 0;\n    vertexBuffer[index+1] = 0;\n    vertexBuffer[index+2] = 0;\n    vertexBuffer[index+3] = 0;\n\n    vertexBuffer[index+4] = width;\n    vertexBuffer[index+5] = 0;\n    vertexBuffer[index+6] = 0;\n    vertexBuffer[index+7] = 0;\n\n    vertexBuffer[index+8] = width;\n    vertexBuffer[index+9] = -height;\n    vertexBuffer[index+10] = 0;\n    vertexBuffer[index+11] = 0;\n\n    texcoordsBuffer[index] = icon[1];\n    texcoordsBuffer[index+1] = icon[2];\n    texcoordsBuffer[index+2] = 0;\n    texcoordsBuffer[index+3] = 0;\n\n    texcoordsBuffer[index+4] = icon[1]+icon[3];\n    texcoordsBuffer[index+5] = icon[2];\n    texcoordsBuffer[index+6] = 0;\n    texcoordsBuffer[index+7] = 0;\n\n    texcoordsBuffer[index+8] = icon[1]+icon[3];\n    texcoordsBuffer[index+9] = icon[2]+icon[4];\n    texcoordsBuffer[index+10] = 0;\n    texcoordsBuffer[index+11] = 0;\n\n    index += 12;\n\n    //add polygon\n    vertexBuffer[index] = 0;\n    vertexBuffer[index+1] = 0;\n    vertexBuffer[index+2] = 0;\n    vertexBuffer[index+3] = 0;\n\n    vertexBuffer[index+4] = 0;\n    vertexBuffer[index+5] = -height;\n    vertexBuffer[index+6] = 0;\n    vertexBuffer[index+7] = 0;\n\n    vertexBuffer[index+8] = width;\n    vertexBuffer[index+9] = -height;\n    vertexBuffer[index+10] = 0;\n    vertexBuffer[index+11] = 0;\n\n    texcoordsBuffer[index] = icon[1];\n    texcoordsBuffer[index+1] = icon[2];\n    texcoordsBuffer[index+2] = 0;\n    texcoordsBuffer[index+3] = 0;\n\n    texcoordsBuffer[index+4] = icon[1];\n    texcoordsBuffer[index+5] = icon[2]+icon[4];\n    texcoordsBuffer[index+6] = 0;\n    texcoordsBuffer[index+7] = 0;\n\n    texcoordsBuffer[index+8] = icon[1]+icon[3];\n    texcoordsBuffer[index+9] = icon[2]+icon[4];\n    texcoordsBuffer[index+10] = 0;\n    texcoordsBuffer[index+11] = 0;\n\n    index += 12;\n\n    const p1 = point[0];\n    const p2 = point[1];\n    const p3 = point[2];\n\n    //set origin buffer and apply offset\n    for (let i = lastIndex; i < index; i+=4) {\n        vertexBuffer[i] += offsetX;\n        vertexBuffer[i+1] -= offsetY;\n\n        originBuffer[index2] = p1;\n        originBuffer[index2 + 1] = p2;\n        originBuffer[index2 + 2] = p3;\n        index2 += 3;\n    }\n\n    iconData.index = index;\n    iconData.index2 = index2;\n\n    return [offsetX * 0.5, offsetY * 0.5, (offsetX + width) * 0.5 + 1, (offsetY + height) *0.5];\n}\n\n\nfunction processLabel(point, labelData, cloneBuffers) {\n\n    if (cloneBuffers) {\n        labelData.index = 0;\n        labelData.index2 = 0;\n        labelData.vertexBuffer = labelData.vertexBuffer ?  (new Float32Array(labelData.vertexBuffer.length)) : null;\n        labelData.originBuffer = labelData.originBuffer ?  (new Float32Array(labelData.originBuffer.length)) : null;\n        labelData.singleBuffer = labelData.singleBuffer ?  (new Float32Array(labelData.singleBuffer.length)) : null;\n    }\n\n    const vertexBuffer = labelData.vertexBuffer;\n    const texcoordsBuffer = labelData.texcoordsBuffer;\n    const originBuffer = labelData.originBuffer;\n    let singleBuffer = labelData.singleBuffer;\n    let index = labelData.index;\n    let index2 = labelData.index2;\n    let lastIndex = index;\n    //let text = '' + labelData.text;\n    const fonts = labelData.fonts;\n    let planes = {}, i, li, res;\n    let glyphsRes = labelData.glyphsRes;\n\n    const linesGlyphsRes = [];\n    const linesGlyphsRes2 = [];\n\n    //split text to lines\n    do {\n        res = glyphsRes[2].indexOf(10); //search /n\n\n        if (res != -1) {\n            linesGlyphsRes.push([glyphsRes[0].slice(0,res), glyphsRes[1].slice(0,res), glyphsRes[2].slice(0,res)]);\n            glyphsRes = [glyphsRes[0].slice(res+1), glyphsRes[1].slice(res+1), glyphsRes[2].slice(res+1)];\n        } else {\n            linesGlyphsRes.push(glyphsRes);\n        }\n\n    } while (res != -1);\n\n    //split lines by width\n    for (let i = 0, li = linesGlyphsRes.length; i < li; i++) {\n\n        glyphsRes = linesGlyphsRes[i];\n\n        // eslint-disable-next-line\n        do {\n            const splitIndex = getSplitIndex(null, labelData.width, labelData.size, labelData.spacing, fonts, glyphsRes);\n            const codes = glyphsRes[2];\n\n            if (codes.length == splitIndex) {\n                linesGlyphsRes2.push(glyphsRes);\n                break;\n            }\n\n            linesGlyphsRes2.push([glyphsRes[0].slice(0,splitIndex), glyphsRes[1].slice(0,splitIndex), glyphsRes[2].slice(0,splitIndex)]);\n\n            glyphsRes = [glyphsRes[0].slice(splitIndex+1), glyphsRes[1].slice(splitIndex+1), glyphsRes[2].slice(splitIndex+1)];\n\n        // eslint-disable-next-line\n        } while(true);\n\n    }\n\n    let x = 0, y = 0;\n    let lineHeight = getLineHeight(labelData.size, labelData.lineHeight, fonts);\n    let maxWidth = 0;\n    let lineWidths = [];\n\n    //get max width\n    for (i = 0, li = linesGlyphsRes2.length; i < li; i++) {\n        lineWidths[i] = getTextLength(null, labelData.size, labelData.spacing, fonts, linesGlyphsRes2[i]);\n        maxWidth = Math.max(lineWidths[i], maxWidth);\n    }\n\n    //generate text\n    for (i = 0, li = linesGlyphsRes2.length; i < li; i++) {\n        const textWidth = lineWidths[i];\n\n        switch(labelData.align) {\n        case 'left': x = 0; break;\n        case 'right': x = maxWidth - textWidth; break;\n        case 'center': x = (maxWidth - textWidth)*0.5; break;\n        }\n\n        index = addText([x,y,0], [1,0,0], null, labelData.size, labelData.spacing, fonts, vertexBuffer, texcoordsBuffer, true, index, planes, linesGlyphsRes2[i], singleBuffer);\n        y -= lineHeight;\n    }\n\n    //get offset\n    const originOffset = getOriginOffset(labelData.origin, maxWidth, -y);\n    const offsetX = originOffset[0] + labelData.offset[0];\n    const offsetY = originOffset[1] + labelData.offset[1];\n\n    const p1 = point[0];\n    const p2 = point[1];\n    const p3 = point[2];\n\n    //set origin buffer and apply offset\n    if (!singleBuffer) {\n        for (i = lastIndex; i < index; i+=4) {\n            vertexBuffer[i] += offsetX;\n            vertexBuffer[i+1] -= offsetY;\n\n            originBuffer[index2] = p1;\n            originBuffer[index2 + 1] = p2;\n            originBuffer[index2 + 2] = p3;\n            index2 += 3;\n        }\n    } else {\n        for (i = lastIndex; i < index; i+=8) {\n            singleBuffer[i] += offsetX;\n            singleBuffer[i+1] -= offsetY;\n            singleBuffer[i+2] += offsetX;\n            singleBuffer[i+3] -= offsetY;\n        }\n\n        labelData.pos = [p1,p2,p3];\n        singleBuffer = new Float32Array(singleBuffer.buffer, 0, index);\n    }\n\n    //const fonts = labelData.fonts;\n    labelData.files = new Array(fonts.length);\n\n    for (i = 0, li= fonts.length; i < li; i++) {\n        labelData.files[i] = [];\n    }\n\n    for (let key in planes) {\n        const fontIndex = parseInt(key);\n        const planes2 = planes[key];\n\n        const files = [];\n\n        for (let key2 in planes2) {\n            const plane = parseInt(key2) - (fontIndex*4000);\n            const file = Math.round((plane - (plane % 4)) / 4);\n\n            if (files.indexOf(file) == -1) {\n                files.push(file);\n            }\n        }\n\n        labelData.files[fontIndex] = files;\n    }\n\n    labelData.index = index;\n    labelData.index2 = index2;\n\n    return [offsetX * 0.5, offsetY * 0.5, (offsetX + maxWidth) * 0.5 + 1, (offsetY + Math.abs(y)) *0.5];\n}\n\nfunction processPointArrayGeometry(pointArray) {\n\n    checkDPoints(pointArray);\n\n    let pointsGroups;\n\n    if (pointArray['lines']) {  //use lines as points\n        pointsGroups = pointArray['lines'];\n    } else {\n        pointsGroups = [pointArray['points']];\n    }\n\n    if (!pointsGroups || pointsGroups.length == 0) {\n        return;\n    }\n\n    let totalPoints = 0;\n    const indicesBuffer = new Uint32Array(pointsGroups.length);\n\n    for (let i = 0; i < pointsGroups.length; i++) {\n        indicesBuffer[i] = totalPoints;\n\n        if (Array.isArray(pointsGroups[i])) {\n            totalPoints += pointsGroups[i].length;\n        }\n    }\n\n    const geometryBuffer = new Float64Array(totalPoints * 3);\n\n    /*const forceOrigin = globals.forceOrigin;\n    const tileX = globals.tileX;\n    const tileY = globals.tileY;*/\n    const forceScale = globals.forceScale;\n    let index = 0, p1, pp, p;\n\n    for (let i = 0; i < pointsGroups.length; i++) {\n        if (!Array.isArray(pointsGroups[i]) || !pointsGroups[i].length) {\n            continue;\n        }\n\n        const points = pointsGroups[i];\n\n        p = points[0];\n        p1 = [p[0], p[1], p[2]];\n\n        //add lines\n        for (let j = 0, lj = points.length; j < lj; j++) {\n\n            /*if (forceOrigin) {\n                pp = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n            }*/\n\n            if (forceScale != null) {\n                pp = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n            }\n\n            geometryBuffer[index] = pp[0];\n            geometryBuffer[index+1] = pp[1];\n            geometryBuffer[index+2] = pp[2];\n            index += 3;\n\n            if (j == (lj - 1)) {\n                break;\n            }\n\n            p1 = points[j+1];\n        }\n    }\n\n    globals.signatureCounter++;\n    postGroupMessageFast(5, 5, {\n        'id':pointArray['id'] }, [geometryBuffer, indicesBuffer], (\"\"+globals.signatureCounter));\n}\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/map/geodata-processor/worker-polygon.js\":\n/*!**********************************************************!*\\\n  !*** ./src/core/map/geodata-processor/worker-polygon.js ***!\n  \\**********************************************************/\n/*! exports provided: processPolygonPass */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processPolygonPass\", function() { return processPolygonPass; });\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \"./src/core/map/geodata-processor/worker-globals.js\");\n/* harmony import */ var _worker_style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-style.js */ \"./src/core/map/geodata-processor/worker-style.js\");\n/* harmony import */ var _worker_message_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker-message.js */ \"./src/core/map/geodata-processor/worker-message.js\");\n/* harmony import */ var _worker_linestring_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./worker-linestring.js */ \"./src/core/map/geodata-processor/worker-linestring.js\");\n/* harmony import */ var _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./worker-pointarray.js */ \"./src/core/map/geodata-processor/worker-pointarray.js\");\n\n\n\n\n\n\n\n//get rid of compiler mess\nconst globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"globals\"], vec3Normalize = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3Normalize\"];\nconst getLayerPropertyValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\"getLayerPropertyValue\"];\nconst postGroupMessageFast = _worker_message_js__WEBPACK_IMPORTED_MODULE_2__[\"postGroupMessageFast\"];\nconst processLineStringPass = _worker_linestring_js__WEBPACK_IMPORTED_MODULE_3__[\"processLineStringPass\"];\nconst processPointArrayPass = _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__[\"processPointArrayPass\"];\n\nfunction processPolygonPass(polygon, lod, style, featureIndex, zIndex, eventInfo) {\n    const vertices = polygon['vertices'] || [];\n    if (vertices.length == 0) {\n        return;\n    }\n\n    // borders as points\n    if (getLayerPropertyValue(style, 'point', polygon, lod) ||\n        getLayerPropertyValue(style, 'label', polygon, lod)) {\n        processPolygonLines(polygon, vertices, lod, style, featureIndex, zIndex, eventInfo, false);\n    }\n\n    // borders as lines\n    if (getLayerPropertyValue(style, 'line', polygon, lod) ||\n        getLayerPropertyValue(style, 'line-label', polygon, lod)) {\n        processPolygonLines(polygon, vertices, lod, style, featureIndex, zIndex, eventInfo, true);\n    }\n\n    const spolygon = getLayerPropertyValue(style, 'polygon', polygon, lod);\n\n    if (!spolygon) {\n        return;\n    }\n\n    const surface = polygon['surface'] || [];\n    if (surface.length == 0) {\n        return;\n    }\n\n    const hoverEvent = getLayerPropertyValue(style, 'hover-event', polygon, lod);\n    const clickEvent = getLayerPropertyValue(style, 'click-event', polygon, lod);\n    const drawEvent = getLayerPropertyValue(style, 'draw-event', polygon, lod);\n    const enterEvent = getLayerPropertyValue(style, 'enter-event', polygon, lod);\n    const leaveEvent = getLayerPropertyValue(style, 'leave-event', polygon, lod);\n    const advancedHit = getLayerPropertyValue(style, 'advanced-hit', polygon, lod);\n\n    const zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', polygon, lod);\n\n    const polygonColor = getLayerPropertyValue(style, 'polygon-color', polygon, lod);\n    const polygonStencil = getLayerPropertyValue(style, 'polygon-use-stencil', polygon, lod);\n    const polygonExtrude = getLayerPropertyValue(style, 'polygon-extrude', polygon, lod);\n    let polygonStyle = getLayerPropertyValue(style, 'polygon-style', polygon, lod);\n    let polygonCulling = getLayerPropertyValue(style, 'polygon-culling', polygon, lod);\n\n    polygonStyle = (polygonStyle == 'flatshade') ? 1 : 0;\n    polygonCulling = (polygonCulling == 'back') ? 1 : 0;\n\n    const geocent = globals.geocent;\n    const bboxMin = globals.bboxMin;\n    let center = [0,0,0], n = [0,0,0];\n\n    // allocate vertex buffer\n    const trisCount = surface.length / 3;\n    const vertexCount = trisCount * 3;\n    let vertexBuffer = new Float32Array(vertexCount * 3), vertexBuffer2;\n\n    let surfaceI = 0;\n    let index = 0;\n    let p1 = [0,0,0], p2 = [0,0,0], p3 = [0,0,0], p4 = [0,0,0];\n    let offs, j, lj;\n\n    const tileX = globals.tileX;\n    const tileY = globals.tileY;\n    const forceOrigin = globals.forceOrigin;\n    const forceScale = globals.forceScale;\n\n    //debugger\n\n    //console.log(\"vertexCount = \" + vertexCount);\n    //add tris\n    for (let i = 0; i < vertexCount; i++) {\n        offs = 3 * surface[surfaceI++];\n        p1 = [vertices[offs], vertices[offs+1], vertices[offs+2]];\n\n        if (forceOrigin) {\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n        }\n\n        if (forceScale != null) {\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n        }\n\n        if (polygonExtrude) {\n            if (geocent) {\n                vec3Normalize([p1[0] + bboxMin[0], p1[1] + bboxMin[1], p1[2] + bboxMin[2]], n);\n                p1[0] += n[0] * polygonExtrude;\n                p1[1] += n[1] * polygonExtrude;\n                p1[2] += n[2] * polygonExtrude;\n            } else {\n                p1[2] += polygonExtrude;\n            }\n        }\n\n        center[0] += p1[0];\n        center[1] += p1[1];\n        center[2] += p1[2];\n\n        //add vertex\n        vertexBuffer[index++] = p1[0];\n        vertexBuffer[index++] = p1[1];\n        vertexBuffer[index++] = p1[2];\n    }\n\n    //console.log( \"vertexBuffer: \" + vertexBuffer );\n\n    if (vertexCount > 0) {\n        const k = 1.0 / vertexCount;\n        center[0] *= k;\n        center[1] *= k;\n        center[2] *= k;\n    }\n\n    center[0] += globals.groupOrigin[0];\n    center[1] += globals.groupOrigin[1];\n    center[2] += globals.groupOrigin[2];\n\n    const borders = polygon['borders'] || [];\n    if (borders.length > 0) {\n\n        let totalFaces = 0;\n\n        for (let i = 0, li = borders.length; i < li; i++) {\n            const border = borders[i];\n            totalFaces += (border.length + 1) * 2;\n        }\n\n        vertexBuffer2 = vertexBuffer;\n        vertexBuffer = new Float32Array(vertexBuffer.length + (totalFaces * 3 * 3));\n        vertexBuffer.set(vertexBuffer2);\n\n        for (let i = 0, li = borders.length; i < li; i++) {\n            const border = borders[i];\n            let offset;\n\n            for (j = 0, lj = border.length; j < lj; j++) {\n\n                if (border[j] >= 0) {\n                    offset = 3 * border[j];\n                } else {\n                    offset = 3 * (-border[j]);\n                }\n\n                p1[0] = vertices[offset];\n                p1[1] = vertices[offset+1];\n                p1[2] = vertices[offset+2];\n\n                p3[0] = vertices[offset];\n                p3[1] = vertices[offset+1];\n                p3[2] = vertices[offset+2];\n\n                if (j < lj - 1) {\n                    if (border[j+1] >= 0) {\n                        offset = 3 * border[j+1];\n                    } else {\n                        offset = 3 * (-border[j+1]);\n                    }\n                } else {\n                    if (border[0] >= 0) {\n                        offset = 3 * border[0];\n                    } else {\n                        offset = 3 * (-border[0]);\n                    }\n                }\n\n                p2[0] = vertices[offset];\n                p2[1] = vertices[offset+1];\n                p2[2] = vertices[offset+2];\n\n                p4[0] = vertices[offset];\n                p4[1] = vertices[offset+1];\n                p4[2] = vertices[offset+2];\n\n                if (forceOrigin) {\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n                    p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n                    p3 = [p3[0] - tileX, p3[1] - tileY, p3[2]];\n                    p4 = [p4[0] - tileX, p4[1] - tileY, p4[2]];\n                }\n\n                if (forceScale != null) {\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n                    p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n                    p3 = [p3[0] * forceScale[0], p3[1] * forceScale[1], p3[2] * forceScale[2]];\n                    p4 = [p4[0] * forceScale[0], p4[1] * forceScale[1], p4[2] * forceScale[2]];\n                }\n\n                if (polygonExtrude) {\n                    if (geocent) {\n                        vec3Normalize([p1[0] + bboxMin[0], p1[1] + bboxMin[1], p1[2] + bboxMin[2]], n);\n                        p1 = [p1[0] + n[0] * polygonExtrude, p1[1] + n[1] * polygonExtrude, p1[2] + n[2] * polygonExtrude];\n\n                        vec3Normalize([p2[0] + bboxMin[0], p2[1] + bboxMin[1], p2[2] + bboxMin[2]], n);\n                        p2 = [p2[0] + n[0] * polygonExtrude, p2[1] + n[1] * polygonExtrude, p2[2] + n[2] * polygonExtrude];\n                    } else {\n                        p1[2] += polygonExtrude;\n                        p2[2] += polygonExtrude;\n                    }\n                }\n\n                vertexBuffer[index] = p4[0];\n                vertexBuffer[index+1] = p4[1];\n                vertexBuffer[index+2] = p4[2];\n\n                vertexBuffer[index+3] = p2[0];\n                vertexBuffer[index+4] = p2[1];\n                vertexBuffer[index+5] = p2[2];\n\n                vertexBuffer[index+6] = p1[0];\n                vertexBuffer[index+7] = p1[1];\n                vertexBuffer[index+8] = p1[2];\n\n                vertexBuffer[index+9] = p1[0];\n                vertexBuffer[index+10] = p1[1];\n                vertexBuffer[index+11] = p1[2];\n\n                vertexBuffer[index+12] = p3[0];\n                vertexBuffer[index+13] = p3[1];\n                vertexBuffer[index+14] = p3[2];\n\n                vertexBuffer[index+15] = p4[0];\n                vertexBuffer[index+16] = p4[1];\n                vertexBuffer[index+17] = p4[2];\n\n                index += 18;\n            }\n        }\n    }\n\n    const hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\n\n    const signature = JSON.stringify({\n        style: polygonStyle,\n        culling: polygonCulling,\n        stencil: polygonStencil,\n        color : polygonColor,\n        zIndex : zIndex,\n        zOffset : zbufferOffset,\n        state : globals.hitState\n    });\n\n    //debugger\n\n    postGroupMessageFast(5, 13, {\n        'color':polygonColor, 'z-index':zIndex, 'center': center, 'advancedHit': advancedHit, 'culling': polygonCulling,\n        'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'style' : polygonStyle, 'stencil': polygonStencil,\n        'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n        'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\n        'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer], signature);\n}\n\nfunction createEmptyFeatureFromPolygon(polygon) {\n    const feature = {};\n    for(let key in polygon) {\n        if(key != 'surface' && key != 'vertices' && key != 'borders') {\n            feature[key] = polygon[key];\n        }\n    }\n    return feature;\n}\n\nfunction processPolygonLines(polygon, vertices, lod, style, featureIndex, zIndex, eventInfo, processLines) {\n    const borders = polygon['borders'] || [];\n    if (borders.length == 0) {\n        return;\n    }\n    const polygonExtrude = getLayerPropertyValue(style, 'polygon-extrude', polygon, lod);\n    const feature = createEmptyFeatureFromPolygon(polygon);\n    const bordersCount = borders.length;\n    let allPoints = [], allPoints2 = [];\n    let p, p2, n = [0,0,0];\n\n    const tileX = globals.tileX;\n    const tileY = globals.tileY;\n    const forceOrigin = globals.forceOrigin;\n    const forceScale = globals.forceScale;\n    const forceScale2 = [1.0/forceScale[0], 1.0/forceScale[1], 1.0/forceScale[2]];\n    const geocent = globals.geocent;\n    const bboxMin = globals.bboxMin;\n\n    for (let j = 0; j < bordersCount; j++) {\n        const border = borders[j];\n        let pointsCount = border.length;\n        let pointsCount2 = 0;\n        let offset;\n\n        if (pointsCount > 0) {\n            let points, points2, points3, points4, i;\n            if (processLines) {\n                points = new Array(pointsCount + 1);\n                points3 = new Array(pointsCount + 1);\n            } else {\n                points = new Array(pointsCount);\n                points3 = new Array(pointsCount);\n            }\n            for (i = 0; i < pointsCount; i++) {\n                if (border[i] >= 0) {\n                    offset = 3 * border[i];\n                    pointsCount2++; // count vertices with positive index\n                } else {\n                    offset = 3 * (-border[i]);\n                }\n\n                if (polygonExtrude) {\n                    p = [vertices[offset], vertices[offset+1], vertices[offset+2]];\n                    p2 = p.slice();\n\n                    if (forceOrigin) {\n                        p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n                    }\n\n                    if (forceScale != null) {\n                        p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n                    }\n\n                    if (geocent) {\n                        vec3Normalize([p2[0] + bboxMin[0], p2[1] + bboxMin[1], p2[2] + bboxMin[2]], n);\n                        p2 = [p[0] + (n[0] * polygonExtrude) * forceScale2[0], p[1] + (n[1] * polygonExtrude) * forceScale2[1], p[2] + (n[2] * polygonExtrude) * forceScale2[2]];\n                    } else {\n                        p2[2] += polygonExtrude;\n                    }\n\n                    points[i] = p;\n                    points3[i] = p2;\n\n                    if (border[i] >= 0) {\n                        allPoints.push([p,p2]);\n                    }\n\n                } else {\n                    points[i] = [vertices[offset], vertices[offset+1], vertices[offset+2]];\n                }\n\n                if (processLines && i == 0) {\n                    points[pointsCount] = points[0];\n                    points3[pointsCount] = points3[0];\n                }\n            }\n\n            points2 = new Array(pointsCount2);\n            points4 = new Array(pointsCount2);\n            let i2 = 0;\n            //debugger\n\n            //create array of points only for vertices with positive value\n            for (i = 0; i < pointsCount; i++) {\n                if (border[i] >= 0) {\n                    points2[i2] = points[i].slice();\n\n                    if (polygonExtrude) {\n                        points4[i2] = points3[i].slice();\n                    }\n\n                    i2++;\n                }\n            }\n\n            allPoints.push(points);\n            allPoints2 = allPoints2.concat(points2);\n\n            if (polygonExtrude) {\n                allPoints.push(points3);\n                allPoints2 = allPoints2.concat(points4);\n            }\n\n        }\n    }\n\n    if(processLines && allPoints.length > 0) {\n        feature['lines'] = allPoints;\n        processLineStringPass(feature, lod, style, featureIndex, zIndex, eventInfo);\n    } else if(allPoints2.length > 0) {\n        feature['points'] = allPoints2;\n        processPointArrayPass(feature, lod, style, featureIndex, zIndex, eventInfo);\n    }\n\n}\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/map/geodata-processor/worker-style.js\":\n/*!********************************************************!*\\\n  !*** ./src/core/map/geodata-processor/worker-style.js ***!\n  \\********************************************************/\n/*! exports provided: getFilterResult, processStylesheet, getLayer, getLayerPropertyValue, getLayerExpresionValue, getLayerPropertyValueInner, makeFasterFilter, hasLayerProperty */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFilterResult\", function() { return getFilterResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"processStylesheet\", function() { return processStylesheet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLayer\", function() { return getLayer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLayerPropertyValue\", function() { return getLayerPropertyValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLayerExpresionValue\", function() { return getLayerExpresionValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLayerPropertyValueInner\", function() { return getLayerPropertyValueInner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeFasterFilter\", function() { return makeFasterFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasLayerProperty\", function() { return hasLayerProperty; });\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \"./src/core/map/geodata-processor/worker-globals.js\");\n/* harmony import */ var _worker_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-text.js */ \"./src/core/map/geodata-processor/worker-text.js\");\n\n\n\n\n//get rid of compiler mess\nconst globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"globals\"];\nconst clamp = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"clamp\"];\nconst simpleFmtCall = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"simpleFmtCall\"];\nconst getHash = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"getHash\"];\nconst hasLatin = _worker_text_js__WEBPACK_IMPORTED_MODULE_1__[\"hasLatin\"], isCJK = _worker_text_js__WEBPACK_IMPORTED_MODULE_1__[\"isCJK\"];\nconst areTextCharactersAvailable = _worker_text_js__WEBPACK_IMPORTED_MODULE_1__[\"areTextCharactersAvailable\"];\n\n\nfunction getLayer(layerId, featureType, index) {\n    const layer = globals.stylesheetData.layers[layerId];\n    if (layer == null) {\n        logError('wrong-Layer', layerId, null, null, index, featureType);\n        return {};\n    } else {\n        return layer;\n    }\n}\n\n\nfunction getLayerExpresionValue(layer, value, feature, lod, key, depth) {\n    let finalValue;\n    if (!depth) {\n        depth = 0;\n    }\n    if (depth > 100) {\n        return void(0);\n    }\n\n\n    switch(typeof value) {\n    case 'string':\n\n        if (value.length > 0) {\n\n            switch (value.charAt(0)) {\n                case '#':\n                case '$':\n                case '@':\n                case '&':\n                case '%':\n\n                    finalValue = getLayerPropertyValueInnerString(layer, key, feature, lod, value, depth + 1);\n\n                    if (typeof finalValue == 'undefined') {\n                        logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\n                    }\n\n                    return finalValue;\n            }\n\n\n            return simpleFmtCall(value, (function(str){\n\n                if (str.length > 0) {\n\n                    switch (str.charAt(0)) {\n                        case '#':\n                        case '$':\n                        case '@':\n                        case '&':\n                        case '%':\n\n                            finalValue = getLayerPropertyValueInnerString(layer, key, feature, lod, str, depth + 1);\n\n                            if (typeof finalValue == 'undefined') {\n                                logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\n                            }\n\n                            return finalValue;\n                    }\n\n                    if (str.indexOf('{') != -1) {\n\n                        try {\n                            str = str.replace(/'/g, '\"');\n                            finalValue = JSON.parse(str);\n                        } catch(e) {\n                            logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\n                            return \"\";\n                        }\n\n                        if (typeof finalValue == 'undefined') {\n                            logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\n                            return \"\";\n                        } else {\n                            return getLayerPropertyValueInner(layer, key, feature, lod, finalValue, depth + 1);\n                        }\n\n                    } else {\n                        return str;\n                    }\n\n                }\n\n            }));\n        }\n\n        break;\n    }\n\n    return value;\n}\n\n\nfunction hasLayerProperty(layer, key) {\n    return (typeof layer[key] !== 'undefined');\n}\n\n\nfunction getLayerPropertyValue(layer, key, feature, lod) {\n    const value = getLayerPropertyValueInner(layer, key, feature, lod);\n    return validateLayerPropertyValue(layer['$$layer-id'], key, value);\n}\n\n\nfunction getLayerPropertyValueInnerString(layer, key, feature, lod, value, depth) {\n    let finalValue = value;\n\n    //is it feature property, variable or constant?\n    switch(value.charAt(0)) {\n        case '$': finalValue = feature.properties[value.substr(1)]; break;\n        case '@': finalValue = globals.stylesheetConstants[value]; break;\n        case '%': finalValue = globals.stylesheetVariables[value.substr(1)]; break;\n        case '&': finalValue = globals.stylesheetLocals[value]; break;\n        case '#':\n            //debugger;\n            switch(value) {\n                case '#id':        return feature.id;\n                case '#type':      return globals.featureType;\n                case '#group':     return globals.groupId;\n                case '#lod':       return globals.tileLod;\n                case '#ix':        return globals.tileIX;\n                case '#iy':        return globals.tileIY;\n                case '#tileSize':  return globals.tileSize;\n                case '#pixelSize': return globals.pixelSize;\n                case '#metric':    return globals.metricUnits;\n                case '#dpr':       return globals.pixelFactor;\n                case '#language':  return globals.language;\n            }\n            break;\n    }\n\n    if (value.charAt(0) == '&') {\n        if (typeof finalValue === 'undefined') {\n            finalValue = layer[value];\n            if (typeof finalValue !== 'undefined') {\n\n                if (typeof finalValue === 'string') {\n                    finalValue = getLayerExpresionValue(layer, finalValue, feature, lod, key, depth+1);\n                } else {\n                    if (typeof finalValue !== 'undefined') {\n                        finalValue = getLayerPropertyValueInner(layer, key, feature, lod, finalValue, depth+1);\n                    }\n                }\n\n                globals.stylesheetLocals[value] = finalValue;\n            }\n        }\n    } else { // @,$,%\n\n        if (typeof finalValue === 'string') {\n            finalValue = getLayerExpresionValue(layer, finalValue, feature, lod, key, depth+1);\n        } else {\n            if (typeof finalValue !== 'undefined' && value.charAt(0) == '@') {\n                finalValue = getLayerPropertyValueInner(layer, key, feature, lod, finalValue, depth+1);\n            }\n        }\n\n    }\n\n    return finalValue;\n}\n\nfunction getLayerPropertyValueInner(layer, key, feature, lod, value, depth) {\n    let index = 0, i, li, finalValue, root, v1, v2, v3, v4;\n    let tmpValue;\n\n    if ((typeof value) === 'undefined') {\n        /*\n        if (layer[key]) {\n            value = JSON.parse(JSON.stringify(layer[key])); //make copy\n        } else {\n            value = layer[key];\n        }*/\n\n        value = layer[key];\n\n        root = true;\n        depth = 0;\n    } else {\n        if (depth > 100) {\n            return void(0);\n        }\n    }\n\n    switch(typeof value) {\n    case 'string':\n\n        if (value.length > 0) {\n            finalValue = getLayerPropertyValueInnerString(layer, key, feature, lod, value, depth);\n\n            if (typeof finalValue !== 'undefined') {\n                return finalValue;\n            } else {\n                logError('wrong-object', layer['$$layer-id'], key, value, null, 'feature-property');\n\n                if (root) {\n                    return getDefaultLayerPropertyValue(key);\n                } else {\n                    return void(0);\n                }\n            }\n        }\n\n        return value;\n\n    case 'object':\n        {\n                //is it null?\n            if (value == null) {\n                if (root) {\n                    return getDefaultLayerPropertyValue(key);\n                } else {\n                    return void(0);\n                }\n            }\n\n            //is it array (rgb, rgba, vec2)?\n            if (Array.isArray(value)) {\n\n                if (key == 'icon-source') {\n                    //index++;\n                    if (globals.stylesheetBitmaps[value[0]] == null) {\n                        logError('wrong-object', layer['$$layer-id'], key, value, null, 'bitmap');\n\n                        if (root) {\n                            return getDefaultLayerPropertyValue(key);\n                        } else {\n                            return void(0);\n                        }\n                    }\n                }\n\n                if (key != 'filter') {\n                    tmpValue = new Array(value.length);\n\n                    for (i = index, li = value.length; i < li; i++) {\n                        tmpValue[i] = getLayerPropertyValueInner(layer, key, feature, lod, value[i], depth + 1);\n                    }\n\n                    return tmpValue;\n                }\n\n                return value;\n            }\n\n            let functionName, functionValue, functionError, finalValue;\n\n            for (functionName in value) {\n                break;\n            }\n\n            if (!functionName) {\n                if (root) {\n                    return getDefaultLayerPropertyValue(key);\n                } else {\n                    return void(0);\n                }\n            }\n\n            functionValue = value[functionName];\n\n            switch (functionName) {\n                case 'if':\n\n                    if (!Array.isArray(functionValue) || functionValue.length != 3) {\n                        functionError = true;\n                    } else {\n                        if (getFilterResult(functionValue[0], feature, globals.featureType, globals.groupId, layer, key, lod, 0)) {\n                            finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\n                        } else {\n                            finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\n                        }\n\n                        if (typeof finalValue === 'undefined') {\n                            functionError = true;\n                        } else {\n                            return finalValue;\n                        }\n                    }\n\n                    break;\n\n                case 'add':\n                case 'sub':\n                case 'mul':\n                case 'div':\n                case 'mod':\n                case 'pow':\n                case 'tofixed':\n                case 'atan2':\n                case 'random':\n\n                    if (!Array.isArray(functionValue) || functionValue.length != 2) {\n                        functionError = true;\n                    } else {\n\n                        v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n                        v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\n\n                        if (typeof v1 !== 'number' || typeof v2 !== 'number') {\n                            functionError = true;\n                        } else {\n                            switch (functionName) {\n                                case 'add':    return v1 + v2;\n                                case 'sub':    return v1 - v2;\n                                case 'mul':    return v1 * v2;\n                                case 'div':    return v1 / v2;\n                                case 'mod':    return v1 % v2;\n                                case 'pow':    return Math.pow(v1, v2);\n                                case 'atan2':  return Math.atan2(v1, v2);\n                                case 'tofixed': return v1.tofixed(v2);\n                                case 'random': return v1 + Math.random() * (v2-v1);\n                            }\n                        }\n                    }\n\n                    break;\n\n                case 'clamp':\n\n                    if (!Array.isArray(functionValue) || functionValue.length != 3) {\n                        functionError = true;\n                    } else {\n\n                        v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n                        v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\n                        v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\n\n                        if (typeof v1 !== 'number' || typeof v2 !== 'number' || typeof v3 !== 'number') {\n                            functionError = true;\n                        } else {\n                            return clamp(v1, v2, v3);\n                        }\n                    }\n\n                    break;\n\n                case 'logScale':\n                case 'log-scale':\n\n                    if (!Array.isArray(functionValue) || functionValue.length < 2) {\n                        functionError = true;\n                    } else {\n\n                        v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n                        v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\n                        v3 = 0, v4 = 100;\n\n                        if (functionValue.length > 2) {\n                            v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\n\n                            if (typeof v3 !== 'number') {\n                                functionError = true;\n                            }\n                        }\n\n                        if (functionValue.length > 3) {\n                            v4 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[3], depth + 1);\n\n                            if (typeof v4 !== 'number') {\n                                functionError = true;\n                            }\n                        }\n\n                        if (functionError || typeof v1 !== 'number' || typeof v2 !== 'number') {\n                            functionError = true;\n                        } else {\n                            const imax = v4, imin = v3, smax = v2;\n                            let s = v1, p, i;\n\n                            if (s > smax) s = smax;\n\n                            p = (imax - imin) / Math.log(smax + 1);\n                            i = p * Math.log(s + 1) + imin;\n\n                            return i;\n                        }\n                    }\n\n                    break;\n\n\n                case 'sgn':\n                case 'sin':\n                case 'cos':\n                case 'tan':\n                case 'asin':\n                case 'acos':\n                case 'atan':\n                case 'sqrt':\n                case 'abs':\n                case 'log':\n                case 'round':\n                case 'floor':\n                case 'ceil':\n                case 'deg2rad':\n                case 'rad2deg':\n\n                    functionValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue, depth + 1);\n\n                    if (typeof functionValue !== 'number') {\n                        functionError = true;\n                    } else {\n                        switch (functionName) {\n                            case 'sgn':  return functionValue < 0 ? -1 : 1;\n                            case 'sin':  return Math.sin(functionValue);\n                            case 'cos':  return Math.cos(functionValue);\n                            case 'tan':  return Math.tan(functionValue);\n                            case 'asin': return Math.asin(functionValue);\n                            case 'acos': return Math.acos(functionValue);\n                            case 'atan': return Math.atan(functionValue);\n                            case 'sqrt': return Math.sqrt(functionValue);\n                            case 'abs':  return Math.abs(functionValue);\n                            case 'log':  return Math.log(functionValue);\n                            case 'round': return Math.round(functionValue);\n                            case 'floor': return Math.floor(functionValue);\n                            case 'ceil':  return Math.ceil(functionValue);\n                            case 'deg2rad':  return (functionValue / 180) * Math.PI;\n                            case 'rad2deg':  return (functionValue / Math.PI) * 180;\n                        }\n                    }\n\n                    break;\n\n                case 'strlen':\n                case 'trim':\n                case 'str2num':\n                case 'lowercase':\n                case 'uppercase':\n                case 'capitalize':\n                case 'has-fonts':\n                case 'has-latin':\n                case 'is-cjk':\n\n                    functionValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue, depth + 1);\n\n                    if (typeof functionValue !== 'string') {\n                        if (typeof functionValue === 'number') {\n                            return functionValue;\n                        } else {\n                            functionError = true;\n                        }\n                    } else {\n                        switch (functionName) {\n                            case 'strlen':     return functionValue.length;\n                            case 'trim':       return functionValue.trim();\n                            case 'str2num':    return parseFloat(functionValue);\n                            case 'lowercase':  return functionValue.toLowerCase();\n                            case 'uppercase':  return functionValue.toUpperCase();\n                            case 'capitalize': return functionValue.replace(/(?:^|\\s)\\S/g, function(a) { return a.toUpperCase(); });\n                            case 'has-fonts':  return areTextCharactersAvailable(functionValue);\n                            case 'has-latin':  return hasLatin(functionValue);\n                            case 'is-cjk':     return isCJK(functionValue);\n                        }\n                    }\n\n                    break;\n\n                case 'find':\n                case 'replace':\n                case 'substr':\n\n                    if (Array.isArray(functionValue) && functionValue.length >= 2) {\n\n                        v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n                        v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\n\n                        if (functionName == 'find' && typeof v1 === 'string' && typeof v2 === 'string') {\n                            return v1.indexOf(v2);\n                        }\n\n                        if (functionName == 'replace' && functionValue.length == 3) {\n\n                            v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\n\n                            if (typeof v1 === 'string' && typeof v2 === 'string' && typeof v3 === 'string') {\n                                return v1.replace(v2,v3);\n                            }\n                        }\n\n                        if (functionName == 'substr') {\n\n                            if (functionValue.length == 2) {\n                                if (typeof v1 === 'string' && typeof v2 === 'number') {\n                                    return v1.substr(v2);\n                                }\n                            } else {\n                                v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\n\n                                if (typeof v1 === 'string' && typeof v2 === 'number' && typeof v3 === 'number') {\n                                    return v1.substr(v2,v3);\n                                }\n                            }\n                        }\n\n                    }\n\n                    functionError = true;\n                    break;\n\n                case 'min':\n                case 'max':\n\n                    if (!Array.isArray(functionValue)) {\n                        functionError = true;\n                    } else {\n\n                        finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n\n                        for (i = index, li = functionValue.length; i < li; i++) {\n                            tmpValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[i], depth + 1);\n\n                            if (typeof tmpValue !== 'number') {\n                                functionError = true;\n                                break;\n                            }\n\n                            if (functionName == 'max') {\n                                finalValue = Math.max(finalValue, tmpValue);\n                            } else {\n                                finalValue = Math.min(finalValue, tmpValue);\n                            }\n                        }\n\n                        return finalValue;\n                    }\n\n                    break;\n\n                case 'map':\n\n                    if (!Array.isArray(functionValue)) {\n                        functionError = true;\n                    } else {\n\n                        finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n\n                        const mapItems = functionValue[1];\n\n                        if (!Array.isArray(mapItems)) {\n                            functionError = true;\n                        } else {\n\n                            for (i = index, li = mapItems.length; i < li; i++) {\n                                const item = mapItems[i];\n\n                                if (!Array.isArray(item)) {\n                                    functionError = true;\n                                    break;\n                                } else {\n\n                                    const itemValue = getLayerPropertyValueInner(layer, key, feature, lod, item[0], depth + 1);\n\n                                    if (finalValue == itemValue) {\n                                        return getLayerPropertyValueInner(layer, key, feature, lod, item[1], depth + 1);\n                                    }\n                                }\n                            }\n                        }\n\n                        return getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\n                    }\n\n                    break;\n\n                case 'linear':\n                case 'linear2':\n                case 'discrete':\n                case 'discrete2':\n                case 'lod-scaled':\n                    {\n\n                        //LOD based functions\n                        let stops = null;\n                        let lodScaledArray = null;\n                        let functionValue = lod;\n\n                        if (value['lod-scaled'] != null) {\n                            const array = value['lod-scaled'];\n\n                            if ((typeof array[1]) == 'number') {\n                                return array[1] * Math.pow(2*array[2], array[0] - lod);\n                            }\n\n                            stops = array[1];\n                            lodScaledArray = array;\n\n                        } if (value['discrete2'] != null || value['linear2'] != null) {\n                            const array = value['discrete2'] || value['linear2'];\n                            stops = array[1];\n                            functionValue = getLayerPropertyValueInner(layer, key, feature, lod, array[0], depth + 1);\n                        } else {\n                            stops = value['discrete'] || value['linear'];\n                        }\n\n                        let lastLod = stops[0][0];\n                        let lastValue = stops[0][1];\n                        let valueType = (typeof lastValue);\n                        let newValue = lastValue;\n\n                        let currentLod, currentValue;\n\n                        for (let i = 0, li = stops.length; i <= li; i++) {\n\n                            if (i == li) {\n                                newValue = lastValue;\n                                break;\n                            }\n\n                            if (stops[i][0] > functionValue) {\n\n                                if (value['discrete'] != null || value['discrete2'] != null || lodScaledArray != null) { //no interpolation\n                                    newValue = lastValue;\n                                    break;\n                                } else { //interpolate\n\n                                    currentLod = stops[i][0];\n                                    currentValue = stops[i][1];\n\n                                    if (currentLod == lastLod) { //end of array no interpolation needed\n                                        break;\n                                    }\n\n                                    switch(valueType) {\n\n                                    case 'boolean':\n                                        lastValue = lastValue ? 1 : 0;\n                                        currentValue = lastValue ? 1 : 0;\n                                        newValue = lastValue + (currentValue - lastValue) * ((functionValue - lastLod) / (currentLod - lastLod));\n\n                                        newValue = newValue > 0.5 ? true : false;\n                                        break;\n\n                                    case 'number':\n                                        newValue = lastValue + (currentValue - lastValue) * ((functionValue - lastLod) / (currentLod - lastLod));\n                                        break;\n\n                                    case 'object':\n                                        newValue = [];\n\n                                        for (let j = 0, lj= lastValue.length; j < lj; j++) {\n                                            newValue[j] = lastValue[j] + (currentValue[j] - lastValue[j]) * ((functionValue - lastLod) / (currentLod - lastLod));\n                                        }\n\n                                        break;\n                                    }\n\n                                    break;\n                                }\n                            }\n\n                            lastLod = stops[i][0];\n                            lastValue = stops[i][1];\n                        }\n\n                        if (lodScaledArray != null) {\n                            newValue *= Math.pow(2*lodScaledArray[2], lodScaledArray[0] - functionValue);\n                        }\n\n                        return newValue;\n                    }\n\n                default:\n                    functionError = true;\n                    break;\n            }\n\n            if (functionError) {\n                if (root) {\n                    return getDefaultLayerPropertyValue(key);\n                } else {\n                    return void(0);\n                }\n            }\n\n            return value;\n        }\n\n    case 'number':\n    case 'boolean':\n        return value;\n    }\n\n    if (root) {\n        return getDefaultLayerPropertyValue(key);\n    } else {\n        return void(0);\n    }\n}\n\n\nconst inheritLayer = function(layerId, layer, layerData, stylesheetLayersData, depth) {\n    if (depth > 100) {\n        logError('custom', 'infinite inherit loop in Layer: ' + layerId);\n        return;\n    }\n\n    //do we need inherite Layer?\n    if (layerData['inherit'] != null) {\n        //get inherited Layer\n        const LayerToInherit = stylesheetLayersData['layers'][layerData['inherit']];\n\n        if (LayerToInherit != null) {\n\n            if (LayerToInherit['inherit'] != null) {\n                inheritLayer(layerData['inherit'], layer, LayerToInherit, stylesheetLayersData, depth++);\n            }\n\n            //copy inherited Layer properties\n            for (let key in LayerToInherit) {\n                layer[key] = LayerToInherit[key];\n            }\n        } else {\n            logError('wrong-object', layerId, 'inherit', LayerToInherit, 'Layer');\n            return getDefaultLayerPropertyValue(null /*key*/);\n        }\n    }\n}\n\n\nfunction copyLayer(layerId, layer, layerData, stylesheetLayersData) {\n    //do we need inherite Layer?\n    if (layerData['inherit'] != null) {\n        inheritLayer(layerId, layer, layerData, stylesheetLayersData, 0);\n    }\n\n    //copy Layer properties\n    //if inherited properties are present then they will be overwriten\n    for (let key in layerData) {\n        layer[key] = layerData[key];\n    }\n\n    //store layer id\n    layer['$$layer-id'] = layerId;\n}\n\n\nfunction logError(errorType, layerId, key, value, index, subkey) {\n    if (globals.disableLog) {\n        return;\n    }\n\n    if ((typeof value) == 'object') {\n        value = JSON.stringify(value);\n    }\n\n    let str = null;\n\n    switch(errorType) {\n    case 'wrong-property-value':\n        str = 'Error: wrong layer property ' + (subkey ? ('\\'' + subkey + '\\'') : '') + ': ' + layerId + '.' + key + ' = ' + value;\n        break;\n\n    case 'wrong-property-value[]':\n        str = 'Error: wrong layer property ' + (subkey ? ('\\'' + subkey + '\\'') : '') + '['+index+']: ' + layerId + '.' + key + ' = ' + value;\n        break;\n\n    case 'wrong-object':\n        str = 'Error: reffered '+ subkey + ' does not exist: ' + layerId + '.' + key + ' = ' + value;\n        break;\n\n    case 'wrong-object[]':\n        str = 'Error: reffered '+ subkey + ' does not exist: ' + layerId + '.' + key + '['+index+'] = ' + value;\n        break;\n\n    case 'wrong-Layer':\n        str = 'Error: reffered '+ subkey + ' Layer does not exist: ' + subkey + '['+index+'].Layer = ' + layerId;\n        break;\n\n    case 'wrong-bitmap':\n        str = 'Error: wrong definition of bitmap: ' + layerId;\n        break;\n\n    case 'custom':\n        str = 'Error: ' + layerId;\n        break;\n    }\n\n    if (str && globals.log) {\n         // eslint-disable-next-line\n        console.log(str);\n        //throw str;\n    }\n}\n\n\n// eslint-disable-next-line\nfunction getUnitsNormalizedValue(value, screen, fallbackUnits) {\n    if (typeof value === 'string') {\n        if (value == '0' || value.length == 0) return 0;\n\n        value = value.trim();\n\n        if (value.length >= 2) {\n\n            const pf = globals.pixelsPerMM, ipf = globals.invPixelsPerMM;\n            let factor = 1;\n\n            switch(value.substr(-2, 2)) {\n                case 'km': factor = screen ? pf * 1000 * 1000 : 1000; break;\n                case 'cm': factor = screen ? pf * 10 : 1/100; break;\n                case 'mm': factor = screen ? pf : 1/1000; break;\n                case 'px': factor = screen ? 1 : ipf * 1/1000; break;\n                case 'pc': factor = screen ? pf * 2.54 * 1/6 : ipf * 1/1000 * 2.54 * 1/6; break;\n                case 'pt': factor = screen ? pf * 2.54 * 1/72 : ipf * 1/1000 * 2.54 * 1/72; break;\n                case 'in': factor = screen ? pf * 2.54 : ipf * 1/1000 * 2.54; break;\n\n                default:\n\n                    if (value.charAt(value.length - 1) == 'm') {\n                        return (screen ? pf * 1000 : 1) * parseFloat(value.substr(0, value.length - 1));\n                    } else {\n                        return parseFloat(value);\n                    }\n\n            }\n\n            return factor * parseFloat(value.substr(0, value.length - 2));\n\n        } else {\n\n            //fallbackUnits\n\n            return parseFloat(value);\n        }\n\n    } else if (typeof value === 'number') {\n        return value;\n    }\n}\n\n\n// eslint-disable-next-line\nfunction validateValue(layerId, key, value, type, arrayLength, min, max, hasUnits) {\n    let i, li;\n\n    //check for object\n    if (value != null && (typeof value) == 'object' && !Array.isArray(value)) {\n        logError('wrong-property-value', layerId, key, value);\n        return getDefaultLayerPropertyValue(key);\n    }\n\n    //check value type\n    if ((typeof value) != type) {\n        //check for exceptions\n        if (!(value === null && (key == 'icon-source' || key == 'visibility' || key == 'label-no-overlap-factor'))) {\n            logError('wrong-property-value', layerId, key, value);\n            return getDefaultLayerPropertyValue(key);\n        }\n    }\n\n    //check value\n    switch(typeof value) {\n\n    case 'object':\n\n        //accepted cases for null value\n        if (value === null && (key == 'line-style-texture' || key == 'icon-source' || 'dynamic-reduce' || 'reduce' ||\n            key == 'hysteresis' || key == 'visibility' || key == 'visibility-abs' || key == 'visibility-rel' || key == 'next-pass')) {\n            return value;\n        }\n\n        //check reduce\n        if (key == 'reduce' || key == 'dynamic-reduce' || key == 'label-no-overlap-factor' || key == 'line-points') {\n            if (Array.isArray(value) && value.length > 0 && (typeof value[0] === 'string')) {\n\n                if (key == 'line-points') {\n\n                    if (!(value[0] == 'vertices' || value[0] == 'by-length' || value[0] == 'by-ratio' || value[0] == 'endpoints' ||\n                          value[0] == 'start' || value[0] == 'end' || value[0] == 'middle' || value[0] == 'midpoint')) {\n                        logError('wrong-property-value', layerId, key, value);\n                        return getDefaultLayerPropertyValue(key);\n                    }\n\n                } else if (key == 'dynamic-reduce') {\n                    if (value[0] == 'by-extenal-param') {\n                        value[0] = globals.reduceMode;\n                    }\n\n                    if (!((value[0] == 'tilt' || value[0] == 'tilt-cos' || value[0] == 'tilt-cos2' || value[0] == 'scr-count' || value[0] == 'scr-count2' ||\n                           value[0] == 'scr-count3' || value[0] == 'scr-count4' || value[0] == 'scr-count5' || value[0] == 'scr-count6' || value[0] == 'scr-count7' || value[0] == 'scr-count8') &&\n                        (typeof value[1] === 'number') && ((typeof value[2] === 'number') || value[0] == 'scr-count4' || value[0] == 'scr-count5' || value[0] == 'scr-count6' || value[0] == 'scr-count7' || value[0] == 'scr-count8'))) {\n                        logError('wrong-property-value', layerId, key, value);\n                        return getDefaultLayerPropertyValue(key);\n                    }\n                } else if (key == 'reduce') {\n                    if (value[0] != 'odd' && value != 'even') {\n                        if ((typeof value[1] !== 'number') || ((value[0] != 'top' || value != 'bottom') && (typeof value[2] !== 'string'))) {\n                            logError('wrong-property-value', layerId, key, value);\n                            return getDefaultLayerPropertyValue(key);\n                        }\n                    }\n                } else if (key == 'label-no-overlap-factor') {\n                    if (!(value[0] == 'direct' || value[0] == 'div-by-dist')) {\n                        logError('wrong-property-value', layerId, key, value);\n                        return getDefaultLayerPropertyValue(key);\n                    }\n                }\n\n            } else {\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        //check multipasss\n        if (key == 'next-pass' || key == 'visibility-switch') {\n            const vswitch = (key == 'visibility-switch');\n            if (Array.isArray(value) && value.length > 0) {\n\n                for (i = 0; i < li; i++) {\n                    const valueItem = value[i];\n\n                    if (!(typeof valueItem == 'object' &&\n                            Array.isArray(valueItem) &&\n                            valueItem.length == 2 &&\n                            typeof valueItem[0] == 'number' &&\n                            (typeof valueItem[1] == 'string' || (vswitch && valueItem[1] === null)))) {\n\n                        logError('wrong-property-value[]', layerId, key, value, i);\n                        return getDefaultLayerPropertyValue(key);\n                    } else {\n                        //fast constant\n                        if (typeof valueItem[1] == 'string' && valueItem[1].charAt(0) == '@') {\n                            if (typeof globals.stylesheetConstants[valueItem[1]] == 'undefined') {\n                                logError('wrong-property-value[]', layerId, key, value, i);\n                                return getDefaultLayerPropertyValue(key);\n                            } else {\n                                valueItem[1] = globals.stylesheetConstants[valueItem[1]];\n                            }\n                        }\n                    }\n                }\n\n            } else {\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        if (key == 'label-font' || key == 'line-label-font') {\n\n            if (!Array.isArray(value) || value.length < 1) {\n                logError('wrong-property-value[]', layerId, key, value, 0);\n                return getDefaultLayerPropertyValue(key);\n            } else {\n                for (i = 0, li = value.length; i < li; i++) {\n                    if (typeof value[i] != 'string' || !globals.fonts[value[i]]) {\n                        logError('wrong-property-value[]', layerId, key, value, 0);\n                        return getDefaultLayerPropertyValue(key);\n                    }\n                }\n            }\n\n            return value;\n        }\n\n        //check array\n        if (arrayLength != null) {\n            if (Array.isArray(value) && (value.length == arrayLength || ((key == 'icon-stick' || 'label-stick') && value.length >= 7) )) {\n\n                //validate array values\n                i = 0;\n\n                if (key == 'icon-source' || key == 'line-style-texture') {\n                    if (typeof value[0] != 'string') {\n                        logError('wrong-property-value[]', layerId, key, value, 0);\n                        return getDefaultLayerPropertyValue(key);\n                    }\n\n                    if (globals.stylesheetBitmaps[value[0]] == null) {\n                        logError('wrong-object', layerId, key, value, null, 'bitmap');\n                        return getDefaultLayerPropertyValue(key);\n                    }\n\n                    i = 1;\n                }\n\n                for (li = value.length; i < li; i++) {\n                    if (typeof value[i] != 'number') {\n                        logError('wrong-property-value[]', layerId, key, value, i);\n                        return getDefaultLayerPropertyValue(key);\n                    }\n                }\n\n                if ((key == 'icon-stick' || 'label-stick') && value.length == 7) {\n                    value[7] = 0;\n                }\n\n                return value;\n            } else {\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        return value;\n\n    case 'string':\n\n        if (key == 'line-type' || key == 'point-type') {\n            switch(value) {\n            case 'screen':\n            case 'flat':\n            case 'screen-flat': return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        if (key == 'line-label-type') {\n            switch(value) {\n            case 'flat':\n            case 'screen-flat': return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        //validate line Layer enum\n        if (key == 'line-style') {\n            switch(value) {\n            case 'solid':\n            case 'texture': return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        if (key == 'label-size-units') {\n            switch(value) {\n            case 'pixels':\n            case 'points': return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        if (key == 'line-width-units') {\n            switch(value) {\n            case 'pixels':\n            case 'points':\n            case 'meters':\n            case 'ratio': return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        //validate origin enum\n        if (key == 'label-origin' || key == 'icon-origin') {\n            switch(value) {\n            case 'top-left':\n            case 'top-right':\n            case 'top-center':\n            case 'center-left':\n            case 'center-right':\n            case 'center-center':\n            case 'bottom-left':\n            case 'bottom-right':\n            case 'bottom-center':   return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        //validate align enum\n        if (key == 'label-align') {\n            switch(value) {\n            case 'left':\n            case 'right':\n            case 'center':  return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        return value;\n\n    case 'number':\n\n        if (value > max || value < min) {\n            logError('wrong-property-value', layerId, key, value);\n            return getDefaultLayerPropertyValue(key);\n        }\n\n        return value;\n\n    case 'boolean':\n        return value;\n    }\n}\n\n\nfunction validateLayerPropertyValue(layerId, key, value) {\n\n    switch(key) {\n\n    case 'inherit' :        return validateValue(layerId, key, value, 'string');\n    case 'reduce':          return validateValue(layerId, key, value, 'object');\n    case 'dynamic-reduce':  return validateValue(layerId, key, value, 'object');\n    case 'line-points':     return validateValue(layerId, key, value, 'object');\n\n    case 'line':              return validateValue(layerId, key, value, 'boolean');\n    case 'line-type':         return validateValue(layerId, key, value, 'string');\n    case 'line-flat':         return validateValue(layerId, key, value, 'boolean');\n    case 'line-width':        return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'line-width-units':  return validateValue(layerId, key, value, 'string');\n    case 'line-color':        return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'line-style':        return validateValue(layerId, key, value, 'string');\n    case 'line-style-texture':    return validateValue(layerId, key, value, 'object', 3, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'line-style-background': return validateValue(layerId, key, value, 'object', 4, 0, 255);\n\n    case 'line-label':         return validateValue(layerId, key, value, 'boolean');\n    case 'line-label-type':    return validateValue(layerId, key, value, 'string');\n    case 'line-label-source':  return validateValue(layerId, key, value, 'string');\n    case 'line-label-color':   return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'line-label-color2':  return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'line-label-size':    return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE, true);\n    case 'line-label-offset':  return validateValue(layerId, key, value, 'number', null, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'line-label-spacing': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'line-label-line-height': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'line-label-no-overlap':  return validateValue(layerId, key, value, 'boolean');\n    case 'line-label-no-overlap-factor': return validateValue(layerId, key, value, 'object');\n    case 'line-label-no-overlap-margin': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n\n    case 'point':        return validateValue(layerId, key, value, 'boolean');\n    case 'point-type':   return validateValue(layerId, key, value, 'string');\n    case 'point-flat':   return validateValue(layerId, key, value, 'boolean');\n    case 'point-radius': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'point-Layer':  return validateValue(layerId, key, value, 'string');\n\n    case 'point-color':  return validateValue(layerId, key, value, 'object', 4, 0, 255);\n\n    case 'icon':             return validateValue(layerId, key, value, 'boolean');\n    case 'icon-source':      return validateValue(layerId, key, value, 'object', 5, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'icon-scale':       return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'icon-offset':      return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'icon-origin':      return validateValue(layerId, key, value, 'string');\n    case 'icon-stick':       return validateValue(layerId, key, value, 'object', 8, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'icon-color':       return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'icon-no-overlap':  return validateValue(layerId, key, value, 'boolean');\n    case 'icon-no-overlap-factor': return validateValue(layerId, key, value, 'object');\n    case 'icon-no-overlap-margin': return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\n\n    case 'label':             return validateValue(layerId, key, value, 'boolean');\n    case 'label-color':       return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'label-color2':      return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'label-source':      return validateValue(layerId, key, value, 'string');\n    case 'label-size':        return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'label-size-units':  return validateValue(layerId, key, value, 'string');\n    case 'label-spacing':     return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'label-line-height': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'label-offset':      return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'label-origin':      return validateValue(layerId, key, value, 'string');\n    case 'label-align':       return validateValue(layerId, key, value, 'string');\n    case 'label-stick':       return validateValue(layerId, key, value, 'object', 8, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'label-width':       return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'label-no-overlap':  return validateValue(layerId, key, value, 'boolean');\n    case 'label-no-overlap-factor': return validateValue(layerId, key, value, 'object');\n    case 'label-no-overlap-margin': return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\n\n    case 'polygon':             return validateValue(layerId, key, value, 'boolean');\n    case 'polygon-style':       return validateValue(layerId, key, value, 'string');\n    case 'polygon-use-stencil': return validateValue(layerId, key, value, 'boolean');\n    case 'polygon-culling':     return validateValue(layerId, key, value, 'string');\n    case 'polygon-color':       return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'polygon-extrude':     return validateValue(layerId, key, value, 'number', 0, -Number.MAX_VALUE, Number.MAX_VALUE);\n\n    case 'z-index':        return validateValue(layerId, key, value, 'number', null, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'zbuffer-offset': return validateValue(layerId, key, value, 'object', 3, 0, Number.MAX_VALUE);\n\n    case 'selected-hover-layer':  return validateValue(layerId, key, value, 'string');\n    case 'selected-layer':  return validateValue(layerId, key, value, 'string');\n    case 'hover-event':     return validateValue(layerId, key, value, 'boolean');\n    case 'hover-layer':     return validateValue(layerId, key, value, 'string');\n    case 'enter-event':     return validateValue(layerId, key, value, 'boolean');\n    case 'leave-event':     return validateValue(layerId, key, value, 'boolean');\n    case 'click-event':     return validateValue(layerId, key, value, 'boolean');\n    case 'draw-event':      return validateValue(layerId, key, value, 'boolean');\n    case 'advanced-hit':    return validateValue(layerId, key, value, 'boolean');\n    case 'export-geometry': return validateValue(layerId, key, value, 'boolean');\n    case 'pack':            return validateValue(layerId, key, value, 'boolean');\n\n    case 'visible':           return validateValue(layerId, key, value, 'boolean');\n    case 'visibility':        return validateValue(layerId, key, value, 'number', null, 0.00001, Number.MAX_VALUE);\n    case 'visibility-abs':    return validateValue(layerId, key, value, 'object', 2, 0.00001, Number.MAX_VALUE);\n    case 'visibility-rel':    return validateValue(layerId, key, value, 'object', 4, 0.00001, Number.MAX_VALUE);\n    case 'visibility-switch': return validateValue(layerId, key, value, 'object');\n\n    case 'hysteresis':  return validateValue(layerId, key, value, 'object');\n    case 'culling':     return validateValue(layerId, key, value, 'number', 180, 0.0001, 180);\n    case 'next-pass':   return validateValue(layerId, key, value, 'object');\n\n    case 'importance-source':  return validateValue(layerId, key, value, 'string');\n    case 'importance-weight':  return validateValue(layerId, key, value, 'number', null, 0, Number.MAX_VALUE);\n\n    }\n\n    return value; //custom property\n}\n\n\nfunction getDefaultLayerPropertyValue(key) {\n    switch(key) {\n    case 'inherit':          return '';\n    case 'filter':           return null;\n    case 'reduce':           return null;\n    case 'dynamic-reduce':   return null;\n    case 'line-points':      return ['vertices',0,0];\n\n    case 'line':             return false;\n    case 'line-type':        return 'screen';\n    case 'line-flat':        return false;\n    case 'line-width':       return 1;\n    case 'line-width-units': return 'meters';\n    case 'line-color':       return [255,255,255,255];\n    case 'line-style':       return 'solid';\n    case 'line-style-texture':    return null;\n    case 'line-style-background': return [0,0,0,0];\n\n    case 'line-label':         return false;\n    case 'line-label-type':    return 'flat'; //'screen-flat';\n    case 'line-label-font':    return ['#default'];\n    case 'line-label-color':   return [255,255,255,255];\n    case 'line-label-color2':  return [0,0,0,255];\n    case 'line-label-outline': return [0.27,0.75,2.2,2.2];\n    case 'line-label-source':  return '$name';\n    case 'line-label-size':    return 1;\n    case 'line-label-offset':  return 0;\n    case 'line-label-spacing': return 1;\n    case 'line-label-line-height': return 1;\n    case 'line-label-no-overlap':  return true;\n    case 'line-label-no-overlap-factor': return null;\n    case 'line-label-no-overlap-margin': return 1.1;\n\n    case 'point':        return false;\n    case 'point-type':   return 'screen';\n    case 'point-flat':   return false;\n    case 'point-radius': return 1;\n    case 'point-Layer':  return 'solid';\n    case 'point-color':  return [255,255,255,255];\n\n    case 'icon':         return false;\n    case 'icon-source':  return null;\n    case 'icon-scale':   return 1;\n    case 'icon-offset':  return [0,0];\n    case 'icon-origin':  return 'bottom-center';\n    case 'icon-stick':   return [0,0,0,255,255,255,255,0];\n    case 'icon-color':   return [255,255,255,255];\n    case 'icon-no-overlap':  return false;\n    case 'icon-no-overlap-factor': return null;\n    case 'icon-no-overlap-margin': return [5,5];\n\n    case 'label':             return false;\n    case 'label-font':        return ['#default'];\n    case 'label-color':       return [255,255,255,255];\n    case 'label-color2':      return [0,0,0,255];\n    case 'label-outline':     return [0.27,0.75,2.2,2.2];\n    case 'label-source':      return '$name';\n    case 'label-size':        return 10;\n    case 'label-size-units':  return 'pixels';\n    case 'label-spacing':     return 1;\n    case 'label-line-height': return 1;\n    case 'label-offset':      return [0,0];\n    case 'label-origin':      return 'bottom-center';\n    case 'label-align':       return 'center';\n    case 'label-stick':       return [0,0,0,255,255,255,255,0];\n    case 'label-width':       return 200;\n    case 'label-no-overlap':  return true;\n    case 'label-no-overlap-factor': return null;\n    case 'label-no-overlap-margin': return [5,5];\n\n    case 'polygon':             return false;\n    case 'polygon-style':       return 'solid';\n    case 'polygon-use-stencil': return true;\n    case 'polygon-culling':     return 'none';\n    case 'polygon-color':       return [255,255,255,255];\n    case 'polygon-extrude':     return 0;\n\n    case 'z-index':        return 0;\n    case 'zbuffer-offset': return [0,0,0];\n\n    case 'selected-hover-layer':  return '';\n    case 'selected-layer':  return '';\n    case 'hover-event':     return false;\n    case 'hover-layer':     return '';\n    case 'enter-event':     return false;\n    case 'leave-event':     return false;\n    case 'click-event':     return false;\n    case 'draw-event':      return false;\n    case 'advanced-hit':    return false;\n    case 'export-geometry': return false;\n    case 'pack':            return false;\n\n    case 'visible':           return true;\n    case 'visibility':        return null;\n    case 'visibility-abs':    return null;\n    case 'visibility-rel':    return null;\n    case 'visibility-switch': return null;\n\n    case 'hysteresis':      return null;\n    case 'culling':         return 180;\n    case 'next-pass':       return null;\n\n    case 'importance-source':  return null; //''\n    case 'importance-weight':  return 1;\n    }\n}\n\n\nfunction getFilterResult(filter, feature, featureType, group, layer, key, lod, depth, fast) {\n    let result, i, li;\n\n    if (!filter || !Array.isArray(filter)) {\n        return false;\n    }\n\n    if (depth > 100) {\n        return false;\n    }\n\n    switch(filter[0]) {\n        case 'all':\n            for (i = 1, li = filter.length; i < li; i++) {\n                result = getFilterResult(filter[i], feature, featureType, group, layer, key, lod, depth + 1, fast);\n\n                if (!result) {\n                    return false;\n                }\n            }\n\n            return true;\n\n        case 'any':\n            for (i = 1, li = filter.length; i < li; i++) {\n                result = getFilterResult(filter[i], feature, featureType, group, key, lod, depth + 1, fast);\n\n                if (result) {\n                    return true;\n                }\n            }\n\n            return false;\n\n        case 'none':\n            for (i = 1, li = filter.length; i < li; i++) {\n                result = getFilterResult(filter[i], feature, featureType, group, key, lod, depth + 1, fast);\n\n                if (result) {\n                    return false;\n                }\n            }\n\n            return true;\n\n        case 'skip': return false;\n    }\n\n    let value, value2;\n\n    if (fast && filter[2]) {\n        value = filter[1];\n    } else {\n        globals.disableLog = (filter[0] == 'has' || filter[0] == '!has');\n        value = getLayerPropertyValueInner(layer, key, feature, lod, filter[1], 0);\n        globals.disableLog = false;\n    }\n\n    switch(filter[0]) {\n    case '==':\n    case '!=':\n    case '>=':\n    case '<=':\n    case '>':\n    case '<':\n        value2 = filter[fast ? 3 : 2];\n\n        if (typeof value2 == 'undefined') {\n            return false;\n        }\n\n        if (!(fast && filter[4])) {\n            value2 = getLayerPropertyValueInner(layer, key, feature, lod, value2, 0);\n        }\n\n        break;\n    }\n\n    switch(filter[0]) {\n    case '==': return (value == value2);\n    case '!=': return (value != value2);\n    case '>=': return (value >= value2);\n    case '<=': return (value <= value2);\n    case '>': return (value > value2);\n    case '<': return (value < value2);\n\n    case 'has': return (typeof value != 'undefined');\n    case '!has': return (typeof value == 'undefined');\n\n    case 'in':\n        for (i = fast ? 3 : 2, li = filter.length; i < li; i++) {\n            if (filter[i] == value) {\n                return true;\n            }\n        }\n        return false;\n\n    case '!in':\n        for (i = fast ? 3 : 2, li = filter.length; i < li; i++) {\n            if (filter[i] == value) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    return false;\n}\n\n\nfunction isSimpleValue(value) {\n    switch(typeof value) {\n        case 'number':  return true;\n        case 'string':\n\n            if (value.length > 0) {\n                switch(value.charAt(0)) {\n                    case '#':\n                    case '$':\n                    case '@':\n                    case '&':\n                        break;\n\n                    default:\n\n                        if (value.indexOf('{') == -1) {\n                            return true;\n                        }\n\n                        break;\n                }\n            } else {\n                return true;\n            }\n\n            break;\n    }\n\n    return false;\n}\n\n\nfunction makeFasterFilter(filter) {\n    if (!filter || !Array.isArray(filter)) {\n        return filter;\n    }\n\n    let i, li, result = [filter[0]];\n\n    switch(filter[0]) {\n    case 'all':\n    case 'any':\n    case 'none':\n    case 'skip':\n        for (i = 1, li = filter.length; i < li; i++) {\n            result[i] = makeFasterFilter(filter[i]);\n        }\n\n        return result;\n    }\n\n    result[1] = filter[1];\n    result[2] = isSimpleValue(filter[1]);\n\n    switch(filter[0]) {\n    case '==':\n    case '!=':\n    case '>=':\n    case '<=':\n    case '>':\n    case '<':\n        result[3] = filter[2];\n        result[4] = isSimpleValue(filter[2]);\n        break;\n\n    case 'in':\n    case '!in':\n\n        for (i = 2, li = filter.length; i < li; i++) {\n            result[i+1] = filter[i];\n        }\n\n    }\n\n    return result;\n}\n\nfunction processLayer(layerId, layerData, stylesheetLayersData) {\n    let layer = {}, key, value;\n\n    //copy Layer and inherit Layer if needed\n    copyLayer(layerId, layer, layerData, stylesheetLayersData);\n\n    //replace constants and validate properties\n    for (key in layer) {\n\n        value = layer[key];\n\n        //replace constant with value\n        if ((typeof value) == 'string') {\n            if (value.length > 0) {\n                //is it constant?\n                switch(value.charAt(0)) {\n                    case '@':\n                        if (globals.stylesheetConstants[value] != null) {\n                            //replace constant with value\n                            layer[key] = globals.stylesheetConstants[value];\n                        } else {\n                            logError('wrong-object', layerId, key, value, null, 'constant');\n\n                            //replace constant with deafault value\n                            layer[key] = getDefaultLayerPropertyValue(key);\n                        }\n                        break;\n\n                    case '%':  // reserved for variators\n\n                        if (globals.stylesheetLocals[value] != null) {\n                            if (!layer['$$layer-variables']) {\n                                layer['$$layer-variables'] = {};\n                            }\n\n                            layer['$$layer-variables'][key] = value;\n\n                            //replace variable with value\n                            layer[key] = globals.stylesheetLocals[value];\n\n                        } else {\n                            logError('wrong-object', layerId, key, value, null, 'variable');\n\n                            //replace constant with deafault value\n                            layer[key] = getDefaultLayerPropertyValue(key);\n                        }\n                        break;\n                }\n            }\n        }\n\n        //copy constats to vswitch\n        if (key == 'visibility-switch') {\n            if (Array.isArray(value) && value.length > 0) {\n                for (let i = 0, li = value.length; i < li; i++) {\n                    const valueItem = value[i];\n                    let wrong = false;\n\n                    if (!(typeof valueItem == 'object' && Array.isArray(valueItem) && valueItem.length == 2)) {\n                        wrong = true;\n                    } else {\n                        if (typeof valueItem[0] == 'string' && valueItem[0].charAt(0) == '@') {\n                            if (typeof globals.stylesheetConstants[valueItem[0]] == 'undefined') {\n                                wrong = true;\n                            } else {\n                                valueItem[0] = globals.stylesheetConstants[valueItem[0]];\n                            }\n                        }\n\n                        if (!(typeof valueItem[0] == 'number' && (typeof valueItem[1] == 'string' || valueItem[1] === null))) {\n                            wrong = true;\n                        }\n                    }\n\n                    if (wrong) {\n                        logError('wrong-property-value[]', layerId, key, value, i);\n                    }\n                }\n\n            } else {\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n    }\n\n    return layer;\n}\n\n\nfunction processStylesheet(stylesheetLayersData) {\n    globals.stylesheetBitmaps = {};\n    globals.stylesheetFonts = {};\n    globals.stylesheetConstants = stylesheetLayersData['constants'] || {};\n    globals.stylesheetVariables = stylesheetLayersData['variables'] || {};\n    globals.stylesheetLocals = {};\n\n    //get bitmaps\n    let bitmaps = stylesheetLayersData['bitmaps'] || {}, bitmap;\n\n    //build map\n    for (let key in bitmaps) {\n        bitmap = bitmaps[key];\n\n        if ((typeof bitmap) == 'string') {\n            bitmap = {'url':bitmap, 'hash': getHash(bitmap) };\n        } else if((typeof bitmap) == 'object'){\n            if (bitmap['url'] == null) {\n                bitmap['hash'] = 'null';\n                logError('wrong-bitmap', key);\n            } else {\n                bitmap['hash'] = getHash(bitmap['url']);\n            }\n        } else {\n            logError('wrong-bitmap', key);\n        }\n\n        globals.stylesheetBitmaps[key] = bitmap;\n    }\n\n    //load bitmaps\n    postMessage({'command':'loadBitmaps', 'bitmaps': globals.stylesheetBitmaps});\n\n    //remove urls\n    bitmaps = globals.stylesheetBitmaps;\n\n    for (let key in bitmaps) {\n        bitmap = bitmaps[key];\n        bitmap['url'] = null;\n    }\n\n    //get fonts\n    const fonts = stylesheetLayersData['fonts'] || {};\n\n    //build map\n    for (let key in fonts) {\n        let font = fonts[key];\n\n        if ((typeof font) == 'string') {\n            font = {'url':font};\n        } else if((typeof font) == 'object'){\n            if (font['url'] == null) {\n                logError('wrong-font', key);\n            }\n        } else {\n            logError('wrong-font', key);\n        }\n\n        globals.stylesheetFonts[key] = font;\n    }\n\n    //load fonts\n    postMessage({'command':'loadFonts', 'fonts': globals.stylesheetFonts});\n\n\n    //get layers\n    globals.stylesheetData = {\n        layers : {}\n    };\n\n    const layers = stylesheetLayersData['layers'] || {};\n\n    globals.stylesheetLayers = globals.stylesheetData.layers;\n\n    //process layers\n    for (let key in layers) {\n        globals.stylesheetData.layers[key] = processLayer(key, layers[key], stylesheetLayersData);\n    }\n}\n\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/map/geodata-processor/worker-text.js\":\n/*!*******************************************************!*\\\n  !*** ./src/core/map/geodata-processor/worker-text.js ***!\n  \\*******************************************************/\n/*! exports provided: addStreetTextOnPath, getTextLength, getLineHeight, getFontFactor, getSplitIndex, areTextCharactersAvailable, addText, addTextOnPath, setFont, setFontMap, getCharVerticesCount, getFonts, getFontsStorage, hasLatin, isCJK, getTextGlyphs */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addStreetTextOnPath\", function() { return addStreetTextOnPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTextLength\", function() { return getTextLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLineHeight\", function() { return getLineHeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFontFactor\", function() { return getFontFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSplitIndex\", function() { return getSplitIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"areTextCharactersAvailable\", function() { return areTextCharactersAvailable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addText\", function() { return addText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addTextOnPath\", function() { return addTextOnPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setFont\", function() { return setFont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setFontMap\", function() { return setFontMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCharVerticesCount\", function() { return getCharVerticesCount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFonts\", function() { return getFonts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFontsStorage\", function() { return getFontsStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasLatin\", function() { return hasLatin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isCJK\", function() { return isCJK; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTextGlyphs\", function() { return getTextGlyphs; });\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \"./src/core/map/geodata-processor/worker-globals.js\");\n/* harmony import */ var _worker_font_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-font.js */ \"./src/core/map/geodata-processor/worker-font.js\");\n\n\n\n\n\n\n//get rid of compiler mess\nconst globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"globals\"],\n    vec3Normalize = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3Normalize\"], vec3Length = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3Length\"],\n    vec3Cross = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3Cross\"],\n    Typr = _worker_font_js__WEBPACK_IMPORTED_MODULE_1__[\"Typr\"];\n\n\nfunction setFont(fontData) {\n    //console.log('setFont ' + fontData['url']);\n    //debugger;\n\n    const font = Typr.parse(fontData['data']);\n\n    globals.fontsStorage[fontData['url']] = font;\n}\n\n\nfunction setFontMap(fontMap) {\n    const fonts = fontMap['map'];\n    for (let key in fonts) {\n        globals.fonts[key] = globals.fontsStorage[fonts[key]];\n    }\n\n    globals.fontsMap = fonts;\n}\n\n\n//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\nfunction mat3toQuad2(m) {  //TODO: use m as one dimensional vector\n\n    const tr = m[0][0] + m[1][1] + m[2][2];\n    let qx,qy,qz,qw,s;\n\n    if (tr > 0) {\n      s = Math.sqrt(tr+1.0) * 2; // S=4*qw\n      qw = 0.25 * s;\n      qx = (m[2][1] - m[1][2]) / s;\n      qy = (m[0][2] - m[2][0]) / s;\n      qz = (m[1][0] - m[0][1]) / s;\n    } else if ((m[0][0] > m[1][1])&(m[0][0] > m[2][2])) {\n      s = Math.sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]) * 2; // S=4*qx\n      qw = (m[2][1] - m[1][2]) / s;\n      qx = 0.25 * s;\n      qy = (m[0][1] + m[1][0]) / s;\n      qz = (m[0][2] + m[2][0]) / s;\n    } else if (m[1][1] > m[2][2]) {\n      s = Math.sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]) * 2; // S=4*qy\n      qw = (m[0][2] - m[2][0]) / s;\n      qx = (m[0][1] + m[1][0]) / s;\n      qy = 0.25 * s;\n      qz = (m[1][2] + m[2][1]) / s;\n    } else {\n      s = Math.sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]) * 2; // S=4*qz\n      qw = (m[1][0] - m[0][1]) / s;\n      qx = (m[0][2] + m[2][0]) / s;\n      qy = (m[1][2] + m[2][1]) / s;\n      qz = 0.25 * s;\n    }\n\n    return [qx,qy,qz,qw];\n}\n\n\nfunction addChar(pos, dir, verticalShift, char, factor, spacing, index, index2, textVector, fonts, vertexBuffer, texcoordsBuffer, flat, planes, fontIndex, singleBuffer) {\n    let n, font = fonts[fontIndex];\n    let up = [0,0,0];\n\n    if (globals.geocent && !flat) {\n        n = [0,0,0];\n        vec3Normalize(globals.bboxMin, up);\n        vec3Cross(up, dir, n);\n    } else {\n        n = [-dir[1],dir[0],0];\n    }\n\n    vec3Cross(dir, n, up);\n\n    let p1 = [pos[0], pos[1], pos[2]];\n    let p2 = [p1[0], p1[1], p1[2]];\n\n    let fc = font.glyphs[char];\n    char = 0; // hack\n\n    if (!fc) {\n        return [pos, index, index2, 0];\n    }\n\n    let l = 0;\n    let nx = textVector[0];\n    let ny = textVector[1];\n    let nz = textVector[2];\n\n    if (char == 9 || char == 32) {  //tab or space\n        fc = font.glyphs[32]; //chars[32]; //space\n\n        if (fc) {\n            pos[0] += dir[0] * (fc.step) * factor * spacing;\n            pos[1] += dir[1] * (fc.step) * factor * spacing;\n            l = fc.lx * factor;\n        }\n    } else {\n        if (fc.lx == 0) {\n            pos[0] = pos[0] + dir[0] * fc.step * factor * spacing;\n            pos[1] = pos[1] + dir[1] * fc.step * factor * spacing;\n            l = fc.lx * factor;\n        } else {\n            const planeShift = fontIndex * 4000;\n            const plane = fc.plane + planeShift;\n\n            if (planes) {\n                if (!planes[fontIndex]) {\n                    planes[fontIndex] = {};\n                }\n\n                planes[fontIndex][plane] = true;\n            }\n\n            const factorX = fc.lx * factor;\n            const factorY = fc.ly * factor;\n\n            if (singleBuffer) {\n\n                if (globals.processLineLabel && globals.useLineLabel2) {\n\n                    p1[0] = p1[0] + dir[0] * fc.sx * factor;\n                    p1[1] = p1[1] + dir[1] * fc.sx * factor;\n                    p1[2] = p1[2] + dir[2] * fc.sx * factor;\n                    p1[0] = p1[0] + n[0] * (fc.sy - font.size) * factor;\n                    p1[1] = p1[1] + n[1] * (fc.sy - font.size) * factor;\n                    p1[2] = p1[2] + n[2] * (fc.sy - font.size) * factor;\n\n                    const n2 = [n[0] * verticalShift, n[1] * verticalShift, n[2] * verticalShift];\n                    //const n3 = [n2[0] + n[0] * factorY, n2[1] + n[1] * factorY, n2[2] + n[2] * factorY];\n\n                    singleBuffer[index] = p1[0] - n2[0];\n                    singleBuffer[index+1] = p1[1] - n2[1];\n                    singleBuffer[index+2] = p1[2] - n2[2];\n\n\n                    const m = [ [dir[0], dir[1], dir[2]],\n                              [n[0], n[1], n[2]],\n                              [up[0], up[1], up[2]] ];\n\n                    /*\n                    const m = [ dir[0], dir[1], dir[2],\n                              n[0], n[1], n[2],\n                              up[0], up[1], up[2] ];*/\n\n                    const q = mat3toQuad2(m);\n                    singleBuffer[index+3] = q[0];  //x\n                    singleBuffer[index+4] = q[1];  //y\n                    singleBuffer[index+5] = q[2];  //z\n                    singleBuffer[index+6] = q[3];  //w\n\n                    if (!globals.lineLabelPass) {\n                        singleBuffer[index+7] = factorX;\n                        singleBuffer[index+8] = factorY;\n                    }\n\n                    singleBuffer[index+9] = fc.u1;\n                    singleBuffer[index+10] = fc.v1 + planeShift;\n\n                    const dtx = (fc.u2 - fc.u1) * 1024;\n                    const dty = (fc.v2 - fc.v1);// * 1024;\n\n                    singleBuffer[index+11] = dtx + dty;  // u store in decimal part, v stored in fraction part\n\n                    const dx = dir[0]*0.5*factorX - n[0]*0.5*factorY - n2[0];\n                    const dy = dir[1]*0.5*factorX - n[1]*0.5*factorY - n2[1];\n                    const dz = dir[2]*0.5*factorX - n[2]*0.5*factorY - n2[2];\n\n                    //globals.lineLabelPoints.push([p1[0] + dx, p1[1] + dy, p1[2] + dz, Math.sqrt(factorX*factorX + factorY*factorY)*0.5]);\n                    globals.lineLabelPoints.push([p1[0] + dx, p1[1] + dy, p1[2] + dz, Math.sqrt(factorX*factorX + factorY*factorY)*0.5,\n                                                  singleBuffer[index], singleBuffer[index+1], singleBuffer[index+2],\n                                                  singleBuffer[index+3], singleBuffer[index+4], singleBuffer[index+5], singleBuffer[index+6], factorX, factorY]);\n\n                    index += 12;\n\n                } else {\n                    singleBuffer[index] = p1[0] + fc.sx * factor;\n                    singleBuffer[index+1] = p1[1] + (fc.sy - font.size) * factor;\n                    singleBuffer[index+2] = singleBuffer[index] + factorX;\n                    singleBuffer[index+3] = singleBuffer[index+1] - factorY;\n                    singleBuffer[index+4] = fc.u1;\n                    singleBuffer[index+5] = fc.v1 + planeShift;\n                    singleBuffer[index+6] = fc.u2;\n                    singleBuffer[index+7] = fc.v2 + planeShift;\n\n                    index += 8;\n                }\n\n            } else {\n\n                const n2 = [n[0] * verticalShift, n[1] * verticalShift, n[2] * verticalShift];\n                const n3 = [n2[0] + n[0] * factorY, n2[1] + n[1] * factorY, n2[2] + n[2] * factorY];\n\n                p1[0] = p1[0] + dir[0] * fc.sx * factor;\n                p1[1] = p1[1] + dir[1] * fc.sx * factor;\n                p1[2] = p1[2] + dir[2] * fc.sx * factor;\n                p1[0] = p1[0] + n[0] * (fc.sy - font.size) * factor;\n                p1[1] = p1[1] + n[1] * (fc.sy - font.size) * factor;\n                p1[2] = p1[2] + n[2] * (fc.sy - font.size) * factor;\n\n                p2[0] = p1[0] + dir[0] * factorX;\n                p2[1] = p1[1] + dir[1] * factorX;\n                p2[2] = p1[2] + dir[2] * factorX;\n\n                //first polygon\n                vertexBuffer[index] = p1[0] - n2[0];\n                vertexBuffer[index+1] = p1[1] - n2[1];\n                vertexBuffer[index+2] = p1[2] - n2[2];\n                vertexBuffer[index+3] = nz;\n\n                texcoordsBuffer[index2] = fc.u1;\n                texcoordsBuffer[index2+1] = fc.v1 +  planeShift;\n                texcoordsBuffer[index2+2] = nx;\n                texcoordsBuffer[index2+3] = ny;\n\n                vertexBuffer[index+4] = p1[0] - n3[0];\n                vertexBuffer[index+5] = p1[1] - n3[1];\n                vertexBuffer[index+6] = p1[2] - n3[2];\n                vertexBuffer[index+7] = nz;\n\n                texcoordsBuffer[index2+4] = fc.u1;\n                texcoordsBuffer[index2+5] = fc.v2 +  planeShift;\n                texcoordsBuffer[index2+6] = nx;\n                texcoordsBuffer[index2+7] = ny;\n\n                vertexBuffer[index+8] = p2[0] - n2[0];\n                vertexBuffer[index+9] = p2[1] - n2[1];\n                vertexBuffer[index+10] = p2[2] - n2[2];\n                vertexBuffer[index+11] = nz;\n\n                texcoordsBuffer[index2+8] = fc.u2;\n                texcoordsBuffer[index2+9] = fc.v1 +  planeShift;\n                texcoordsBuffer[index2+10] = nx;\n                texcoordsBuffer[index2+11] = ny;\n\n\n                //next polygon\n                vertexBuffer[index+12] = p1[0] - n3[0];\n                vertexBuffer[index+13] = p1[1] - n3[1];\n                vertexBuffer[index+14] = p1[2] - n3[2];\n                vertexBuffer[index+15] = nz;\n\n                texcoordsBuffer[index2+12] = fc.u1;\n                texcoordsBuffer[index2+13] = fc.v2 +  planeShift;\n                texcoordsBuffer[index2+14] = nx;\n                texcoordsBuffer[index2+15] = ny;\n\n                vertexBuffer[index+16] = p2[0] - n3[0];\n                vertexBuffer[index+17] = p2[1] - n3[1];\n                vertexBuffer[index+18] = p2[2] - n3[2];\n                vertexBuffer[index+19] = nz;\n\n                texcoordsBuffer[index2+16] = fc.u2;\n                texcoordsBuffer[index2+17] = fc.v2 +  planeShift;\n                texcoordsBuffer[index2+18] = nx;\n                texcoordsBuffer[index2+19] = ny;\n\n                vertexBuffer[index+20] = p2[0] - n2[0];\n                vertexBuffer[index+21] = p2[1] - n2[1];\n                vertexBuffer[index+22] = p2[2] - n2[2];\n                vertexBuffer[index+23] = nz;\n\n                texcoordsBuffer[index2+20] = fc.u2;\n                texcoordsBuffer[index2+21] = fc.v1 +  planeShift;\n                texcoordsBuffer[index2+22] = nx;\n                texcoordsBuffer[index2+23] = ny;\n\n                index += 24;\n                index2 += 24;\n            }\n\n            pos[0] = pos[0] + dir[0] * fc.step * factor * spacing;\n            pos[1] = pos[1] + dir[1] * fc.step * factor * spacing;\n            l = fc.lx * factor;\n        }\n    }\n\n    return [pos, index, index2, l * spacing];\n}\n\n\nfunction getCharVerticesCount(origin) {\n    return (origin ? 3 : 4) * 3 * 2;\n}\n\n\nfunction addText(pos, dir, text, size, spacing, fonts, vertexBuffer, texcoordsBuffer, flat, index, planes, glyphsRes, singleBuffer) {\n    let textVector = [0,1,0];\n    let p1 = [pos[0], pos[1], pos[2]];\n\n    const res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    const glyphs = res[0];\n    const gfonts = res[1];\n\n    for (let i = 0, li = glyphs.length; i < li; i++) {\n        let glyph = glyphs[i];\n        let font = fonts[gfonts[i]];\n\n        if (font) {\n            const factor = getFontFactor(size, font);\n\n            const shift = addChar(p1, dir, 0, glyph, factor, spacing, index, index, textVector, fonts, vertexBuffer, texcoordsBuffer, flat, planes, gfonts[i], singleBuffer);\n\n            //const gid2 = (i<gls.length-1 && gls[i+1]!=-1)  ? gls[i+1] : 0;\n            //x += Typr.U.getPairAdjustment(font, gid, gid2);\n\n            p1 = shift[0];\n            index = shift[1];\n        }\n    }\n\n    return index;\n}\n\n\nfunction addTextOnPath(points, distance, text, size, spacing, textVector, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes, singleBuffer) {\n    if (textVector == null) {\n        textVector = [0,1,0];\n    }\n\n    //let p1 = points[0];\n    //const newLineSpace = getLineHeight(size, fonts);\n    //const s = [p1[0], p1[1], p1[2]];\n\n    //p1 = [p1[0], p1[1], p1[2]];\n    let l = distance;\n\n    const res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    const glyphs = res[0];\n    const gfonts = res[1];\n\n    globals.processLineLabel = true;\n\n    for (let i = 0, li = glyphs.length; i < li; i++) {\n        /*\n        let char = text.charCodeAt(i);\n\n        if (char == 10) { //new line\n            s[0] += -dir[1] * newLineSpace;\n            s[1] += dir[0] * newLineSpace;\n            p1 = [s[0], s[1], s[2]];\n            continue;\n        }\n\n        if (char == 9) { //tab\n            char = 32;\n        }\n        */\n\n        const glyph = glyphs[i];\n        const font = fonts[gfonts[i]];\n\n        if (font) {\n            const factor = getFontFactor(size, font);\n\n            let ll = 0.01;\n            const fc = font.glyphs[glyph];\n            if (fc) {\n                ll = fc.step * factor * spacing;\n            }\n\n            const posAndDir = getPathPositionAndDirection(points, l);\n            const posAndDir2 = getPathPositionAndDirection(points, l+ll);\n\n            //average dir\n            const dir = [(posAndDir2[1][0] + posAndDir[1][0])*0.5,\n                (posAndDir2[1][1] + posAndDir[1][1])*0.5,\n                (posAndDir2[1][2] + posAndDir[1][2])*0.5];\n\n            vec3Normalize(dir);\n\n            const shift = addChar(posAndDir[0], dir, -factor*font.size*0.7+verticalOffset, glyph, factor, spacing, index, index, textVector, fonts, vertexBuffer, texcoordsBuffer, null, planes, gfonts[i], singleBuffer);\n\n            //p1 = shift[0];\n            index = shift[1];\n            //index2 = shift[2];\n            l += ll;\n        }\n    }\n\n    globals.processLineLabel = false;\n\n    return index;\n}\n\n\nfunction addStreetTextOnPath(points, text, size, spacing, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes, singleBuffer) {\n    const textLength = getTextLength(text, size, spacing, fonts, glyphsRes);\n    const pathLength = getPathLength(points);\n    let shift = (pathLength -  textLength)*0.5;\n    if (shift < 0) {\n        shift = 0;\n    }\n\n    if (textLength > pathLength) {\n        return;\n    }\n\n    const textVector = getPathTextVector(points, shift, text, size, spacing, fonts, glyphsRes);\n    globals.textVector = textVector;\n    globals.textCenter = getPathPositionAndDirection(points, pathLength * 0.5)[0];\n    globals.textLength = textLength;\n\n    return addTextOnPath(points, shift, text, size, spacing, textVector, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes, singleBuffer);\n}\n\n\nfunction getFontFactor(size, font) {\n    return font ? ((size / font.size) * 1.52) : 1;\n}\n\n\nfunction getLineHeight(size, lineHeight, fonts) {\n    const factor = getFontFactor(size, fonts[0]);\n    //return font.space * factor;\n    return fonts[0].cly * factor * lineHeight;\n}\n\n\nfunction getTextLength(text, size, spacing, fonts, glyphsRes) {\n    let l = 0;\n\n    const res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    const glyphs = res[0];\n    const gfonts = res[1];\n\n    for (let i = 0, li = glyphs.length; i < li; i++) {\n        const glyph = glyphs[i];\n        const font = fonts[gfonts[i]];\n\n        if (font) {\n            const factor = getFontFactor(size, font) * spacing;\n            const fc = font.glyphs[glyph];\n\n            if (fc) {\n                if (i == (li-1)) {\n                    l += fc.lx * factor;\n                } else {\n                    l += fc.step * factor;\n                }\n            }\n        }\n    }\n\n    return l;\n}\n\n\nfunction getSplitIndex(text, width, size, spacing, fonts, glyphsRes) {\n    let l = 0, i, li;\n\n    const res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    const glyphs = res[0];\n    const gfonts = res[1];\n    const codes = res[2];\n\n    for (i = 0, li = glyphs.length; i < li; i++) {\n        const glyph = glyphs[i];\n        const char = codes[i];//text.charCodeAt(i);\n\n        if (l > width && (char == 10 || char == 9 || char == 32)) {\n            return i;\n        }\n\n        if (char == 10) { //new line\n            continue;\n        }\n\n        const font = fonts[gfonts[i]];\n\n        if (font) {\n            const factor = getFontFactor(size, font) * spacing;\n            const fc = font.glyphs[glyph];\n\n            if (fc) {\n                if (i == (li-1)) {\n                    l += fc.lx * factor;\n                } else {\n                    l += fc.step * factor;\n                }\n            }\n        }\n    }\n\n    return li;\n}\n\n\nfunction getPathLength(points) {\n    let l = 0;\n\n    for (let i = 0, li = points.length-1; i < li; i++) {\n        const p1 = points[i];\n        const p2 = points[i+1];\n        const dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n        l += vec3Length(dir);\n    }\n\n    return l;\n}\n\n\nfunction getPathPositionAndDirection(points, distance) {\n    let l = 0, p2;\n    let p1 = [0,0,0];\n    let dir = [1,0,0];\n\n    for (let i = 0, li = points.length-1; i < li; i++) {\n        p1 = points[i];\n        p2 = points[i+1];\n        dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n        const ll = vec3Length(dir);\n\n        if ((l + ll) > distance) {\n\n            const factor = (distance - l) / (ll);\n            const p = [p1[0] + dir[0] * factor,\n                p1[1] + dir[1] * factor,\n                p1[2] + dir[2] * factor];\n\n            vec3Normalize(dir);\n\n            return [p, dir];\n        }\n\n        l += ll;\n    }\n\n    return [p1, dir];\n}\n\n\nfunction getPathTextVector(points, shift, text, size, spacing, fonts, glyphsRes) {\n    let l = 0;\n    let p1 = [0,0,0], p2;\n    let dir = [1,0,0];\n    let textDir = [0,0,0];\n    const textStart = shift;\n    const textEnd = shift + getTextLength(text, size, spacing, fonts, glyphsRes);\n    const bboxMin = globals.bboxMin;\n    const geocent = globals.geocent;\n\n    for (let i = 0, li = points.length-1; i < li; i++) {\n        p1 = points[i];\n        p2 = points[i+1];\n        dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n        l += vec3Length(dir);\n\n        if (l > textStart) {\n            vec3Normalize(dir);\n            textDir[0] += dir[0];\n            textDir[1] += dir[1];\n            textDir[2] += dir[2];\n        }\n\n        if (l > textEnd) {\n            vec3Normalize(textDir);\n\n            if (geocent) {\n                const nn = [0,0,0];\n                vec3Normalize(bboxMin, nn);\n                vec3Cross(nn, textDir, nn);\n                return nn;\n            } else {\n                return [-textDir[1], textDir[0],0];\n            }\n        }\n    }\n\n    return textDir;\n}\n\n\nfunction areTextCharactersAvailable(text, fonts, glyphsRes) {\n    if (!text || text == '') {\n        return false;\n    }\n\n    const res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    const glyphs = res[0];\n    //const gfonts = res[1];\n\n    if (glyphs.indexOf(0) != -1) {\n        return false;\n    }\n\n    return true;\n}\n\n\nfunction hasLatin(str) {\n    for (let i = 0, li = str.length; i < li; i++) {\n        const c = str.charCodeAt(i);\n        if ((c >= 0x41 && c <= 0x5a) || (c >= 0x61 && c <= 0x7a) ||\n            ((c >= 0xc0 && c <= 0xff) && c!= 0xd7 && c!= 0xf7) || (c >= 0x100 && c <= 0x17f)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\nfunction isCJK(str) {\n    for (let i = 0, li = str.length; i < li; i++) {\n        const c = str.charCodeAt(i);\n\n        if (!((c >= 0x4E00 && c <= 0x62FF) || (c >= 0x6300 && c <= 0x77FF) ||\n              (c >= 0x7800 && c <= 0x8CFF) || (c >= 0x8D00 && c <= 0x9FFF) ||\n              (c >= 0x3400 && c <= 0x4DBF) || (c >= 0x20000 && c <= 0x215FF) ||\n              (c >= 0x21600 && c <= 0x230FF) || (c >= 0x23100 && c <= 0x245FF) ||\n              (c >= 0x24600 && c <= 0x260FF) || (c >= 0x26100 && c <= 0x275FF) ||\n              (c >= 0x27600 && c <= 0x290FF) || (c >= 0x29100 && c <= 0x2A6DF) ||\n              (c >= 0x2A700 && c <= 0x2B73F) || (c >= 0x2B740 && c <= 0x2B81F) ||\n              (c >= 0x2B820 && c <= 0x2CEAF) || (c >= 0x2CEB0 && c <= 0x2EBEF) ||\n              (c >= 0xF900 && c <= 0xFAFF) || (c >= 0x3300 && c <= 0x33FF) ||\n              (c >= 0xFE30 && c <= 0xFE4F) || (c >= 0xF900 && c <= 0xFAFF) ||\n              (c >= 0x2F800 && c <= 0x2FA1F) ||\n              (c >= 0x0 && c <= 0x40) || (c >= 0xa0 && c <= 0xbf)  )) { //neutral\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\nfunction getFonts(fonts) {\n    const fontsMap = [];\n    for (let i = 0, li = fonts.length; i < li; i++) {\n        fontsMap.push(globals.fonts[fonts[i]]);\n    }\n\n    return fontsMap;\n}\n\n\nfunction getFontsStorage(fonts) {\n    const fontsMap = [];\n    for (let i = 0, li = fonts.length; i < li; i++) {\n        fontsMap.push(globals.fontsMap[fonts[i]]);\n    }\n\n    return fontsMap;\n}\n\n\nfunction getTextGlyphs(text, fonts) {\n    return Typr.U.stringToGlyphs(fonts, text);\n}\n\n\n\n\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=7997866a2469f1b14654.worker.js.map", null);
};

/***/ }),

/***/ "./node_modules/worker-loader/dist/cjs.js?inline&fallback=false!./src/core/map/loader/worker-main.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js?inline&fallback=false!./src/core/map/loader/worker-main.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/*!\n * Copyright (c) 2021 Melown Technologies SE\n *  *  For terms of use, see accompanying main file.\n *  *  For 3rd party libraries licenses, see 3rdpartylicenses.txt.\n * \n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/core/map/loader/worker-main.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/core/map/geodata-import/3dtiles2.js\":\n/*!*************************************************!*\\\n  !*** ./src/core/map/geodata-import/3dtiles2.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/matrix */ \"./src/core/utils/matrix.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"./src/core/utils/utils.js\");\n\n//import {math as math_} from '../../utils/math';\n\n\n//import {utilsUrl as utilsUrl_} from '../../utils/url';\n\n\n//get rid of compiler mess\n//const math = math_;\nconst vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"];\nconst utils = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"utils\"];\n//const utilsUrl = utilsUrl_;\n\nconst MapGeodataImport3DTiles2 = function() {\n    this.bintree = null;\n    this.pathTable = null;\n    this.totalNodes = 0;\n    this.pathTableSize = 1;\n    this.nodesIndex = 0;\n    this.rootSize = 1;\n};\n\n// eslint-disable-next-line\nMapGeodataImport3DTiles2.prototype.countNode = function(node, onlyChildren) {\n    this.totalNodes++;\n\n    const content = node['content'];\n\n    if (content && content['uri']) {\n        const path = content['uri'];\n\n        const tmp = path.split(\".\");\n        if (tmp.length > 1) {\n\n            const ext = tmp[tmp.length - 1];\n            tmp.pop();\n            const stmp = tmp.join('.');\n\n            if (ext == \"json\") {\n                this.pathTableSize += stmp.length + 1 + 4;\n            } else if (ext == \"mesh\") {\n                this.pathTableSize += stmp.length + 1;\n            }\n        }\n    }\n\n\n    const children = node['children'];\n\n    if (children) {\n        for (let i = 0, li = children.length; i < li; i++) {\n            this.countNode(children[i]);\n        }\n    }\n};\n\n/*\nMapGeodataImport3DTiles2.prototype.processNodeOctant = function(node, originalOctant) {\n    const content = node['content'];\n\n    if (content && content['uri']) {\n        const path = content['uri'];\n\n        const tmp = path.split(\".\");\n        if (tmp.length > 1) {\n\n            const ext = tmp[tmp.length - 1];\n            tmp.pop();\n            const stmp = tmp.join('.');\n\n            if (ext == \"json\") {\n\n                tmp = stmp.split(\"-\");\n\n            } else if (ext == \"mesh\") {\n\n                const fname = tmp;\n\n                tmp = stmp.split(\"/\");\n                tmp = tmp[tmp.length - 1];\n                tmp = tmp.split(\"-\");\n\n                const ix = parseInt(tmp[tmp.length - 3]);\n                const iy = parseInt(tmp[tmp.length - 2]);\n                const iz = parseInt(tmp[tmp.length - 1]);\n\n                const octant = (ix % 2) + (iy % 2)*2 + ((iz+1) % 2)*4;\n\n                console.log(\"octant: node: \" + originalOctant + \" mesh:\" + octant + \"   \"  + fname);\n            }\n        }\n    }\n\n};\n*/\n\n// eslint-disable-next-line\nMapGeodataImport3DTiles2.prototype.processNode = function(node, index, lod, onlyChildren) {\n\n    let index2 = index * 9;\n\n    //debugger\n    const content = node['content'];\n\n    if (content && content['uri']) {\n        const path = content['uri'];\n\n        const tmp = path.split(\".\");\n        if (tmp.length > 1) {\n\n            const ext = tmp[tmp.length - 1];\n            tmp.pop();\n            const stmp = tmp.join('.');\n\n            if (ext == \"json\") {\n                this.bintree[index2] = this.pathTableSize | (1<<31);\n                this.pathTableSize += 4;\n            } else if (ext == \"mesh\") {\n                this.bintree[index2] = this.pathTableSize;\n            }\n\n            for (let i = 0, li = stmp.length; i < li; i++) {\n                this.pathTable[this.pathTableSize++] = stmp.charCodeAt(i);\n            }\n\n            this.pathTable[this.pathTableSize++] = 0;\n        }\n    }\n\n    const children = node['children'];\n\n    if (children) {\n\n        for (let i = 0, li = children.length; i < li; i++) {\n            const child = children[i];\n            const boundingVolume = child['boundingVolume'];\n\n            if (boundingVolume) {\n\n                const extras = child['extras'];\n                let octant = 0;\n\n                if (extras) {\n                    octant = extras['ci'];\n                }\n\n\n                /*const ix = octant & 1;\n                const iy = (octant & (1<<1)) >> 1;\n                const iz = (octant & (1<<2)) >> 2;*/\n\n                /*\n                switch(octant) {\n                    case 0: octant = 4; break;\n                    case 1: octant = 5; break;\n                    case 2: octant = 6; break;\n                    case 3: octant = 7; break;\n                    case 4: octant = 0; break; //\n                    case 5: octant = 1; break; //\n                    case 6: octant = 2; break; //\n                    case 7: octant = 3; break; //\n                }*/\n\n                //this.processNodeOctant(child, octant);*/\n\n                /*\n                if (lod > 1) {\n                    iy = 1 - iy;\n                }*/\n\n                //iz = 1 - iz;\n\n                //octant = (ix<<0) + (iy << 1) + (iz << 2);\n                //octant = (ix<<0) + (iy << 1) + (iz << 2);\n\n                //octant = 0;\n\n                if (boundingVolume['region']) {\n\n                    this.totalNodes++;\n                    const childIndex = this.totalNodes;\n\n                    this.bintree[index2 + 1 + octant] = childIndex;\n\n                    this.processNode(child, childIndex, lod + 1);\n                }\n            }\n        }\n\n        /*let testCount = 0;\n        for (let i = 0, li = 8; i < li; i++) {\n            if (this.bintree[index2 + 1 + i]) {\n                testCount++;\n            }\n        }\n\n        if (testCount != children.length) {\n            console.log('duplicit octants!!!');\n        } */\n    }\n};\n\n\nMapGeodataImport3DTiles2.prototype.processJSON = function(json, options) {\n    if (!json) {\n        return;\n    }\n\n    this.rootPath = '';\n\n    this.countNode(json['root']);\n    //alloc memory\n    this.bintree = new Uint32Array(this.totalNodes*9);\n    this.pathTable = new Uint8Array(this.pathTableSize+1);\n\n    this.totalNodes = 0;\n    this.pathTableSize = 1;\n\n    //debugger\n\n    if (options.root) {\n\n        const extras = json['extras'];\n        const points = extras['extents'];\n\n        const center = [ (points[0][0]+points[1][0]+points[2][0]+points[3][0]+points[4][0]+points[5][0]+points[6][0]+points[7][0])/8,\n                         (points[0][1]+points[1][1]+points[2][1]+points[3][1]+points[4][1]+points[5][1]+points[6][1]+points[7][1])/8,\n                         (points[0][2]+points[1][2]+points[2][2]+points[3][2]+points[4][2]+points[5][2]+points[6][2]+points[7][2])/8 ];\n\n       const yv = [(points[1][0] - points[0][0]), (points[1][1] - points[0][1]), (points[1][2] - points[0][2])];\n       const xv = [(points[1][0] - points[2][0]), (points[1][1] - points[2][1]), (points[1][2] - points[2][2])];\n       const zv = [(points[4][0] - points[0][0]), (points[4][1] - points[0][1]), (points[4][2] - points[0][2])];\n\n       yv[0] = -yv[0];\n       yv[1] = -yv[1];\n       yv[2] = -yv[2];\n\n       xv[0] = -xv[0];\n       xv[1] = -xv[1];\n       xv[2] = -xv[2];\n\n       /*zv[0] = -zv[0];\n       zv[1] = -zv[1];\n       zv[2] = -zv[2];*/\n\n\n       const p = points[1];\n\n       this.rootPoints = [\n\n            [p[0],\n             p[1],\n             p[2]],\n\n            [p[0] + xv[0],\n             p[1] + xv[1],\n             p[2] + xv[2]],\n\n            [p[0] + xv[0] + yv[0],\n             p[1] + xv[1] + yv[1],\n             p[2] + xv[2] + yv[2]],\n\n            [p[0] + yv[0],\n             p[1] + yv[1],\n             p[2] + yv[2]],\n\n            [p[0] + zv[0],\n             p[1] + zv[1],\n             p[2] + zv[2]],\n\n            [p[0] + xv[0] + zv[0],\n             p[1] + xv[1] + zv[1],\n             p[2] + xv[2] + zv[2]],\n\n            [p[0] + xv[0] + yv[0] + zv[0],\n             p[1] + xv[1] + yv[1] + zv[1],\n             p[2] + xv[2] + yv[2] + zv[2]],\n\n            [p[0] + yv[0] + zv[0],\n             p[1] + yv[1] + zv[1],\n             p[2] + yv[2] + zv[2]]\n\n        ];\n\n        //this.rootPoints = points;\n        this.rootCenter = center;\n        this.rootRadius = vec3.distance(center, points[0]);\n        this.rootTexelSize = extras['nominalResolution'] * Math.pow(2,extras['depth']);\n    } else {\n        this.rootPoints = [];\n        this.rootCenter = [];\n        this.rootRadius = 1;\n        this.rootTexelSize = 1;\n    }\n\n    this.processNode(json['root'], 0, 0);\n    this.totalNodes++;\n};\n\n\nMapGeodataImport3DTiles2.prototype.loadJSON = function(path, options, onLoaded) {\n    utils.loadJSON(path, this.onLoaded.bind(this, options, onLoaded), null);\n};\n\nMapGeodataImport3DTiles2.prototype.onLoaded = function(options, onLoaded, json) {\n    this.processJSON(json, options);\n\n    if (onLoaded) {\n        onLoaded(options, {\n                   'bintree': this.bintree,\n                   'pathTable': this.pathTable,\n                   'totalNodes': this.totalNodes,\n                   'rootSize': this.rootSize,\n                   'points': this.rootPoints,\n                   'center': this.rootCenter,\n                   'radius': this.rootRadius,\n                   'texelSize': this.rootTexelSize\n               });\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MapGeodataImport3DTiles2);\n\n\n/***/ }),\n\n/***/ \"./src/core/map/loader/worker-globals.js\":\n/*!***********************************************!*\\\n  !*** ./src/core/map/loader/worker-globals.js ***!\n  \\***********************************************/\n/*! exports provided: globals */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"globals\", function() { return globals; });\n\nconst globals = {};\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/map/loader/worker-main.js\":\n/*!********************************************!*\\\n  !*** ./src/core/map/loader/worker-main.js ***!\n  \\********************************************/\n/*! no exports provided */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \"./src/core/map/loader/worker-globals.js\");\n/* harmony import */ var _worker_mesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-mesh.js */ \"./src/core/map/loader/worker-mesh.js\");\n/* harmony import */ var _geodata_import_3dtiles2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geodata-import/3dtiles2 */ \"./src/core/map/geodata-import/3dtiles2.js\");\n\n\n\n\n\n\n//get rid of compiler mess\nconst globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"globals\"];\nconst parseMesh = _worker_mesh_js__WEBPACK_IMPORTED_MODULE_1__[\"parseMesh\"];\nconst MapGeodataImport3DTiles2 = _geodata_import_3dtiles2__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n\nvar packedEvents = [];\nvar packedTransferables = [];\n\n\nfunction postPackedMessage(message, transferables) {\n\n    if (globals.config.mapPackLoaderEvents) {\n\n        packedEvents.push(message);\n\n        if (transferables) {\n            packedTransferables = packedTransferables.concat(transferables);\n        }\n\n    } else {\n\n        if (transferables) {\n            postMessage(message, transferables);\n        } else {\n            postMessage(message);\n        }\n\n    }\n}\n\n\nfunction loadBinary(path, onLoaded, onError, withCredentials, xhrParams, responseType, kind, options) {\n    const xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0: // UNINITIALIZED\n        case 1: // LOADING\n        case 2: // LOADED\n        case 3: // INTERACTIVE\n            break;\n        case 4: // COMPLETED\n            {\n                if (xhr.status >= 400 || xhr.status == 0) {\n                    if (onError) {\n                        postPackedMessage({'command' : 'on-error', 'path': path, 'status':xhr.status});\n                    }\n                    break;\n                }\n\n                const abuffer = xhr.response;\n\n                if (!abuffer) {\n                    if (onError) {\n                        postPackedMessage({'command' : 'on-error', 'path': path});\n                    }\n                    break;\n                }\n\n                if (onLoaded) {\n                    if (kind == 'direct-texture') {\n                        createImageBitmap(abuffer).then((function(bitmap){\n                            postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': bitmap, 'filesize': abuffer.size}, [bitmap]);\n                        }).bind(this));\n                    } else if (kind == 'direct-mesh') {\n                        const data = parseMesh({data:new DataView(abuffer), index:0});\n                        postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': data.mesh}, data.transferables);\n                    } else if (kind == 'direct-3dtiles') {\n                        //debugger\n                        const data = parse3DTile(JSON.parse(abuffer), options);\n                        //postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': data.geodata}, data.transferables);\n                        postMessage({'command' : 'on-loaded', 'path': path, 'data': data.geodata}, data.transferables);\n                    } else {\n                        postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': abuffer}, [abuffer]);\n                    }\n                }\n            }\n            break;\n\n        default:\n\n            if (onError) {\n                postPackedMessage({'command' : 'on-error', 'path': path});\n            }\n\n            break;\n        }\n\n    }).bind(this);\n\n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET', path, true);\n    xhr.responseType = responseType ? responseType : 'arraybuffer';\n    xhr.withCredentials = withCredentials;\n\n    if (options && options.size) {\n        xhr.setRequestHeader('Range', 'bytes=' + options.offset + '-' + (options.offset + options.size));\n    }\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n}\n\n\nfunction parse3DTile(json, options) {\n\n    const geodata = new MapGeodataImport3DTiles2();\n    geodata.processJSON(json, options);\n\n    return { geodata:{\n                'bintree': geodata.bintree,\n                'pathTable': geodata.pathTable,\n                'totalNodes': geodata.totalNodes,\n                'rootSize': geodata.rootSize,\n                'points': geodata.rootPoints,\n                'center': geodata.rootCenter,\n                'radius': geodata.rootRadius,\n                'texelSize': geodata.rootTexelSize\n             },\n             transferables:[geodata.bintree.buffer, geodata.pathTable.buffer]\n           };\n\n}\n\n\nself.onmessage = function (e) {\n    const message = e.data;\n    const command = message['command'];\n    //const data = message['data'];\n\n    //console.log(\"workeronmessage: \" + command);\n\n    switch(command) {\n\n        case 'config':\n            globals.config = message['data'];\n            break;\n\n        case 'tick':\n\n            if (packedEvents.length > 0) {\n                if (packedTransferables.length > 0) {\n                    postMessage({'command': 'packed-events', 'messages':packedEvents}, packedTransferables);\n                } else {\n                    postMessage({'command': 'packed-events', 'messages':packedEvents});\n                }\n            }\n\n            packedEvents = [];\n            packedTransferables = [];\n\n            break;\n\n        case 'load-binary':\n            loadBinary(message['path'], true, true, message['withCredentials'], message['xhrParams'], message['responseType'], message['kind'], message['options']);\n            break;\n\n    }\n};\n\n\n/***/ }),\n\n/***/ \"./src/core/map/loader/worker-mesh.js\":\n/*!********************************************!*\\\n  !*** ./src/core/map/loader/worker-mesh.js ***!\n  \\********************************************/\n/*! exports provided: parseMesh */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseMesh\", function() { return parseMesh; });\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \"./src/core/map/loader/worker-globals.js\");\n\n\n\n//get rid of compiler mess\nconst globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"globals\"];\n\nconst flagsInternalTexcoords =  1;\nconst flagsExternalTexcoords =  2;\n//const flagsPerVertexUndulation =  4;\n//const flagsTextureMode =  8;\n\n\nfunction parseMesh(stream) {\n    /*\n    struct MapMesh {\n        struct MapMeshHeader {\n            char magic[2];                // letters \"ME\"\n            ushort version;               // currently 1\n            double meanUndulation;        // read more about undulation below\n            ushort numSubmeshes;          // number of submeshes\n        } header;\n        struct Submesh submeshes [];      // array of submeshes, size of array is defined by numSubmeshes property\n    };\n    */\n\n    let mesh = {}, i, li, submesh;\n\n    //parase header\n    const streamData = stream.data;\n    let magic = '';\n\n    if (streamData.length < 2) {\n        return false;\n    }\n\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n\n    if (magic != 'ME') {\n        return false;\n    }\n\n    mesh.version = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    if (mesh.version > 3) {\n        return false;\n    }\n\n    stream.uint8Data = new Uint8Array(stream.data.buffer);\n\n    mesh.meanUndulation = streamData.getFloat64(stream.index, true); stream.index += 8;\n    mesh.numSubmeshes = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    mesh.submeshes = [];\n    mesh.gpuSize = 0;\n    mesh.faces = 0;\n    mesh.size = 0;\n\n    //const use16bit = globals.config.map16bitMeshes;\n\n    for (i = 0, li = mesh.numSubmeshes; i < li; i++) {\n        const submesh = parseSubmesh(mesh, stream);\n        if (submesh.valid) {\n            mesh.submeshes.push(submesh);\n            mesh.size += submesh.size;\n            mesh.faces += submesh.faces;\n\n            //aproximate size\n            mesh.gpuSize += submesh.size;\n        }\n    }\n\n    mesh.numSubmeshes = mesh.submeshes.length;\n\n    //prevent minification\n\n    const submeshes = [];\n    const transferables = [];\n\n    for (i = 0, li = mesh.numSubmeshes; i < li; i++) {\n        submesh = mesh.submeshes[i];\n        submeshes.push({\n\n            'bboxMax': submesh.bboxMax,\n            'bboxMin': submesh.bboxMin,\n            'externalUVs': (submesh.externalUVs) ? submesh.externalUVs.buffer : null,\n            'faces': submesh.faces,\n            'flags': submesh.flags,\n            'gpuSize': submesh.gpuSize,\n            'indices': (submesh.indices) ? submesh.indices.buffer : null,\n            'internalUVs': (submesh.internalUVs) ? submesh.internalUVs.buffer : null,\n            'size': submesh.size,\n            'surfaceReference': submesh.surfaceReference,\n            'textureLayer': submesh.textureLayer,\n            'textureLayer2': submesh.textureLayer2,\n            //'valid': submesh.valid\n            'vertices': submesh.vertices.buffer\n\n        });\n\n        if (submesh.externalUVs) transferables.push(submesh.externalUVs.buffer);\n        if (submesh.internalUVs) transferables.push(submesh.internalUVs.buffer);\n        if (submesh.vertices) transferables.push(submesh.vertices.buffer);\n        if (submesh.indices) transferables.push(submesh.indices.buffer);\n    }\n\n    return { mesh:{\n               'faces': mesh.faces,\n               'gpuSize': mesh.gpuSize,\n               'meanUndulation': mesh.meanUndulation,\n               'numSubmeshes': mesh.numSubmeshes,\n               'size': mesh.size,\n               'submeshes': mesh.submeshes,\n               'version': mesh.version\n             },\n             transferables:transferables\n           };\n}\n\n\nfunction parseSubmesh(mesh, stream) {\n    /*\n    struct MapSubmesh {\n        struct MapSubmeshHeader header;\n        struct VerticesBlock vertices;\n        struct TexcoordsBlock internalTexcoords;   // if header.flags & ( 1 << 0 )\n        struct FacesBlock faces;\n    };\n    */\n\n    const submesh = { valid:true };\n\n    parseHeader(mesh, submesh, stream);\n    if (mesh.version >= 3) {\n        parseVerticesAndFaces2(mesh, submesh, stream);\n    } else {\n        parseVerticesAndFaces(mesh, submesh, stream);\n    }\n\n    return submesh;\n}\n\n\nfunction parseHeader(mesh, submesh, stream) {\n    /*\n    struct MapSubmeshHeader {\n        char flags;                    // bit 0 - contains internal texture coords\n                                       // bit 1 - contains external texture coords\n                                       // bit 2 - contains per vertex undulation\n                                       // bit 3 - texture mode (0 - internal, 1 - external)\n\n        uchar surfaceReference;        // reference to the surface of origin, see bellow\n        ushort textureLayer;           // applicable if texture mode is external: texture layer numeric id\n        double boundingBox[2][3];      // read more about bounding box bellow\n    };\n    */\n\n    //debugger\n    const streamData = stream.data;\n\n    submesh.flags = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    if (mesh.version > 1) {\n        submesh.surfaceReference = streamData.getUint8(stream.index, true); stream.index += 1;\n    } else {\n        submesh.surfaceReference = 0;\n    }\n\n    submesh.textureLayer = streamData.getUint16(stream.index, true); stream.index += 2;\n    submesh.textureLayer2 = submesh.textureLayer; //hack for presentation\n\n    const bboxMin = [];\n    const bboxMax = [];\n\n    bboxMin[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n\n    bboxMax[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n\n    submesh.bboxMin = bboxMin;\n    submesh.bboxMax = bboxMax;\n}\n\n\nfunction parseVerticesAndFaces(mesh, submesh, stream) {\n    /*\n    struct VerticesBlock {\n        ushort numVertices;              // number of vertices\n\n        struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n            // vertex coordinates\n            ushort x;\n            ushort y;\n            ushort z;\n\n            // if header.flags & ( 1 << 1 ): external texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort eu;\n            ushort ev;\n\n            // if header.flags & ( 1 << 2 ): undulation delta\n            float16 undulationDelta;\n        } vertices[];\n    };\n    */\n\n    let index = stream.index;\n    const data = stream.data;\n    const uint8Data = stream.uint8Data;\n    const use16bit = globals.config.map16bitMeshes;\n    const numVertices = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        submesh.valid = false;\n    }\n\n    const onlyOneUVs = globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords);\n\n    let internalUVs, externalUVs;\n    let tmpVertices, tmpExternalUVs, tmpInternalUVs;\n\n    let vertices = use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n\n    if (submesh.flags & flagsExternalTexcoords) {\n        if (onlyOneUVs) {\n            externalUVs = true;\n        } else {\n            externalUVs = use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n        }\n    }\n\n    const uvfactor = use16bit ? 1.0 : (1.0 / 65535);\n    let vindex = 0;\n    let uvindex = 0;\n    let i, li;\n\n    for (i = 0; i < numVertices; i++) {\n        vertices[vindex] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n        vertices[vindex+1] = (uint8Data[index+2] + (uint8Data[index + 3]<<8)) * uvfactor;\n        vertices[vindex+2] = (uint8Data[index+4] + (uint8Data[index + 5]<<8)) * uvfactor;\n        vindex += 3;\n\n        if (externalUVs) {\n            if (!onlyOneUVs) {\n                externalUVs[uvindex] = (uint8Data[index+6] + (uint8Data[index + 7]<<8)) * uvfactor;\n                externalUVs[uvindex+1] = (65535 - (uint8Data[index+8] + (uint8Data[index + 9]<<8))) * uvfactor;\n                uvindex += 2;\n            }\n            index += 10;\n        } else {\n            index += 6;\n        }\n    }\n\n\n    tmpVertices = vertices;\n    tmpExternalUVs = externalUVs;\n\n    /*\n    struct TexcoorsBlock {\n        ushort numTexcoords;              // number of texture coordinates\n\n        struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n            // internal texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort u;\n            ushort v;\n        } texcoords[];\n    };\n    */\n\n    if (submesh.flags & flagsInternalTexcoords) {\n        const numUVs = data.getUint16(index, true); index += 2;\n\n        internalUVs = use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        //const uvfactor = 1.0 / 65535;\n\n        for (i = 0, li = numUVs * 2; i < li; i+=2) {\n            internalUVs[i] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n            internalUVs[i+1] = (65535 - (uint8Data[index+2] + (uint8Data[index + 3]<<8))) * uvfactor;\n            index += 4;\n        }\n\n        tmpInternalUVs = internalUVs;\n    }\n\n    /*\n    struct FacesBlock {\n        ushort numFaces;              // number of faces\n\n        struct Face {                 // array of faces, size of array is defined by numFaces property\n\n            ushort v[3]; // array of indices to stored vertices\n            ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n        } faces[];\n    };\n    */\n\n    const numFaces = data.getUint16(index, true); index += 2;\n    let indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    const onlyExternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && !(submesh.flags & flagsInternalTexcoords));\n    const onlyInternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords));\n    const onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (submesh.flags & flagsInternalTexcoords) {\n            internalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (submesh.flags & flagsExternalTexcoords)) {\n            externalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    let vtmp = tmpVertices;\n    let eUVs = tmpExternalUVs;\n    let iUVs = tmpInternalUVs;\n    let v1, v2, v3, vv1, vv2, vv3, sindex;\n\n    if (onlyExternalIndices) {\n        vertices = tmpVertices;\n        externalUVs = tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = tmpInternalUVs;\n    }\n\n    for (i = 0; i < numFaces; i++) {\n        v1 = (uint8Data[index] + (uint8Data[index + 1]<<8));\n        v2 = (uint8Data[index+2] + (uint8Data[index + 3]<<8));\n        v3 = (uint8Data[index+4] + (uint8Data[index + 5]<<8));\n\n        if (onlyIndices) {\n            vindex = i * 3;\n\n            if (internalUVs != null) {\n                vv1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                vv2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                vv3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n\n                vertices[vv1*3] = vtmp[v1*3];\n                vertices[vv1*3+1] = vtmp[v1*3+1];\n                vertices[vv1*3+2] = vtmp[v1*3+2];\n\n                vertices[vv2*3] = vtmp[v2*3];\n                vertices[vv2*3+1] = vtmp[v2*3+1];\n                vertices[vv2*3+2] = vtmp[v2*3+2];\n\n                vertices[vv3*3] = vtmp[v3*3];\n                vertices[vv3*3+1] = vtmp[v3*3+1];\n                vertices[vv3*3+2] = vtmp[v3*3+2];\n\n                indices[vindex] = vv1;\n                indices[vindex+1] = vv2;\n                indices[vindex+2] = vv3;\n\n                index += 12;\n            } else {\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n\n                index += 6;\n            }\n\n        } else {\n            vindex = i * (3 * 3);\n\n            sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n\n            if (internalUVs != null) {\n                v1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                v2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                v3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n                index += 12;\n\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            } else {\n                index += 6;\n            }\n        }\n    }\n\n    submesh.vertices = vertices;\n    submesh.internalUVs = internalUVs;\n    submesh.externalUVs = externalUVs;\n    submesh.indices = indices;\n\n    tmpVertices = null;\n    tmpInternalUVs = null;\n    tmpExternalUVs = null;\n\n    stream.index = index;\n\n    submesh.size = submesh.vertices.byteLength;\n    if (submesh.internalUVs) submesh.size += submesh.internalUVs.byteLength;\n    if (submesh.externalUVs) submesh.size += submesh.externalUVs.byteLength;\n    if (submesh.indices) submesh.size += submesh.indices.byteLength;\n    submesh.faces = numFaces;\n}\n\n\nfunction parseWord(data, res) {\n    const value = data[res[1]];\n\n    if (value & 0x80) {\n        res[0] = (value & 0x7f) | (data[res[1]+1] << 7);\n        res[1] += 2;\n    } else {\n        res[0] = value;\n        res[1] ++;\n    }\n}\n\n\nfunction parseDelta(data, res) {\n    let value = data[res[1]];\n\n    if (value & 0x80) {\n        value = (value & 0x7f) | (data[res[1]+1] << 7);\n\n        if (value & 1) {\n            res[0] = -((value >> 1)+1);\n            res[1] += 2;\n        } else {\n            res[0] = (value >> 1);\n            res[1] += 2;\n        }\n    } else {\n        if (value & 1) {\n            res[0] = -((value >> 1)+1);\n            res[1] ++;\n        } else {\n            res[0] = (value >> 1);\n            res[1] ++;\n        }\n    }\n}\n\n\nfunction parseVerticesAndFaces2(mesh, submesh, stream) {\n    /*\n    struct VerticesBlock {\n        ushort numVertices;              // number of vertices\n        ushort geomQuantCoef;            // geometry quantization coefficient\n\n        struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n            // vertex coordinates\n            delta x;\n            delta y;\n            delta z;\n        } vertices[];\n    };\n    */\n\n    const data = stream.data;\n    const uint8Data = stream.uint8Data;\n\n    const use16bit = globals.config.map16bitMeshes;\n    const onlyOneUVs = globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords);\n\n    let index = stream.index;\n    let tmpVertices, tmpExternalUVs, tmpInternalUVs;\n\n    const numVertices = data.getUint16(index, true); index += 2;\n    let quant = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        submesh.valid = false;\n    }\n\n    const bmin = submesh.bboxMin;\n    const bmax = submesh.bboxMax;\n\n    const center = [(bmin[0] + bmax[0])*0.5, (bmin[1] + bmax[1])*0.5, (bmin[2] + bmax[2])*0.5];\n    const scale = Math.abs(Math.max(bmax[0] - bmin[0], bmax[1] - bmin[1], bmax[2] - bmin[2]));\n\n    let multiplier = 1.0 / quant;\n    let externalUVs = null, internalUVs = null;\n\n    let vertices = use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n    let vindex;\n\n    let x = 0, y = 0,z = 0;\n    const cx = center[0], cy = center[1], cz = center[2];\n    const mx = bmin[0];\n    const my = bmin[1];\n    const mz = bmin[2];\n    const sx = 1.0 / (bmax[0] - bmin[0]);\n    const sy = 1.0 / (bmax[1] - bmin[1]);\n    const sz = 1.0 / (bmax[2] - bmin[2]);\n\n    let res = [0, index];\n    let i, li, t;\n\n    if (use16bit) {\n        for (i = 0; i < numVertices; i++) {\n            parseDelta(uint8Data, res);\n            x += res[0];\n            parseDelta(uint8Data, res);\n            y += res[0];\n            parseDelta(uint8Data, res);\n            z += res[0];\n\n            vindex = i * 3;\n            t = ((x * multiplier * scale + cx) - mx) * sx;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex] = t * 65535;\n            t = ((y * multiplier * scale + cy) - my) * sy;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+1] = t * 65535;\n            t = ((z * multiplier * scale + cz) - mz) * sz;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+2] = t * 65535;\n        }\n    } else {\n        for (i = 0; i < numVertices; i++) {\n            parseDelta(uint8Data, res);\n            x += res[0];\n            parseDelta(uint8Data, res);\n            y += res[0];\n            parseDelta(uint8Data, res);\n            z += res[0];\n\n            vindex = i * 3;\n            vertices[vindex] = ((x * multiplier * scale + cx) - mx) * sx;\n            vertices[vindex+1] = ((y * multiplier * scale + cy) - my) * sy;\n            vertices[vindex+2] = ((z * multiplier * scale + cz) - mz) * sz;\n        }\n    }\n\n    index = res[1];\n\n    if (submesh.flags & flagsExternalTexcoords) {\n        quant = data.getUint16(index, true); index += 2;\n        res[1] = index;\n\n        if (onlyOneUVs) {\n\n            for (i = 0; i < numVertices; i++) {\n                parseDelta(uint8Data, res);\n                parseDelta(uint8Data, res);\n            }\n\n        } else {\n            multiplier = (use16bit) ? (65535 / quant) : (1.0 / quant);\n            externalUVs = use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n            x = 0, y = 0;\n\n            if (use16bit) {\n                for (i = 0; i < numVertices; i++) {\n                    parseDelta(uint8Data, res);\n                    x += res[0];\n                    parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    const uvindex = i * 2;\n                    t = x * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex] = t;\n                    t = y * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex+1] = 65535 - t;\n                }\n            } else {\n                for (i = 0; i < numVertices; i++) {\n                    parseDelta(uint8Data, res);\n                    x += res[0];\n                    parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    const uvindex = i * 2;\n                    externalUVs[uvindex] = x * multiplier;\n                    externalUVs[uvindex+1] = 1 - (y * multiplier);\n                }\n            }\n        }\n    }\n\n    index = res[1];\n\n    tmpVertices = vertices;\n    tmpExternalUVs = externalUVs;\n\n    /*\n    struct TexcoorsBlock {\n        ushort numTexcoords;              // number of texture coordinates\n\n        struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n            // internal texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort u;\n            ushort v;\n        } texcoords[];\n    };\n    */\n\n    if (submesh.flags & flagsInternalTexcoords) {\n        const numUVs = data.getUint16(index, true); index += 2;\n        const quantU = data.getUint16(index, true); index += 2;\n        const quantV = data.getUint16(index, true); index += 2;\n        const multiplierU = (use16bit) ? (65536.0 / quantU) : (1.0 / quantU);\n        const multiplierV = (use16bit) ? (65536.0 / quantV) : (1.0 / quantV);\n        x = 0, y = 0;\n\n        internalUVs = use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        res[1] = index;7\n\n        if (use16bit) {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                parseDelta(uint8Data, res);\n                x += res[0];\n                parseDelta(uint8Data, res);\n                y += res[0];\n\n                t = x * multiplierU;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i] = t;\n                t = y * multiplierV;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i+1] = 65535 - t;\n            }\n        } else {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                parseDelta(uint8Data, res);\n                x += res[0];\n                parseDelta(uint8Data, res);\n                y += res[0];\n\n                internalUVs[i] = x * multiplierU;\n                internalUVs[i+1] = 1 - (y * multiplierV);\n            }\n        }\n\n        index = res[1];\n\n        tmpInternalUVs = internalUVs;\n    }\n\n    /*\n    struct FacesBlock {\n        ushort numFaces;              // number of faces\n\n        struct Face {                 // array of faces, size of array is defined by numFaces property\n\n            ushort v[3]; // array of indices to stored vertices\n            ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n        } faces[];\n    };\n    */\n\n    const numFaces = data.getUint16(index, true); index += 2;\n    let indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    const onlyExternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && !(submesh.flags & flagsInternalTexcoords));\n    const onlyInternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords));\n    const onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (submesh.flags & flagsInternalTexcoords) {\n            internalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (submesh.flags & flagsExternalTexcoords)) {\n            externalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    let vtmp = tmpVertices;\n    let eUVs = tmpExternalUVs;\n    let iUVs = tmpInternalUVs;\n    let high = 0;\n    let v1, v2, v3, vv1, vv2, vv3;\n    res[1] = index;\n\n    for (i = 0; i < numFaces; i++) {\n        parseWord(uint8Data, res);\n        v1 = high - res[0];\n        if (!res[0]) { high++; }\n\n        parseWord(uint8Data, res);\n        v2 = high - res[0];\n        if (!res[0]) { high++; }\n\n        parseWord(uint8Data, res);\n        v3 = high - res[0];\n        if (!res[0]) { high++; }\n\n        if (onlyIndices) {\n            vindex = i * 3;\n            indices[vindex] = v1;\n            indices[vindex+1] = v2;\n            indices[vindex+2] = v3;\n        } else {\n            vindex = i * (3 * 3);\n            let sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n        }\n    }\n\n    if (onlyExternalIndices) {\n        vertices = tmpVertices;\n        externalUVs = tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = tmpInternalUVs;\n    }\n\n    high = 0;\n\n    if (internalUVs != null) {\n        for (i = 0; i < numFaces; i++) {\n            parseWord(uint8Data, res);\n            v1 = high - res[0];\n            if (!res[0]) { high++; }\n\n            parseWord(uint8Data, res);\n            v2 = high - res[0];\n            if (!res[0]) { high++; }\n\n            parseWord(uint8Data, res);\n            v3 = high - res[0];\n            if (!res[0]) { high++; }\n\n            if (onlyInternalIndices) {\n                vindex = i * 3;\n\n                vv1 = indices[vindex] * 3;\n                vv2 = indices[vindex+1] * 3;\n                vv3 = indices[vindex+2] * 3;\n\n                vertices[v1*3] = vtmp[vv1];\n                vertices[v1*3+1] = vtmp[vv1+1];\n                vertices[v1*3+2] = vtmp[vv1+2];\n\n                vertices[v2*3] = vtmp[vv2];\n                vertices[v2*3+1] = vtmp[vv2+1];\n                vertices[v2*3+2] = vtmp[vv2+2];\n\n                vertices[v3*3] = vtmp[vv3];\n                vertices[v3*3+1] = vtmp[vv3+1];\n                vertices[v3*3+2] = vtmp[vv3+2];\n\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n            } else {\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            }\n        }\n    }\n\n    index = res[1];\n\n    submesh.vertices = vertices;\n    submesh.internalUVs = internalUVs;\n    submesh.externalUVs = externalUVs;\n    submesh.indices = indices;\n\n    //tmpVertices = null;\n    //tmpInternalUVs = null;\n    //tmpExternalUVs = null;\n\n    stream.index = index;\n\n    submesh.size = submesh.vertices.byteLength;\n    if (submesh.internalUVs) submesh.size += submesh.internalUVs.byteLength;\n    if (submesh.externalUVs) submesh.size += submesh.externalUVs.byteLength;\n    if (submesh.indices) submesh.size += submesh.indices.byteLength;\n    submesh.faces = numFaces;\n}\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/utils/math.js\":\n/*!********************************!*\\\n  !*** ./src/core/utils/math.js ***!\n  \\********************************/\n/*! exports provided: math */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"math\", function() { return math; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ \"./src/core/utils/matrix.js\");\n\n\n\n//get rid of compiler mess\nconst mat4 = _matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"];\n\n\nconst math = {};\n\n\nmath.isEqual = function(value, value2, delta) {\n    return (Math.abs(value - value2) < delta);\n};\n\n\nmath.clamp = function(value, min, max) {\n    if (value < min) value = min;\n    else if (value > max) value = max;\n\n    return value;\n};\n\n\nmath.radians = function(degrees) {\n    return degrees * Math.PI / 180;\n};\n\n\nmath.degrees = function(radians) {\n    return (radians / Math.PI) * 180;\n};\n\n\nmath.mix = function(a, b, c) {\n    return a + (b - a) * c;\n};\n\n\nmath.frustumMatrix = function(left, right, bottom, top, near, far) {\n    const w = (right - left);\n    const h = (top - bottom);\n    const d = (far - near);\n\n    const m = mat4.create([2*near/w, 0, (right+left)/w, 0,\n        0, 2*near/h, (top+bottom)/h, 0,\n        0, 0, -(far+near)/d, -2*far*near/d,\n        0, 0, -1, 0]);\n\n    mat4.transpose(m);\n    return m;\n};\n\n\nmath.perspectiveMatrix = function(fovy, aspect, near, far) {\n    const ymax = near * Math.tan(fovy * Math.PI / 180.0);\n    const xmax = ymax * aspect;\n    return math.frustumMatrix(-xmax, xmax, -ymax, ymax, near, far);\n};\n\n\nmath.orthographicMatrix = function(vsize, aspect, near, far) {\n    //vsize *= 0.020;\n    const w = vsize* 0.5 * aspect;\n    const h = vsize * 0.5;\n    const d = (far - near);\n\n    const m = mat4.create([1/w, 0, 0, 0,\n        0, 1/h, 0, 0,\n        0, 0, -2/d, -((far+near)/d),\n        0, 0, 0, 1]);\n\n    mat4.transpose(m);\n    return m;\n};\n\n\nmath.rotationMatrix = function(axis, angle) {\n    const ca = Math.cos(angle), sa = Math.sin(angle);\n\n    /*    const m;\n    switch (axis) {\n    case 0:\n        m = [\n            1,  0,  0, 0,\n            0, ca,-sa, 0,\n            0, sa, ca, 0,\n            0,  0,  0, 1 ];\n        break;\n    case 1:\n        m = [\n            ca, 0,-sa, 0,\n            0, 1,  0,  0,\n            sa, 0, ca, 0,\n            0, 0,  0, 1 ];\n        break;\n    default:\n        m = [\n            ca,-sa, 0, 0,\n            sa, ca, 0, 0,\n            0,  0,  1, 0,\n            0,  0,  0, 1 ];\n        break;\n    }\n    mat4.transpose(m);\n    return m; */\n\n    switch (axis) {\n    case 0:\n        return [\n            1,   0,   0,  0,\n            0,  ca,  sa,  0,\n            0, -sa,  ca,  0,\n            0,   0,   0,  1 ];\n    case 1:\n        return [\n             ca,  0,  sa,  0,\n              0,  1,   0,  0,\n            -sa,  0,  ca,  0,\n              0,  0,   0,  1 ];\n    default:\n        return [\n             ca, sa,  0,  0,\n            -sa, ca,  0,  0,\n              0,  0,  1,  0,\n              0,  0,  0,  1 ];\n    }\n\n};\n\n\nmath.scaleMatrix = function(sx, sy, sz) {\n    /*const m = [\n        sx,  0,  0, 0,\n        0, sy,  0, 0,\n        0,  0, sz, 0,\n        0,  0,  0, 1 ];\n\n    mat4.transpose(m);\n    return m;*/\n    return [\n        sx,   0,   0,   0,\n        0,   sy,   0,   0,\n        0,    0,  sz,   0,\n        0,    0,   0,   1 ];\n};\n\n\nmath.scaleMatrixf = function(s) {\n    return math.scaleMatrix(s, s, s);\n};\n\n\nmath.translationMatrix = function(tx, ty, tz) {\n    /*\n    const m = [\n        1, 0, 0, tx,\n        0, 1, 0, ty,\n        0, 0, 1, tz,\n        0, 0, 0, 1 ];\n\n    mat4.transpose(m);\n    */\n\n    return [\n        1,   0,  0,  0,\n        0,   1,  0,  0,\n        0,   0,  1,  0,\n        tx, ty, tz,  1 ];\n};\n\n\nmath.translationMatrix2f = function(t) {\n    return math.translationMatrix(t[0], t[1], 0);\n};\n\n\nmath.translationMatrix3f = function(t) {\n    return math.translationMatrix(t[0], t[1], t[2]);\n};\n\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/utils/matrix.js\":\n/*!**********************************!*\\\n  !*** ./src/core/utils/matrix.js ***!\n  \\**********************************/\n/*! exports provided: vec2, vec3, vec4, mat3, mat4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vec2\", function() { return vec2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vec3\", function() { return vec3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vec4\", function() { return vec4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mat3\", function() { return mat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mat4\", function() { return mat4; });\n\nconst vec2 = {};\n\n\nvec2.create = function (a) {\n    const b = new Array(2);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n    }\n    return b;\n};\n\n\nconst vec4 = {};\n\n\nvec4.create = function (a) {\n    const b = new Array(4);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n    }\n    return b;\n};\n\n\nvec4.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n};\n\n\nvec4.dot2 = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3];\n};\n\n\nvec4.dot3 = function (a, b, i, x, y, z) {\n    return a[0] * (b[i]-x) + a[1] * (b[i+1]-y) + a[2] * (b[i+2]-z) + a[3];\n};\n\n\nconst vec3 = {};\n\n\nvec3.create = function (a) {\n    const b = new Array(3);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n    }\n    return b;\n};\n\n\nvec3.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    return b;\n};\n\n\nvec3.add = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] += b[0];\n        a[1] += b[1];\n        a[2] += b[2];\n        return a;\n    }\n    c[0] = a[0] + b[0];\n    c[1] = a[1] + b[1];\n    c[2] = a[2] + b[2];\n    return c;\n};\n\n\nvec3.subtract = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] -= b[0];\n        a[1] -= b[1];\n        a[2] -= b[2];\n        return a;\n    }\n    c[0] = a[0] - b[0];\n    c[1] = a[1] - b[1];\n    c[2] = a[2] - b[2];\n    return c;\n};\n\n\nvec3.negate = function (a, b) {\n    b || (b = a);\n    b[0] = -a[0];\n    b[1] = -a[1];\n    b[2] = -a[2];\n    return b;\n};\n\n\nvec3.scale = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] *= b;\n        a[1] *= b;\n        a[2] *= b;\n        return a;\n    }\n    c[0] = a[0] * b;\n    c[1] = a[1] * b;\n    c[2] = a[2] * b;\n    return c;\n};\n\n\nvec3.normalize = function (a, b) {\n    b || (b = a);\n    const c = a[0],\n        d = a[1],\n        e = a[2];\n    let g = Math.sqrt(c * c + d * d + e * e);\n\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n    return b;\n};\n\n\nvec3.normalize2 = function (a, i, b) {\n    const c = a[i],\n        d = a[i+1],\n        e = a[i+2];\n    let g = Math.sqrt(c * c + d * d + e * e);\n\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n};\n\n\nvec3.normalize3 = function (a, i, b, j) {\n    const c = a[i],\n        d = a[i+1],\n        e = a[i+2];\n    let g = Math.sqrt(c * c + d * d + e * e);\n\n    if (g) {\n        if (g == 1) {\n            b[j] = c;\n            b[j+1] = d;\n            b[j+2] = e;\n            return b;\n        }\n    } else {\n        b[j] = 0;\n        b[j+1] = 0;\n        b[j+2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[j] = c * g;\n    b[j+1] = d * g;\n    b[j+2] = e * g;\n};\n\n\nvec3.normalize4 = function (a, b) {\n    b || (b = a);\n    const c = a[0],\n        d = a[1],\n        e = a[2];\n    let g = Math.sqrt(c * c + d * d + e * e);\n\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    const dd = g;\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n    return dd;\n};\n\n\nvec3.cross = function (a, b, c) {\n    c || (c = a);\n    const d = a[0],\n        e = a[1];\n    a = a[2];\n    const g = b[0],\n        f = b[1];\n    b = b[2];\n    c[0] = e * b - a * f;\n    c[1] = a * g - d * b;\n    c[2] = d * f - e * g;\n    return c;\n};\n\n\nvec3.length = function (a) {\n    const b = a[0],\n        c = a[1];\n    a = a[2];\n    return Math.sqrt(b * b + c * c + a * a);\n};\n\n\nvec3.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};\n\n\nvec3.dot2 = function (a, b, i) {\n    return a[0] * b[i] + a[1] * b[i+1] + a[2] * b[i+2];\n};\n\n\nvec3.dot3 = function (a, i, b, j) {\n    return a[i] * b[j] + a[i+1] * b[j+1] + a[i+2] * b[j+2];\n};\n\nvec3.distance = function (a, b) {\n    const dx = b[0] - a[0];\n    const dy = b[1] - a[1];\n    const dz = b[2] - a[2];\n    return Math.sqrt(dx*dx + dy*dy + dz*dz);\n};\n\nvec3.distance2 = function (a, i, b, j) {\n    const dx = b[j] - a[i];\n    const dy = b[j+1] - a[i+1];\n    const dz = b[j+2] - a[i+2];\n    return Math.sqrt(dx*dx + dy*dy + dz*dz);\n};\n\n\nvec3.squareDistance = function (a, b) {\n    const dx = b[0] - a[0];\n    const dy = b[1] - a[1];\n    const dz = b[2] - a[2];\n    return dx*dx + dy*dy + dz*dz;\n};\n\n\nvec3.direction = function (a, b, c) {\n    c || (c = a);\n    const d = a[0] - b[0],\n          e = a[1] - b[1];\n    a = a[2] - b[2];\n    b = Math.sqrt(d * d + e * e + a * a);\n    if (!b) {\n        c[0] = 0;\n        c[1] = 0;\n        c[2] = 0;\n        return c;\n    }\n    b = 1 / b;\n    c[0] = d * b;\n    c[1] = e * b;\n    c[2] = a * b;\n    return c;\n};\n\n\nvec3.lerp = function (a, b, c, d) {\n    d || (d = a);\n    d[0] = a[0] + c * (b[0] - a[0]);\n    d[1] = a[1] + c * (b[1] - a[1]);\n    d[2] = a[2] + c * (b[2] - a[2]);\n    return d;\n};\n\n\nvec3.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ']';\n};\n\n\nconst mat3 = {};\n\n\nmat3.create = function (a) {\n    const b = new Array(9);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n        b[4] = a[4];\n        b[5] = a[5];\n        b[6] = a[6];\n        b[7] = a[7];\n        b[8] = a[8];\n        b[9] = a[9];\n    }\n    return b;\n};\n\n\nmat3.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    return b;\n};\n\n\nmat3.identity = function (a) {\n    a[0] = 1;\n    a[1] = 0;\n    a[2] = 0;\n    a[3] = 0;\n    a[4] = 1;\n    a[5] = 0;\n    a[6] = 0;\n    a[7] = 0;\n    a[8] = 1;\n    return a;\n};\n\n\nmat3.transpose = function (a, b) {\n    if (!b || a == b) {\n        const c = a[1],\n            d = a[2],\n            e = a[5];\n        a[1] = a[3];\n        a[2] = a[6];\n        a[3] = c;\n        a[5] = a[7];\n        a[6] = d;\n        a[7] = e;\n        return a;\n    }\n    b[0] = a[0];\n    b[1] = a[3];\n    b[2] = a[6];\n    b[3] = a[1];\n    b[4] = a[4];\n    b[5] = a[7];\n    b[6] = a[2];\n    b[7] = a[5];\n    b[8] = a[8];\n    return b;\n};\n\n\nmat3.toMat4 = function (a, b) {\n    b || (b = mat4.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = 0;\n    b[4] = a[3];\n    b[5] = a[4];\n    b[6] = a[5];\n    b[7] = 0;\n    b[8] = a[6];\n    b[9] = a[7];\n    b[10] = a[8];\n    b[11] = 0;\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\nmat3.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    const d = b[0],\n        e = b[1];\n    b = b[2];\n    c[0] = a[0] * d + a[3] * e + a[6] * b;\n    c[1] = a[1] * d + a[4] * e + a[7] * b;\n    c[2] = a[2] * d + a[5] * e + a[8] * b;\n    return c;\n};\n\n\nmat3.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ']';\n};\n\n\nconst mat4 = {};\n\n\nmat4.create = function (a) {\n    const b = new Array(16);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n        b[4] = a[4];\n        b[5] = a[5];\n        b[6] = a[6];\n        b[7] = a[7];\n        b[8] = a[8];\n        b[9] = a[9];\n        b[10] = a[10];\n        b[11] = a[11];\n        b[12] = a[12];\n        b[13] = a[13];\n        b[14] = a[14];\n        b[15] = a[15];\n    }\n    return b;\n};\n\n\nmat4.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    b[9] = a[9];\n    b[10] = a[10];\n    b[11] = a[11];\n    b[12] = a[12];\n    b[13] = a[13];\n    b[14] = a[14];\n    b[15] = a[15];\n    return b;\n};\n\n\nmat4.identity = function (a) {\n    a[0] = 1;\n    a[1] = 0;\n    a[2] = 0;\n    a[3] = 0;\n    a[4] = 0;\n    a[5] = 1;\n    a[6] = 0;\n    a[7] = 0;\n    a[8] = 0;\n    a[9] = 0;\n    a[10] = 1;\n    a[11] = 0;\n    a[12] = 0;\n    a[13] = 0;\n    a[14] = 0;\n    a[15] = 1;\n    return a;\n};\n\n\nmat4.transpose = function (a, b) {\n    if (!b || a == b) {\n        const c = a[1],\n            d = a[2],\n            e = a[3],\n            g = a[6],\n            f = a[7],\n            h = a[11];\n        a[1] = a[4];\n        a[2] = a[8];\n        a[3] = a[12];\n        a[4] = c;\n        a[6] = a[9];\n        a[7] = a[13];\n        a[8] = d;\n        a[9] = g;\n        a[11] = a[14];\n        a[12] = e;\n        a[13] = f;\n        a[14] = h;\n        return a;\n    }\n    b[0] = a[0];\n    b[1] = a[4];\n    b[2] = a[8];\n    b[3] = a[12];\n    b[4] = a[1];\n    b[5] = a[5];\n    b[6] = a[9];\n    b[7] = a[13];\n    b[8] = a[2];\n    b[9] = a[6];\n    b[10] = a[10];\n    b[11] = a[14];\n    b[12] = a[3];\n    b[13] = a[7];\n    b[14] = a[11];\n    b[15] = a[15];\n    return b;\n};\n\n\nmat4.determinant = function (a) {\n    const b = a[0],\n        c = a[1],\n        d = a[2],\n        e = a[3],\n        g = a[4],\n        f = a[5],\n        h = a[6],\n        i = a[7],\n        j = a[8],\n        k = a[9],\n        l = a[10],\n        o = a[11],\n        m = a[12],\n        n = a[13],\n        p = a[14];\n    a = a[15];\n    return m * k * h * e - j * n * h * e - m * f * l * e + g * n * l * e + j * f * p * e - g * k * p * e - m * k * d * i + j * n * d * i + m * c * l * i - b * n * l * i - j * c * p * i + b * k * p * i + m * f * d * o - g * n * d * o - m * c * h * o + b * n * h * o + g * c * p * o - b * f * p * o - j * f * d * a + g * k * d * a + j * c * h * a - b * k * h * a - g * c * l * a + b * f * l * a;\n};\n\n\nmat4.inverse = function (a, b) {\n    b || (b = a);\n    const c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = a[4],\n        h = a[5],\n        i = a[6],\n        j = a[7],\n        k = a[8],\n        l = a[9],\n        o = a[10],\n        m = a[11],\n        n = a[12],\n        p = a[13],\n        r = a[14],\n        s = a[15],\n        A = c * h - d * f,\n        B = c * i - e * f,\n        t = c * j - g * f,\n        u = d * i - e * h,\n        v = d * j - g * h,\n        w = e * j - g * i,\n        x = k * p - l * n,\n        y = k * r - o * n,\n        z = k * s - m * n,\n        C = l * r - o * p,\n        D = l * s - m * p,\n        E = o * s - m * r,\n        q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x);\n    b[0] = (h * E - i * D + j * C) * q;\n    b[1] = (-d * E + e * D - g * C) * q;\n    b[2] = (p * w - r * v + s * u) * q;\n    b[3] = (-l * w + o * v - m * u) * q;\n    b[4] = (-f * E + i * z - j * y) * q;\n    b[5] = (c * E - e * z + g * y) * q;\n    b[6] = (-n * w + r * t - s * B) * q;\n    b[7] = (k * w - o * t + m * B) * q;\n    b[8] = (f * D - h * z + j * x) * q;\n    b[9] = (-c * D + d * z - g * x) * q;\n    b[10] = (n * v - p * t + s * A) * q;\n    b[11] = (-k * v + l * t - m * A) * q;\n    b[12] = (-f * C + h * y - i * x) * q;\n    b[13] = (c * C - d * y + e * x) * q;\n    b[14] = (-n * u + p * B - r * A) * q;\n    b[15] = (k * u - l * B + o * A) * q;\n    return b;\n};\n\n\nmat4.toRotationMat = function (a, b) {\n    b || (b = mat4.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    b[9] = a[9];\n    b[10] = a[10];\n    b[11] = a[11];\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\n\nmat4.toMat3 = function (a, b) {\n    b || (b = mat3.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[4];\n    b[4] = a[5];\n    b[5] = a[6];\n    b[6] = a[8];\n    b[7] = a[9];\n    b[8] = a[10];\n    return b;\n};\n\n\nmat4.toInverseMat3 = function (a, b) {\n    const c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[4],\n        f = a[5],\n        h = a[6],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = k * f - h * j,\n        o = -k * g + h * i,\n        m = j * g - f * i;\n    let n = c * l + d * o + e * m;\n    if (!n) return null;\n    n = 1 / n;\n    b || (b = mat3.create());\n    b[0] = l * n;\n    b[1] = (-k * d + e * j) * n;\n    b[2] = (h * d - e * f) * n;\n    b[3] = o * n;\n    b[4] = (k * c - e * i) * n;\n    b[5] = (-h * c + e * g) * n;\n    b[6] = m * n;\n    b[7] = (-j * c + d * i) * n;\n    b[8] = (f * c - d * g) * n;\n    return b;\n};\n\n\nmat4.multiply = function (a, b, c) {\n    c || (c = a);\n    const d = a[0],\n        e = a[1],\n        g = a[2],\n        f = a[3],\n        h = a[4],\n        i = a[5],\n        j = a[6],\n        k = a[7],\n        l = a[8],\n        o = a[9],\n        m = a[10],\n        n = a[11],\n        p = a[12],\n        r = a[13],\n        s = a[14];\n    a = a[15];\n    const A = b[0],\n        B = b[1],\n        t = b[2],\n        u = b[3],\n        v = b[4],\n        w = b[5],\n        x = b[6],\n        y = b[7],\n        z = b[8],\n        C = b[9],\n        D = b[10],\n        E = b[11],\n        q = b[12],\n        F = b[13],\n        G = b[14];\n    b = b[15];\n    c[0] = A * d + B * h + t * l + u * p;\n    c[1] = A * e + B * i + t * o + u * r;\n    c[2] = A * g + B * j + t * m + u * s;\n    c[3] = A * f + B * k + t * n + u * a;\n    c[4] = v * d + w * h + x * l + y * p;\n    c[5] = v * e + w * i + x * o + y * r;\n    c[6] = v * g + w * j + x * m + y * s;\n    c[7] = v * f + w * k + x * n + y * a;\n    c[8] = z * d + C * h + D * l + E * p;\n    c[9] = z * e + C * i + D * o + E * r;\n    c[10] = z * g + C * j + D * m + E * s;\n    c[11] = z * f + C * k + D * n + E * a;\n    c[12] = q * d + F * h + G * l + b * p;\n    c[13] = q * e + F * i + G * o + b * r;\n    c[14] = q * g + F * j + G * m + b * s;\n    c[15] = q * f + F * k + G * n + b * a;\n    return c;\n};\n\n\nmat4.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    const d = b[0],\n        e = b[1];\n    b = b[2];\n    c[0] = a[0] * d + a[4] * e + a[8] * b + a[12];\n    c[1] = a[1] * d + a[5] * e + a[9] * b + a[13];\n    c[2] = a[2] * d + a[6] * e + a[10] * b + a[14];\n    return c;\n};\n\n\nmat4.multiplyVec4 = function (a, b, c) {\n    c || (c = b);\n    const d = b[0],\n        e = b[1],\n        g = b[2];\n    b = b[3];\n    c[0] = a[0] * d + a[4] * e + a[8] * g + a[12] * b;\n    c[1] = a[1] * d + a[5] * e + a[9] * g + a[13] * b;\n    c[2] = a[2] * d + a[6] * e + a[10] * g + a[14] * b;\n    c[3] = a[3] * d + a[7] * e + a[11] * g + a[15] * b;\n    return c;\n};\n\n\nmat4.translate = function (a, b, c) {\n    const d = b[0],\n        e = b[1];\n    b = b[2];\n    if (!c || a == c) {\n        a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];\n        a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];\n        a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];\n        a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];\n        return a;\n    }\n    const g = a[0],\n        f = a[1],\n        h = a[2],\n        i = a[3],\n        j = a[4],\n        k = a[5],\n        l = a[6],\n        o = a[7],\n        m = a[8],\n        n = a[9],\n        p = a[10],\n        r = a[11];\n    c[0] = g;\n    c[1] = f;\n    c[2] = h;\n    c[3] = i;\n    c[4] = j;\n    c[5] = k;\n    c[6] = l;\n    c[7] = o;\n    c[8] = m;\n    c[9] = n;\n    c[10] = p;\n    c[11] = r;\n    c[12] = g * d + j * e + m * b + a[12];\n    c[13] = f * d + k * e + n * b + a[13];\n    c[14] = h * d + l * e + p * b + a[14];\n    c[15] = i * d + o * e + r * b + a[15];\n    return c;\n};\n\n\nmat4.scale = function (a, b, c) {\n    const d = b[0],\n        e = b[1];\n    b = b[2];\n    if (!c || a == c) {\n        a[0] *= d;\n        a[1] *= d;\n        a[2] *= d;\n        a[3] *= d;\n        a[4] *= e;\n        a[5] *= e;\n        a[6] *= e;\n        a[7] *= e;\n        a[8] *= b;\n        a[9] *= b;\n        a[10] *= b;\n        a[11] *= b;\n        return a;\n    }\n    c[0] = a[0] * d;\n    c[1] = a[1] * d;\n    c[2] = a[2] * d;\n    c[3] = a[3] * d;\n    c[4] = a[4] * e;\n    c[5] = a[5] * e;\n    c[6] = a[6] * e;\n    c[7] = a[7] * e;\n    c[8] = a[8] * b;\n    c[9] = a[9] * b;\n    c[10] = a[10] * b;\n    c[11] = a[11] * b;\n    c[12] = a[12];\n    c[13] = a[13];\n    c[14] = a[14];\n    c[15] = a[15];\n    return c;\n};\n\n\nmat4.rotate = function (a, b, c, d) {\n    let e = c[0],\n        g = c[1];\n    c = c[2];\n    let f = Math.sqrt(e * e + g * g + c * c);\n    if (!f) return null;\n    if (f != 1) {\n        f = 1 / f;\n        e *= f;\n        g *= f;\n        c *= f;\n    }\n    const h = Math.sin(b),\n        i = Math.cos(b),\n        j = 1 - i;\n    b = a[0];\n    f = a[1];\n    const k = a[2],\n        l = a[3],\n        o = a[4],\n        m = a[5],\n        n = a[6],\n        p = a[7],\n        r = a[8],\n        s = a[9],\n        A = a[10],\n        B = a[11],\n        t = e * e * j + i,\n        u = g * e * j + c * h,\n        v = c * e * j - g * h,\n        w = e * g * j - c * h,\n        x = g * g * j + i,\n        y = c * g * j + e * h,\n        z = e * c * j + g * h;\n    e = g * c * j - e * h;\n    g = c * c * j + i;\n    if (d) {\n        if (a != d) {\n            d[12] = a[12];\n            d[13] = a[13];\n            d[14] = a[14];\n            d[15] = a[15];\n        }\n    } else d = a;\n    d[0] = b * t + o * u + r * v;\n    d[1] = f * t + m * u + s * v;\n    d[2] = k * t + n * u + A * v;\n    d[3] = l * t + p * u + B * v;\n    d[4] = b * w + o * x + r * y;\n    d[5] = f * w + m * x + s * y;\n    d[6] = k * w + n * x + A * y;\n    d[7] = l * w + p * x + B * y;\n    d[8] = b * z + o * e + r * g;\n    d[9] = f * z + m * e + s * g;\n    d[10] = k * z + n * e + A * g;\n    d[11] = l * z + p * e + B * g;\n    return d;\n};\n\n\nmat4.rotateX = function (a, b, c) {\n    const d = Math.sin(b);\n    b = Math.cos(b);\n    const e = a[4],\n        g = a[5],\n        f = a[6],\n        h = a[7],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = a[11];\n    if (c) {\n        if (a != c) {\n            c[0] = a[0];\n            c[1] = a[1];\n            c[2] = a[2];\n            c[3] = a[3];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[4] = e * b + i * d;\n    c[5] = g * b + j * d;\n    c[6] = f * b + k * d;\n    c[7] = h * b + l * d;\n    c[8] = e * -d + i * b;\n    c[9] = g * -d + j * b;\n    c[10] = f * -d + k * b;\n    c[11] = h * -d + l * b;\n    return c;\n};\n\n\nmat4.rotateY = function (a, b, c) {\n    const d = Math.sin(b);\n    b = Math.cos(b);\n    const e = a[0],\n        g = a[1],\n        f = a[2],\n        h = a[3],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = a[11];\n    if (c) {\n        if (a != c) {\n            c[4] = a[4];\n            c[5] = a[5];\n            c[6] = a[6];\n            c[7] = a[7];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[0] = e * b + i * -d;\n    c[1] = g * b + j * -d;\n    c[2] = f * b + k * -d;\n    c[3] = h * b + l * -d;\n    c[8] = e * d + i * b;\n    c[9] = g * d + j * b;\n    c[10] = f * d + k * b;\n    c[11] = h * d + l * b;\n    return c;\n};\n\n\nmat4.rotateZ = function (a, b, c) {\n    const d = Math.sin(b);\n    b = Math.cos(b);\n    const e = a[0],\n        g = a[1],\n        f = a[2],\n        h = a[3],\n        i = a[4],\n        j = a[5],\n        k = a[6],\n        l = a[7];\n    if (c) {\n        if (a != c) {\n            c[8] = a[8];\n            c[9] = a[9];\n            c[10] = a[10];\n            c[11] = a[11];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[0] = e * b + i * d;\n    c[1] = g * b + j * d;\n    c[2] = f * b + k * d;\n    c[3] = h * b + l * d;\n    c[4] = e * -d + i * b;\n    c[5] = g * -d + j * b;\n    c[6] = f * -d + k * b;\n    c[7] = h * -d + l * b;\n    return c;\n};\n\n\nmat4.frustum = function (a, b, c, d, e, g, f) {\n    f || (f = mat4.create());\n    const h = b - a,\n        i = d - c,\n        j = g - e;\n    f[0] = e * 2 / h;\n    f[1] = 0;\n    f[2] = 0;\n    f[3] = 0;\n    f[4] = 0;\n    f[5] = e * 2 / i;\n    f[6] = 0;\n    f[7] = 0;\n    f[8] = (b + a) / h;\n    f[9] = (d + c) / i;\n    f[10] = -(g + e) / j;\n    f[11] = -1;\n    f[12] = 0;\n    f[13] = 0;\n    f[14] = -(g * e * 2) / j;\n    f[15] = 0;\n    return f;\n};\n\n\nmat4.perspective = function (a, b, c, d, e) {\n    a = c * Math.tan(a * Math.PI / 360);\n    b = a * b;\n    return mat4.frustum(-b, b, -a, a, c, d, e);\n};\n\n\nmat4.ortho = function (a, b, c, d, e, g, f) {\n    f || (f = mat4.create());\n    const h = b - a,\n        i = d - c,\n        j = g - e;\n    f[0] = 2 / h;\n    f[1] = 0;\n    f[2] = 0;\n    f[3] = 0;\n    f[4] = 0;\n    f[5] = 2 / i;\n    f[6] = 0;\n    f[7] = 0;\n    f[8] = 0;\n    f[9] = 0;\n    f[10] = -2 / j;\n    f[11] = 0;\n    f[12] = -(a + b) / h;\n    f[13] = -(d + c) / i;\n    f[14] = -(g + e) / j;\n    f[15] = 1;\n    return f;\n};\n\n\nmat4.lookAt = function (a, b, c, d) {\n    d || (d = mat4.create());\n    let e = a[0],\n        g = a[1];\n    a = a[2];\n    let f = c[0],\n        h = c[1],\n        i = c[2];\n    c = b[1];\n    let j = b[2];\n    if (e == b[0] && g == c && a == j) return mat4.identity(d);\n    let k, l, o, m;\n    c = e - b[0];\n    j = g - b[1];\n    b = a - b[2];\n    m = 1 / Math.sqrt(c * c + j * j + b * b);\n    c *= m;\n    j *= m;\n    b *= m;\n    k = h * b - i * j;\n    i = i * c - f * b;\n    f = f * j - h * c;\n    m = Math.sqrt(k * k + i * i + f * f);\n    if (m) {\n        m = 1 / m;\n        k *= m;\n        i *= m;\n        f *= m;\n    } else f = i = k = 0;\n    h = j * f - b * i;\n    l = b * k - c * f;\n    o = c * i - j * k;\n    m = Math.sqrt(h * h + l * l + o * o);\n    if (m) {\n        m = 1 / m;\n        h *= m;\n        l *= m;\n        o *= m;\n    } else o = l = h = 0;\n    d[0] = k;\n    d[1] = h;\n    d[2] = c;\n    d[3] = 0;\n    d[4] = i;\n    d[5] = l;\n    d[6] = j;\n    d[7] = 0;\n    d[8] = f;\n    d[9] =\n        o;\n    d[10] = b;\n    d[11] = 0;\n    d[12] = -(k * e + i * g + f * a);\n    d[13] = -(h * e + l * g + o * a);\n    d[14] = -(c * e + j * g + b * a);\n    d[15] = 1;\n    return d;\n};\n\n\nmat4.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ']';\n};\n\n\nconst quat4 = {};\n\n\nquat4.create = function (a) {\n    const b = new Array(4);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n    }\n    return b;\n};\n\n\nquat4.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    return b;\n};\n\n\nquat4.calculateW = function (a, b) {\n    const c = a[0],\n        d = a[1],\n        e = a[2];\n    if (!b || a == b) {\n        a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\n        return a;\n    }\n    b[0] = c;\n    b[1] = d;\n    b[2] = e;\n    b[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\n    return b;\n};\n\n\nquat4.inverse = function (a, b) {\n    if (!b || a == b) {\n        a[0] *= 1;\n        a[1] *= 1;\n        a[2] *= 1;\n        return a;\n    }\n    b[0] = -a[0];\n    b[1] = -a[1];\n    b[2] = -a[2];\n    b[3] = a[3];\n    return b;\n};\n\n\nquat4.length = function (a) {\n    const b = a[0],\n        c = a[1],\n        d = a[2];\n    a = a[3];\n    return Math.sqrt(b * b + c * c + d * d + a * a);\n};\n\n\nquat4.normalize = function (a, b) {\n    b || (b = a);\n    const c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3];\n    let f = Math.sqrt(c * c + d * d + e * e + g * g);\n    if (f == 0) {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        b[3] = 0;\n        return b;\n    }\n    f = 1 / f;\n    b[0] = c * f;\n    b[1] = d * f;\n    b[2] = e * f;\n    b[3] = g * f;\n    return b;\n};\n\n\nquat4.multiply = function (a, b, c) {\n    c || (c = a);\n    const d = a[0],\n        e = a[1],\n        g = a[2];\n    a = a[3];\n    const f = b[0],\n        h = b[1],\n        i = b[2];\n    b = b[3];\n    c[0] = d * b + a * f + e * i - g * h;\n    c[1] = e * b + a * h + g * f - d * i;\n    c[2] = g * b + a * i + d * h - e * f;\n    c[3] = a * b - d * f - e * h - g * i;\n    return c;\n};\n\n\nquat4.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    let d = b[0];\n    const e = b[1],\n        g = b[2];\n    b = a[0];\n    const f = a[1],\n        h = a[2];\n    a = a[3];\n    const i = a * d + f * g - h * e,\n        j = a * e + h * d - b * g,\n        k = a * g + b * e - f * d;\n    d = -b * d - f * e - h * g;\n    c[0] = i * a + d * -b + j * -h - k * -f;\n    c[1] = j * a + d * -f + k * -b - i * -h;\n    c[2] = k * a + d * -h + i * -f - j * -b;\n    return c;\n};\n\n\nquat4.toMat3 = function (a, b) {\n    b || (b = mat3.create());\n    let c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = c + c,\n        h = d + d,\n        i = e + e,\n        j = c * f,\n        k = c * h;\n    c = c * i;\n    const l = d * h;\n    d = d * i;\n    e = e * i;\n    f = g * f;\n    h = g * h;\n    g = g * i;\n    b[0] = 1 - (l + e);\n    b[1] = k - g;\n    b[2] = c + h;\n    b[3] = k + g;\n    b[4] = 1 - (j + e);\n    b[5] = d - f;\n    b[6] = c - h;\n    b[7] = d + f;\n    b[8] = 1 - (j + l);\n    return b;\n};\n\n\nquat4.toMat4 = function (a, b) {\n    b || (b = mat4.create());\n    let c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = c + c,\n        h = d + d,\n        i = e + e,\n        j = c * f,\n        k = c * h;\n    c = c * i;\n    const l = d * h;\n    d = d * i;\n    e = e * i;\n    f = g * f;\n    h = g * h;\n    g = g * i;\n    b[0] = 1 - (l + e);\n    b[1] = k - g;\n    b[2] = c + h;\n    b[3] = 0;\n    b[4] = k + g;\n    b[5] = 1 - (j + e);\n    b[6] = d - f;\n    b[7] = 0;\n    b[8] = c - h;\n    b[9] = d + f;\n    b[10] = 1 - (j + l);\n    b[11] = 0;\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\n\nquat4.slerp = function (a, b, c, d) {\n    d || (d = a);\n    let e = c;\n    if (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3] < 0) e = -1 * c;\n    d[0] = 1 - c * a[0] + e * b[0];\n    d[1] = 1 - c * a[1] + e * b[1];\n    d[2] = 1 - c * a[2] + e * b[2];\n    d[3] = 1 - c * a[3] + e * b[3];\n    return d;\n};\n\n\nquat4.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ']';\n};\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/utils/url.js\":\n/*!*******************************!*\\\n  !*** ./src/core/utils/url.js ***!\n  \\*******************************/\n/*! exports provided: utilsUrl */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"utilsUrl\", function() { return utilsUrl; });\n\nconst utilsUrl = {};\n\n\nutilsUrl.isSameOrigin = function(url) {\n    if (typeof url !== 'string') {\n        return false;\n    }\n    const docHost = document.location.hostname;\n    const parser = utilsUrl.parse(url);\n    return parser['hostname'] === docHost;\n};\n\n\nutilsUrl.parse = function(url) {\n    if (typeof url !== 'string') {\n        return null;\n    }\n\n    const parser = document.createElement('a');\n    parser['href'] = url;\n    return parser;\n};\n\n\nutilsUrl.getParamsFromUrl = function(url) {\n    const parser = utilsUrl.parse(url);\n    const queryString = {};\n    const query = parser['search'].substring(1);\n    const vars = query.split('&');\n    if (!(vars.length == 1 && vars[0] == '')) {\n        for (let i = 0; i < vars.length; i++) {\n            const pair = vars[i].split('=');\n            if (typeof queryString[pair[0]] === 'undefined') {\n                queryString[pair[0]] = pair[1];\n            } else if (typeof queryString[pair[0]] === 'string') {\n                const arr = [ queryString[pair[0]], pair[1] ];\n                queryString[pair[0]] = arr;\n            } else {\n                queryString[pair[0]].push(pair[1]);\n            }\n        }\n    }\n    return queryString;\n};\n\n\nutilsUrl.getHost = function(url) {\n    const location = document.createElement('a');\n    location.href = url;\n    return location.hostname;\n};\n\n\nutilsUrl.getSchema = function(url) {\n    //if (window.location.href.indexOf(\"file://\") != -1) {\n    if (url.indexOf('http://') != -1) {\n        return 'http:';\n    } else if (url.indexOf('https://') != -1) {\n        return 'https:';\n    } else {\n        const location = document.createElement('a');\n        location.href = url;\n        return location.protocol;\n    }\n};\n\n\nutilsUrl.getOrigin = function(url) {\n    const location = document.createElement('a');\n    location.href = url;\n\n    if (!location.origin) {  //IE11 hack\n      return location.protocol + \"//\" + location.hostname + (location.port ? ':' + location.port: '');\n    }\n\n    return location.origin;\n};\n\n\nutilsUrl.getBase = function(url) {\n    return url.split('?')[0].split('/').slice(0, -1).join('/')+'/';\n};\n\n\nutilsUrl.makeAbsolute = function(href) {\n    const link = document.createElement(\"a\");\n    link.href = href;\n    return link.href;\n};\n\nutilsUrl.getProcessUrl = function(url, originUrl) {\n    if (!url || !originUrl) {\n        return url;\n    }\n\n    url = url.trim();\n    originUrl= originUrl.trim();\n    const baseUrl = utilsUrl.getBase(originUrl);\n    const baseUrlSchema = utilsUrl.getSchema(originUrl);\n    const baseUrlOrigin = utilsUrl.getOrigin(originUrl);\n\n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return baseUrlOrigin + url;\n    } else {  //relative\n        return baseUrl + url;\n    }\n};\n\n\n\n\n\n/***/ }),\n\n/***/ \"./src/core/utils/utils.js\":\n/*!*********************************!*\\\n  !*** ./src/core/utils/utils.js ***!\n  \\*********************************/\n/*! exports provided: utils */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"utils\", function() { return utils; });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ \"./src/core/utils/math.js\");\n/* harmony import */ var _url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./url */ \"./src/core/utils/url.js\");\n\n\n\n\n//get rid of compiler mess\nconst math = _math__WEBPACK_IMPORTED_MODULE_0__[\"math\"];\nconst utilsUrl = _url__WEBPACK_IMPORTED_MODULE_1__[\"utilsUrl\"];\n\n\nconst utils = {};\nutils.useCredentials = false; //\nutils.forceCredentials = false;\nutils.instanceCounter = 0;\n\n\nutils.validateBool = function(value, defaultValue) {\n    if (typeof value === 'boolean') {\n        return value;\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.validateNumber = function(value, minValue, maxValue, defaultValue) {\n    if (typeof value === 'number') {\n        return math.clamp(value, minValue, maxValue);\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.validateNumberArray = function(array, arraySize, minValues, maxValues, defaultValues) {\n    if (Array.isArray(array) && array.length == arraySize) {\n        for (let i = 0; i < arraySize; i++) {\n            array[i] = math.clamp(array[i], minValues[i], maxValues[i]);\n        }\n        return array;\n    } else {\n        return defaultValues;\n    }\n};\n\n\nutils.validateString = function(value, defaultValue) {\n    if (typeof value === 'string') {\n        return value;\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.padNumber = function(n, width) {\n    const z = '0';\n\n    if (n < 0) {\n        n = (-n) + '';\n        width--;     //7\n        return n.length >= width ? ('-' + n) : '-' + (new Array(width - n.length + 1).join(z) + n);\n    } else {\n        n = n + '';\n        return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n    }\n};\n\n\nutils.decodeFloat16 = function(binary) {\n    const exponent = (binary & 0x7C00) >> 10;\n    const fraction = binary & 0x03FF;\n    return (binary >> 15 ? -1 : 1) * (\n        exponent ?\n        (\n            exponent === 0x1F ?\n            fraction ? NaN : Infinity :\n            Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n        ) :\n        6.103515625e-5 * (fraction / 0x400)\n    );\n};\n\n\nutils.simpleFmtObj = (function obj(str, obj) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    return str.replace(/\\{([$a-zA-Z0-9][$a-zA-Z0-9]*)\\}/g, function(s, match) {\n        return (match in obj ? obj[match] : s);\n    });\n});\n\n\nutils.simpleWikiLinks = (function obj(str, plain) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    const str2 = utils.simpleFmtObj(str, {'copy':'&copy;', 'Y': (new Date().getFullYear())});\n\n    return str2.replace(/\\[([^\\]]*)\\]/g, function(s, match) {\n        match  = match.trim();\n        const urls = match.split(' ');//, 1);\n\n        if (urls[0].indexOf('//') != -1) {\n            if (plain) {\n                if (urls.length > 1) {\n                    return '' + match.substring(urls[0].length);\n                } else {\n                    return '' + urls[0];\n                }\n            } else {\n                if (urls.length > 1) {\n                    return '<a href=' + urls[0] + ' target=\"blank\">' + match.substring(urls[0].length)+'</a>';\n                } else {\n                    return '<a href=' + urls[0] + ' target=\"blank\">' + urls[0]+'</a>';\n                }\n            }\n        }\n\n        return match;\n    });\n});\n\n\nutils.simpleFmtObjOrCall = (function obj(str, obj, call) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    return str.replace(/\\{([$a-zA-Z(-9][$a-zA-Z(-9]*)\\}/g, function(s, match) {\n        return (match in obj ? obj[match] : call(match));\n    });\n});\n\n\nutils.getABGRFromHexaCode = (function(code) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(code);\n\n    return result ?\n    [ parseInt(result[4], 16),\n        parseInt(result[3], 16),\n        parseInt(result[2], 16),\n        parseInt(result[1], 16)]\n    : [0,0,0,255];\n});\n\n\nutils.stringifyFunction = (function(fn) {\n    // Stringify the code\n    return '(' + fn + ').call(self);';\n});\n\n\nutils.isPowerOfTwo = (function(value) {\n    return (value & (value - 1)) === 0 && value !== 0;\n});\n\n\nutils.nearestPowerOfTwo = (function(value) {\n    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));\n});\n\n\nutils.fitToPowerOfTwo = (function(value) {\n    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n});\n\n\nutils.getHash = function(str) {\n    if (!str || str.length === 0) {\n        return 0;\n    }\n\n    let hash = 0, c;\n    for (let i = 0, li = str.length; i < li; i++) {\n        c   = str.charCodeAt(i);\n        hash  = ((hash << 5) - hash) + c;\n        hash |= 0; // Convert to 32bit integer\n    }\n\n    return hash;\n};\n\n\nutils.convertRGB2YCbCr = function(r, g, b) {\n  return [( .299 * r + .587 * g  +  0.114 * b) + 0,\n          ( -.169 * r + -.331 * g +  0.500 * b) + 128,\n          ( .500 * r + -.419 * g +  -0.081 * b) + 128];\n};\n\n\nutils.convertYCbCr2RGB = function(y, cb, cr) {\n  return [1 * y +  0 * (cb-128)      +  1.4 * (cr-128),\n          1 * y +  -.343 * (cb-128)  +  -.711 * (cr-128),\n          1 * y +  1.765 * (cb-128)  +  0 * (cr-128)];\n};\n\n\nutils.convertHSL2RGB = function(h, s, l){\n   let r, g, b, m, c, x;\n\n    h /= 60;\n    if (h < 0) h = 6 - (-h % 6);\n    h %= 6;\n\n    s = Math.max(0, Math.min(1, s / 100));\n    l = Math.max(0, Math.min(1, l / 100));\n\n    c = (1 - Math.abs((2 * l) - 1)) * s;\n    x = c * (1 - Math.abs((h % 2) - 1));\n\n    if (h < 1) {\n        r = c, g = x, b = 0;\n    } else if (h < 2) {\n        r = x, g = c, b = 0;\n    } else if (h < 3) {\n        r = 0, g = c, b = x;\n    } else if (h < 4) {\n        r = 0, g = x, b = c;\n    } else if (h < 5) {\n        r = x, g = 0, b = c;\n    } else {\n        r = c, g = 0, b = x;\n    }\n\n    m = l - c / 2\n\n    return [(r + m),\n            (g + m),\n            (b + m)];\n}\n\n\nutils.getHashColor = function(str) {\n    const h = utils.getHash(str);\n    const c = utils.convertRGB2YCbCr(h&255,(h>>8)&255,(h>>16)&255);\n    c[0] = math.clamp(c[0], 50, 200);\n    return utils.convertRGB2YCbCr(c[0],c[1],c[2]);\n};\n\n\nutils.getHashColor2 = function(counter) {\n    let h = Math.floor(counter / 18);\n    let l = 50;\n\n    if (h >= 1) {\n        if (h % 2) {\n            l = 50 + ((l * 10) % 30);\n        } else {\n            l = 50 - (((l-1) * 10) % 30);\n        }\n     }\n\n    h = (counter % 18) * 20;\n\n    return utils.convertHSL2RGB(h,100,l);\n};\n\n\nutils.loadText = function(path, onLoaded, onError, withCredentials, xhrParams) {\n    utils.loadJSON(path, onLoaded, onError, true, withCredentials, xhrParams);\n};\n\n\nutils.loadXML = function(path, onLoaded, onError, withCredentials, xhrParams) {\n    const onLoaded2 = (function(data){\n        const parser = new DOMParser();\n        data = parser.parseFromString(data, 'text/xml');\n        if (onLoaded) {\n            onLoaded(data);\n        }\n    });\n\n    utils.loadJSON(path, onLoaded2, onError, true, withCredentials, xhrParams);\n};\n\n\nutils.loadJSON = function(path, onLoaded, onError, skipParse, withCredentials, xhrParams) {\n    const xhr = new XMLHttpRequest();\n\n    //xhr.onload  = (function() {\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0: // UNINITIALIZED\n        case 1: // LOADING\n        case 2: // LOADED\n        case 3: // INTERACTIVE\n            break;\n        case 4: // COMPLETED\n            {\n                if (xhr.status >= 400 || xhr.status == 0) {\n                    if (onError) {\n                        onError(xhr.status);\n                    }\n                    break;\n                }\n\n                const data = xhr.response;\n                let parsedData = data;\n\n                if (!skipParse) {\n                    try {\n                        parsedData = JSON.parse(data);\n                    } catch(e) {\n                        // eslint-disable-next-line\n                        console.log('JSON Parse Error ('+path+'): ' + (e['message'] ? e['message'] : ''));\n\n                        if (onError ) {\n                            onError(xhr.status);\n                        }\n\n                        return;\n                    }\n                }\n\n                if (onLoaded) {\n                    onLoaded(parsedData);\n                }\n            }\n            break;\n        }\n\n    }).bind(this);\n\n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET',  path, true);\n    xhr.withCredentials = utils.forceCredentials || withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    if (xhrParams && xhrParams['charset']) {\n        xhr.overrideMimeType('text/xml; charset=' + xhrParams['charset']);\n        //xhr.setRequestHeader('Content-type', xhrParams['Content-type']);\n    }\n\n    xhr.send('');\n};\n\n\nutils.loadBinary = function(path, onLoaded, onError, withCredentials, xhrParams, responseType) {\n    const xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0: // UNINITIALIZED\n        case 1: // LOADING\n        case 2: // LOADED\n        case 3: // INTERACTIVE\n            break;\n        case 4: // COMPLETED\n            {\n                if (xhr.status >= 400 || xhr.status == 0) {\n                    if (onError) {\n                        onError(xhr.status);\n                    }\n                    break;\n                }\n\n                const abuffer = xhr.response;\n\n                if (!abuffer) {\n                    if (onError) {\n                        onError();\n                    }\n                    break;\n                }\n\n                if (onLoaded) {\n                    onLoaded(abuffer);\n                }\n            }\n            break;\n\n        default:\n\n            if (onError) {\n                onError();\n            }\n\n            break;\n        }\n\n    }).bind(this);\n\n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET', path, true);\n    xhr.responseType = responseType ? responseType : 'arraybuffer';\n    xhr.withCredentials = utils.forceCredentials || withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n};\n\n\nutils.headRequest = function(url, onLoaded, onError, withCredentials, xhrParams) {\n    const xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n            if (onLoaded != null) {\n                onLoaded(xhr.getAllResponseHeaders(), xhr.status);\n                    //onLoaded(xhr.getResponseHeader(\"X-VE-Tile-Info\"), xhr.status);\n            }\n            break;\n\n        default:\n\n            if (onError != null) {\n                onError();\n            }\n\n            break;\n        }\n\n    }).bind(this);\n\n    xhr.onerror  = (function() {\n        if (onError != null) {\n            onError();\n        }\n    }).bind(this);\n\n    xhr.open('HEAD', url, true);\n    //xhr.responseType = responseType ? responseType : \"arraybuffer\";\n    xhr.withCredentials = utils.forceCredentials || withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n};\n\n\nutils.loadImage = function(url, onload, onerror, withCredentials, direct) {\n    const image = new Image();\n    image.onerror = onerror;\n    image.onload = onload;\n\n    if (!direct){\n        image.crossOrigin = withCredentials ? 'use-credentials' : 'anonymous';\n    }\n\n    image.src = url;\n    return image;\n};\n\n\nutils.getParamsFromUrl = function(url) {\n    return utilsUrl.getParamsFromUrl(url);\n};\n\n\nconst textDecoderUtf8 = (typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\n\nutils.unint8ArrayToString = function(array) {\n    if (textDecoderUtf8) {\n        return textDecoderUtf8.decode(array);\n    } else {\n//        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));\n\n        /*\n        const buff = new Uint16Array(array.buffer, array.byteOffset, array.byteLength);\n        const getChar = String.fromCharCode;\n        //const buff2 = new Array(buff.length);\n        const str = '';\n\n        for (let i = 0, li = buff.length; i < li; i++) {\n            //buff2[i] = getChar(buff[i]);\n            str += getChar(buff[i]);\n        }\n\n        return str;\n        //return buff2.join('');\n        */\n\n        let s = '';\n        //const code_points2 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        const code_points2 = new Uint8Array(array.byteLength);\n        code_points2.set(array);\n        const code_points = new Uint32Array(code_points2.buffer);\n\n        for (let i = 0, li = code_points.length; i < li; ++i) {\n          let cp = code_points[i];\n          if (cp <= 0xFFFF) {\n            s += String.fromCharCode(cp);\n          } else {\n            cp -= 0x10000;\n            s += String.fromCharCode((cp >> 10) + 0xD800,\n                                     (cp & 0x3FF) + 0xDC00);\n          }\n        }\n        return s;\n\n    }\n}\n\n\n\n\n// only implement if no native implementation is available\n/*\nif (typeof Array.isArray === 'undefined') {\n  Array.isArray = (function(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  });\n}*/\n\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=868097ccb3d166340fc9.worker.js.map", null);
};

/***/ }),

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ }),

/***/ "./src/browser/autopilot/autopilot.js":
/*!********************************************!*\
  !*** ./src/browser/autopilot/autopilot.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


const Autopilot = function(browser) {
    this.browser = browser;
    this.trajectory = [];
    this.flightDuration = 1;
    this.flightTime = 0;
    this.trajectoryIndex = 0;
    this.finished = true;
    this.autoMovement = false;
    this.autoRotate = 0;
    this.autoPan = 0;
    this.autoPanAzimuth = 0;

    this.center = [0,0,0];
    this.orientation = [0,0,0];
    this.viewHeight = 0;
    this.fov = 90;
    this.lastTime = 0;
};


Autopilot.prototype.setAutorotate = function(speed) {
    if (this.autoRotate != speed) {
        this.browser.callListener('autorotate-changed', { 'autorotate' : speed});
    }

    this.autoRotate = speed;
};


Autopilot.prototype.getAutorotate = function() {
    return this.autoRotate;
};


Autopilot.prototype.setAutopan = function(speed, azimuth) {
    this.autoPan = speed;
    this.autoPanAzimuth = azimuth;
};


Autopilot.prototype.getAutopan = function() {
    return [this.autoPan, this.autoPanAzimuth];
};

Autopilot.prototype.flyToDAH = function(distance, azimuth, height, options) {
    const map = this.browser.core.map;
    if (!map) {
        return;
    }

    options = options || {};

    const trajectory = map.generatePIHTrajectory(map.getPosition(), distance, azimuth, height, options);
    this.setTrajectory(trajectory, options['samplePeriod'] || 10, options);
};


Autopilot.prototype.flyTo = function(position, options) {
    const map = this.browser.core.map;
    if (!map) {
        return;
    }

    options = options || {};
    const trajectory = map.generateTrajectory(map.getPosition(), position, options);
    this.setTrajectory(trajectory, options['samplePeriod'] || 10, options);
};


Autopilot.prototype.flyTrajectory = function(trajectory, sampleDuration) {
    this.setTrajectory(trajectory, sampleDuration || 10, {});
};


Autopilot.prototype.cancelFlight = function() {
    this.browser.getControlMode().setCurrentControlMode(this.lastControlMode);
    this.finished = true;
};


Autopilot.prototype.setTrajectory = function(trajectory, sampleDuration, options) {
    if (trajectory == null || trajectory.length == 0) {
        return;
    }

    this.setAutorotate(0);
    this.setAutopan(0,0);

    this.speed = options['speed'] || 1.0;
    if (this.finished) {
        this.lastControlMode = this.browser.getControlMode().getCurrentControlMode();
    }
    this.browser.getControlMode().setCurrentControlMode('disabled');

    this.trajectory = trajectory;
    this.sampleDuration = sampleDuration;
    //this.

    this.browser.callListener('fly-start', { 'startPosition' : this.trajectory[0],
        'endPosition' : this.trajectory[this.trajectory.length - 1],
        'options' : options
    });

    this.timeStart = performance.now();
    this.finished = false;
};


Autopilot.prototype.tick = function() {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    let time = performance.now(), pos;
    const timeFactor =  (time - this.lastTime) / 1000;
    this.lastTime = time;

    if (this.browser.ui && this.browser.ui.loading &&
        this.browser.ui.loading.control.getVisible()) {
        return;
    }


    if (this.autoRotate != 0) {
        pos = map.getPosition();
        const o = pos.getOrientation();
        o[0] = (o[0] + this.autoRotate*timeFactor) % 360;
        pos.setOrientation(o);
        map.setPosition(pos);
    }

    if (this.autoPan != 0) {
        pos = map.getPosition();
        pos = map.movePositionCoordsTo(pos, this.autoPanAzimuth, pos.getViewExtent()*(this.autoPan*0.01)*timeFactor, 0);
        map.setPosition(pos);
    }

    if (this.finished || !this.trajectory) {
        return;
    }

    time = time - this.timeStart;
    const sampleIndex =  Math.floor((time / this.sampleDuration)*this.speed);
    const totalSamples = this.trajectory.length - 1;

    if (sampleIndex < totalSamples) {
        //interpolate
        map.setPosition(this.trajectory[sampleIndex]);
        //console.log(JSON.stringify(this.trajectory[sampleIndex]));

        this.browser.callListener('fly-progress', { 'position' : this.trajectory[sampleIndex],
            'progress' : 100 * (sampleIndex / totalSamples)
        });

    } else {
        map.setPosition(this.trajectory[totalSamples]);
        //console.log(JSON.stringify(this.trajectory[totalSamples]));
    }

    if (sampleIndex >= this.trajectory.length) {
        this.browser.callListener('fly-end', { 'position' : this.trajectory[totalSamples] });

        this.browser.getControlMode().setCurrentControlMode(this.lastControlMode);
        this.finished = true;
    }
};


Autopilot.prototype.generateTrajectory = function(p1, p2, options) {
    const map = this.browser.core.map;
    if (!map) {
        return;
    }

    options = options || {};
    return map.generateTrajectory(p1, p2, options);
};


Autopilot.prototype.generatePIHTrajectory = function(position, azimuth, distance, options) {
    const map = this.browser.core.map;
    if (!map) {
        return;
    }

    options = options || {};
    return map.generatePIHTrajectory(position, azimuth, distance, options);
};


/* harmony default export */ __webpack_exports__["default"] = (Autopilot);


/***/ }),

/***/ "./src/browser/browser.css":
/*!*********************************!*\
  !*** ./src/browser/browser.css ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/browser/browser.js":
/*!********************************!*\
  !*** ./src/browser/browser.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/core */ "./src/core/core.js");
/* harmony import */ var _core_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/interface */ "./src/core/interface.js");
/* harmony import */ var _core_utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _ui_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui/ui */ "./src/browser/ui/ui.js");
/* harmony import */ var _autopilot_autopilot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./autopilot/autopilot */ "./src/browser/autopilot/autopilot.js");
/* harmony import */ var _control_mode_control_mode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./control-mode/control-mode */ "./src/browser/control-mode/control-mode.js");
/* harmony import */ var _presenter_presenter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./presenter/presenter */ "./src/browser/presenter/presenter.js");
/* harmony import */ var _rois_rois__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rois/rois */ "./src/browser/rois/rois.js");









//import UIEvent_ from './ui/element/event';


//get rid of compiler mess
const CoreInterface = _core_interface__WEBPACK_IMPORTED_MODULE_1__["CoreInterface"];
const utils = _core_utils_utils__WEBPACK_IMPORTED_MODULE_2__["utils"];
const UI = _ui_ui__WEBPACK_IMPORTED_MODULE_3__["default"];
const Autopilot = _autopilot_autopilot__WEBPACK_IMPORTED_MODULE_4__["default"];
const ControlMode = _control_mode_control_mode__WEBPACK_IMPORTED_MODULE_5__["default"];
const Presenter = _presenter_presenter__WEBPACK_IMPORTED_MODULE_6__["default"];
const Rois = _rois_rois__WEBPACK_IMPORTED_MODULE_7__["default"];
const checkSupport = _core_core__WEBPACK_IMPORTED_MODULE_0__["checkSupport"];


const Browser = function(element, config) {
    this.killed = false;
    this.configStorage = {};
    this.initConfig();
    this.setConfigParams(config, true);
    this.originalConfig = JSON.parse(JSON.stringify(config));

    this.element = (typeof element === 'string') ? document.getElementById(element) : element;
    this.ui = new UI(this, this.element);

    element = (typeof element !== 'string') ? element : document.getElementById(element);

    if (!checkSupport()) {
        this.ui.setControlVisible('fallback', true);
        return;
    }

    if (config.tiles3d) { //} && !(config.pos || config.position)) {
        this.config.autocenter = true;
    }

    this.core = new CoreInterface(this.ui.getMapControl().getMapElement().getElement(), config);

    if (this.core == null) {
        this.ui.setControlVisible('fallback', true);
        return;
    }

    this.updatePosInUrl = false;
    this.lastUrlUpdateTime = false;
    this.mapLoaded = false;
    this.mapInteracted = false;

    this.autopilot = new Autopilot(this);
    this.rois = new Rois(this);
    this.controlMode = new ControlMode(this, this.ui);
    this.presenter = new Presenter(this, config);
    this.wsId = Date.now();
    this.lastWsPos = null;
    this.lastWSConnectTime = 0;

    if (this.config.sync) {
        this.setupWS();
    }

    this.on('map-loaded', this.onMapLoaded.bind(this));
    this.on('map-unloaded', this.onMapUnloaded.bind(this));
    this.on('map-update', this.onMapUpdate.bind(this));
    this.on('map-position-changed', this.onMapPositionChanged.bind(this));
    this.on('map-position-fixed-height-changed', this.onMapPositionFixedHeightChanged.bind(this));
    this.on('map-position-panned', this.onMapPositionPanned.bind(this));
    this.on('map-position-rotated', this.onMapPositionRotated.bind(this));
    this.on('map-position-zoomed', this.onMapPositionZoomed.bind(this));

    this.on('tick', this.onTick.bind(this));
};


Browser.prototype.kill = function() {
    this.ui.kill();
    this.killed = true;

    if (this.ws) {
        this.ws.close();
    }
};


Browser.prototype.getCore = function() {
    return this.core;
};


Browser.prototype.getMap = function() {
    return this.core ? this.core.map : null;
};


Browser.prototype.getRenderer = function() {
    return this.core ? this.core.renderer : null;
};


Browser.prototype.getProj4 = function() {
    return this.core ? this.core.proj4 : null;
};


Browser.prototype.getUI = function() {
    return this.ui;
};


Browser.prototype.setControlMode = function(mode) {
    this.controlMode = mode;
};


Browser.prototype.getControlMode = function() {
    return this.controlMode;
};


Browser.prototype.on = function(name, listener) {
    return this.core.on(name, listener);
};


Browser.prototype.callListener = function(name, event) {
    this.core.callListener(name, event);
};


Browser.prototype.setupWS = function() {

    this.ws = new WebSocket(this.config.syncServer);

    this.ws.onmessage = (e) => {

        const map = this.getMap();
        if (!map) {
            return ;
        }

        try {

            const json = JSON.parse(e.data);

            //console.log(e.data);

            switch(json.command) {

                //case 'id':
                    //this.wsId = json.id;
                    //break;

                case 'cursor':
                case 'hide-cursor':
                    //this.wsId = json.id;
                        if (this.ui && this.ui.sync) {
                            this.ui.sync.updateCursor(json);
                        }

                    break;

                case 'pos':
                    {
                        const pos = json.pos;
                        const pos2 = map.getPosition().toArray();

                        this.lastWsPos = pos;

                        if (json.fixedHeight) {
                            this.config.fixedHeight = json.fixedHeight;
                        }

                        if (Math.abs(pos[1] - pos2[1]) > 0.00001 ||
                            Math.abs(pos[2] - pos2[2]) > 0.00001 ||
                            Math.abs(pos[4] - pos2[4]) > 0.001 ||
                            Math.abs(pos[5] - pos2[5]) > 0.01 ||
                            Math.abs(pos[6] - pos2[6]) > 0.01 ||
                            Math.abs(pos[7] - pos2[7]) > 0.01 ||
                            Math.abs(pos[8] - pos2[8]) > 0.01 ||
                            Math.abs(pos[9] - pos2[9]) > 0.01) {

                                map.setPosition(json.pos);
                            }
                    }
                    break;

                default:
            }

        } catch(ee) {
            console.log(ee);
        }

      //console.log(e.data)
    }

    this.ws.onopen = () => {
      this.ws.send('{ "command": "client", "channel": "' + this.config.sync + '", "id":' + this.wsId + '  }');
    }

    this.ws.onerror = (error) => {
      console.log(`WebSocket error: ${error}`)
    }

};


Browser.prototype.onMapLoaded = function(event) {
    this.mapLoaded = true;

    //overwrite browser options
    const options = event['browserOptions'] || {};
    const originalOptions = this.originalConfig;
    for (let key in originalOptions) {
        if (typeof options[key] !== 'undefined') {
            options[key] = originalOptions[key];
        }
    }

    this.setConfigParams(options);

    if (this.config.geojson || this.config.geodata) {
        let data = this.config.geojson || this.config.geodata;

        if (typeof data === 'string') {
            data = data.trim();

            if (data.charAt(0) == '{') {
                try {
                    data = JSON.parse(data);
                    this.onGeoJsonLoaded(data);
                // eslint-disable-next-line
                } catch(e){ }
            } else {
                utils.loadJSON(data, this.onGeoJsonLoaded.bind(this));
            }
        }
    }

    const map = this.getMap();
    map.config.autocenter = this.config.autocenter;

    if (this.config.tiles3d && map) {

        if (!this.config.position) {
            this.config.autocenter = true;
        }

        const freeLayer = {
            credits:[],
            displaySize:1024,
            extents:{"ll":[null,null,null],"ur":[null,null,null]},
            style:{},
            type:"geodata",
            hitable: true
        };

        freeLayer.geodata = {  binPath : this.config.tiles3d };

        map.addFreeLayer('geodatatest', freeLayer);

        const view = map.getView();
        view.freeLayers.geodatatest = { options: { fastParse: true }};
        map.setView(view);
    }

    if (this.autopilot) {
        this.autopilot.setAutorotate(this.config.autoRotate);
        this.autopilot.setAutopan(this.config.autoPan[0], this.config.autoPan[1]);
    }
};


Browser.prototype.getLinkWithCurrentPos = function() {
    const map = this.getMap();
    if (!map) {
        return '';
    }

    //get url params
    const params = utils.getParamsFromUrl(window.location.href);

    //get position string
    let p = map.getPosition();
    p = map.convertPositionHeightMode(p, 'fix', true);

    let s = '';
    s += p.getViewMode() + ',';
    const c = p.getCoords();
    s += c[0].toFixed(6) + ',' + c[1].toFixed(6) + ',' + p.getHeightMode() + ',' + c[2].toFixed(2) + ',';
    const o = p.getOrientation();
    s += o[0].toFixed(2) + ',' + o[1].toFixed(2) + ',' + o[2].toFixed(2) + ',';
    s += p.getViewExtent().toFixed(2) + ',' + p.getFov().toFixed(2);

    //replace old value with new one
    params['pos'] = s;

    if (this.mapInteracted) {
        if (params['rotate'] || this.getConfigParam('rotate')) {
            params['rotate'] = '0';
        }

        const pan = this.getConfigParam('pan');
        if (params['pan'] || (pan && (pan[0] || pan[1]))) {
            params['pan'] = '0,0';
        }
    }

    if (this.config.fixedHeight) {
        params['fixedHeight'] = '' + this.config.fixedHeight.toFixed(3);
    }

    //convert prameters to url parameters string
    s = '';
    for (let key in params) {
        s += ((s.length > 0) ? '&' : '') + key + '=' + params[key];
    }

    //separete base url and url params
    const urlParts = window.location.href.split('?');

    if (urlParts.length > 1) {
        const extraParts = urlParts[1].split('#'); //is there anchor?
        return urlParts[0] + '?' + s + (extraParts[1] || '');
    } else {
        return urlParts[0] + '?' + s;
    }
};


Browser.prototype.onMapPositionChanged = function(event) {
    if (this.config.positionInUrl) {
        this.updatePosInUrl = true;
    }

    if (this.ws) {

        const pos = this.getPositionString(event.position);
        const pos2 = this.lastWsPos ? this.getPositionString(this.lastWsPos) : "";

        if (pos != pos2) {

            if (this.ws.readyState == 1) {
                if (this.config.fixedHeight) {
                    this.ws.send('{ "command":"pos", "pos": ' + pos + ' "fixedHeight" : ' + this.config.fixedHeight + ' }')
                } else {
                    this.ws.send('{ "command":"pos", "pos": ' + pos + ' }')
                }
            }

        }
    }
};


Browser.prototype.onMapPositionPanned = function() {
    this.mapInteracted = true;
};


Browser.prototype.onMapPositionRotated = function() {
    this.mapInteracted = true;
};


Browser.prototype.onMapPositionZoomed = function() {
    this.mapInteracted = true;
};


Browser.prototype.onMapPositionFixedHeightChanged = function() {
    if (this.config.positionInUrl) {
        this.updatePosInUrl = true;
    }
};


Browser.prototype.onMapUnloaded = function() {
};


Browser.prototype.onMapUpdate = function() {
    this.dirty = true;
};


Browser.prototype.onGeoJsonLoaded = function(data) {
    const map = this.getMap();
    const geodata = map.createGeodata();

    const addFreeLayer = (function(){
        const freeLayer = geodata.makeFreeLayer(this.config.geojsonStyle);
        map.addFreeLayer('geojson', freeLayer);
        const view = map.getView();
        view.freeLayers.geojson = {};
        map.setView(view);
    }).bind(this)

    if (this.config.geodata) {
        geodata.importVTSGeodata(data);
        addFreeLayer();
    } else {
        geodata.importGeoJson(data);
        geodata.processHeights('node-by-precision', 62, addFreeLayer);
    }
};


Browser.prototype.on3DTilesLoaded = function() {
    const map = this.getMap();
    const freeLayer = this.tiles3d.makeFreeLayer({});
    map.addFreeLayer('tiles3d', freeLayer);
    const view = map.getView();
    view.freeLayers.tiles3d = { options: { fastParse: true }};
    map.setView(view);
}


Browser.prototype.onTick = function() {
    if (this.killed) {
        return;
    }

    this.autopilot.tick();
    this.ui.tick(this.dirty);
    this.dirty = false;

    if (this.ws) {
        if (this.ws.readyState > 1) {
            const timer = performance.now();
            if ((timer - this.lastWSConnectTime) > 1000) {
                this.setupWS();
                this.lastWSConnectTime = timer;
            }
        }
    }

    if (this.updatePosInUrl) {
        const timer = performance.now();
        if ((timer - this.lastUrlUpdateTime) > 1000) {
            if (window.history.replaceState) {
                window.history.replaceState({}, null, this.getLinkWithCurrentPos());
            }
            this.updatePosInUrl = false;
            this.lastUrlUpdateTime = timer;
        }
    }
};


Browser.prototype.initConfig = function() {
    this.config = {
        panAllowed : true,
        rotationAllowed : true,
        zoomAllowed : true,
        jumpAllowed : false,
        separatePanAndZoom : true,
        sensitivity : [1, 0.06, 0.05],
        inertia : [0.81, 0.9, 0.7],
        timeNormalizedInertia : false, // legacy inertia [0.8,0.8,0.8] sensitivity [0.5,0.4]
        legacyInertia : false, // legacy inertia [0.8,0.8,0.8] sensitivity [0.5,0.4]
        positionInUrl : false,
        positionUrlHistory : false,
        constrainCamera : true,
        navigationMode : 'azimuthal',
        controlCompass : true,
        controlZoom : true,
        controlSpace : true,
        controlSearch : true,
        controlSearchSrs : null,
        controlSearchUrl : null,
        controlSearchFilter : false,
        controlMeasure : false,
        controlMeasureLite : false,
        controlLink : false,
        controlGithub : false,
        controlScale : true,
        controlLayers : false,
        controlCredits : true,
        controlFullscreen : false,
        controlLoading : true,
        searchElement : null,
        searchValue : null,
        walkMode : false,
        wheelInputLag : [70,1],
        fixedHeight : 0,
        geojson : null,
        sync: null,
        syncServer: 'ws://localhost:9080',
        syncCursor: false,
        syncId: '',
        tiltConstrainThreshold : [0.5,1],
        bigScreenMargins : false, //75,
        minViewExtent : 20, //75,
        maxViewExtent : Number.MAXINTEGER,
        autocenter : false,
        autoRotate : 0,
        autoPan : [0,0]
    };
};


Browser.prototype.setConfigParams = function(params, ignoreCore) {
    if (typeof params === 'object' && params !== null) {
        for (let key in params) {
            this.setConfigParam(key, params[key], ignoreCore);

            /*if (!(key == "pos" || key == "position" || key == "view" ||
                key.indexOf("map") == 0 || key.indexOf("renderer") == 0)) {
                this.configStorage[key] = params[key];
            }*/
        }
    }
};


Browser.prototype.getPositionString = function(p) {

    var s = '[';
    s += '"' + p[0] + '",';
    s += p[1].toFixed(6) + ',' + p[2].toFixed(6) + ',"' + p[3] + '",' + p[4].toFixed(2) + ',';
    s += p[5].toFixed(2) + ',' + p[6].toFixed(2) + ',' + p[7].toFixed(2) + ',';
    s += p[8].toFixed(2) + ',' + p[9].toFixed(2) +  ']';

    return s;
}



Browser.prototype.updateUI = function(key) {
    if (this.ui == null) {
        return;
    }

    this.ui.setParam(key);
};


Browser.prototype.setConfigParam = function(key, value, ignoreCore) {
    const map = this.getMap();

    switch (key) {
    case 'pos':
    case 'position':
        this.config.position = value;
        if (map) {
            map.setPosition(this.config.position);
        }
        break;

    case 'view':
        this.config.view = value;
        if (map) {
            map.setView(this.config.view);
        }
        break;

    case 'panAllowed':             this.config.panAllowed = utils.validateBool(value, true);           break;
    case 'rotationAllowed':        this.config.rotationAllowed = utils.validateBool(value, true);      break;
    case 'zoomAllowed':            this.config.zoomAllowed = utils.validateBool(value, true);          break;
    case 'jumpAllowed':            this.config.jumpAllowed = utils.validateBool(value, false);         break;
    case 'separatePanAndZoom':     this.config.separatePanAndZoom = utils.validateBool(value, false);  break;
    case 'constrainCamera':        this.config.constrainCamera = utils.validateBool(value, true);      break;
    case 'navigationMode':         this.config.navigationMode = value;                                 break;
    case 'positionInUrl':          this.config.positionInUrl = utils.validateBool(value, false);       break;
    case 'positionUrlHistory':     this.config.positionUrlHistory = utils.validateBool(value, false);  break;
    case 'controlCompass':         this.config.controlCompass = utils.validateBool(value, true); this.updateUI(key);    break;
    case 'controlZoom':            this.config.controlZoom = utils.validateBool(value, true); this.updateUI(key);       break;
    case 'controlScale':           this.config.controlScale = utils.validateBool(value, true); this.updateUI(key);      break;
    case 'controlLayers':          this.config.controlLayers = utils.validateBool(value, false); this.updateUI(key);    break;
    case 'controlSpace':           this.config.controlSpace = utils.validateBool(value, false); this.updateUI(key);     break;
    case 'controlSearch':          this.config.controlSearch = utils.validateBool(value, false); this.updateUI(key);    break;
    case 'controlSearchUrl':       this.config.controlSearchUrl = value;    break;
    case 'controlSearchSrs':       this.config.controlSearchSrs = value;    break;
    case 'controlSearchFilter':    this.config.controlSearchFilter = utils.validateBool(value, true);  break;
    case 'controlSearchElement':   this.config.controlSearchElement = value; this.updateUI(key);  break;
    case 'controlSearchValue':     this.config.controlSearchValue = /*utils.validateString(*/value/*, null)*/; this.updateUI(key); break;
    case 'controlLink':            this.config.controlLink = utils.validateBool(value, false); this.updateUI(key);        break;
    case 'controlGithub':          this.config.controlGithub = utils.validateBool(value, false); this.updateUI(key);      break;
    case 'controlMeasure':         this.config.controlMeasure = utils.validateBool(value, false); this.updateUI(key);     break;
    case 'controlMeasureLite':     this.config.controlMeasureLite = utils.validateBool(value, false); this.updateUI(key); break;
    case 'controlLogo':            this.config.controlLogo = utils.validateBool(value, false); this.updateUI(key);        break;
    case 'controlFullscreen':      this.config.controlFullscreen = utils.validateBool(value, true); this.updateUI(key);   break;
    case 'controlCredits':         this.config.controlCredits = utils.validateBool(value, true); this.updateUI(key);      break;
    case 'controlLoading':         this.config.controlLoading = utils.validateBool(value, true); this.updateUI(key);      break;
    case 'minViewExtent':          this.config.minViewExtent = utils.validateNumber(value, 0.01, Number.MAXINTEGER, 100); break;
    case 'maxViewExtent':          this.config.maxViewExtent = utils.validateNumber(value, 0.01, Number.MAXINTEGER, Number.MAXINTEGER); break;
    case 'wheelInputLag':          this.config.wheelInputLag = utils.validateNumberArray(value, 2, [0,0], [999, 999], [70, 1]); break;
    case 'sensitivity':            this.config.sensitivity = utils.validateNumberArray(value, 3, [0,0,0], [10, 10, 10], [1, 0.12, 0.05]); break;
    case 'inertia':                this.config.inertia = utils.validateNumberArray(value, 3, [0,0,0], [0.99, 0.99, 0.99], [0.85, 0.9, 0.7]); break;
    case 'legacyInertia':          this.config.legacyInertia = utils.validateBool(value, false); break;
    case 'timeNormalizedInertia':  this.config.timeNormalizedInertia = utils.validateBool(value, false); break;
    case 'bigScreenMargins':       this.config.bigScreenMargins = utils.validateBool(value, false); break;
    case 'tiltConstrainThreshold': this.config.tiltConstrainThreshold = utils.validateNumberArray(value, 2, [0.5,1], [-Number.MAXINTEGER, -Number.MAXINTEGER], [Number.MAXINTEGER, Number.MAXINTEGER]); break;
    case 'walkMode':               this.config.walkMode = utils.validateBool(value, false); break;
    case 'fixedHeight':            this.config.fixedHeight = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, 0); break;
    case 'sync':                   this.config.sync = value; break;
    case 'syncCursor':             this.config.syncCursor = utils.validateBool(value, false); break;
    case 'syncServer':             this.config.syncServer = value; break;
    case 'syncId':                 this.config.syncId = value; break;
    case 'geodata':                this.config.geodata = value; break;
    case 'tiles3d':                this.config.tiles3d = value; break;
    case 'geojson':                this.config.geojson = value; break;
    case 'geojsonStyle':           this.config.geojsonStyle =  JSON.parse(value); break;
    case 'rotate':
        this.config.autoRotate = utils.validateNumber(value, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, 0);
        if (map && this.autopilot) {
            this.autopilot.setAutorotate(this.config.autoRotate);
        }
        break;
    case 'pan':
        if (Array.isArray(value) && value.length == 2){
            this.config.autoPan = [
                utils.validateNumber(value[0], Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, 0),
                utils.validateNumber(value[1], -360, 360, 0)
            ];
        }

        if (map && this.autopilot) {
            this.autopilot.setAutorotate(this.config.autoRotate);
        }
        break;
    }

    if (ignoreCore) {
        if ((key.indexOf('map') == 0 || key.indexOf('mario') == 0 || key.indexOf('authorization') == 0) && map) {
            map.setConfigParam(key, value);
        }

        if (key.indexOf('renderer') == 0 && this.getRenderer()) {
            this.getRenderer().setConfigParam(key, value);
        }

        if (key.indexOf('debug') == 0 && this.core) {
            this.core.setConfigParam(key, value);
        }

    }
};


Browser.prototype.getConfigParam = function(key) {
    const map = this.getMap();

    switch (key) {
    case 'pos':
    case 'position':

        if (map) {
            map.getPosition();
        } else {
            return this.config.position;
        }

        break;

    case 'view':

        if (map) {
            return map.getView();
        } else {
            return this.config.view;
        }

    case 'panAllowed':             return this.config.panAllowed;
    case 'rotationAllowed':        return this.config.rotationAllowed;
    case 'zoomAllowed':            return this.config.zoomAllowed;
    case 'jumpAllowed':            return this.config.jumpAllowed;
    case 'sensitivity':            return this.config.sensitivity;
    case 'inertia':                return this.config.inertia;
    case 'legacyInertia':          return this.config.legacyInertia;
    case 'timeNormalizedInertia':  return this.config.timeNormalizedInertia;
    case 'bigScreenMargins':       return this.config.bigScreenMargins;
    case 'navigationMode':         return this.config.navigationMode;
    case 'constrainCamera':        return this.config.constrainCamera;
    case 'positionInUrl':          return this.config.positionInUrl;
    case 'positionUrlHistory':     return this.config.positionUrlHistory;
    case 'controlCompass':         return this.config.controlCompass;
    case 'controlZoom':            return this.config.controlZoom;
    case 'controlScale':           return this.config.controlScale;
    case 'controlLayers':          return this.config.controlLayers;
    case 'controlSpace':           return this.config.controlSpace;
    case 'controlSearch':          return this.config.controlSearch;
    case 'controlLink':            return this.config.controlLink;
    case 'controlGithub':          return this.config.controlGithub;
    case 'controlMeasure':         return this.config.controlMeasure;
    case 'controlMeasureLite':     return this.config.controlMeasureLite;
    case 'controlLogo':            return this.config.controlLogo;
    case 'controlFullscreen':      return this.config.controlFullscreen;
    case 'controlCredits':         return this.config.controlCredits;
    case 'controlLoading':         return this.config.controlLoading;
    case 'controlSearchElement':   return this.config.controlSearchElement;
    case 'controlSearchValue':     return this.config.controlSearchValue;
    case 'controlSearchUrl':       return this.config.controlSearchUrl;
    case 'controlSearchSrs':       return this.config.controlSearchSrs;
    case 'controlSearchFilter':    return this.config.controlSearchFilter;
    case 'minViewExtent':          return this.config.minViewExtent;
    case 'maxViewExtent':          return this.config.maxViewExtent;
    case 'fixedHeight':            return this.config.fixedHeight;
    case 'rotate':                 return this.config.autoRotate;
    case 'pan':                    return this.config.autoPan;
    }

    //if (ignoreCore) {
    if (key.indexOf('map') == 0 && map) {
        return map.getConfigParam(key);
    }

    if (key.indexOf('renderer') == 0) {
        return map.getConfigParam(key);
    }
    //}
};


/* harmony default export */ __webpack_exports__["default"] = (Browser);


/***/ }),

/***/ "./src/browser/control-mode/control-mode.js":
/*!**************************************************!*\
  !*** ./src/browser/control-mode/control-mode.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _disabled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./disabled */ "./src/browser/control-mode/disabled.js");
/* harmony import */ var _map_observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map-observer */ "./src/browser/control-mode/map-observer.js");
/* harmony import */ var _pano__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pano */ "./src/browser/control-mode/pano.js");





//get rid of compiler mess
const ControlModeDisabled = _disabled__WEBPACK_IMPORTED_MODULE_0__["default"];
const ControlModeMapObserver = _map_observer__WEBPACK_IMPORTED_MODULE_1__["ControlModeMapObserver"];
const ControlModePano = _pano__WEBPACK_IMPORTED_MODULE_2__["default"];


const ControlMode = function(browser) {
    this.browser = browser;
    this.ui = browser.ui;
    this.mapControl = this.ui.getMapControl();
    this.mapElement = this.mapControl.getMapElement();
    this.altKey = false;
    this.shiftKey = false;
    this.ctrlKey = false;

    this.mapElement.on('drag', this.onDrag.bind(this));
    //this.mapElement.on('dragstart', this.onDragStart.bind(this));
    //this.mapElement.on('dragend', this.onDragEnd.bind(this));
    this.mapElement.on('mousedown', this.onDown.bind(this));
    this.mapElement.on('mouseup', this.onUp.bind(this));
    this.mapElement.on('mousewheel', this.onWheel.bind(this));
    this.mapElement.on('keyup', this.onKeyUp.bind(this), window);
    this.mapElement.on('keydown', this.onKeyDown.bind(this), window);
    this.mapElement.on('keypress', this.onKeyPress.bind(this), window);
    this.mapElement.on('dblclick', this.onDoubleClick.bind(this), window);
    this.browser.on('tick', this.onTick.bind(this));

    this.controlModes = {};
    this.currentCotnrolModeId = 'map-observer';
    this.currentControlMode = this.controlModes['map-observer'];

    // default control modes
    this.addControlMode('map-observer', new ControlModeMapObserver(browser));
    this.addControlMode('disabled', new ControlModeDisabled());
    this.addControlMode('pano', new ControlModePano(browser));

    // use map observer mode as default
    this.setDefaultControlMode();
};


ControlMode.prototype.addControlMode = function(id, controller) {
    this.controlModes[id] = controller;
};


ControlMode.prototype.removeControlMode = function(id) {
    if (id === this.currentCotnrolModeId) {
        return;
    }

    delete this.controlModes[id];
};


ControlMode.prototype.setCurrentControlMode = function(id, options) {
    const newMode = this.controlModes[id];
    if (!newMode) {
        return;
    }

    // set new mode
    this.currentControlModeId = id;
    this.currentControlMode = newMode;

    // call reset
    if (newMode['reset']) {
        newMode['reset'](options);
    }
};


ControlMode.prototype.setDefaultControlMode = function() {
    this.setCurrentControlMode('map-observer');
};


ControlMode.prototype.getCurrentControlMode = function() {
    return this.currentControlModeId;
};

ControlMode.prototype.getCurrentController = function() {
    return this.currentControlMode;
};

// Event callbacks

ControlMode.prototype.onDrag = function(event) {
    this.checkAutopilot();
    if (this.currentControlMode['drag']) {
        this.currentControlMode['drag'](event);
    }
};


ControlMode.prototype.onDown = function(event) {
    this.checkAutopilot();
    this.updateModifierKeys(event);
    if (this.currentControlMode['down']) {
        this.currentControlMode['down'](event);
    }
};


ControlMode.prototype.onUp = function(event) {
    this.updateModifierKeys(event);
    if (this.currentControlMode['up']) {
        this.currentControlMode['up'](event);
    }
};


ControlMode.prototype.onWheel = function(event) {
    this.checkAutopilot();
    if (this.currentControlMode['wheel']) {
        this.currentControlMode['wheel'](event);
    }
};


ControlMode.prototype.onKeyUp = function(event) {
    this.updateModifierKeys(event);
    if (this.currentControlMode['keyup']) {
        this.currentControlMode['keyup'](event);
    }
};


ControlMode.prototype.onKeyDown = function(event) {
    this.updateModifierKeys(event);
    if (this.currentControlMode['keydown']) {
        this.currentControlMode['keydown'](event);
    }
};


ControlMode.prototype.onKeyPress = function(event) {
    this.updateModifierKeys(event);
    if (this.currentControlMode['keypress']) {
        this.currentControlMode['keypress'](event);
    }
};


ControlMode.prototype.onDoubleClick = function(event) {
    this.updateModifierKeys(event);
    if (this.currentControlMode['doubleclick']) {
        this.currentControlMode['doubleclick'](event);
    }
};


ControlMode.prototype.onTick = function(event) {
    if (this.currentControlMode['tick']) {
        event.draggingState = this.mapElement.getDraggingState();
        this.currentControlMode['tick'](event);
    }
};


// Private metod
ControlMode.prototype.updateModifierKeys = function(event) {
    this.altKey = event.getModifierKey('alt');
    this.shiftKey = event.getModifierKey('shift');
    this.ctrlKey = event.getModifierKey('ctrl');
    //console.log("alt:" + this.altKey + "  ctrl:" + this.ctrlKey + "  shift:" + this.shiftKey);
};


ControlMode.prototype.checkAutopilot = function() {
    if (this.browser.autopilot) {
        this.browser.autopilot.setAutorotate(0);
        this.browser.autopilot.setAutopan(0,0);
    }
};


/* harmony default export */ __webpack_exports__["default"] = (ControlMode);


/***/ }),

/***/ "./src/browser/control-mode/disabled.js":
/*!**********************************************!*\
  !*** ./src/browser/control-mode/disabled.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const ControlModeDisabled = function() {

};


/* harmony default export */ __webpack_exports__["default"] = (ControlModeDisabled);


/***/ }),

/***/ "./src/browser/control-mode/map-observer.js":
/*!**************************************************!*\
  !*** ./src/browser/control-mode/map-observer.js ***!
  \**************************************************/
/*! exports provided: ControlModeMapObserver, constrainMapPosition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ControlModeMapObserver", function() { return ControlModeMapObserver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constrainMapPosition", function() { return constrainMapPosition; });
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utility/dom */ "./src/browser/utility/dom.js");
/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/math */ "./src/core/utils/math.js");




//get rid of compiler mess
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_0__["default"];
const math = _core_utils_math__WEBPACK_IMPORTED_MODULE_1__["math"];


const ControlModeMapObserver = function(browser) {
    this.browser = browser;
    this.config = browser.config;

    this.coordsDeltas = [];
    this.orientationDeltas = [];
    this.viewExtentDeltas = [];
    this.northResetAnimation = false;

    /*this['drag'] = this.drag;
    this['wheel'] = this.wheel;
    this['tick'] = this.tick;
    this['reset'] = this.reset;
    this['keyup'] = this.keyup;
    this['keydown'] = this.keydown;
    this['keypress'] = this.keypress;
    this['doubleclick'] = this.doubleclick;*/

    this.retinaFactor = 1.0 / Math.max(1.0,(window.devicePixelRatio || 1) - 1);
};


ControlModeMapObserver.prototype.drag = function(event) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    let pos = map.getPosition();
    let delta = event.getDragDelta();
    const coords = pos.getCoords();
    //const zoom = event.getDragZoom();
    const touches = event.getDragTouches();
    const azimuthDistance = this.getAzimuthAndDistance(delta[0], delta[1]);
    const config = this.config;
    let sensitivity;

    const modifierKey = (this.browser.controlMode.altKey
               || this.browser.controlMode.shiftKey
               || this.browser.controlMode.ctrlKey);

    //event.getTouchParameter("touchMode");


    if (touches == 2) {//} && /*event.getDragButton("middle")*/ zoom != 0 && this.config.zoomAllowed) {
        if (pos.getViewMode() != 'obj') {
            return;
        }

        if (event.getTouchParameter('touchMode') == 'pan' && config.rotationAllowed) {

            sensitivity = config.sensitivity[1] * this.retinaFactor;
            this.orientationDeltas.push([delta[0] * sensitivity,  -delta[1] * sensitivity, 0]);
            this.browser.callListener('map-position-rotated', {});

        } else if (event.getTouchParameter('touchMode') == 'zoom' && config.zoomAllowed) {

            delta = event.getTouchParameter('touchDistanceDelta');

            if (Math.abs(delta) >= 1) {

                const factor = 1.0 + (delta > 0 ? -1 : 1)*0.01;
                this.viewExtentDeltas.push(factor);
                this.reduceFloatingHeight(0.8);

                if (config.legacyInertia) {
                    this.updateDeltas(false, false, true);
                }

                this.browser.callListener('map-position-zoomed', {});
            }
        }

    } else if ((event.getDragButton('left') && !modifierKey) && config.panAllowed) { //pan

        if (pos.getHeightMode() == 'fix') {
            const pos2 = map.convertPositionHeightMode(pos, 'float', true);
            if (pos2 != null) {
                pos = pos2;
                this.setPosition(pos);
            }
        } else {
            sensitivity = config.sensitivity[0] * this.retinaFactor;
            const fov = pos.getFov();
            const fovCorrection = (fov > 0.01 && fov < 179) ? (1.0 / Math.tan(math.radians(fov*0.5))) : 1.0;
            const azimuth = math.radians(azimuthDistance[0]);
            const forward = [Math.sin(azimuth), //direction vector x
                Math.cos(azimuth), //direction vector y
                azimuthDistance[1] * fovCorrection * sensitivity, azimuthDistance[0], //distance and azimut
                coords[0], coords[1]]; //coords

            this.coordsDeltas.push(forward);
            this.reduceFloatingHeight(0.9);

            if (config.legacyInertia) {
                this.updateDeltas(true);
            }

            this.browser.callListener('map-position-panned', {});
        }
    } else if (((touches <= 1 && event.getDragButton('right')) || event.getDragButton('middle') || modifierKey)  && config.rotationAllowed) { //rotate

        sensitivity = config.sensitivity[1] * this.retinaFactor * (pos.getViewMode() != 'obj' ? 0.5 : 1);
        this.orientationDeltas.push([delta[0] * sensitivity, -delta[1] * sensitivity, 0]);

        if (config.legacyInertia) {
            this.updateDeltas(false, true);
        }

        this.browser.callListener('map-position-rotated', {});
    }
};


ControlModeMapObserver.prototype.wheel = function(event) {
    dom.preventDefault(event);

    const map = this.browser.getMap();
    if (!map || !this.config.zoomAllowed) {
        return;
    }

    if (map.getStats(true)['maxZoom']) {
        this.browser.config.minViewExtent = 0.5;
    }

    const pos = map.getPosition();
    const delta = event.getWheelDelta();
    let sensitivity = this.config.sensitivity[2];

    if (this.browser.controlMode.shiftKey) sensitivity *= 0.1;

    const factor = 1.0 + (delta > 0 ? -1 : 1)*sensitivity;

    if (this.browser.controlMode.altKey &&
        this.browser.controlMode.shiftKey &&
        this.browser.controlMode.ctrltKey) {
        const fov = math.clamp(pos.getFov() * factor, 1, 179);
        pos.setFov(fov);
        map.setPosition(pos);
    } else {
        if (pos.getViewMode() != 'obj') {
            let coords = pos.getCoords();

            const cameraInfo = map.getCameraInfo();
            const vector = cameraInfo.vector;
            const height = cameraInfo.height;
            const speed = Math.max(100, height) * (this.browser.controlMode.shiftKey ? 0.00025 : 0.0025) * (delta > 0 ? 1 : -1);

            coords = map.convertCoordsFromNavToPhys(coords, 'float');

            coords[0] += vector[0] * speed;
            coords[1] += vector[1] * speed;
            coords[2] += vector[2] * speed;

            coords = map.convertCoordsFromPhysToNav(coords, 'float');

            pos.setCoords(coords);
            map.setPosition(pos);
            return;
        }


        this.viewExtentDeltas.push(factor);
        this.reduceFloatingHeight(0.8);
        this.browser.callListener('map-position-zoomed', {});
    }
};


ControlModeMapObserver.prototype.doubleclick = function(event) {
    dom.preventDefault(event);

    if (this.browser.controlMode.altKey &&
        this.browser.controlMode.shiftKey &&
        this.browser.controlMode.ctrlKey &&
        this.browser.config.minViewExtent > 0.5) {
        this.browser.config.minViewExtent = 0.5;
        return;
    }

    const map = this.browser.getMap();
    if (!map || (!this.config.jumpAllowed && !this.browser.controlMode.altKey)) {
        return;
    }


    const coords = event.getMouseCoords();
    const canvasSize = this.browser.getRenderer().getCanvasSize();

    if (coords[0] < 0 || coords[1] < 0 || coords[0] >= canvasSize[0] || coords[1] >= canvasSize[1]) {
        return;
    }

    //get hit coords with fixed height
    const mapCoords = map.getHitCoords(coords[0], coords[1], 'fix');

    if (mapCoords) {
        let pos = map.getPosition();
        pos.setCoords(mapCoords);
        pos = map.convertPositionHeightMode(pos, 'fix');
        pos.setHeight(mapCoords[2]);
        //pos = map.convertPositionHeightMode(pos, "fix");
        //pos.setPositionHeight(0);

        console.log(JSON.stringify(mapCoords));

        if (this.browser.controlMode.altKey) {

            pos = map.getPosition();
            pos.setCoords(mapCoords);
            pos = map.convertPositionHeightMode(pos, 'fix');
            const h = mapCoords[2] + 1.6;
            this.config.fixedHeight = (h == 0) ? 0.001 : h;
            this.setPosition(map.getPosition());

        } else {

            if (this.browser.controlMode.shiftKey) {
                map.setPosition(pos);
            } else {
                this.browser.autopilot.flyTo(pos, {'mode' : 'direct', 'maxDuration' : 2000 });
            }

        }

    }
};


ControlModeMapObserver.prototype.keyup = function() {
};


ControlModeMapObserver.prototype.keydown = function() {
};


ControlModeMapObserver.prototype.keypress = function() {
};


ControlModeMapObserver.prototype.setPosition = function(pos) {

    if (!this.config.walkMode) {
        pos = constrainMapPosition(this.browser, pos);
    }

    if (this.config.fixedHeight) {
        pos.setHeight(this.config.fixedHeight);
    }

    const map = this.browser.getMap();
    map.setPosition(pos);
    //console.log(JSON.stringify(pos));
};


ControlModeMapObserver.prototype.reduceFloatingHeight = function(factor) {
    const map = this.browser.getMap();
    const pos = map.getPosition();
    const coords = pos.getCoords();

    if (pos.getHeightMode() == 'float' &&
        pos.getViewMode() == 'obj') {
        if (coords[2] != 0) {
            coords[2] *= factor;

            if (Math.abs(coords[2]) < 0.1) {
                coords[2] = 0;
            }

            pos.setCoords(coords);
            this.setPosition(pos);
        }
    }
};


ControlModeMapObserver.prototype.isNavigationSRSProjected = function() {
    const map = this.browser.getMap();
    const rf = map.getReferenceFrame();
    const srs = map.getSrsInfo(rf['navigationSrs']);
    return (srs) ? (srs['type'] == 'projected') : false;
};


ControlModeMapObserver.prototype.getAzimuthAndDistance = function(dx, dy) {
    const map = this.browser.getMap();
    const pos = map.getPosition();
    const fov = pos.getFov()*0.5;
    let viewExtent = pos.getViewExtent();

    if (this.config.walkMode) {
        viewExtent += 5;
    }

    //const sensitivity = 0.5;
    const zoomFactor = (((viewExtent*0.5) * Math.tan(math.radians(fov))) / 800);
    dx *= zoomFactor;
    dy *= zoomFactor;

    const distance = Math.sqrt(dx*dx + dy*dy);
    const azimuth = -math.degrees(Math.atan2(dx, dy)) + pos.getOrientation()[0];

    return [azimuth, distance];
};


ControlModeMapObserver.prototype.updateDeltas = function(onlyLastPan, onlyLastRotate, onlyLastZoom) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    let pos = map.getPosition();
    const inertia = this.config.inertia; //, stats = map.getStats();
    let update = false, azimuth, correction, i;
    let timeFactor = 1;
    let invTimeFactor = 1;
    let delta, deltas;

    if (this.config.timeNormalizedInertia) {
        let fps = (1000/(map.getStats()['frameTime'] + 0.000001));

        if (fps < 1) {
            fps = 60;
        }

        timeFactor = (fps/60);  //normalized to 60 fps
        invTimeFactor = 1.0/timeFactor;
    }

    //console.log(''+timeFactor);

    //process coords deltas
    if (!onlyLastRotate && !onlyLastZoom && this.coordsDeltas.length > 0) {
        deltas = this.coordsDeltas;
        const forward = [0,0];
        const coords = pos.getCoords();

        //get foward vector form coord deltas
        for (i = (onlyLastPan ? (deltas.length - 1) : 0); i < deltas.length; i++) {
            delta = deltas[i];

            azimuth = delta[3];
            azimuth = math.radians(azimuth);

            forward[0] += Math.sin(azimuth) * (delta[2] * invTimeFactor);
            forward[1] += Math.cos(azimuth) * (delta[2] * invTimeFactor);

            delta[2] *= inertia[0] * timeFactor;

            //remove zero deltas
            if (delta[2] < 0.01) {
                deltas.splice(i, 1);
                i--;
            }
        }

        const distance = Math.sqrt(forward[0]*forward[0] + forward[1]*forward[1]);
        azimuth = math.degrees(Math.atan2(forward[0], forward[1]));

        if (!this.isNavigationSRSProjected()) {
            if (!this.northResetAnimation && this.config.navigationMode == 'azimuthal' && (Math.abs(coords[1]) > 75 || Math.abs(pos.getOrientation()[0]) > 1))  {
                this.config.navigationMode = 'azimuthal2';
            }
        }

        //apply final azimuth and distance
        correction = pos.getOrientation()[0];
        pos = map.movePositionCoordsTo(pos, (this.isNavigationSRSProjected() ? -1 : 1) * azimuth, distance,
                                            (!(this.config.navigationMode == 'free' || this.config.navigationMode == 'azimuthal2')) ? 0 : 1);
        correction = pos.getOrientation()[0] - correction;


        for (i = 0; i < deltas.length; i++) {
            delta = deltas[i];
            delta[3] += correction;
        }

        update = true;
    }

    //process coords deltas
    if (!onlyLastPan && !onlyLastZoom && this.orientationDeltas.length > 0) {
        deltas = this.orientationDeltas;
        const orientation = pos.getOrientation();

        //apply detals to current orientation
        for (i = (onlyLastRotate ? (deltas.length - 1) : 0); i < deltas.length; i++) {
            delta = deltas[i];
            orientation[0] += delta[0] * invTimeFactor;
            orientation[1] += delta[1] * invTimeFactor;
            orientation[2] += delta[2] * invTimeFactor;

            delta[0] *= inertia[1] * timeFactor;
            delta[1] *= inertia[1] * timeFactor;
            delta[2] *= inertia[1] * timeFactor;

            //remove zero deltas
            if (delta[0]*delta[0] + delta[1]*delta[1] + delta[2]*delta[2] < 0.1) {
                deltas.splice(i, 1);
                i--;
            }
        }

        //apply final orintation
        // HACK
        pos.setOrientation(orientation);
        update = true;
    }

    //process view extents deltas
    if (!onlyLastRotate && !onlyLastPan && this.viewExtentDeltas.length > 0) {
        deltas = this.viewExtentDeltas;
        let viewExtent = pos.getViewExtent();

        //apply detals to current view extent
        for (i = (onlyLastZoom ? (deltas.length - 1) : 0); i < deltas.length; i++) {
            //viewExtent *= deltas[i];
            viewExtent *= Math.pow(deltas[i], invTimeFactor);
            deltas[i] += (1 - deltas[i]) * (1.0 - (inertia[2] * timeFactor));

            //deltas[i] *= Math.pow(deltas[i], Math.pow(inertia[2], timeFactor));

            //remove zero deltas
            if (Math.abs(1 - deltas[i]) < 0.001) {
                deltas.splice(i, 1);
                i--;
            }
        }

        viewExtent = Math.max(1, viewExtent);

        //apply final view extrent
        pos.setViewExtent(viewExtent);
        update = true;
    }

    //set new position
    if (update) {
        this.setPosition(pos);
    }
};

ControlModeMapObserver.prototype.tick = function() {
    this.updateDeltas();
};


ControlModeMapObserver.prototype.reset = function() {
    this.coordsDeltas = [];
    this.orientationDeltas = [];
    this.viewExtentDeltas = [];
};


function constrainMapPosition(browser, pos) {
    if (!browser.config.constrainCamera) {
        return pos;
    }

    const minVE = browser.config.minViewExtent;
    const maxVE = browser.config.maxViewExtent;

    const map = browser.getMap();
    let o;

    //clamp view extets
    const viewExtent = math.clamp(pos.getViewExtent(), minVE, maxVE);
    pos.setViewExtent(viewExtent);

    const distance = (viewExtent*0.5) / Math.tan(math.radians(pos.getFov()*0.5));
    //const hmaxOffset = 0;

    //reduce tilt when you are far off the planet
    if (pos.getViewMode() == 'obj') {
        const rf = map.getReferenceFrame();
        const srs = map.getSrsInfo(rf['navigationSrs']);

        if (srs['a']) {

            const a1 = Math.asin(srs['a'] / (distance + srs['a'])); //get angle to horion
            //console.log('a1: ' + math.degrees(a1));

            let factor = Math.tan(math.radians(pos.getFov()*0.5)) / Math.tan(a1);
            //const viewFactor = factor;

            //console.log('factor: ' + factor);

            const threshold = browser.config.tiltConstrainThreshold;
            const thresholdMin = threshold[0];// * 0.5;
            const thresholdMax = threshold[1];// * 0.5;
            let maxTilt, minTilt = -90;

            if (!(thresholdMin > thresholdMax || thresholdMin == thresholdMax)) {
                factor = math.clamp(factor, thresholdMin, thresholdMax);
                factor = ((factor - thresholdMin) / (thresholdMax - thresholdMin));
                maxTilt = 20 + ((-90) - 20) * (factor);
            } else {
                maxTilt = 20;
            }

            //console.log('maxTilt: ' + maxTilt);

            o = pos.getOrientation();
            o[1] = math.clamp(o[1], minTilt, maxTilt);

            pos.setOrientation(o);
        }

        //do not allow camera under terrain
        const camPos = map.getPositionCameraCoords(pos, 'float');
        //const cameraConstrainDistance = 1;
        let cameraConstrainDistance = (minVE*0.5) / Math.tan(math.radians(pos.getFov()*0.5));
        cameraConstrainDistance *= 0.5; //divice by 2 to alow 45deg tilt in maximum zoom

        //const hmax = Math.max(Math.min(4000,cameraConstrainDistance), (distance * Math.tan(math.radians(3.0))));
        //const hmax = Math.max(Math.min(4000,cameraConstrainDistance), (distance * Math.tan(math.radians(3.0))));
        const hmax = Math.max(cameraConstrainDistance, (distance * Math.tan(math.radians(3.0))));

        const cameraHeight = camPos[2]; //this.cameraHeight() - this.cameraHeightOffset - this.cameraHeightOffset2;

        if (cameraHeight < hmax) {
            o = pos.getOrientation();

            const getFinalOrientation = (function(start, end, level) {
                const value = (start + end) * 0.5;

                if (level > 20) {
                    return value;
                } else {
                    o[1] = value;
                    pos.setOrientation(o);

                    if (map.getPositionCameraCoords(pos, 'float')[2] < hmax) {
                        return getFinalOrientation(start, value, level+1);
                    } else {
                        return getFinalOrientation(value, end, level+1);
                    }
                }

            });//.bind(this);

            o[1] = getFinalOrientation(-90, Math.min(20, o[1]), 0);
            pos.setOrientation(o);
        }
    }

    return pos;
}





/***/ }),

/***/ "./src/browser/control-mode/pano.js":
/*!******************************************!*\
  !*** ./src/browser/control-mode/pano.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/math */ "./src/core/utils/math.js");




//get rid of compiler mess
const math = _core_utils_math__WEBPACK_IMPORTED_MODULE_0__["math"];


const ControlModePano = function(browser) {
    this.browser = browser;
    this.config = null;

    this.center = [0, 0];
    this.dragging = false;
    this.velocity = [0, 0];

    this.impulse = [0, 0];

    /*this['drag'] = this.drag;
    this['down'] = this.drag;
    this['up'] = this.drag;
    this['wheel'] = this.wheel;
    this['tick'] = this.tick;
    this['reset'] = this.reset;
    this['keyup'] = this.keyup;
    this['keydown'] = this.keydown;
    this['keypress'] = this.keypress;*/
};


ControlModePano.prototype.drag = function(event) {
    if (!this.dragging) {
        return;
    }

    const mouse = event.getMouseCoords();
    const delta = [mouse[0] - this.center[0], mouse[1] - this.center[1]];
    const sensitivity = 0.008;
    this.velocity[0] = delta[0] * sensitivity;
    this.velocity[1] = delta[1] * sensitivity;

    this.impulse[0] = delta[0] * sensitivity;
    this.impulse[1] = delta[1] * sensitivity;
};


ControlModePano.prototype.down = function(event) {
    if (event.getMouseButton() === 'left') {
        this.center = event.getMouseCoords();
        this.dragging = true;
    }
};


ControlModePano.prototype.up = function(event) {
    if (event.getMouseButton() === 'left') {
        this.dragging = false;
    }
};


ControlModePano.prototype.wheel = function(event) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    const pos = map.getPosition();
    const delta = event.getWheelDelta();

    const factor = (delta > 0 ? -1 : 1) * 1;
    pos.setViewExtent(math.clamp(pos.getViewExtent() + factor, 1, 179));

    map.setPosition(pos);
};


ControlModePano.prototype.keyup = function() {
};


ControlModePano.prototype.keydown = function() {
};


ControlModePano.prototype.keypress = function() {
};


ControlModePano.prototype.tick = function() {
    if (this.velocity[0] == 0.0 && this.velocity[1] == 0.0) {
        return;
    }

    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    const pos = map.getPosition();
    const coords = pos.getCoords();
    coords[0] -= this.velocity[0];
    coords[1] -= this.velocity[1];
    pos.setCoords(coords);
    map.setPosition(pos);

    // friction
    if (this.dragging) {
        return;
    }

    const step = 0.9;
    const treshold = 0.0005;

    if (Math.abs(this.velocity[0]) < treshold) {
        this.velocity[0] = 0.0;
    } else {
        this.velocity[0] *= step;
    }

    if (Math.abs(this.velocity[1]) < treshold) {
        this.velocity[1] = 0.0;
    } else {
        this.velocity[1] *= step;
    }
};


ControlModePano.prototype.reset = function(config) {
    this.config = config;
};


/* harmony default export */ __webpack_exports__["default"] = (ControlModePano);


/***/ }),

/***/ "./src/browser/index.js":
/*!******************************!*\
  !*** ./src/browser/index.js ***!
  \******************************/
/*! exports provided: vec2, vec3, vec4, mat3, mat4, math, utils, getCoreVersion, checkSupport, browser, getBrowserVersion, proj4, earcut, platform, dom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return vec2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return vec3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return vec4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return mat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return mat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "math", function() { return math; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return utils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCoreVersion", function() { return getCoreVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkSupport", function() { return checkSupport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "browser", function() { return browser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBrowserVersion", function() { return getBrowserVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "proj4", function() { return proj4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "platform", function() { return platform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dom", function() { return dom; });
/* harmony import */ var melowntech_proj4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! melowntech-proj4 */ "./node_modules/melowntech-proj4/lib/index.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "earcut", function() { return earcut__WEBPACK_IMPORTED_MODULE_1___default.a; });
/* harmony import */ var _core_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/core */ "./src/core/core.js");
/* harmony import */ var _core_utils_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _core_utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/utils/math */ "./src/core/utils/math.js");
/* harmony import */ var _core_utils_platform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/utils/platform */ "./src/core/utils/platform.js");
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interface */ "./src/browser/interface.js");
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utility/dom */ "./src/browser/utility/dom.js");











//get rid of compiler mess
const getCoreVersion = _core_core__WEBPACK_IMPORTED_MODULE_2__["getCoreVersion"], checkSupport = _core_core__WEBPACK_IMPORTED_MODULE_2__["checkSupport"];
const vec2 = _core_utils_matrix__WEBPACK_IMPORTED_MODULE_3__["vec2"], vec3 = _core_utils_matrix__WEBPACK_IMPORTED_MODULE_3__["vec3"], vec4 = _core_utils_matrix__WEBPACK_IMPORTED_MODULE_3__["vec4"], mat3 = _core_utils_matrix__WEBPACK_IMPORTED_MODULE_3__["mat3"], mat4 = _core_utils_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"];
const utils = _core_utils_utils__WEBPACK_IMPORTED_MODULE_4__["utils"];
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_8__["default"];
const math = _core_utils_math__WEBPACK_IMPORTED_MODULE_5__["math"];
const BrowserInterface = _interface__WEBPACK_IMPORTED_MODULE_7__["default"];
const proj4 = melowntech_proj4__WEBPACK_IMPORTED_MODULE_0__["default"];
const platform = _core_utils_platform__WEBPACK_IMPORTED_MODULE_6__["platform"];

function browser (element, config) {
    const browserInterface = new BrowserInterface(element, config);
    return browserInterface.core ? browserInterface : null;
}

function getBrowserVersion() {
//    return "Browser: 2.0.0, Core: " + getCoreVersion();
    return '' + getCoreVersion();
}




/***/ }),

/***/ "./src/browser/interface.js":
/*!**********************************!*\
  !*** ./src/browser/interface.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _browser_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser.css */ "./src/browser/browser.css");
/* harmony import */ var _browser_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_browser_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _presenter_css_main_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./presenter/css/main.css */ "./src/browser/presenter/css/main.css");
/* harmony import */ var _presenter_css_main_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_presenter_css_main_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _presenter_css_panel_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./presenter/css/panel.css */ "./src/browser/presenter/css/panel.css");
/* harmony import */ var _presenter_css_panel_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_presenter_css_panel_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _presenter_css_subtitles_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./presenter/css/subtitles.css */ "./src/browser/presenter/css/subtitles.css");
/* harmony import */ var _presenter_css_subtitles_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_presenter_css_subtitles_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./browser */ "./src/browser/browser.js");

//css stuff








//get rid of compiler mess
const Browser = _browser__WEBPACK_IMPORTED_MODULE_4__["default"];


const BrowserInterface = function(element, config) {
    this.browser = new Browser(element, config);
    this.core = this.browser.getCore();
    this.killed = false;


    Object.defineProperty(this, 'map', {
        get: function() {
            if (this.killed) return null;
            return this.core.map;
        }
    });

    Object.defineProperty(this, 'renderer', {
        get: function() {
            if (this.killed) return null;
            return this.core.renderer;
        }
    });

    Object.defineProperty(this, 'autopilot', {
        get: function() {
            if (this.killed) return null;
            return this.browser.autopilot;
        }
    });

    Object.defineProperty(this, 'presenter', {
        get: function() {
            if (this.killed) return null;
            return this.browser.presenter;
        }
    });

    Object.defineProperty(this, 'ui', {
        get: function() {
            if (this.killed) return null;
            return this.browser.ui;
        }
    });
};



BrowserInterface.prototype.destroy = function() {
    if (this.killed) return;
    this.core.destroy();
    this.browser.kill();
    this.killed = true;
    return null;
};


BrowserInterface.prototype.setControlMode = function(mode) {
    if (this.killed) return;
    this.browser.setControlMode(mode);
    return this;
};


BrowserInterface.prototype.getControlMode = function() {
    if (this.killed) return;
    return this.browser.getControlMode();
};


BrowserInterface.prototype.loadMap = function(path) {
    if (this.killed) return;
    this.core.loadMap(path);
    return this;
};


BrowserInterface.prototype.destroyMap = function() {
    if (this.killed) return;
    this.core.destroyMap();
    this.map = null;
    return this;
};


BrowserInterface.prototype.on = function(eventName, call) {
    if (this.killed) return;
    return this.core.on(eventName, call);
    //return this;
};


BrowserInterface.prototype.setParams = function(params) {
    if (this.killed) return;
    this.setConfigParams(params,true);
    return this;
};


BrowserInterface.prototype.setParam = function(key, value) {
    if (this.killed) return;
    this.browser.setConfigParam(key, value, true);
    return this;
};


BrowserInterface.prototype.getParam = function(key) {
    if (this.killed) return;
    return this.browser.getConfigParam(key);
};


/* harmony default export */ __webpack_exports__["default"] = (BrowserInterface);


/***/ }),

/***/ "./src/browser/presenter/css/main.css":
/*!********************************************!*\
  !*** ./src/browser/presenter/css/main.css ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/browser/presenter/css/panel.css":
/*!*********************************************!*\
  !*** ./src/browser/presenter/css/panel.css ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/browser/presenter/css/subtitles.css":
/*!*************************************************!*\
  !*** ./src/browser/presenter/css/subtitles.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/browser/presenter/presenter.js":
/*!********************************************!*\
  !*** ./src/browser/presenter/presenter.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


const Presenter = function(browser, config) {
    this.container = null;
    this.aTags = null;
    this.sectionTags = null;
    this.defaultHeight = 0; // Changes based on presentation"s height
    this.maxHeight = 0; // Height of inner container to be set
    this.subtitlesHeights = []; // Set of heights after init() for subtitles

    this.firstTitleMargin = 20; // First slide of presentation has some css margin-top, so here we use it
    this.swipeOffset = 60; // Height of swipeControl

    this.actualNode = 0;
    this.maxNodes = 1;
    this.animTime = 600; // Default css transition time
    this.currentToolbox = 'right'; // Default toolbox (right | wide)

    this.browser = browser;
    this.id = [];
    this.current = null;

    this.presenter = (typeof config['presenter'] !== 'undefined') ? JSON.parse(JSON.stringify(config['presenter'])) : {};
    this.presenterAutoplay = config['presenterAutoplay'];

    if (typeof this.presenter !== 'undefined') {
        this.playPresentation();
    }
};


Presenter.prototype.addPresentation = function(id, source) {
    if (Object.keys(this.presenter).length !== 0) {
        this.presenter[id] = source;
    } else if (typeof id !== 'undefined') {
        this.presenter = {};
        this.presenter[id] = source;
    }
};


Presenter.prototype.removePresentation = function(id) {
    if (typeof id !== 'undefined') {
        if (this.getCurrentPresentation() == id) {
            this.stopPresentation();
            this.current = null;
        }
        delete this.presenter[id];
        return('Removed presentation id: '+id);
    } else {
        if (this.getCurrentPresentation() !== null) {
            this.stopPresentation();
        }
        this.presenter = {}; // Remove all presentations
        this.presenterAutoplay = '';
        this.current = null;
        return('All presentations removed.');
    }
};


Presenter.prototype.getCurrentPresentation = function() {
    return this.current;
};


Presenter.prototype.getCurrentPresentationType = function() {
    return this.currentToolbox;
};


Presenter.prototype.playPresentation = function(id) {
    this.stopPresentation();
    if (this.presenterAutoplay !== undefined && typeof id === 'undefined') {
        id = this.presenterAutoplay;
    } else if (typeof id === 'undefined' && this.presenter !== undefined && Object.keys(this.presenter).length > 0) {
        for (let key in this.presenter) {
            id = key;
            break;
        }
    }

    if (typeof id !== 'undefined' && Object.keys(this.presenter).indexOf(id) != -1) {
        this.current = id;
        this.readTextInput(id);
        return true;
    } else {
        return false;
    }
};


Presenter.prototype.stopPresentation = function() {
    const current = this.getCurrentPresentation();
    this.currentToolbox = 'right';
    if (current !== null) {
        this.current = null;
        this.browser.ui.removeControl(current);
        this.container.getElementsByTagName('article')[0].parentNode.parentNode.parentNode.remove();
        return true;
    }
    return false;
};


Presenter.prototype.listPresentations = function(id) {
    if (Object.keys(this.presenter).length === 0) {
        return [];
    }
    if (typeof id !== 'undefined') {
        if (this.presenter[id] !== 'undefined') {
            return this.presenter[id];
        } else {
            return null;
        }
    } else {
        const tmp = [];
        for (let key in this.presenter) {
            tmp.push(key);
        }
        return tmp;
    }
};


Presenter.prototype.initPresentation = function(id, HTMLtemplate) {
    const obj = this;
    const templatePanelPrefix = '<div class="vts-presenter panelContainer"><div class="vts-presenter swipeControl top"></div><div class="vts-presenter toolboxContainer">';
    const templatePanelSuffix = '</div><div class="vts-presenter swipeControl"></div></div>';
    const templatePanel = templatePanelPrefix + HTMLtemplate + templatePanelSuffix;
    const templateSubtitlesPrefix = '<div class="vts-presenter subtitlesContainer"><button type="button"></button><button type="button"></button>'
                                    + '<div class="vts-presenter swipeSubtitles"><div><div></div></div></div><div class="vts-presenter swipeSubtitles"><div><div></div></div></div><div class="vts-presenter innerContainer">';
    const templateSubtitlesSuffix = '</div></div>';
    const templateSubtitles = templateSubtitlesPrefix + HTMLtemplate + templateSubtitlesSuffix;
    const template = templatePanel + templateSubtitles;
    const ctrlDelve = this.browser.ui.addControl(id, template);
    this.id.push(id);
    this.setContainer(ctrlDelve);

    // Set all <a> tags to have onclick
    this.aTags = this.container.getElementsByTagName('a');
    for (let i = 0; i < this.aTags.length; i++) {
        this.aTags[i].onclick = function() {
            obj.linksDecode(this);
        };
    }

    setTimeout((function(){
        this.renderControl();
    }).bind(this), 200);
};


Presenter.prototype.readTextInput = function(id) {
    const presentation = {
        htmlDataStorage : this.presenter[id],
        id : id,
        checkID : function() {
            const url = /^(ftp|http|https):\/\/[^ "]+$/;
            const relative = /.*\/+.*/;
            const level = /(\.\.\/|\.\/)/g;
            const hash = /^#.*$/;
            const str = /(<article)/g;
            if (str.test(this.htmlDataStorage)) {
                return 'string';
            } else if (url.test(this.htmlDataStorage)) {
                return 'url';
            } else if (relative.test(this.htmlDataStorage)) {
                let getLevel;
                let l = 0;
                let split = '';
                const loc = window.location.href.split('/');
                let path = '';
                while ((getLevel = level.exec(this.htmlDataStorage)) !== null) {
                    split = split + getLevel[0];
                    if (getLevel[0] === './') {
                        break;
                    }
                    l++;
                }
                l++;
                for (let i = 0; i < (loc.length-l); i++) {
                    path = path + loc[i] + '/';
                }
                path = path + this.htmlDataStorage.split(split)[1];
                //console.log('Final path:');
                //console.log(path);
                this.htmlDataStorage = path;
                return 'url';
            } else if (hash.test(this.htmlDataStorage)) {
                return 'hash';
            } else {
                return 'string';
            }
        }
    };

    const mode = presentation.checkID();

    if (mode == 'url') {
        const rawFile = new XMLHttpRequest();
        rawFile.open('GET', presentation.htmlDataStorage, false);
        rawFile.onreadystatechange = (function() {
            if (rawFile.readyState === 4) {
                if (rawFile.status === 200 || rawFile.status == 0) {
                    const allText = rawFile.responseText;
                    this.html = allText;
                    this.initPresentation(presentation.id, this.html);
                } else {
                    this.file = 'undefined';
                }
            }
        }).bind(this);
        rawFile.send(null);
    } else if (mode == 'hash') {
        const obj = document.getElementById(presentation.htmlDataStorage).innerHTML;
        this.initPresentation(presentation.id, obj);
    } else if (mode == 'string') {
        this.initPresentation(presentation.id, presentation.htmlDataStorage);
    }
};


Presenter.prototype.linksDecode = function(obj) {
    let position = null;
    let autorotate = null;
    let transition = null;
    let navigate = null;

    if (obj.getAttribute('data-mln-navigate') !== null) {
        navigate = obj.getAttribute('data-mln-navigate');
        if (navigate !== null) {
            if (navigate == 'prev') {
                this.nextArticle('-1');
            } else if (navigate == 'next') {
                this.nextArticle('+1');
            } else if (navigate == 'first') {
                this.nextArticle(0);
            } else if (navigate == 'last') {
                this.nextArticle(this.maxNodes-1);
            } else {
                this.nextArticle(navigate);
            }
            return 'navigation:true';
        }
    }

    if (obj.getAttribute('data-mln-position') === null){
        return 'position:false';
    }

    position = this.getNumbers(obj.getAttribute('data-mln-position').split(','));

    if (obj.getAttribute('data-mln-autorotate') !== null) {
        autorotate = this.getNumbers(obj.getAttribute('data-mln-autorotate'));
    }
    if (obj.getAttribute('data-mln-transition') !== null) {
        transition = obj.getAttribute('data-mln-transition');
    }

    if (transition === null) {
        this.browser.autopilot.flyTo(position);
    } else if (transition == 'teleport') {
        this.browser.core.getMap().setPosition(position);
    } else {
        this.browser.autopilot.flyTo(position);
        // Feature to be considered
        // browser.flyTo(position, {mode : transition});
    }
    if (autorotate !== null) {
        this.browser.autopilot.setAutorotate(autorotate);
    }

    return 'Moving to position: ' + position;
};


// parseFloat here
Presenter.prototype.getNumbers = function(obj) {
    for (let i = 0; i < obj.length; i++){
        if (typeof obj == 'string' && parseFloat(obj)) {
            obj = parseFloat(obj);
            break;
        }
        if (parseFloat(obj[i])) {
            obj[i] = parseFloat(obj[i]); // toFixed might be added here
        }
    }
    return obj;
};


Presenter.prototype.nextArticle = function(node, init, lastNode) {
    // fly to whatever node we wish
    if (node === '+1') {
        node = 1;
    } else if (node === '-1') {
        node = -1;
    } else {
        this.actualNode = node;
        node = 0;
    }
    this.actualNode = this.actualNode + node;

    if (this.actualNode >= 0 && this.actualNode < this.maxNodes) {
        if (!init) {
            if (this.currentToolbox == 'right') {
                this.handleArticle(this.actualNode);
            } else if (this.currentToolbox == 'wide') {
                this.handleSubtitlesPosition(this.actualNode);
            }
        }
        if (typeof lastNode !== 'undefined') {
            this.maxNodes = lastNode;
        }
        this.linksDecode(this.container.getElementsByTagName('section')[this.actualNode]);
        return true;

    } else {
        this.actualNode = this.actualNode - node;
    }
    return false;
};


Presenter.prototype.useToolbox = function() {
    let type = this.container.getElementsByTagName('article')[0].getAttribute('data-mln-style');

    if (type === null) {
        type = 'right';
    }

    const rightPanel = this.container.getElementsByClassName('vts-presenter panelContainer')[0];
    const subtitles = this.container.getElementsByClassName('vts-presenter subtitlesContainer')[0];
    const swipeControl = this.container.getElementsByClassName('vts-presenter swipeControl');
    let i;
    this.currentToolbox = type;

    subtitles.setAttribute('style', 'opacity: 0;');
    subtitles.setAttribute('class', 'vts-presenter subtitlesContainer');
    if (type == 'right') {
        rightPanel.style.display = 'block';
        setTimeout(function() {
            rightPanel.style.opacity = 1;
        }, 20);
        swipeControl[0].style.display = 'block';
        swipeControl[1].style.display = 'block';
        for (i = 0; i < this.sectionTags.length; i++) { // Set maxHeight back as there is no dynamic rescaling of rightPanel
            this.sectionTags[i].style.height = this.maxHeight + 'px';
        }
        this.nextArticle(0);
    } else if (type == 'wide') {
        subtitles.style.display = 'block';
        setTimeout(function() {
            subtitles.style.opacity = 1;
        }, 20);
        rightPanel.style.display = 'none';
        rightPanel.style.opacity = 0;
        swipeControl[0].style.display = 'none';
        swipeControl[1].style.display = 'none';
        for (i = 0; i < this.sectionTags.length; i++) { // Set height to auto so we can dynamicaly adjust subtitles height
            this.sectionTags[i].style.height = 'auto';
        }
        this.handleSubtitlesPosition(0, true);
    }
};


Presenter.prototype.setContainer = function(c) {
    this.container = c.element;
};


// Rendering of DOM elements for Presenter

Presenter.prototype.renderControl = function() {
    // Set every <section> tag excluding the first one to not to be displayed
    this.sectionTags = this.container.getElementsByClassName('vts-presenter toolboxContainer')[0].querySelectorAll('section');

    const swipeControlUp = this.container.getElementsByClassName('vts-presenter swipeControl')[0];
    const swipeControlDw = this.container.getElementsByClassName('vts-presenter swipeControl')[1];

    const nextButton = document.createElement('button');
    nextButton.innerHTML = '<div><div></div></div>';
    nextButton.setAttribute('type','button');
    nextButton.setAttribute('class','vts-presenter-btnDw');
    nextButton.onclick = (function(){
        this.nextArticle('+1');
    }).bind(this);

    const prevButton = document.createElement('button');
    prevButton.innerHTML = '<div><div></div></div>';
    prevButton.setAttribute('type','button');
    prevButton.setAttribute('class','vts-presenter-btnUp');
    prevButton.onclick = (function(){
        this.nextArticle('-1');
    }).bind(this);

    // End of all buttons and other controllers

    swipeControlUp.appendChild(prevButton);
    swipeControlDw.appendChild(nextButton);

    this.getElementsTrueHeight(this.sectionTags);

    const offsetTop = this.maxHeight + this.swipeOffset;

    this.container.getElementsByClassName('vts-presenter panelContainer')[0].style.height = (offsetTop + this.swipeOffset) + 'px';
    swipeControlDw.style.top = offsetTop +'px';
    swipeControlUp.style.opacity = '1';
    swipeControlDw.style.opacity = '1';

    // init now
    setTimeout((function() {
        this.useToolbox();
    }).bind(this), this.animTime);
    this.nextArticle(0, false, this.sectionTags.length);
};


Presenter.prototype.getElementsTrueHeight = function(elems) {
    for (let i = 0; i < elems.length; i++) {
        if (elems[i].offsetHeight > this.maxHeight) {
            this.maxHeight = elems[i].offsetHeight;
        }
    }

    for (let i = 0; i < elems.length; i++) {
        elems[i].style.height = this.maxHeight + 'px';
    }
};


Presenter.prototype.handleArticle = function(node) {
    const rightPanel = this.container.getElementsByClassName('vts-presenter toolboxContainer')[0];
    const btnUp = this.container.getElementsByClassName('vts-presenter-btnUp')[0];
    const btnDw = this.container.getElementsByClassName('vts-presenter-btnDw')[0];

    const articleClass = (function(a) {
        this.container.getElementsByClassName('vts-presenter toolboxContainer')[0].querySelectorAll('article')[0].setAttribute('class',a);
    }).bind(this);

    const actualHeight = this.maxHeight * this.actualNode * -1;

    btnUp.setAttribute('class','vts-presenter-btnUp');
    btnDw.setAttribute('class','vts-presenter-btnDw');

    if (node === 0) {
        btnUp.setAttribute('class','vts-presenter-btnUp vts-presenter hidden');
    } else if (node === this.maxNodes-1) {
        btnDw.setAttribute('class','vts-presenter-btnDw vts-presenter hidden');
    }

    this.container.getElementsByTagName('article')[0].setAttribute('style','top: '+actualHeight+'px');

    if (this.actualNode === 0) {
        /* handle right panel stuff */
        rightPanel.style.height = (this.maxHeight + this.swipeOffset) + 'px';
        rightPanel.style.top = 0;
        articleClass('vts-presenter');
        /* done - now add some cosmetic attributes */
        this.container.getElementsByClassName('vts-presenter swipeControl')[0].style.height = 0;
        this.container.getElementsByTagName('article')[0].style.top = 0;
        this.container.getElementsByTagName('section')[0].style.height = (this.maxHeight + (this.swipeOffset - this.firstTitleMargin)) + 'px';
    } else {
        /* handle right panel stuff */
        rightPanel.style.height = this.maxHeight + 'px';
        rightPanel.style.top = this.swipeOffset + 'px';
        articleClass('vts-presenter nonFirst');
        /* done - now add some cosmetic attributes */
        this.container.getElementsByClassName('vts-presenter swipeControl')[0].style.height = this.swipeOffset + 'px';
        this.container.getElementsByTagName('section')[0].style.height = (this.maxHeight + this.swipeOffset) + 'px';
    }
    return true;
};


Presenter.prototype.handleSubtitlesPosition = function(node, init) {
    if (typeof node === 'undefined') {
        node = 0;
    }

    const subtitlesContainer = this.container.getElementsByClassName('vts-presenter subtitlesContainer')[0];
    const leftButton = subtitlesContainer.childNodes[0];
    const rightButton = subtitlesContainer.childNodes[1];
    const sections = subtitlesContainer.childNodes[4].querySelectorAll('article')[0].querySelectorAll('section');
    const swipeSubtitles = this.container.getElementsByClassName('vts-presenter swipeSubtitles');

    this.linksDecode(sections[node]);

    // clean all previous states
    sections[node].removeAttribute('style');
    subtitlesContainer.setAttribute('class','vts-presenter subtitlesContainer');
    subtitlesContainer.removeAttribute('onclick');
    swipeSubtitles[0].removeAttribute('onclick');
    swipeSubtitles[1].removeAttribute('onclick');
    swipeSubtitles[0].removeAttribute('style');
    swipeSubtitles[1].removeAttribute('style');
    leftButton.removeAttribute('onclick');
    rightButton.removeAttribute('onclick');
    leftButton.setAttribute('class', 'vts-presenter hidden');
    rightButton.setAttribute('class', 'vts-presenter hidden');

    for (let i = 0; i < sections.length; i++) {
        sections[i].style.opacity = 0;
        if (this.subtitlesHeights[i] === undefined) {
            sections[i].style.display = 'block';
            this.subtitlesHeights[i] = sections[i].offsetHeight;
            sections[i].style.display = 'none';
        }
        if (i !== node) {
            this.hideSections(sections[i]);
        }
    }
    this.showSections(sections[node]);

    let sectionType = sections[node].getAttribute('data-mln-style');
    if (sectionType == undefined) {
        sectionType = 'full';
    }

    if (sectionType == 'full') {
        swipeSubtitles[0].style.opacity = 0;
        swipeSubtitles[1].style.opacity = 0;
        swipeSubtitles[0].style.cursor = 'default';
        swipeSubtitles[1].style.cursor = 'default';

        if (node === 0) {
            leftButton.setAttribute('class', 'vts-presenter hidden');
            rightButton.setAttribute('class', 'vts-presenter');
            rightButton.onclick = (function() {
                this.nextArticle(1);
            }).bind(this);
            rightButton.innerHTML = 'Continue';
        } else if (node === sections.length - 2) { // One more before end
            leftButton.setAttribute('class', 'vts-presenter');
            leftButton.onclick = (function() {
                this.nextArticle('-1');
            }).bind(this);
            leftButton.innerHTML = 'Back';
            rightButton.setAttribute('class', 'vts-presenter');
            rightButton.onclick = (function() {
                this.nextArticle('+1');
            }).bind(this);
            rightButton.innerHTML = 'Explore';
        }
        if (typeof init === 'undefined') {
            subtitlesContainer.setAttribute('style', 'display: block;');
        }
        subtitlesContainer.setAttribute('class','vts-presenter subtitlesContainer full');
    } else if (sectionType == 'title') {
        swipeSubtitles[0].style.opacity = 1;
        swipeSubtitles[1].style.opacity = 1;
        swipeSubtitles[0].onclick = (function() {
            this.nextArticle('-1');
        }).bind(this);
        swipeSubtitles[1].onclick = (function() {
            this.nextArticle('+1');
        }).bind(this);
        leftButton.setAttribute('class', 'vts-presenter hidden');
        rightButton.setAttribute('class', 'vts-presenter hidden');
        subtitlesContainer.style.height = this.subtitlesHeights[node] + 'px';
        subtitlesContainer.setAttribute('class','vts-presenter subtitlesContainer title');

    } else if (sectionType == 'mini') {
        subtitlesContainer.setAttribute('style', 'display: block;');
        subtitlesContainer.setAttribute('class','vts-presenter subtitlesContainer mini');
        leftButton.setAttribute('class', 'vts-presenter hidden');
        rightButton.setAttribute('class', 'vts-presenter hidden');
    }
};



Presenter.prototype.hideSections = function(elem) {
    setTimeout(function() {
        elem.style.display = 'none';
    }, this.animTime);
};


Presenter.prototype.showSections = function(elem) {
    setTimeout(function() {
        elem.style.display = 'block';
        setTimeout(function() {
            elem.style.opacity = 1;
        }, 50);
    }, this.animTime);
};


/* harmony default export */ __webpack_exports__["default"] = (Presenter);


/***/ }),

/***/ "./src/browser/rois/rois.js":
/*!**********************************!*\
  !*** ./src/browser/rois/rois.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Basic class for requesting ROI servers. It hasn't any UI. Eg. Explore Bar
// class has this class as ancestor.

/**
 * @constructor
 */

const Rois = function(roiServers) {
    this.roiServers = roiServers;
};


/**
 * roisAtPosition
 * Request rois intended for specific position
 * @param position position array
 * @param count number of requested rois
 * @param clb callback
 * @return Response promise object (if ES6 is supported otherwise null)
 */
Rois.prototype.roisAtPosition = function(/*position, count, clb*/) {
    // TODO request ROI server
    // ROI gravity must be defined before implementation
};


/* harmony default export */ __webpack_exports__["default"] = (Rois);


/***/ }),

/***/ "./src/browser/ui/control/compass.js":
/*!*******************************************!*\
  !*** ./src/browser/ui/control/compass.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utility/dom */ "./src/browser/utility/dom.js");



//get rid of compiler mess
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_0__["default"];

const UIControlCompass = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('compass',
      '<div id="vts-compass">'

        + '<div id="vts-compass-frame">'
            + '<img id="vts-compass-compass" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGMAAABjCAYAAACPO76VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODRDNjZFNDJCQjNCMTFFM0IyN0ZCQTZFQTAwNzEzNDUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODRDNjZFNDNCQjNCMTFFM0IyN0ZCQTZFQTAwNzEzNDUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4NEM2NkU0MEJCM0IxMUUzQjI3RkJBNkVBMDA3MTM0NSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4NEM2NkU0MUJCM0IxMUUzQjI3RkJBNkVBMDA3MTM0NSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pgg3VBcAAAzUSURBVHja7F1bbBTXGf7tNdiAbTAXYxscMJe04GDLwVwKNDgNhaogRB+4qKgtzUMrISEhIXjiLsT9gQd4oQ8lPFRtEdACoWCCuASRBCelJBASEnM1xsbgGwYbg03PN/4PHI93vTO7s7tnxv6kX7Pe9Y7H/zf/5fxnzn/iXr16Rd3QA3HdZHST0Q2XktFTSLKQNCGpQlKEJLL4WFqFvGRp5uMTIfVCaoQ08PvdZNgEFJ8uZIiQQQ6fu0rIfSEPmaBuMvygv5CRQrJN78cLyeLPQc4AIX2ZsB5Cegn5qZBqIff47oc8F1In5DErH5+XswWpwHdK+fMuTQYUOUrIaJPy3xLyEyYnV0iGQ3+vQsg1Vv73Qu6ayPlByI9CGrsSGf34bs5SCMgRksfKL4jSdVxmcr4WckshBhb0nZBaL5ORysrO5J+ThExmmRBjD3FJyBdCPhfSxO89YLLqvUQGsp18IcP5Z2RD04X8jC1EJ8AiPhNyjrMx4LaQK0Ja3E7GGBaZon4gZCbHBZ2BeHJKyCdKSnydxXVk+Nj1ZHFMeEfIbCGFLhuHfSnkYyFXOaYgnpREykoiQQbSz2lMCFLS+WwNbkaxkAOcAoOIC5w2a03GOCVVRXa0UMO4EE48+QdnXzIV/kZXMibwoA0WMU/Ib8mb+JuQf7GF3GO3pQ0Z8ZwZDeZMaYmQIvI2zgrZxxlXJWdgrbEmA0T8nOMEyPijBmOGaAEW8VcmA/Hj03AJCYeMOA7UKOYNFfJ7IeOpa+ErIfuFlFFbERKB/VU4d3aomMhEoID3oVUijhw5QqWlpV4hYzz/77LCPDFcNxMK3uULQJ3pdzzCtoSmpiaqqanxknXksw7SWCfvRpOMd7i0gTL2n63EiKqqKrp+vW3w2qtXL3r27JnX3BV08CfWyXDWUcTJgCW8zenrEqtmWVlZSSUlbRlg7969qbGxkTyIiawTH+soLZJk4Hen8OtfC3nfikuSBMjXHrUMifdZN8Tpvq2bPcEm8yh7j7E6oNu8eTNt3LjRIEMS0LdvXzp27BhdvnyZfD6f8RkIeu+99ygvL88LhEA3mKS6zjr73GkyQICc/kStqaedq+vTp89ry8jNzTVIAl68eEFPnz41iEpOTvaKdfRkHe1WdHfdKTJ8fMJ4/iP5wVJX3OX9+vVrRwaC+KFDhwwrgMAiBg4cSCNGjGj3ux7KsKCrv7DubpCFSm+8xRMDKAIGrb6WlZXRkydt8zJwQy9fvqT4+HhasmQJZWVlUWJiIjU0NNCdO3fo1q1brtEuLLi52dbTPjMV3eU7YRmpnKolKoGpUyQlJb2OD7AAKD09Pd1wTyDFjbh48SJduHCBVq1aZfervxLyLesQcaQ+HDJy+TiDLE4Mwf3gLgLGjh1LR48epefPnxvpbGtrK8XFxdH69euNoxusYefOnXTu3Dk6cOBAKKcoZN19zLr8LFQy4Mjx8EAKn9AS1NR1zpw5rnX6sIZNmzbRw4cPacOGDTRgwIBQTwXdnVd0WhsKGXJSqIhszFmDjOPHj9OlS5deB2vI9OnTKSMjwzXWAIsGpk2bRrNnzw7nlG+xDo+yTgOmuoGqtkkcI3DcSG0PlFkGLEOmrPL1yJEjKS0tzTXWYATM1FTDPYVhFRKojK6ltseA/kMBHpQLZBly6nSyXSJk3IC4KVNSrUFixYoVThBBrEPo8iy1PUX5jZ3UdjR/Nok8DgTn+fPndyDCAfdkxiTW6Wg7MaM/H3MozPq8zsBYaNu2bXTixImO+bxwT2vWrHH6T05knZayjqutWIZ0S3letwZ/RADLly93yj2ZkWfScVDLyGaScruSNUhMnjyZ5s6dG6lLgE7/zTouCUaGrNZhxFjgNWvYsmULPXr0KODvoFi5du3aSF5GAev2Juu6oTMy0k3ZVJewBtU9oXQTYbzNZKQHI2NIZz7Ni9aguqd58+ZF47JGKLq+2RkZeMLB5/Z4YccaouSezHHDR37WK6pkyAkj1KMyuoI1RNk9SWSwjstY583+yEg2jTNchbq6OsMaiouLbX0viu7JPJYrY51X+xtnpJnihmtw+vRpY9xgl4gouycVQ00672AZqXwc4CZr2Lp1K506dSqk70fZPfmrcqQGIiOFj33dYg1wS9XVoS3hjpF7IpOOUwKRkWSKHdoCAfrgwYMhfz+G7skcn5PUN+P9ZFM9dLcISUSoU7cxdE8SiSaddyDDx8deumdMAOZLMAeBCqsdTJo0KZbuyWwZvmBkaLsGD8Faxohly5YZU7l79uyxTAgIXL16tQ7/yshgZMhVN9U6EgH3JLOmCRMmGKksMGbMGMuEgMDMzExtXbBKxks+3tPdPZmDrxVCVAI1gFwt1BKMDO2aZG3fvr2de/J3d3dGiD8CY4yGYGRIEl7odNWoNZ08edLS3R2IEA3d03N/N75KhiRBm5UsqL5iTGHn7gYhixYt0tU9mS2jKdCgD8+BDtIpgCNOyOqrlbvbXB7R0D1JyFYXdYHIkKseH+ninuR8hJW721weARF4wkPT7OmRSecdyJD9lcrd5J78FQtBHr6jcRpbbtJ5BzKkH6t1i3vyZw34fQ1jhBm1Jp13IEMGcLRfQHPFjFi7p8LCQr+Kdak1SFSwjjtkruY58CoO4tdiQYbqnvDkur/ShYutQeIajy+qzB+YybjPZGCE+EEs3dPSpUtp6NChnVoD5iQQpAcPHkwuwk1F152S8ZCPP8TSPRUUFLQbK5itAfMRKINrUH0NBTdMug5Ihgwot6mt72tBLNzTunXrjLkKKB8kgAzVGhAbYjwfESous247BG9/ZAAoFGazbyuIlXtCCWTHjh1UW1vrBWuQwGLLVgpQjPVHRimT8XU0ru78+fPt3NOsWbNo5cqVdObMGa9Yg4orio4tkSHLIVikjU7IEVujgRVDCMrSPU2dOpUWLFjgNWuQuMQ6pUAlp0DLyBDA8fDzF5EkA9Omcv0csHv3bi9ag0QJu6iAyVEgMn5kMrAyEwstHX8QGosZ1aVbsu2RbtaARmXoHIeWG3KtonxtA3BLFxXd2iKjkesnaN7yqdNkwD1hVakZOloDGgqADNwsUpBsFBUV0cyZlnsnQ4dNrNNGu2QA3zEZZ4X8ghzsX252T5gMgjVEcMVQyMDa9YULF7Z7D60rHj+23PD5LusQ+L6zX0wIUsx6wK/RoP3DSLgnrCrFKDpCa+hCAtbGo6UGjuh3guQCDWhGjRpldH2Ai0LDGouA7p6wLmtCJUPWUTL5hFgcWOiUe4I1YJ21w8t7HQEGnGhRAaDfCa4bloyH50AGYobFbnJfsu6kLikcMup5xDhcyIlwyZDuSUdrkGUXjPplPywZrMeNG2e8J5MMtc1fEEBnmO++QxY2RbHSc+iKciwOxz2h/oQ7bteuXdoRAeTk5NCwYcOMjA6Bu7y8nPbt22dYR0JCArW0tD3MkZKS0q6IGQDFiu7+Z+XvW+nEhitAWzd0FEOfH5RI8+26JwQ9h/pwOIr6+nqjGRnu9uzsbKMznIobN24Y1w8CJNA5LkiycYV11cq6a3GKDOITysfYDzAxlvsU9ujRI5TGWVHB7du3jZIMXBDiAO5+dI9bvHix0bAMzczMZARBM73Za6OcbOxGY6cXOlwaOovhMXbcFn8gj+Lw4cPGHMmUKVNo7969NGPGDMNiECdAThB8JOQIjytOkI1m9Xb61OGkspMYOoud8SoZaiNktc2fBSLOsG6IQtjGwW7TQOTJshPlPnJwIw+doHaTw9y6xZnEEtZJC+vIdsP3hBCu9SrHi+FskiB0vNcso6KiwniNJxQt4CvWRQMPBa6G8ncTQrze/9KbRTX7+Tz5XiEDHeMsuCQ1c9rPI+xK1k1og80wNjOBRWAzk4HUvZkJaiOYqrxAYewu4+Q2P5mcYXWlbX4+YouI+TY/KiFdbQOsc0xEHWm0AZYKuTUc4sdvhCzyKBF/x1CE2hYXabc1nIruTRM1IoOo43aiC4T80uVE4DHGf5LLthOVMG+0C4vBXLobN9o9zhbgyo12VahbUKMrwAwWN2xB/QmLXH/n2i2ozVZi3py9iFNi3drvlXKKepY8uDm7CixBzeXxCIAhLjbUmqjB2ASuBw+Z4XEaOYWH8QOmSuujdRHRJON1tYEzrExlnJLD1jOWotfCFQ8hf8t3/S1lnPCAM6eo7+wYCzIkUNsaRe3btsZzPAFZI9iSnFq0U8F3+k1W9l3TQA2pKh4wi9nS61iSoaI/x49sP6N7uQvaEE6bMeOYzAlBmpIM3OW7GQG3gUfHSD/v05tZN/Mo+R6T81gHJehChopkLq2AhEEOn7uKSakkP+sjuskIjp5MUBonASkc/HtypibbBLWwNHMQfsLBt4YV36z7P+oGMroMusnQCP8XYACgtQtbAKLiKwAAAABJRU5ErkJggg==">'
        + '</div>'

        + '<div id="vts-compass-frame2">'
            + '<img id="vts-compass-compass2" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGMAAABjCAYAAACPO76VAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABG9JREFUeNrtnM9LFGEcxkeEPCQVmbkh7EXoEgW6noIQzQwKoQ5Lkgh7SA8iddlCQfAQFApdghAxooJCsEMe9JAEek8i81YQCIEYQvgHZM9L37Fpmpl9Z3d+rs8DDw7unuaz3+ddX+d9DIOiKIqiKIqiKIqiKIqiKIqiKIqiKMpTQ0NDyqNwTq7/MRUNAKsfwL2EER+MLHxBru/BA4QR3zR0wY/lWmmEMKKHcVh+tsEv5PoGPE4Y0cP4LD9b4AW57oC/whvwB3gZfgN3886FG1EmjAZ41WEa6uAm+DTcyLsXPAz11fWkDUYtvAVPwHfgAnwdbmVMhQtjDj4jN3gNPiTXF+E8fAsuwvfhQScIuVwuMusK762H69IGYwY+LwDew+3wcZkOQ2fhThoMvK8TnkrjZEzCV+RGF2XhXoE/wuvwJ7jGK5aSAkOm4Qm8DTemEcYYfNNtCnTWiCTAkGn4Bu/B+bSuGcPwF3gJfg1Pww/l661uLMQGwzINe+L5tH+1PSpbIOdkG0TtRWWSDsM2Dco/UhlPQSpqGA7TsJfqeEorDLjHNg3pj6cUwjgCzzpAYDxFDENNw6YLCOU+Uggfhtc0mH5LAuHDKDUNyjtwhgTCg6EzDab7effDg6EzDYynkGH4mQbGU4gw/EwD4ykkGMfgZz4hMJ5CgHEV/l4GCMZTgDDUNDwvAwLjKeD1odxp2I8nP/92JQx3P6oAwn48EUYw64N5U3+VG09+H0ggDOc1woymn/Bl2WH1A2KhnKdDCON/WxfrgvzurA8gCmAzYVQOwxpPi7bXdIEUyn1uijDc46nZ4T2lgCxW8hAbYfz1U69PtwYQN4AE4BNGT6lPtwaQQqWPdxLGn93XzVKfbgff1QVI6cOY1Ywnt+2RkgApPRh+48m+PaJA9Ab1FPpBhuEnnpw2Cxd1I40qDUM3npymoRDG+YyDCsMaT0thTANh6MGwxtMunA1jGghDD4Y1ngY1pkH9T+JUFMfIDhoMazy9g2s8pmHHug1OGMHCcIunBvilwzRkoj5geZBgOMXTNXgrjGkgDHcYl2zxdAJ+FeY0EIYziHrLQRUVT7ejmAbCcIZhPbq1G9U06MIo97RuGkF0ejy50Z9LwDlwuekZOSB6QQ6MZuUAaVXGU+TT4BNGixydnpaj1EtytHq4GuPJPEPXF/HBSkcYOmUCUjowVo3xNK8OM8YBwgNGjdRqrEvNxorUbhTldVXHMVlN8aSmIR8XBDsMjymolSKadimmMaSoZqZa4mnePNqbMBiDUr1UlCqmvFQzGVLVtCbXqsJpLu3xtG1vHYgThMMUtEopWUFKyiaktKzWVmamys1G0xxPU04H3RMAo1Fq+Zqkps8OaFVq/aww0vt3hleDWQJgdEth5bIUWG5IoWWHvL5gNgJZYVABy2PRHpfKV0MqYNts1bC8eRHCGJEyZEPKkbvYwRsfjAGpCTdkGyRLAPHB6JUCfU5DAmDkpJ+XN4miKIqiKIqiKIqiKIqiKIqiKIpKpn4DKrVAiBFUfdUAAAAASUVORK5CYII=">'
        + '</div>'

        + '<div id="vts-compass-frame3">'
            + '<img id="vts-compass-compass3" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGMAAABjCAYAAACPO76VAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABG9JREFUeNrtnM9LFGEcxkeEPCQVmbkh7EXoEgW6noIQzQwKoQ5Lkgh7SA8iddlCQfAQFApdghAxooJCsEMe9JAEek8i81YQCIEYQvgHZM9L37Fpmpl9Z3d+rs8DDw7unuaz3+ddX+d9DIOiKIqiKIqiKIqiKIqiKIqiKIqiKMpTQ0NDyqNwTq7/MRUNAKsfwL2EER+MLHxBru/BA4QR3zR0wY/lWmmEMKKHcVh+tsEv5PoGPE4Y0cP4LD9b4AW57oC/whvwB3gZfgN3886FG1EmjAZ41WEa6uAm+DTcyLsXPAz11fWkDUYtvAVPwHfgAnwdbmVMhQtjDj4jN3gNPiTXF+E8fAsuwvfhQScIuVwuMusK762H69IGYwY+LwDew+3wcZkOQ2fhThoMvK8TnkrjZEzCV+RGF2XhXoE/wuvwJ7jGK5aSAkOm4Qm8DTemEcYYfNNtCnTWiCTAkGn4Bu/B+bSuGcPwF3gJfg1Pww/l661uLMQGwzINe+L5tH+1PSpbIOdkG0TtRWWSDsM2Dco/UhlPQSpqGA7TsJfqeEorDLjHNg3pj6cUwjgCzzpAYDxFDENNw6YLCOU+Uggfhtc0mH5LAuHDKDUNyjtwhgTCg6EzDab7effDg6EzDYynkGH4mQbGU4gw/EwD4ykkGMfgZz4hMJ5CgHEV/l4GCMZTgDDUNDwvAwLjKeD1odxp2I8nP/92JQx3P6oAwn48EUYw64N5U3+VG09+H0ggDOc1woymn/Bl2WH1A2KhnKdDCON/WxfrgvzurA8gCmAzYVQOwxpPi7bXdIEUyn1uijDc46nZ4T2lgCxW8hAbYfz1U69PtwYQN4AE4BNGT6lPtwaQQqWPdxLGn93XzVKfbgff1QVI6cOY1Ywnt+2RkgApPRh+48m+PaJA9Ab1FPpBhuEnnpw2Cxd1I40qDUM3npymoRDG+YyDCsMaT0thTANh6MGwxtMunA1jGghDD4Y1ngY1pkH9T+JUFMfIDhoMazy9g2s8pmHHug1OGMHCcIunBvilwzRkoj5geZBgOMXTNXgrjGkgDHcYl2zxdAJ+FeY0EIYziHrLQRUVT7ejmAbCcIZhPbq1G9U06MIo97RuGkF0ejy50Z9LwDlwuekZOSB6QQ6MZuUAaVXGU+TT4BNGixydnpaj1EtytHq4GuPJPEPXF/HBSkcYOmUCUjowVo3xNK8OM8YBwgNGjdRqrEvNxorUbhTldVXHMVlN8aSmIR8XBDsMjymolSKadimmMaSoZqZa4mnePNqbMBiDUr1UlCqmvFQzGVLVtCbXqsJpLu3xtG1vHYgThMMUtEopWUFKyiaktKzWVmamys1G0xxPU04H3RMAo1Fq+Zqkps8OaFVq/aww0vt3hleDWQJgdEth5bIUWG5IoWWHvL5gNgJZYVABy2PRHpfKV0MqYNts1bC8eRHCGJEyZEPKkbvYwRsfjAGpCTdkGyRLAPHB6JUCfU5DAmDkpJ+XN4miKIqiKIqiKIqiKIqiKIqiKIpKpn4DKrVAiBFUfdUAAAAASUVORK5CYII=">'
        + '</div>'

      + ' </div>', visible, visibleLock);

    const compass = this.control.getElement('vts-compass');
    compass.setDraggableState(true);
    compass.on('drag', this.onDrag.bind(this));
    compass.on('dblclick', this.onDoubleClick.bind(this));

    this.image = this.control.getElement('vts-compass-compass');
    this.image2 = this.control.getElement('vts-compass-compass2');
    this.image3 = this.control.getElement('vts-compass-compass3');

    this.lastStyle = '';
};


UIControlCompass.prototype.update = function() {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    const pos = map.getPosition();
    const orientation = pos.getOrientation();
    const value = 'rotateX('+(Math.round(orientation[1]+90)*0.7)+'deg) ' + 'rotateZ('+Math.round(-orientation[0]-45)+'deg)';

    if (value != this.lastStyle) {
        this.lastStyle = value;
        this.image.setStyle(dom.TRANSFORM, value);
        this.image2.setStyle(dom.TRANSFORM, value);
        this.image3.setStyle(dom.TRANSFORM, value);
    }
};


UIControlCompass.prototype.onDrag = function(event) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    if (this.browser.autopilot) { //stop autorotation
        this.browser.autopilot.setAutorotate(0);
        this.browser.autopilot.setAutopan(0,0);
    }

    const delta = event.getDragDelta();
    const sensitivity = 0.4;

    const controller = this.browser.controlMode.getCurrentController();

    if (controller.orientationDeltas) {
        controller.orientationDeltas.push([delta[0] * sensitivity,
            -delta[1] * sensitivity, 0]);
    }
};


UIControlCompass.prototype.onDoubleClick = function(event) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    if (this.browser.autopilot) { //stop autorotation
        this.browser.autopilot.setAutorotate(0);
        this.browser.autopilot.setAutopan(0,0);
    }

    const pos = map.getPosition();
    const orientation = pos.getOrientation();
    orientation[0] = 0;
    orientation[1] = -90;
    pos.setOrientation(orientation);

    map.setPosition(pos);

    if (this.browser.config.navigationMode == 'azimuthal2')  {
        this.browser.config.navigationMode = 'azimuthal';
    }

    dom.stopPropagation(event);
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlCompass);


/***/ }),

/***/ "./src/browser/ui/control/credits.js":
/*!*******************************************!*\
  !*** ./src/browser/ui/control/credits.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const UIControlCredits = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('credits',
      '<div id="vts-credits"'
      + ' class="vts-credits">'
      + ' </div>', visible, visibleLock);

    this.lastHTML = '';
    this.lastHTML2 = '';
    this.lastHTML3 = '';
    this.credits = this.control.getElement('vts-credits');
};


UIControlCredits.prototype.getCreditsString = function(array, separator, full) {
    const map = this.browser.getMap();
    let html = '';

    let li = array.length;
    let plain = '';
    let more = false;
    let creditInfo;

    for (let i = 0; i < li; i++) {
        creditInfo = map.getCreditInfo(array[i]);
        if (creditInfo['plain']) {
            plain += creditInfo['plain'];
        }
    }

    if (plain && plain.length > 30 && li > 1 && !full) {
        for (let i = 0; i < li; i++) {
            creditInfo = map.getCreditInfo(array[i]);
            if (creditInfo['html'].trim() != '') {
                li = i + 1;
                break;
            }
        }

        if (li < array.length) {
            more = true;
        } else {
            li = array.length;
        }
    }

    for (let i = 0; i < li; i++) {
        creditInfo = map.getCreditInfo(array[i]);

        if (creditInfo['html'] && creditInfo['html'].trim() != '') {
            html += creditInfo['html'];

            if (i + 1 < li) {
                html += separator;
            }
        }
    }

    return [html, more];
};


UIControlCredits.prototype.update = function() {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    let html = '', html2 = '', html3 = '', res;
    const credits = map.getCurrentCredits();

    if (credits['imagery'].length > 0) {
        res = this.getCreditsString(credits['imagery'], ', ');
        if (res[0] != '') {
            html += '<div class="vts-credits-supercell">';
            html += '<div class="vts-credits-cell">Imagery: ' + res[0] + '</div>';
            html += res[1] ? '<div class="vts-credits-cell-button" id="vts-credits-imagery-more">and others</div>' : '';
            html += '<div class="vts-credits-separator"></div>';
            html += '</div>';
            html2 = '<div class="vts-credits-list">';
            html2 += this.getCreditsString(credits['imagery'], '<br/>', true)[0] + '</div>';
        }
    }

    if (credits['mapdata'].length > 0) {
        res = this.getCreditsString(credits['mapdata'], ', ');
        if (res[0] != '') {
            html += '<div class="vts-credits-supercell">';
            html += '<div class="vts-credits-cell">Map Data: ' + res[0] + '</div>';
            html += res[1] ? '<div class="vts-credits-cell-button" id="vts-credits-mapdata-more">and others</div>' : '';
            html += '<div class="vts-credits-separator"></div>';
            html += '</div>';
            html3 = '<div class="vts-credits-list">';
            html3 += this.getCreditsString(credits['mapdata'], '<br/>', true)[0] + '</div>';
        }
    }

    html += '<div class="vts-credits-supercell">';
    html += '<div class="vts-credits-cell">Powered by <a class="vts-logo" href="https://www.melown.com/products/vts/" target="blank">VTS 3D Geospatial Software Stack</a></div>';
    html += '<div class="vts-credits-separator"></div>';
    html += '</div>';

    if (this.lastHTML != html) {
        this.lastHTML = html;
        this.credits.setHtml(html);

        let butt = this.control.getElement('vts-credits-imagery-more');
        if (butt) {
            butt.on('click', this.onMoreButton.bind(this, butt, '2'));
        }

        butt = this.control.getElement('vts-credits-mapdata-more');
        if (butt) {
            butt.on('click', this.onMoreButton.bind(this, butt, '3'));
        }
    }

    this.lastHTML2 = html2;
    this.lastHTML3 = html3;
};


UIControlCredits.prototype.onMoreButton = function(butt, html) {
    const rect = butt.getRect();

    if (html == '2') {
        html = this.lastHTML2;
    } else {
        html = this.lastHTML3;
    }

    this.ui.popup.show({'right' : Math.max(0,(rect['fromRight']-rect['width'])) + 'px',
        'bottom' : (rect['fromBottom']+7) + 'px'}, html);
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlCredits);


/***/ }),

/***/ "./src/browser/ui/control/fallback.js":
/*!********************************************!*\
  !*** ./src/browser/ui/control/fallback.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


const UIControlFallback = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.control = this.ui.addControl('fallback',
      '<div class="vts-fallback">'

        + '<div class="vts-fallback-text">'
            + '<p>VTS Browser needs <a href="http://get.webgl.org/">WebGL</a> capable web browser.</p>'
        + '</div>'

      + ' </div>', visible, visibleLock);
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlFallback);


/***/ }),

/***/ "./src/browser/ui/control/fullscreen.js":
/*!**********************************************!*\
  !*** ./src/browser/ui/control/fullscreen.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utility/dom */ "./src/browser/utility/dom.js");



//get rid of compiler mess
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_0__["default"];


const UIControlFullscreen = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.control = this.ui.addControl('fullscreen',
      '<img id="vts-fullscreen" class="vts-fullscreen" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAwUlEQVRo3u2YwRWDIBBEIc+SLMKmckpTFkFPePKQQ57DsitR/z/D6KgMDikBAMCTycKYxai9Bul8MYkic+NFS7BOs4FUa/1IrzTn9xk6O6+rrwEMjGayTlS/UXWeujbcDKgpEZRObgYOc1oYt7CIMXCFFLKmTrS+aqAEP8iSAGBYI1s776FLv7eReaWHWd/cyLz3Bas+vxIYGNXIhBTxOhcKNdCaHvPfGPjVYb3OhVjEGLhrI/Pewc9uZDQvAABwZQMKFi+DmFdLbgAAAABJRU5ErkJggg==">'
      , visible, visibleLock);

    const img = this.control.getElement('vts-fullscreen');
    img.on('click', this.onClick.bind(this));
    img.on('dblclick', this.onDoNothing.bind(this));

    this.enabled = false;
};


UIControlFullscreen.prototype.onDoNothing = function(event) {
    dom.preventDefault(event);
    dom.stopPropagation(event);
};


UIControlFullscreen.prototype.requestFullscreen = function(element) {
    if(element.requestFullscreen) {
        element.requestFullscreen();
    } else if(element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
    } else if(element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen();
    } else if(element.msRequestFullscreen) {
        element.msRequestFullscreen();
    }
};


UIControlFullscreen.prototype.exitFullscreen = function() {
    if(document.exitFullscreen) {
        document.exitFullscreen();
    } else if(document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
    } else if(document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
    }
};


UIControlFullscreen.prototype.fullscreenEnabled = function() {
    return (document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled);
};


UIControlFullscreen.prototype.onClick = function() {
    const element = this.ui.element;

    if (!this.enabled) {
    //if (!this.fullscreenEnabled()) {
        this.enabled = true;
        this.requestFullscreen(element);
    } else {
        this.enabled = false;
        this.exitFullscreen();
    }
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlFullscreen);


/***/ }),

/***/ "./src/browser/ui/control/github.js":
/*!******************************************!*\
  !*** ./src/browser/ui/control/github.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const UIControlGithub = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.control = this.ui.addControl("github",
      '<a target="_blank" href="https://github.com/Melown/vts-browser-js">'
      + '<img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/52760788cde945287fbb584134c4cbc2bc36f904/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png">'
      + '</a>'
      , visible, visibleLock);
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlGithub);


/***/ }),

/***/ "./src/browser/ui/control/holder.js":
/*!******************************************!*\
  !*** ./src/browser/ui/control/holder.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _element_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../element/element */ "./src/browser/ui/element/element.js");



//get rid of compiler mess
const UIElement = _element_element__WEBPACK_IMPORTED_MODULE_0__["default"];


const UIControlHolder = function(ui, html, visible, visibleLock, parentElement) {
    this.ui = ui;
    this.html = html;
    this.elementsById = [];
    this.visible = (visible != null) ? visible : true;

    //create holder element
    this.element = document.createElement('div');
    this.setVisible(this.visible);

    this.visibleLock = visibleLock ? true : false;
    this.setVisibleLock(this.visibleLock);

    //set element content
    this.setHtml(html);

    //append elemenet to UI
    if (parentElement) {
        parentElement.appendChild(this.element);
    } else {
        this.ui.element.appendChild(this.element);
    }
};


UIControlHolder.prototype.setHtml = function(html) {
    this.element.innerHTML = html;

    const allElements = this.element.getElementsByTagName('*');

    //store all elements with id attribute to the table
    for (let i = 0, li = allElements.length; i < li; i++) {
        const id = allElements[i].getAttribute('id');

        if (id !== null) {
            //store element to the table
            this.elementsById[id] = new UIElement(this, allElements[i]);
        }
    }
};


UIControlHolder.prototype.getElement = function(id) {
    return this.elementsById[id];
};


UIControlHolder.prototype.setVisible = function(state) {
    if (this.visibleLock) {
        return;
    }

    this.element.style.display = state ? 'block' : 'none';
    this.visible = state;
};


UIControlHolder.prototype.getVisible = function() {
    return this.visible;
};

UIControlHolder.prototype.setVisibleLock = function(state) {
    this.visibleLock = state;
};


UIControlHolder.prototype.getVisibleLock = function() {
    return this.visibleLock;
};

/* harmony default export */ __webpack_exports__["default"] = (UIControlHolder);

/*
//prevent minification
UIControlHolder.prototype["setHtml"] = UIControlHolder.prototype.setHtml;
UIControlHolder.prototype["getElement"] = UIControlHolder.prototype.getElement;
UIControlHolder.prototype["setVisible"] = UIControlHolder.prototype.setVisible;
UIControlHolder.prototype["getVisible"] = UIControlHolder.prototype.getVisible;
*/


/***/ }),

/***/ "./src/browser/ui/control/layers.js":
/*!******************************************!*\
  !*** ./src/browser/ui/control/layers.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const UIControlLayers = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.control = this.ui.addControl('layers',
      '<div class="vts-layers"'
      + '</div>', visible, visibleLock);
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlLayers);


/***/ }),

/***/ "./src/browser/ui/control/link.js":
/*!****************************************!*\
  !*** ./src/browser/ui/control/link.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utility/dom */ "./src/browser/utility/dom.js");



//get rid of compiler mess
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_0__["default"];


const UIControlLink = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('link',
      '<div id="vts-link" class="vts-link">'

        + '<div id="vts-link-button" class="vts-link-button">'
          + '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAABrUlEQVRIx+2VMWtUQRSFz5nZjVrpD9gNVhpLQbZZ5vWaIoUECayNRSpbo9UiJI1pBRs7DVjYGBC1ntm3yHaiwgYsZP+EmMe7x8K3YJEH+xYLwT3NcGe483HvnJkBVvovxWWSsiy7BeAxgGuSpmY2zPP8/V+DhBAekDysQgPgAMDMbo5Gow9n5bgmgF6vd47kAYBC0t0Y45qkPQAguV+X1wgymUx+ShqUZZmllI4AlEVRPJckkht1ea1FNu/3+1ve+31JV0h+dc49mq+12+0dkpQ0XfpMQgh7JJ9U4SmANf3WZUnXvfevAbQBbMYY3zVu1x+Awsx2YoznzewOgKcke3OApId1AADwCwIGJG90u12f5/nx+vr6Jefc0RyQUjpsfE9CCJsk3wIoyrLcljRttVrznv8AcAEAFgHUtovksNrkXp7nx+Px+ETSbQBfKrN8NrOtRQC17pK0QbJMKb2az5nZd+fc/ZRSBKAm1q+r5ASADyHsVuPAe/+R5JtlnqEzIWY2rGDPsiw7JfmysulB0ypq3TWbzb51Op0JyaskLwL4BGA3xvhi9aes9G/pF4AdwlhUZ8RfAAAAAElFTkSuQmCC">'
        + '</div>'

        + '<div id="vts-link-text-holder" class="vts-link-text-holder">'
            + '<div class="vts-link-text">'
              + '<textarea id="vts-link-text-input" rows="4" cols="50" wrap="hard"></textarea>'
            + '</div>'
        + '</div>'

     + ' </div>', visible, visibleLock);

    this.div = this.control.getElement('vts-link');

    const button = this.control.getElement('vts-link-button');
    button.on('click', this.onSwitch.bind(this));
    button.on('dblclick', this.onDoNothing.bind(this));

    this.linkPanel = this.control.getElement('vts-link-text-holder');
    this.link = this.control.getElement('vts-link-text-input');

    this.linkVisible = false;
    this.update();
};


UIControlLink.prototype.onDoNothing = function(event) {
    dom.stopPropagation(event);
};


UIControlLink.prototype.onSwitch = function() {
    this.linkVisible = !this.linkVisible;
    this.updateLink();
    this.update();
};


UIControlLink.prototype.update = function() {
    const left = 10 + (this.ui.config.controlZoom ? 70 : 0) +
                (this.ui.config.controlSpace ? 35 : 0);

    this.div.setStyle('left', left + 'px');
    this.linkPanel.setStyle('display', this.linkVisible ? 'block' : 'none');
};


UIControlLink.prototype.updateLink = function() {
    const linkValue =  this.browser.getLinkWithCurrentPos();
    if (this.link.getElement().value != linkValue) {
        this.link.getElement().value = linkValue;
    }
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlLink);


/***/ }),

/***/ "./src/browser/ui/control/loading.js":
/*!*******************************************!*\
  !*** ./src/browser/ui/control/loading.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const UIControlLoading = function(ui, visible) {
    this.ui = ui;
    this.control = this.ui.addControl('loading',
      '<div id="vts-loading" class="vts-loading">'

        + '<div class="vts-loading-progress">'
            + '<div id="vts-loading-dot1" class="vts-loading-dot"></div>'
            + '<div id="vts-loading-dot2" class="vts-loading-dot"></div>'
            + '<div id="vts-loading-dot3" class="vts-loading-dot"></div>'
            + '<div id="vts-loading-dot4" class="vts-loading-dot"></div>'
            + '<div id="vts-loading-dot5" class="vts-loading-dot"></div>'
        + '</div>'

      + ' </div>', visible);

    this.loading = this.control.getElement('vts-loading');
    this.dots = [
        this.control.getElement('vts-loading-dot1'),
        this.control.getElement('vts-loading-dot2'),
        this.control.getElement('vts-loading-dot3'),
        this.control.getElement('vts-loading-dot4'),
        this.control.getElement('vts-loading-dot5')
    ];

    this.time = Date.now();
    this.hiding = null;

    //setTimeout(this.hide.bind(this), 5000);
};


UIControlLoading.prototype.show = function() {
    this.hiding = null;
    this.ui.setControlVisible('compass', false);
    this.ui.setControlVisible('zoom', false);
    this.ui.setControlVisible('space', false);
    this.ui.setControlVisible('search', false);
    this.ui.setControlVisible('link', false);
    this.ui.setControlVisible('github', false);
    this.ui.setControlVisible('measure', false);
    this.ui.setControlVisible('measure2', false);
    this.ui.setControlVisible('fullscreen', false);
    this.ui.setControlVisible('credits', false);
    this.ui.setControlVisible('loading', true);
    this.time = Date.now();
};


UIControlLoading.prototype.hide = function() {
    this.hiding = Date.now();

    let search = this.ui.config.controlSearch;
    if (search && !this.ui.browser.config.controlSearchUrl) { //enable search for melown2015 reference frame only
        const map = this.ui.browser.getMap();
        if (map) {
            //search = (map.getReferenceFrame()["id"] == "melown2015");

            const radius = map.getSrsInfo(map.getReferenceFrame()['physicalSrs'])['a'];

            if (radius < (6378137 + 50000) && radius > (6378137 - 50000)) { //is it earth
                search = true;
            } else {
                search = false;
            }
            //search = (map.getSrsInfo(map.getReferenceFrame()["physical"]) == "melown2015");
        }
    }

    this.ui.setControlVisible('compass', this.ui.config.controlCompass, false);
    this.ui.setControlVisible('zoom', this.ui.config.controlZoom, false);
    this.ui.setControlVisible('space', this.ui.config.controlSpace, false);
    this.ui.setControlVisible('search', search, false);
    this.ui.setControlVisible('link', this.ui.config.controlLink, false);
    this.ui.setControlVisible('github', this.ui.config.controlGithub, false);
    this.ui.setControlVisible('measure', this.ui.config.controlMeasure, false);
    this.ui.setControlVisible('measure2', this.ui.config.controlMeasureLite, false);
    this.ui.setControlVisible('fullscreen', this.ui.config.controlFullscreen, false);
    this.ui.setControlVisible('credits', this.ui.config.controlCredits, false);
    this.ui.setControlVisible('loading', false);
};


UIControlLoading.prototype.update = function() {
    const timer = Date.now();
    let timeDelta;

    if (this.hiding) {
        timeDelta = (timer - this.hiding) * 0.001;
        this.loading.setStyle('opacity', (1-Math.min(1.0, timeDelta*2)) + '' );

        if (timeDelta > 0.5) {
            this.control.setVisible(false);
        }
    }


    timeDelta = (timer - this.time) * 0.001;

    //sine wave
    /*
    for (let i = 0; i < 5; i++) {
        this.dots[i].setStyle("top", (Math.sin(((Math.PI*1.5)/5)*i+timeDelta*Math.PI*2)*10)+"%");
    }*/

    //opacity
    for (let i = 0; i < 5; i++) {
        //this.dots[i].setStyle("opacity", (Math.sin(((Math.PI*1.5)/5)*i+timeDelta*Math.PI*2)*60+20)+"%");
        this.dots[i].setStyle('opacity', (Math.sin(((Math.PI*1.5)/5)*i-timeDelta*Math.PI*2)*0.6+0.2));
    }

    const map = this.ui.browser.getMap();
    if (!map) {
        return;
    }

    const stats = map.getStats();

    if ((stats['surfaces'] == 0 && stats['freeLayers'] == 0) ||  //nothing to load
        ((timer - this.time) > 7000) || //loading takes too long
        (stats['downloading'] == 0 && stats['lastDownload'] > 0 && (timer - stats['lastDownload']) > 1000) || //or everything loaded
        (stats['bestMeshTexelSize'] != 0 && stats['bestMeshTexelSize'] <= (stats['texelSizeFit'] * 3) || //or resolution is good enough
        (stats['loadMode'] == 'fit' || stats['loadMode'] == 'fitonly') && (stats['drawnTiles'] - stats['drawnGeodataTiles']) > 1) ) { //or at leas some tiles are loaded
        this.hide();
        this.ui.browser.callListener('loading-screen-hidden', {});
    }
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlLoading);


/***/ }),

/***/ "./src/browser/ui/control/map.js":
/*!***************************************!*\
  !*** ./src/browser/ui/control/map.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const UIControlMap = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('map',
      '<div id="vts-map"'
      + ' class="vts-map">'
      + ' </div>', visible, visibleLock);

    const map = this.getMapElement();
    map.setDraggableState(true);
};


UIControlMap.prototype.getMapElement = function() {
    return this.control.getElement('vts-map');
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlMap);


/***/ }),

/***/ "./src/browser/ui/control/measure-lite.js":
/*!************************************************!*\
  !*** ./src/browser/ui/control/measure-lite.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utility/dom */ "./src/browser/utility/dom.js");
/* harmony import */ var _measure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./measure */ "./src/browser/ui/control/measure.js");




//get rid of compiler mess
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_0__["default"],
      UIControlMeasureIcon = _measure__WEBPACK_IMPORTED_MODULE_1__["UIControlMeasureIcon"],
      UIControlMeasureIcon2 = _measure__WEBPACK_IMPORTED_MODULE_1__["UIControlMeasureIcon2"];


const UIControlMeasureLite = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('measure2',
      '<div id="vts-measure" class="vts-measure">'

        + '<img id="vts-measure-button"'
          + ' class="vts-measure-button"'
          + ' src="' + UIControlMeasureIcon + '">'

        + '<img id="vts-measure-button2"'
          + ' class="vts-measure-button"'
          + ' src="' + UIControlMeasureIcon2 + '">'

        + '<div id="vts-measure-text-holder" class="vts-measure-text-holder">'
            + '<div class="vts-measure-text-holder2">'
                + '<div class="vts-measure-text">'
                  + '<textarea id="vts-measure-text-input" rows="6" cols="50" wrap="hard"></textarea>'
                + '</div>'
                + '<div class="vts-measure-tools">'
                    + '<div id="vts-measure-clear" class="vts-measure-tools-button">Clear</div>'
                + '</div>'
            + '</div>'
        + '</div>'

        + '<div id="vts-measure-info" class="vts-measure-info">'
        + '</div>'

     + ' </div>', visible, visibleLock);

    this.div = this.control.getElement('vts-measure');

    this.buttonOff = this.control.getElement('vts-measure-button');
    this.buttonOff.on('click', this.onSwitch.bind(this));
    this.buttonOff.on('dblclick', this.onDoNothing.bind(this));

    this.buttonOn = this.control.getElement('vts-measure-button2');
    this.buttonOn.on('click', this.onSwitch.bind(this));
    this.buttonOn.on('dblclick', this.onDoNothing.bind(this));

    this.info = this.control.getElement('vts-measure-info');

    const clearButton = this.control.getElement('vts-measure-clear');
    clearButton.on('click', this.onClear.bind(this));
    clearButton.on('dblclick', this.onDoNothing.bind(this));

    this.measuring = false;
    this.counter = 1;
    this.lastCoords = null;

    this.listPanel = this.control.getElement('vts-measure-text-holder');
    this.list = this.control.getElement('vts-measure-text-input');

    if (this.measuring) {
        this.buttonOn.setStyle('display', 'block');
        this.buttonOff.setStyle('display', 'none');
    } else {
        this.buttonOn.setStyle('display', 'none');
        this.buttonOff.setStyle('display', 'block');
    }

    this.onMouseMoveCall = this.onMouseMove.bind(this);
    this.onMouseLeaveCall = this.onMouseLeave.bind(this);
    this.onMouseClickCall = this.onMouseClick.bind(this);

    this.update();
};


UIControlMeasureLite.prototype.onDoNothing = function(event) {
    dom.stopPropagation(event);
};

UIControlMeasureLite.prototype.onMouseLeave = function(/*event*/) {
    this.info.setStyle('display', 'none');
};


UIControlMeasureLite.prototype.onMouseClick = function(event) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    const mapElement = this.ui.getMapElement();
    const state = mapElement.getDraggingState();

    //if (state['dragging']) { //TODO: why does not work this parameter? Fix it once you have time
      //  return;
    //}
    const delta = state['absMoved'];

    if ((delta[0]+delta[1]) > 0) {
        return;
    }

    const coords = event.getMouseCoords();
    let clickCoords = map.getHitCoords(coords[0], coords[1], 'fix');

    if (!clickCoords) {
        return;
    }

    clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

    let str = '#' + this.counter + '  ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + clickCoords[2].toFixed(2) + 'm';

    if (this.lastCoords) {
        const res = map.getDistance(this.lastCoords, clickCoords, false, true);
        let space = '\n   ';

        for (let i = 0, li = ('' + this.counter).length; i < li; i++) {
            space += ' ';
        }

        str += space + 'great-circle distance: ';

        if (res[0] > 100000) {
            str += '' + (res[0]*0.001).toFixed(2) + 'km';
        } else {
            str += '' + res[0].toFixed(2) + 'm';
        }

        str += space + 'elevation difference: ' + (clickCoords[2] - this.lastCoords[2]).toFixed(2) + 'm';
        str += space + 'euclidean distance: ';

        if (res[2] > 100000) {
            str += '' + (res[2]*0.001).toFixed(2) + 'km';
        } else {
            str += '' + res[2].toFixed(2) + 'm';
        }
    }

    this.counter++;
    this.lastCoords = clickCoords;

    const listElement = this.list.getElement();
    listElement.value += str + '\n';
    listElement.scrollTop = listElement.scrollHeight;    //scroll list to the last line
};

UIControlMeasureLite.prototype.onMouseMove = function(event) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    const coords = event.getMouseCoords();
    let clickCoords = map.getHitCoords(coords[0], coords[1], 'fix');

    if (!clickCoords) {
        this.info.setStyle('display', 'none');
        return;
    }

    clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

    const str = clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + clickCoords[2].toFixed(2) + 'm';

    coords[0] -= this.divRect.left;
    coords[1] -= this.divRect.top;

    this.info.setStyle('display', 'block');
    this.info.setStyle('left', (coords[0]+20)+'px');
    this.info.setStyle('top', (coords[1]+10)+'px');
    this.info.setHtml(str);
};

UIControlMeasureLite.prototype.onSwitch = function() {
    this.measuring = !this.measuring;

    const mapElement = this.ui.getMapElement();

    if (this.measuring) {
        this.buttonOn.setStyle('display', 'block');
        this.buttonOff.setStyle('display', 'none');

        this.divRect = this.div.getRect();

        mapElement.on('mousemove', this.onMouseMoveCall);
        mapElement.on('mouseleave', this.onMouseLeaveCall);
        mapElement.on('click', this.onMouseClickCall);

    } else {
        this.buttonOn.setStyle('display', 'none');
        this.buttonOff.setStyle('display', 'block');

        mapElement.off('mousemove', this.onMouseMoveCall);
        mapElement.off('mouseleave', this.onMouseLeaveCall);
        mapElement.off('click', this.onMouseClickCall);
    }

    this.updateLink();
    this.update();
};

UIControlMeasureLite.prototype.onClear = function() {
    this.counter = 1;
    this.lastCoords = null;

    const listElement = this.list.getElement();
    listElement.value = '';
    listElement.scrollTop = 0;
};

UIControlMeasureLite.prototype.update = function() {
    const left = 10 + (this.ui.config.controlZoom ? 70 : 0) +
                 (this.ui.config.controlSpace ? 35 : 0);

    this.div.setStyle('left', left + 'px');
    this.listPanel.setStyle('display', this.measuring ? 'block' : 'none');
};


UIControlMeasureLite.prototype.updateLink = function() {
    /*
    const linkValue =  this.browser.getLinkWithCurrentPos();
    if (this.list.getElement().value != linkValue) {
        this.list.getElement().value = linkValue;
    }*/
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlMeasureLite);


/***/ }),

/***/ "./src/browser/ui/control/measure.js":
/*!*******************************************!*\
  !*** ./src/browser/ui/control/measure.js ***!
  \*******************************************/
/*! exports provided: UIControlMeasure, UIControlMeasureIcon, UIControlMeasureIcon2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIControlMeasure", function() { return UIControlMeasure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIControlMeasureIcon", function() { return UIControlMeasureIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIControlMeasureIcon2", function() { return UIControlMeasureIcon2; });
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utility/dom */ "./src/browser/utility/dom.js");
/* harmony import */ var _core_utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _core_utils_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/utils/matrix */ "./src/core/utils/matrix.js");





//get rid of compiler mess
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_0__["default"],
      utils = _core_utils_utils__WEBPACK_IMPORTED_MODULE_1__["utils"],
      vec3 = _core_utils_matrix__WEBPACK_IMPORTED_MODULE_2__["vec3"],
      UIControlMeasureIcon = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2lpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpkNjI1MjFjMi1mYzE5LTcyNDUtOTI5My1kNTU3MmE5N2E1MjgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODJGRUI2NzE2NzkwMTFFN0EzRUZFNzQ1NEFCMkVFQUQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODJGRUI2NzA2NzkwMTFFN0EzRUZFNzQ1NEFCMkVFQUQiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRBMjkwN0JENjc4QzExRTc5QTQwRjk4NjQzOEI4RDczIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRBMjkwN0JFNjc4QzExRTc5QTQwRjk4NjQzOEI4RDczIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+k3ySjQAAAdJJREFUeNrclk0oBGEYgHemjZOLm8tSyt9BqT2I1O7JSdSSkpsDxZGLi5MTjn5K4SDh4OfiaPfkIDebOPiPUqKUiLKet96pzzT7MztxMPX0le+b95n3Z2ZZmUwm9NuXHfqLK1smsVhsED5hKkhswc4mYJmHVxgNIvIslyE4hnLYDSqycwiaoCGVSnUFFdk5BH2wKHtBRbYKqlVwbQhGoNU5GETkZHKpggjMqaBFhaGgIltv/mKphRuQss1oZkPuG4oRWTLHlmU5fSlhOYNKSEK7xIUugj+6hmSHpROm2RvL9Q7arqf80IykdDEdgll4IWi/Bm+ECT8Z2R7l+DBKV6N/PoRnEbBuwIKf0nm+8S7RGuzDLaxLMuw/5OuR+bn60ROPt9/pUUQnUEa6A56SyeSWeTYejzs9GkC8ZIpySjxEy1APbdCM6MAlGmeZdIahYIlLVAU9kIA7KZFxrJrA5+bU8RBjBf+eGD26gk0oI4AItiU4dMOqHh+GTylbQT3JU7oj2IMLmNBJrIATKIUoD5L2LfEQJbRPvXAP0iPZj5J92vNl9Fk6mSCZsBV4dwuyflb8XJrRqX6C3iDsFhSdiXOzZlSnwxD2yuBHJv/iX6JvAQYAPSICqA82OnoAAAAASUVORK5CYII=',
      UIControlMeasureIcon2 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2Nzg3NzczMzY3OEMxMUU3QjU2QUUxNTNCNzc4MzVBQiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2Nzg3NzczNDY3OEMxMUU3QjU2QUUxNTNCNzc4MzVBQiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY3ODc3NzMxNjc4QzExRTdCNTZBRTE1M0I3NzgzNUFCIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3ODc3NzMyNjc4QzExRTdCNTZBRTE1M0I3NzgzNUFCIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+owD8TQAAAepJREFUeNrcls8rBGEYx993lIMfxR4kF/+AKMqBg7K1ajelLEWK025tKOTnjVykuAklNgcHuzmQg4MiTtz4Aza3TeGActDr+45nZt41s7tmBwdbn2l35933M9/3eead5UII9tsvjf3FK2uSiGgBKdDtZW6JllXA2DG4A3teRM7LZQl2QRuY9irScghGQRXb5KteRVoOQSMY0895FGkk8JHgSBH0gllzpAeRkeSRBAEwQIIZUJMxukARly3GOZdpivA5DnpAM2iQ5zFx3KE55DIugT6cT+a7PTTlKt9xHAT74AzU6vWJiEVQ4iWR9uXHhkgu3QhYB/JK3zBZE6WoBkE3Ivt9YolOQBd9uwJedQFjC+A8XyJ1J3G+4zNFV+CCmmMejINnY8sQG0wVzZnFlnW2Fd55ezGaIUAtPgzqwAsmv8mYMCLW8DaqdyY1g73w+RMFQRh0glse1RtDHRvDcdJp6XInsScKU3u3gnukSfCoOcoH0YPa3jif/P7zxEqUoPqUkWBZ398YqwdTNHqLdu+YuyTONToEl+AaTIAhUE61qwTtuJC0e4klkssQAn7QTy3+BA5AhRQgfdoovHvJp6iYli5EdTqlBKZA7a7CJFaiHdABUqBUFfyMxBJt06PBrwpskn/xl+hDgAEAH0j0b9rsgVUAAAAASUVORK5CYII=';


const UIControlMeasure = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('measure',
      '<div id="vts-measure" class="vts-measure">'

        + '<img id="vts-measure-button"'
          + ' class="vts-measure-button"'
          + ' src="' + UIControlMeasureIcon + '">'

        + '<img id="vts-measure-button2"'
          + ' class="vts-measure-button"'
          + ' src="' + UIControlMeasureIcon2 + '">'

        + '<div id="vts-measure-text-holder" class="vts-measure-text-holder">'
            + '<div class="vts-measure-text-holder2">'
                + '<div class="vts-measure-text">'
                  + '<textarea id="vts-measure-text-input" rows="10" cols="67" wrap="hard"></textarea>'
                + '</div>'
                + '<div class="vts-measure-tools">'
                    + '<div id="vts-measure-position" class="vts-measure-tools-button">Position</div>'
                    + '<div id="vts-measure-length" class="vts-measure-tools-button">Length</div>'
                    + '<div id="vts-measure-track" class="vts-measure-tools-button">Track Length</div>'
                    + '<div id="vts-measure-area" class="vts-measure-tools-button">Area</div>'
                    + '<div id="vts-measure-volume" class="vts-measure-tools-button">Volume</div>'
                    + '<div id="vts-measure-clear" class="vts-measure-tools-button">Clear Log</div>'
                    + '<div id="vts-measure-metric" class="vts-measure-tools-button">Units: Meters</div>'
                + '</div>'
            + '</div>'
        + '</div>'

        + '<div id="vts-measure-info" class="vts-measure-info">'
        + '</div>'

        + '<div id="vts-measure-buttons" class="vts-measure-compute">'
            + '<div id="vts-measure-undo" class="vts-measure-tools-button">Undo</div>'
            + '<div id="vts-measure-compute" class="vts-measure-tools-button">Compute</div>'
        + '</div>'

     + ' </div>', visible, visibleLock);

    this.div = this.control.getElement('vts-measure');

    this.buttonOff = this.control.getElement('vts-measure-button');
    this.buttonOff.on('click', this.onSwitch.bind(this));
    this.buttonOff.on('dblclick', this.onDoNothing.bind(this));

    this.buttonOn = this.control.getElement('vts-measure-button2');
    this.buttonOn.on('click', this.onSwitch.bind(this));
    this.buttonOn.on('dblclick', this.onDoNothing.bind(this));

    this.info = this.control.getElement('vts-measure-info');
    this.compute = this.control.getElement('vts-measure-buttons');

    const undoButton = this.control.getElement('vts-measure-undo');
    undoButton.on('click', this.onCompute.bind(this, 0));
    undoButton.on('dblclick', this.onDoNothing.bind(this));
    const computeButton = this.control.getElement('vts-measure-compute');
    computeButton.on('click', this.onCompute.bind(this, 1));
    computeButton.on('dblclick', this.onDoNothing.bind(this));

    const clearButton = this.control.getElement('vts-measure-clear');
    clearButton.on('click', this.onClear.bind(this));
    clearButton.on('dblclick', this.onDoNothing.bind(this));

    this.toolButtons = [];
    let toolButton = this.control.getElement('vts-measure-position');
    toolButton.on('click', this.onTool.bind(this, 0));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    toolButton = this.control.getElement('vts-measure-length');
    toolButton.on('click', this.onTool.bind(this, 1));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    toolButton = this.control.getElement('vts-measure-track');
    toolButton.on('click', this.onTool.bind(this, 2));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    toolButton = this.control.getElement('vts-measure-area');
    toolButton.on('click', this.onTool.bind(this, 3));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    toolButton = this.control.getElement('vts-measure-volume');
    toolButton.on('click', this.onTool.bind(this, 4));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    toolButton = this.control.getElement('vts-measure-metric');
    toolButton.on('click', this.onTool.bind(this, 5));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    this.metricButton = toolButton;


    this.measuring = false;
    this.counter = 1;
    this.renderCounter = 1;
    this.lastCoords = null;
    this.navCoords = null;
    this.tool = 0;
    this.metric = true;
    this.mapUpdateDestructor = null;

    this.listPanel = this.control.getElement('vts-measure-text-holder');
    this.list = this.control.getElement('vts-measure-text-input');

    if (this.measuring) {
        this.buttonOn.setStyle('display', 'block');
        this.buttonOff.setStyle('display', 'none');
    } else {
        this.buttonOn.setStyle('display', 'none');
        this.buttonOff.setStyle('display', 'block');
    }

    this.onMouseMoveCall = this.onMouseMove.bind(this);
    this.onMouseLeaveCall = this.onMouseLeave.bind(this);
    this.onMouseClickCall = this.onMouseClick.bind(this);
    this.onMapUpdateCall = this.onMapUpdate.bind(this);

    this.update();
};


UIControlMeasure.prototype.onDoNothing = function(event) {
    dom.stopPropagation(event);
};


UIControlMeasure.prototype.onMouseLeave = function(/*event*/) {
    this.info.setStyle('display', 'none');
};


UIControlMeasure.prototype.onMouseClick = function(event) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    const mapElement = this.ui.getMapElement();
    const state = mapElement.getDraggingState();

    //if (state['dragging']) { //TODO: why does not work this parameter? Fix it once you have time
      //  return;
    //}
    const delta = state['absMoved'];

    if ((delta[0]+delta[1]) > 0) {
        return;
    }

    const coords = event.getMouseCoords();
    let clickCoords = map.getHitCoords(coords[0], coords[1], 'fix');

    map.redraw();

    if (!clickCoords) {
        return;
    }

    let i, li, res, str;
    let space = '  ';

    for (i = 0, li = ('' + this.counter).length; i < li; i++) {
        space += ' ';
    }

    if (this.tool == 0) {
        this.navCoords = clickCoords;
        clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

        str = '------------------------------------------------------\n';
        str += '#' + this.counter + ' Position: ';
        str += '\n' + space + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        this.counter++;

    } else if (this.tool == 1) {
        if (!this.navCoords || this.navCoords.length == 2) {
            this.navCoords = [clickCoords];
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

            str = '------------------------------------------------------\n';
            str += '#' + this.counter + ' Length: ';
            str += '\n' + space + 'p1: ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        } else {
            this.navCoords.push(clickCoords);
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

            str = space + 'p2: ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
            str += '\n' + space + '------------------------';

            res = map.getDistance(this.lastCoords, clickCoords, false, true);
            str += '\n' +  space + 'great-circle distance: ' + this.getTextNumber(res[0]);
            str += '\n' + space + 'euclidean distance: ' + this.getTextNumber(res[2]);
            str += '\n' + space + 'elevation difference: ' + this.getTextNumber(clickCoords[2] - this.lastCoords[2]);
            str += '\n' + space + 'azimuth: ' + res[1].toFixed(2) + ' deg';

            this.counter++;
        }
    } else if (this.tool == 2) {
        if (this.renderCounter != this.counter) {
            this.renderCounter = this.counter;
            this.onTool(2);
        }

        if (!this.navCoords) {
            this.navCoords = [clickCoords];
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');
            str = '------------------------------------------------------\n';
            str += '#' + this.counter + ' Track Length: ';
            str += '\n' + space + 'p1: ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        } else {
            this.navCoords.push(clickCoords);
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

            str = space + 'p' + this.navCoords.length + ': ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        }
    } else if (this.tool == 3 || this.tool == 4) {
        if (this.renderCounter != this.counter) {
            this.renderCounter = this.counter;
            this.onTool(this.tool);
        }

        if (!this.navCoords) {
            this.navCoords = [clickCoords];
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');
            str = '------------------------------------------------------\n';
            str += '#' + this.counter + ((this.tool == 3) ? ' Area: ' : ' Volume: ');
            str += '\n' + space + 'p1: ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        } else {
            this.navCoords.push(clickCoords);
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

            str = space + 'p' + this.navCoords.length + ': ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        }
    }

    this.lastCoords = clickCoords;

    if (str) {
        const listElement = this.list.getElement();
        listElement.value += str + '\n';
        listElement.scrollTop = listElement.scrollHeight;    //scroll list to the last line
    }
};


UIControlMeasure.prototype.onMouseMove = function(event) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    const coords = event.getMouseCoords();
    let clickCoords = map.getHitCoords(coords[0], coords[1], 'fix');

    if (!clickCoords) {
        this.info.setStyle('display', 'none');
        return;
    }

    clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

    const str = clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);

    coords[0] -= this.divRect.left;
    coords[1] -= this.divRect.top;

    this.info.setStyle('display', 'block');
    this.info.setStyle('left', (coords[0]+20)+'px');
    this.info.setStyle('top', (coords[1]+10)+'px');
    this.info.setHtml(str);
};


UIControlMeasure.prototype.onSwitch = function() {
    this.measuring = !this.measuring;

    const mapElement = this.ui.getMapElement();

    if (this.measuring) {
        this.buttonOn.setStyle('display', 'block');
        this.buttonOff.setStyle('display', 'none');

        this.divRect = this.div.getRect();

        mapElement.on('mousemove', this.onMouseMoveCall);
        mapElement.on('mouseleave', this.onMouseLeaveCall);
        mapElement.on('click', this.onMouseClickCall);
        this.mapUpdateDestructor = this.browser.on('map-update', this.onMapUpdateCall);

    } else {
        this.buttonOn.setStyle('display', 'none');
        this.buttonOff.setStyle('display', 'block');

        mapElement.off('mousemove', this.onMouseMoveCall);
        mapElement.off('mouseleave', this.onMouseLeaveCall);
        mapElement.off('click', this.onMouseClickCall);

        if (this.mapUpdateDestructor) {
            this.mapUpdateDestructor();
        }
    }

    this.onTool(this.tool);

    this.compute.setStyle('display', 'none');

    const map = this.browser.getMap();
    if (map) {
        map.redraw();
    }

    this.update();
};


UIControlMeasure.prototype.onTool = function(tool) {
    if (tool == 5) {
        this.metric = !this.metric;
        this.metricButton.setHtml(this.metric ? 'Units: Meters' : 'Units: Feets');
        return;
    }

    this.tool = tool;
    this.navCoords = null;

    this.compute.setStyle('display', 'none');

    for (let i = 0; i < 5; i++) {
        this.toolButtons[i].setClass('vts-measure-tools-button');
    }

    this.toolButtons[tool].setClass('vts-measure-tools-button-selected');

    const map = this.browser.getMap();
    if (map) {
        map.redraw();
    }
};


UIControlMeasure.prototype.onCompute = function(button) {
    if (!this.navCoords) {
        return;
    }

    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    let str, i, li, space;
    let coords, coords2, res;
    const listElement = this.list.getElement();

    if (button == 0) { //undo button
        this.navCoords.pop();
    } else { //compute button
        if (this.tool == 2) {

            let distance = 0;
            let distance2 = 0;
            let emin = Number.POSITIVE_INFINITY;
            let emax = Number.NEGATIVE_INFINITY;

            space = '  ';

            for (i = 0, li = ('' + this.counter).length; i < li; i++) {
                space += ' ';
            }

            str = space + '------------------------';

            for (i = 0, li = this.navCoords.length; i < li; i++) {
                coords = map.convertCoordsFromNavToPublic(this.navCoords[i], 'fix');

                if (coords[2] > emax) {
                    emax = coords[2];
                }

                if (coords[2] < emin) {
                    emin = coords[2];
                }
            }

            for (i = 0, li = this.navCoords.length - 1; i < li; i++) {
                coords = map.convertCoordsFromNavToPublic(this.navCoords[i], 'fix');
                coords2 = map.convertCoordsFromNavToPublic(this.navCoords[i+1], 'fix');
                res = map.getDistance(coords, coords2, false, true);
                distance += res[0];
                distance2 += res[2];
            }

            str += '\n' +  space + 'great-circle distance: ' + this.getTextNumber(distance);
            str += '\n' + space + 'euclidean distance: ' + this.getTextNumber(distance2);
            str += '\n' + space + 'max elevation: ' + this.getTextNumber(emax);
            str += '\n' + space + 'min elevation: ' + this.getTextNumber(emin);
            str += '\n' + space + 'elevation difference: ' + this.getTextNumber(emax - emin);

            this.counter++;
        }

        if (this.tool == 3) {
            console.log(JSON.stringify(this.navCoords));

            const geodata = map.createGeodata();
            geodata.addPolygon3(this.navCoords, [], null, 'fix', {}, 'tmp-polygon');
            geodata.processHeights('node-by-lod', 62, (function(){

                space = '  ';

                for (i = 0, li = ('' + this.counter).length; i < li; i++) {
                    space += ' ';
                }

                str = space + '------------------------';

                const poly = geodata.extractGeometry('tmp-polygon');

                const area = poly.getSurfaceArea()

                if (this.metric) {
                    str += '\n' +  space + 'area: ' + area.toFixed(2) + ' m\u00B2';

                    if (area > 100) {
                        str += '\n' +  space + '      ' + (area/100).toFixed(2) + ' ares';
                    }

                    if (area > 10000) {
                        str += '\n' +  space + '      ' + (area/10000).toFixed(2) + ' hectares';
                    }

                    if (area > 1000000) {
                        str += '\n' +  space + '      ' + (area/1000000).toFixed(2) + ' km\u00B2';
                    }
                } else {
                    //str += '\n' +  space + 'area: ' + (area / 0.09290304).toFixed(2) + ' ft²';
                    str += '\n' +  space + 'area: ' + (area / 0.83612736).toFixed(2) + ' yd\u00B2';

                    if ((area / 4046.8564224) >= 1) {
                        str += '\n' +  space + '      ' + (area / 4046.8564224).toFixed(2) + ' acres';
                    }

                    if ((area / 2589988.110346) >= 1) {
                        str += '\n' +  space + '      ' + (area / 2589988.110346).toFixed(2) + ' mi\u00B2';
                    }
                }

                this.counter++;

            }).bind(this));
        }

        if (this.tool == 4) {

            const center = [0,0,0];

            for (i = 0, li = this.navCoords.length; i < li; i++) {
                coords = map.convertCoordsFromNavToPhys(this.navCoords[i], 'fix');
                center[0] += coords[0];
                center[1] += coords[1];
                center[2] += coords[2];
            }

            center[0] /= li;
            center[1] /= li;
            center[2] /= li;

            let radius = 0, dx, dy, dz, distance;

            for (i = 0, li = this.navCoords.length; i < li; i++) {
                coords = map.convertCoordsFromNavToPhys(this.navCoords[i], 'fix');
                dx = (center[0] - coords[0]);
                dy = (center[1] - coords[1]);
                dz = (center[2] - coords[2]);
                distance = Math.sqrt(dx*dx + dy*dy + dz*dz);

                if (distance > radius) {
                    radius = distance;
                }
            }

            const geodata = map.createGeodata();

            if (radius > 30000) {
                geodata.addPolygon3(this.navCoords, [], null, 'fix', {}, 'tmp-polygon');
            } else {
                geodata.addPolygon(this.navCoords, [], null, 'fix', {}, 'tmp-polygon');
            }

            geodata.processHeights('node-by-lod', 62, (function(){

            if (this.navCoords.length) {

                space = '  ';

                for (i = 0, li = ('' + this.counter).length; i < li; i++) {
                    space += ' ';
                }

                str = space + '------------------------';

                const poly = geodata.extractGeometry('tmp-polygon');

                const faces = new Array(poly.getElements());

                for (i = 0, li = faces.length; i < li; i++) {
                    faces[i] = poly.getElement(i);
                }

                const renderer = this.browser.getRenderer();
                let x, north, east;

                coords = map.convertCoordsFromPhysToNav(center, 'fix');

                const texelSize = radius * 0.0030; //0.15 texel size for 100m diameter
                const core = this.browser.getCore();

                const traceVolumeCall = (function(terrain){

                    str = listElement.value;
                    str = str.substr(0, str.lastIndexOf('loading data ...'));
                    str += 'computation progress: 0%';

                    if (!terrain) {
                        str += '\n some error ocurred. Try it again.';
                        return;
                    }

                    const octree = renderer.buildOctreeFromGeometry(terrain);

                    const ned = map.getNED(coords, false);
                    north = ned.direction;
                    east = ned.east;

                    let steps = 25, sx, sy, res2, dir = [0,0,0], delta;
                    let sampleArea = (1.0 / steps) * radius;
                    let volumeAbove = 0;
                    let volumeBelow = 0;

                    sampleArea *= sampleArea;

                    let y = -steps;

                    const traceVolumeLine = (function(){

                        for (x = -steps; x <= steps; x++) {

                            sx = (1.0 / steps) * x * radius;
                            sy = (1.0 / steps) * y * radius;
                            coords[0] = center[0] * 1.0001 + north[0] * sy + east[0] * sx;
                            coords[1] = center[1] * 1.0001 + north[1] * sy + east[1] * sx;
                            coords[2] = center[2] * 1.0001 + north[2] * sy + east[2] * sx;

                            vec3.normalize(coords, dir); // TODO: add support for projected systems
                            dir[0] = -dir[0];
                            dir[1] = -dir[1];
                            dir[2] = -dir[2];

                            res = this.hitFaces(coords, dir, faces);

                            if (res[0]) {
                                res2 = renderer.raycastOctreeGeometry(octree, coords, dir);

                                if (res2.length > 0) {
                                    delta = (res[1] - res2[0]) * sampleArea;

                                    if (delta >= 0) {
                                        volumeAbove += delta;
                                    } else {
                                        volumeBelow += -delta;
                                    }

                                    ///console.log("T" + JSON.stringify(res2));
                                }
                            }
                        }

                        if (y < steps) {
                            str = str.substr(0, str.lastIndexOf('computation progress:'));
                            str += 'computation progress: ' + (((y + steps) / (steps*2))*100).toFixed(1) + ' %';
                        } else {
                            str = str.substr(0, str.lastIndexOf('computation progress:'));

                            if (this.metric) {
                                str += 'volume above: ' + volumeAbove.toFixed(2) + ' m\u00B3';
                                str += '\n' +  space + 'volume below: ' + volumeBelow.toFixed(2) + ' m\u00B3';
                                str += '\n' +  space + 'volume combined: ' + (volumeAbove + volumeBelow).toFixed(2) + ' m\u00B3' + '\n';
                            } else {
                                const yd2m = 0.764554857984;
                                str += 'volume above: ' + (volumeAbove/yd2m).toFixed(2) + ' yd\u00B3';
                                str += '\n' +  space + 'volume below: ' + (volumeBelow/yd2m).toFixed(2) + ' yd\u00B3';
                                str += '\n' +  space + 'volume combined: ' + ((volumeAbove + volumeBelow)/yd2m).toFixed(2) + ' yd\u00B3' + '\n';
                            }
                        }

                        if (str) {
                            listElement.value = str;
                            listElement.scrollTop = listElement.scrollHeight;    //scroll list to the last line
                        }

                        if (y < steps) {
                            core.once('tick', traceVolumeLine, 1);
                        }

                        y++;

                       //console.log("*");
                    }).bind(this);

                    core.once('tick', traceVolumeLine, 1);

                }).bind(this);

                str += '\n' +  space + 'loading data ...';
                listElement.value += str;
                listElement.scrollTop = listElement.scrollHeight;    //scroll list to the last line
                str = null;

                // eslint-disable-next-line
                const destructor = map.getSurfaceAreaGeometry(coords, radius, 'texelSize', texelSize, traceVolumeCall, false);

            }

            }).bind(this));

            this.counter++;
        }
    }

    if (str) {
        listElement.value += str + '\n';
        listElement.scrollTop = listElement.scrollHeight;    //scroll list to the last line
    }

    map.redraw();
};

UIControlMeasure.prototype.hitFace = function(origin, dir, face) {
    const EPSILON = 0.0000001;
    const v1 = face[0];
    const v2 = face[1];
    const v3 = face[2];

    let h = [0,0,0], q = [0,0,0], s;
    let a,f,u,v;
    const edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
    const edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];

    vec3.cross(dir, edge2, h);
    a = vec3.dot(edge1, h);

    if (a > -EPSILON && a < EPSILON) {
        return [false];
    }

    f = 1/a;
    s = [origin[0] - v1[0], origin[1] - v1[1], origin[2] - v1[2]];
    u = f * (vec3.dot(s, h));

    if (u < 0.0 || u > 1.0) {
        return [false];
    }

    q = vec3.cross(s, edge1);
    v = f * vec3.dot(dir, q);
    if (v < 0.0 || u + v > 1.0) {
        return [false];
    }

    // At this stage we can compute t to find out where the intersection point is on the line.
    const t = f * vec3.dot(edge2, q);
    //if (t > EPSILON) { // ray intersection
        return [true, t]; //[origin[0] + dir[0] * t, origin[1] + dir[1] * t, origin[2] + dir[2] * t ]];
    //} else { // This means that there is a line intersection but not a ray intersection.
     //   return [false];
    //}
};


UIControlMeasure.prototype.hitFaces = function(coords, dir, faces) {
    let hit = false, t = Number.POSITIVE_INFINITY;

    for (let i = 0, li = faces.length; i < li; i++) {
        const res = this.hitFace(coords, dir, faces[i]);

        if (res[0]) {
            hit = true;

            if (res[1] < t) {
                t = res[1];
            }
        }
    }

    //console.log(hit ? ("" + t.toFixed(2)) : ("N"));
    return [hit, t];
};


UIControlMeasure.prototype.onClear = function() {
    this.counter = 1;
    this.lastCoords = null;
    this.navCoords = null;

    const listElement = this.list.getElement();
    listElement.value = '';
    listElement.scrollTop = 0;

    this.compute.setStyle('display', 'none');

    const map = this.browser.getMap();
    if (map) {
        map.redraw();
    }
};


UIControlMeasure.prototype.update = function() {
    const left = 10 + (this.ui.config.controlZoom ? 70 : 0) +
                 (this.ui.config.controlSpace ? 35 : 0);

    this.div.setStyle('left', left + 'px');
    this.listPanel.setStyle('display', this.measuring ? 'block' : 'none');
};


UIControlMeasure.prototype.onMapUpdate = function() {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    const renderer = this.browser.getRenderer();

    if (!this.circleImage) {
        this.circleImage = utils.loadImage(
                'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QAAAAAAAD5Q7t/AAAACW9GRnMAAAAgAAAA4ACD+EAUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/UlEQVRYw+2VPwqDMBTG3dz1Am56EnH2XLroETxGuwc3Z7cOdhY8QJpfSUBspUvStJAPPggvD973/uQligICAgL+DKViqygUV02hbaXLwJlio7gpyhNu2idzEXwwgfI8H+u6vnZdN/V9P3EuimLcCRlsiyArGcfxjWDLsmzyAGzc4aNFNDZ7/iw7AeQH4LNrh5WZYLgkJTaZCyHuVVVdkiSZ0zSdOWMzlaBFWkRrQ4A4Zk/A4wBie1MFYUMAz0wybCYAmR8FUAlzj6+2r18TgM2VAO8tOB1Cyk7mrofQ+zP0voheVjHtIBjDxjrmvCu7k1Xs/TP6ie84ICDAGR5uCYdPo0MWiAAAAABJRU5ErkJggg==',
                //"http://maps.google.com/mapfiles/kml/shapes/placemarkcircle.png",
                (function(){
                    this.circleTexture = renderer.createTexture({ 'source': this.circleImage });
                }).bind(this)
            );
    }

    if (!this.circleTexture) {
        return;
    }

    let i, li, coords, points;

    switch(this.tool) {
        case 0: //point

            if (this.navCoords) {
                coords = map.convertCoordsFromNavToCanvas(this.navCoords, "fix");

                if (coords[2] <= 1) {
                    renderer.drawImage({
                        rect : [coords[0]-12, coords[1]-12, 24, 24],
                        texture : this.circleTexture,
                        color : [255,0,0,255],  //white point is multiplied by red color so resulting point will be red
                        depth : coords[2],
                        depthTest : false,
                        blend : true   //point texture has alpha channel so blend is needed
                        });
                }
            }

            break;

        case 1: //line
        case 2: //track
        case 3: //area
        case 4: //volume

            if (this.navCoords) {
                points = [];

                for (i = 0, li = this.navCoords.length; i < li; i++) {
                    points.push(map.convertCoordsFromNavToCanvas(this.navCoords[i], "fix"));
                }

                if (li > 1) {

                    let points2 = [], points3 = [], tmp;

                    for (i = 0, li = this.navCoords.length - 1; i < li; i++) {
                        tmp = map.getGeodesicLinePoints(this.navCoords[i], this.navCoords[i+1]);
                        points2 = points2.concat(tmp);
                    }

                    if (this.tool == 3 || this.tool == 4) {
                        tmp = map.getGeodesicLinePoints(this.navCoords[li], this.navCoords[0]);
                        points2 = points2.concat(tmp);
                    }

                    for (i = 0, li = points2.length; i < li; i++) {
                        points3.push(map.convertCoordsFromNavToPhys(points2[i], "fix", null, true));
                    }

                    renderer.drawLineString({
                        points : points3,
                        size : 5.0,
                        color : [0,0,0,255],
                        depthTest : false,
                        //depthTest : true,
                        //depthOffset : [-0.01,0,0],
                        screenSpace : false,
                        blend : false
                        });

                    renderer.drawLineString({
                        points : points3,
                        size : 2.0,
                        color : [255,0,0,255],
                        depthTest : false,
                        //depthTest : true,
                        //depthOffset : [-0.01,0,0],
                        screenSpace : false,
                        blend : false
                        });
                }

                for (i = 0, li = points.length; i < li; i++) {
                    coords = points[i];

                    if (coords[2] <= 1) {
                        renderer.drawImage({
                            rect : [coords[0]-12, coords[1]-12, 24, 24],
                            texture : this.circleTexture,
                            color : [255,0,0,255],  //white point is multiplied by red color so resulting point will be red
                            depth : coords[2],
                            depthTest : false,
                            blend : true   //point texture has alpha channel so blend is needed
                            });
                    }
                }
            }


    }


    if ((this.tool == 2 || this.tool == 3 || this.tool == 4) && points) {
        if (points.length < 2 || this.renderCounter != this.counter) {
            this.compute.setStyle('display', 'none');
            return;
        }

        coords = points[points.length - 1];
        coords[0] -= this.divRect.left;
        coords[1] -= this.divRect.top;

        this.compute.setStyle('display', 'block');
        this.compute.setStyle('left', (coords[0]+20)+'px');
        this.compute.setStyle('top', (coords[1]+10)+'px');
    }

};

UIControlMeasure.prototype.getTextNumber = function(value) {
    const m2ft = 3.28084, km2mi = 0.621371;

    if (value >= 100000) {
        return (this.metric) ? (value*0.001).toFixed(2) + 'km' : (value*0.001*km2mi).toFixed(2) + 'mi';
    } else {
        return (this.metric) ? (value).toFixed(2) + 'm' : (value*m2ft).toFixed(2) + 'ft';
    }
};




/***/ }),

/***/ "./src/browser/ui/control/popup.js":
/*!*****************************************!*\
  !*** ./src/browser/ui/control/popup.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const UIControlPopup = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('popup',
        '<div class="vts-popup-background" id="vts-popup-background">'
      +    '<div id="vts-popup"</div>'
      + '</div>', visible, visibleLock);

    this.lastHTML = '';
    this.popup = this.control.getElement('vts-popup');
    this.background = this.control.getElement('vts-popup-background');
    this.background.on('click', this.hide.bind(this));
};


UIControlPopup.prototype.show = function(style, html) {
    this.control.setVisible(true);

    for (let key in style) {
        this.popup.setStyle(key, style[key]);
    }

    this.popup.setHtml(html);
};


UIControlPopup.prototype.hide = function() {
    this.control.setVisible(false);
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlPopup);


/***/ }),

/***/ "./src/browser/ui/control/search-filter.js":
/*!*************************************************!*\
  !*** ./src/browser/ui/control/search-filter.js ***!
  \*************************************************/
/*! exports provided: filterSearch, nofilterSearch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterSearch", function() { return filterSearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nofilterSearch", function() { return nofilterSearch; });
/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/utils/math */ "./src/core/utils/math.js");



//get rid of compiler mess
const math = _core_utils_math__WEBPACK_IMPORTED_MODULE_0__["math"];

// Deduplication of hits, that have the same display_name
// and are subsequent in a result set.
function dedupe(hits) {
    let hit, result = [], dupes = [];

    // Helper function, that takes set of duplicities
    // and returns just one hit.
    //
    // we return first populated place  - if exist
    // or if not exist we return just first one
    const filterHits = (function(dupes){
        for (let j = 0; j < dupes.length; j++) {
            switch (dupes[j].type) {
                case 'hamlet':
                case 'village':
                case 'town':
                case 'city':
                    return dupes[j];
            }
        }

        return dupes[0];
    });

    // We go through all hits and separate results
    // and duplicities
    for (let i = 0; i < hits.length - 1; i++) {
        hit = hits[i];

        if (hit.display_name === hits[ i + 1 ].display_name) {
            dupes.push(hit);
        } else {
            if (dupes.length > 0) {
                dupes.push(hit);
                result.push(filterHits(dupes));
                dupes.length = 0;
            } else {
                result.push(hit);
            }
        }
    }

    // Make sure filterHits is called
    if (dupes.length) {
        result.push(filterHits(dupes));
    }

    return result;
}

function getDistance(lon1, lat1, lon2, lat2) {
    const r = 6371e3; // metres
    const l1 = math.radians(lat1);
    const l2 = math.radians(lat2);
    const dlat = math.radians(lat2-lat1);
    const dlon = math.radians(lon2-lon1);

    const a = Math.sin(dlat/2) * Math.sin(dlat/2) +
              Math.cos(l1) * Math.cos(l2) *
              Math.sin(dlon/2) * Math.sin(dlon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return r * c;
}

// Stupid unprecise comparsion of two points, if
// they lay close to each other (less than 10km)
function layClose(A, B) {
    //return ruler.distance([ A.lon, A.lat ], [ B.lon, B.lat ] ) < 10
    const diff = 0.1;

    return ( +B.lat > +A.lat - diff ) && ( +B.lat < +A.lat + diff )
        && ( +B.lon > +A.lon - diff ) && ( +B.lon < +A.lon + diff );
}

// Hits with low importance can be reshaked by its distance
function reshakeHits(hits) {
    const maxDiff = 0.06;
    const maxRank = 0.4;
    let temp, done;

    do {
        done = true;

        for (let i = 0; i < hits.length - 1; i++ ) {
            const h1 = hits[i];
            const h2 = hits[i + 1];

            if (( h1.rank < maxRank && h2.rank < maxRank ) // both hits have lowRank
                && ( Math.abs( h1.rank - h2.rank ) < maxDiff ) // ...and diff in their rank is small
                && ( h1.distance > h2.distance ) // ...and h1 has bigger distance
                ) {

                // Switch both hits
                h1.note = 'reshaked-down'
                h2.note = 'reshaked-up'

                temp = h1;
                hits[i] = h2;
                hits[i + 1] = temp;
                done = false;
            }
        }
    } while (!done);
}

function nofilterSearch(data, lon, lat) {
    const rtrn = [];
    const hits = data;
    const hasLocation = lat && lon;
    let rtrnHit, hit;

    //Cycle each hit and reduce uts size
    for (let i = 0; i < hits.length; i++) {
        hit = hits[i];

        rtrnHit = {
            lat: +hit['lat'],
            lon: +hit['lon'],
            title: hit['title'],
            rank: 1, //hit.importance || 1,
            country: hit['country'],
            region: hit['region'],
            state: hit['state'],
            cc: '',
            type: '',
            bounds: null, //hit.boundingbox,
            polygon : [],
            bbox : null //hit.boundingbox
        }

        // Calculate distance
        if (hasLocation) {
            rtrnHit.distance = getDistance(lon, lat, rtrnHit.lon, rtrnHit.lat);
        }

        rtrn.push(rtrnHit);
    }

    return rtrn;
}

// Return Promise, that resolves nice deduplicated results from
// Nominatim (on particular keyword)
function filterSearch(data, lon, lat) {
    const rtrn = [];
    const hasLocation = lat && lon;
    let hits = data;

    /*
    // Should we search ZIP code?
    const querySubString = ( /^\d{3,5}$/.test( query ) ) ?
                            `postalcode=${  query }` : `q=${ encodeURIComponent( query ) }`

    const url = `${ searchServer }search.php?format=json&limit=20&addressdetails=1&${ querySubString }&accept-language=${lang}`;

    if( program.dev ) log.info(url);
    */

    let rtrnHit, hit, adr, region, county, display, bounds;

    // Deduplication number 1: Deduplicate consequent
    // results with same name
    if( hits.length > 1) {
        hits = dedupe( hits );
    }

    //Cycle each hit and reduce uts size
    for (let i = 0; i < hits.length; i++) {

        // Shortcuts
        hit = hits[i];

        bounds = hit.boundingbox;

        adr = hit.address;

        display = hit.display_name.replace(/,.*/,'');

        region = adr.state && adr.state
                    || ( adr.state_district && adr.state_district ||
                            ( adr.county && adr.county || '' ) );

        county = adr.county && adr.county
                    || ( adr.state_district && adr.state_district || region );

        // If county is same as title, find
        // something better
        if (county === display) {
            county = adr.state_district && adr.state_district || region;
        }

        // Deduplication number 2: Simple process of throwing away hits
        // that have lower importance, and lay in vicinity
        // of previous hit
        if (rtrnHit && layClose(rtrnHit, hit)) continue;

        // Filter out results with low, low low importance
        // but only if there is more results
        if (hit.importance < 0.01 && i > 5) continue;

        // Rewrite these types of regions
        // "Graubünden - Grigioni - Grischun" --> "Graubunder"
        if (new RegExp(/ - /).test( region )) {
            region = region.replace(/ -.*/,'');
        }

        // Should we display bounds instead of dot in a map?
        if (hit.type === 'archipelago'  ||
            ( hit.type === 'administrative' &&
            (display === adr.country || display === region ))) {

            // Repair undefined lon values in bounds
            if( bounds[2] === '-180' ) {
                bounds[2] = bounds[3] = hit.lon;
            }

        } else {
            bounds = null;
        }

        // Changes display name in adress querries like "Kopeckeho 27"
        if (display === adr.house_number && adr.road ) {
            display = adr.road;
        }

        rtrnHit = {
            lat: +hit.lat,
            lon: +hit.lon,
            title: display,

            rank: hit.importance,

            // for US we use State as country
            country: adr.country_code === 'us' ? region : ( adr.country && adr.country.replace(/,.*/,'')  ),

            display: hit.display_name,
            region: county || '',
            state: region || '',
            cc: adr.country_code,
            type: hit.type,
            bounds: bounds,
            polygon : hit.polygonpoints || [],
            bbox : hit.boundingbox
        }

        // Calculate distance
        if (hasLocation) {
            rtrnHit.distance = getDistance(lon, lat, rtrnHit.lon, rtrnHit.lat);
        }


        rtrn.push(rtrnHit)
    }

    // Reshake hits by distance
    if (hasLocation) {
        reshakeHits(rtrn);
    }

    return rtrn;
}

// return query on reverse search
/*
function geoSearch = ( { lat,lon,zoom,lang } ) => {
    const url = `${ searchServer }reverse.php?format=json&lat=${ lat }&lon=${ lon }&zoom=${ zoom }&addressdetails=1&accept-language=${ lang }`
    return rp.get(url,{ timeout: 3000, json: true })
}
*/




/***/ }),

/***/ "./src/browser/ui/control/search.js":
/*!******************************************!*\
  !*** ./src/browser/ui/control/search.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utility/dom */ "./src/browser/utility/dom.js");
/* harmony import */ var _core_utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _search_filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./search-filter */ "./src/browser/ui/control/search-filter.js");
/* harmony import */ var _core_utils_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/utils/math */ "./src/core/utils/math.js");







//get rid of compiler mess
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_0__["default"];
const vec3 = _core_utils_matrix__WEBPACK_IMPORTED_MODULE_3__["vec3"];
const math = _core_utils_math__WEBPACK_IMPORTED_MODULE_4__["math"];
const utils = _core_utils_utils__WEBPACK_IMPORTED_MODULE_1__["utils"];
const filterSearch = _search_filter__WEBPACK_IMPORTED_MODULE_2__["filterSearch"];
const nofilterSearch = _search_filter__WEBPACK_IMPORTED_MODULE_2__["nofilterSearch"];

const UIControlSearch = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;

    let element = this.browser.config.controlSearchElement;
    if (element) {
        if (typeof element === 'string') {
            element = document.getElementById(element);
        }
    }

    this.control = this.ui.addControl('search',
      '<div class="vts-search">'
      + '<div class="vts-search-input"><input type="text" id="vts-search-input" autocomplete="off" spellcheck="false" placeholder="Search location..."></div>'
      + '<div id="vts-search-list" class="vts-search-list"></div>'
      + '</div>', visible, visibleLock, element);

    this.input = this.control.getElement('vts-search-input');

    //this.input.on("change", this.onChange.bind(this));
    this.input.on('input', this.onChange.bind(this));
    this.input.on('keydown', this.onKeyUp.bind(this));
    this.input.on('focus', this.onFocus.bind(this));
    this.input.on('mousedown', this.onDrag2.bind(this));
    this.input.on('mousewheel', this.onDrag.bind(this));
    this.input.on('dblclick', this.onDoNothing.bind(this));

    this.list = this.control.getElement('vts-search-list');
    this.list.on('mousedown', this.onDrag2.bind(this));
    this.list.on('mousewheel', this.onDrag.bind(this));

    this.mapControl = this.ui.getMapControl();
    this.mapElement = this.mapControl.getMapElement();
    this.mapElement.on('mousedown', this.onDrag.bind(this), window);
    this.mapElement.on('mousewheel', this.onDrag.bind(this), window);

    this.ignoreDrag = false;

    //old template '//cdn.melown.com/vtsapi/geocode?q={value}&format=json&lang=en-US&addressdetails=1&limit=20';
    //this.urlTemplate = '//cdn.melown.com/vtsapi/geocode/v3.0/{lat}/{long}/{value}';
    //this.urlTemplate = '//node.windy.com/search/v3.0/{lat}/{long}/{value}';
    this.urlTemplate = '//cdn.melown.com/vtsapi/geocode/v3.0/{lat}/{long}/{value}';
    this.urlTemplate2 = this.urlTemplate;
    this.data = [];
    this.lastSearch = '';
    this.itemIndex = -1;
    this.searchCounter = 0;
    this.coordsSrs = '+proj=longlat +datum=WGS84 +nodefs';

    this.initialValueUsed = false;

    if (this.browser.config.controlSearchValue) {
        this.initialValueUsed = true;
        this.input.getElement().value = this.browser.config.controlSearchValue;
        this.onChange();
    }
};


UIControlSearch.prototype.onDoNothing = function(event) {
    dom.preventDefault(event);
    dom.stopPropagation(event);
};


UIControlSearch.prototype.processTemplate = function(str, obj) {
    return str.replace(/\{([$a-zA-Z0-9][$a-zA-Z0-9]*)\}/g, function(s, match) {
        return (match in obj ? obj[match] : s);
    });
};


UIControlSearch.prototype.showList = function() {
    this.list.setStyle('display', 'block');
};


UIControlSearch.prototype.hideList = function() {
    //this.data = {};
    this.list.setStyle('display', 'none');
};


UIControlSearch.prototype.moveSelector = function(delta) {
    //this.data = {};
    this.itemIndex += delta;

    if (this.itemIndex >= this.data.length) {
        this.itemIndex = this.data.length - 1;
    }

    if (this.itemIndex < 0) {
        this.itemIndex = 0;
    }

    this.updateList(this.data);
};


UIControlSearch.prototype.updateList = function(json) {
    if (Array.isArray(json)) {
        let data = json, item, list = '';
        data = data.slice(0,10);
        this.data = data;

        for (let i = 0, li = data.length; i < li; i++) {
            item = data[i];

            let title = '';

            if (this.coords && i == 0) {
                title = 'location: ';
            }

            title += item['title'] + '<small>';

            if (item['region'] && item['title'] != item['region']) {
                title += ', ' + item['region'];
            }

            if (item['country'] && item['title'] != item['country'] && item['region'] != item['country']) {
                title += (item['region'] ? ', ' : '') + item['country'];
            }

            title += '</small>';

            if (this.itemIndex == i) {
                list += '<div id="vts-search-item' + i + '"'+ ' class="vts-search-listitem-selected">' + title + '</div>';
            } else {
                list += '<div id="vts-search-item' + i + '"'+ ' class="vts-search-listitem">' + title + '</div>';
            }

        }

        this.list.setHtml(list);

        for (let i = 0, li = data.length; i < li; i++) {
            const id = 'vts-search-item' + i;
            item = this.control.getElement(id);

            if (item) {
                item.on('click', this.onSelectItem.bind(this, i));
                item.on('mouseenter', this.onHoverItem.bind(this, i));
            }
        }

        if (!this.initialValueUsed) {
            this.showList();
        }
    } else {
        this.hideList();
    }
};

UIControlSearch.prototype.solveSRS = function(srs) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    if (srs.indexOf('+proj=') == -1) { //no proj4 string
        srs = map.getSrsInfo(srs);
        if (srs && srs['srsDef']) {
            srs = srs['srsDef'];
        } else {
            srs = this.coordsSrs;
        }
    }

    return srs;
};

UIControlSearch.prototype.onSelectItem = function(index) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    //sort list with polygons
    let pos = map.getPosition();
    const refFrame = map.getReferenceFrame();
    const navigationSrsId = refFrame['navigationSrs'];
    const navigationSrs = map.getSrsInfo(navigationSrsId);
    const physicalSrsId = refFrame['physicalSrs'];
    const physicalSrs = map.getSrsInfo(physicalSrsId);

    const proj4 = this.browser.getProj4();
    let srs = this.browser.config.controlSearchSrs || this.coordsSrs;
    srs = this.solveSRS(srs);

    let coords = proj4(navigationSrs['srsDef'], srs, pos.getCoords());

    pos = map.convertPositionHeightMode(pos, "float", true);

    const item = this.data[index];
    if (item) {
        coords = [item['lon'], item['lat']];

        //conver coords from location srs to map navigation srs
        coords = proj4(srs, navigationSrs['srsDef'], coords);
        coords[2] = 0;

        pos.setCoords(coords);

        let viewExtent = 6667;

        if (item.bbox) {
            const lat1 = parseFloat(item.bbox[0]);
            const lat2 = parseFloat(item.bbox[1]);
            const lon1 = parseFloat(item.bbox[2]);
            const lon2 = parseFloat(item.bbox[3]);

            item.polygon = [
                [lon1, lat1], [(lon2+lon1)*0.5, lat1], [lon2, lat1],
                [lon1, (lat2+lat1)*0.5],  [lon2, (lat2+lat1)*0.5],
                [lon1, lat2], [(lon2+lon1)*0.5, lat2], [lon2, lat2]
            ];
        }

        if (item.polygon && item.type != 'continent') {
            const points = item.polygon;

            //convert point to physical coords
            const cameraPosition = proj4(srs, physicalSrs['srsDef'], coords);
            const cameraVector = [-cameraPosition[0], -cameraPosition[1], -cameraPosition[2]];
            vec3.normalize(cameraVector);

            for (let i = 0, li = points.length; i < li; i++) {
                //convert point to physical coords
                coords = proj4(srs, physicalSrs['srsDef'], [points[i][0], points[i][1], 0]);

                const ab = cameraVector;
                const av = [coords[0] - cameraPosition[0], coords[1] - cameraPosition[1], coords[2] - cameraPosition[2]];

                //final R3 bv  = v.sub( b ) ;
                const b = [cameraPosition[0] + cameraVector[0], cameraPosition[1] + cameraVector[1], cameraPosition[2] + cameraVector[2]];
                const bv = [coords[0] - b[0], coords[1] - b[1], coords[2] - b[2]];

                const af = [0,0,0];
                vec3.cross(ab, av, af);

                const d = (vec3.length(bv) / vec3.length(ab)) * 2;

                if (d > viewExtent) {
                    viewExtent = d;
                }
            }

            if (navigationSrs['type'] != 'projected') {
                if (viewExtent > navigationSrs['a']*1.4) {
                    viewExtent = navigationSrs['a']*1.4;
                }
            }
        } else {
            //try to guess view extent from location type
            switch(item.type) {
            case 'peak':        viewExtent = 20000;   break;
            case 'city':        viewExtent = 30000;   break;
            case 'street':      viewExtent = 4000;    break;
            case 'residential': viewExtent = 3000;    break;
            case 'continent':   viewExtent = 8550000; break;
            case 'pos':         viewExtent = 150000;  break;
            }
        }

        pos.setViewExtent(viewExtent);

        let orientation = [0,-60,0];

        //reduce tilt when you are far off the planet
        if (pos.getViewMode() == 'obj') {
            if (navigationSrs['a']) {
                const distance = (pos.getViewExtent()*0.5) / Math.tan(math.radians(pos.getFov()*0.5));
                const factor = Math.min(distance / (navigationSrs['a']*0.5), 1.0);
                const maxTilt = 20 + ((-90) - 20) * factor;
                const minTilt = -90;

                if (orientation[1] > maxTilt) {
                    orientation[1] = maxTilt;
                }

                if (orientation[1] < minTilt) {
                    orientation[1] = minTilt;
                }
            }
        }

        pos.setOrientation(orientation);
        map.setPosition(pos);

        this.itemIndex = index;
        this.lastSearch = item['title'];

        const element = this.input.getElement();
        element.value = this.lastSearch;
        element.blur(); //defocus
    }

    this.hideList();
};


UIControlSearch.prototype.onHoverItem = function(index) {
    if (this.itemIndex == index) {
        return;
    }

    this.itemIndex = index;
    this.updateList(this.data);
};


UIControlSearch.prototype.onListLoaded = function(counter, data) {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    if (this.searchCounter == counter) {

        const pos = map.getPosition();
        const refFrame = map.getReferenceFrame();
        const navigationSrsId = refFrame['navigationSrs'];
        const navigationSrs = map.getSrsInfo(navigationSrsId);

        const proj4 = this.browser.getProj4();
        let srs = this.browser.config.controlSearchSrs || this.coordsSrs;
        srs = this.solveSRS(srs);

        const coords = proj4(navigationSrs['srsDef'], srs, pos.getCoords());

        //check data format
        if (!(data['data'] && Array.isArray(data['data']) && data['header'] && data['header']['type'] == 'search')) {
            return;
        }

        if (this.browser.config.controlSearchFilter) {
            data = filterSearch(data['data'], coords[0], coords[1]);
        } else {
            data = nofilterSearch(data['data'], coords[0], coords[1]);
        }

        if (this.coords) {
            data.unshift({
                'title' : ('' + this.coords[0].toFixed(6) + ' ' + this.coords[1].toFixed(6)),
                'lat' : this.coords[0],
                'lon' : this.coords[1],
                'type': 'pos'
            });
        }

        this.updateList(data);
    }
};


UIControlSearch.prototype.onListLoadError = function() {
};


UIControlSearch.prototype.onFocus = function() {
    this.lastSearch = '';
    const element = this.input.getElement();
    element.value = this.lastSearch;
    this.hideList();
};


UIControlSearch.prototype.onKeyPress = function(event) {
    //console.log('press');

    this.onKeyUp(event);
};


UIControlSearch.prototype.onKeyUp = function(event) {
    const code = event.getKeyCode();

    switch(code) {
    case 38:  //up
        this.moveSelector(-1);
        dom.preventDefault(event);
        dom.stopPropagation(event);
        break;

    case 40:  //down
        this.moveSelector(1);
        dom.preventDefault(event);
        dom.stopPropagation(event);
        break;

    case 9:  //tab
    case 13: //enter

        this.onSelectItem(Math.max(0,this.itemIndex), null);
        break;
    }
};


UIControlSearch.prototype.parseLatLon = function(value) {
    if (value.replace(/\d+/, '') == value) {
        return null;
    }

    value = value.replace(',',' ');
    value = (value.replace(/  +/g, ' ')).trim().toLowerCase();
    let words = value.split(' '), lat, lon, i;
    let lastChar, lastChar2, skip, part, numbers, num;

    //simple case of two numbers
    if (words.length == 2 && value.indexOf('n') == -1 && value.indexOf('s') == -1 &&
        value.indexOf('w') == -1 && value.indexOf('e') == -1 ) {

        lastChar = words[0].charAt(words[0].length - 1);
        lastChar2 = words[1].charAt(words[1].length - 1);
        skip = false;

        //are numbers in degrees?
        if (lastChar == '°' || lastChar == "'" || lastChar == '"') {
            if (lastChar2 == '°' || lastChar2 == "'" || lastChar2 == '"') {
                words[0] = words[0] + 'n';
                words[1] = words[1] + 'e';
                value = words.join();
            }
        }

        if (!skip) {
            if (!isNaN(words[0]) && !isNaN(words[1])) {
                lat = parseFloat(words[0]);
                lon = parseFloat(words[1]);

                if (!isNaN(lat) && !isNaN(lon)) {

                    if (lat > 90 || lat < -90) {
                        return null;
                    }

                    if (lon > 360 || lon < -360) {
                        return null;
                    }

                    return[lat, lon];
                }
            }
        }

       return null;
    }

    const parts = value.split(/[°'"]+/).join(' ').split(/[^\w\S]+/);

    //check wheteher it make sence to pase it further
    lat = 0, lon = 0, numbers = 0;

    let lengthCheck = false;

    for (i in parts) {
        part = parts[i];

        if (isNaN(part)) {
            num = parseFloat(part);
            lengthCheck = true;
            lastChar = part.charAt(part.length - 1);

            if (!isNaN(num)) {
                numbers++;
                lengthCheck = false;
            }

            if (!lengthCheck || (part.length == 1)) {
                if (lastChar == 'w' || lastChar == 'e') {
                    lat++;
                }

                if (lastChar == 'n' || lastChar == 's') {
                    lon++;
                }
            }

        } else {
            // eslint-disable-next-line
            numbers++;
        }
    }

    if (!(lat == 1 && lon ==1)) {
        return null;
    }

    // parse complex lat lon in degrees with directions
    let directions = [];
    let coords = [];
    let dd = 0;
    let pow = 0;
    let numberCount = 0;

    for (i in parts) {

        // we end on a direction
        if (isNaN(parts[i])) {
            let direction = parts[i];
            num = parseFloat(parts[i]);

            if (!isNaN(num)) {
                dd += ( num / Math.pow( 60, pow++ ) );
                direction = parts[i].replace( num, '' );
                numberCount++;
            }

            direction = direction[0];

            if (direction == 's' || direction == 'w') {
                dd *= -1;
            }

            directions[directions.length] = direction;
            coords[coords.length] = dd;
            dd = pow = 0;

        } else {
            num = parseFloat(parts[i]);

            if (!isNaN(num)) {
                dd += ( num / Math.pow( 60, pow++ ) );
                numberCount++;
            }
        }
    }

    if (coords.length != 2 || numberCount < 2 || isNaN(coords[0]) || isNaN(coords[1])) {
        return null;
    }

    if (directions[0] == 'w' || directions[0] == 'e') {
        const tmp = coords[0];
        coords[0] = coords[1];
        coords[1] = tmp;
    }

    if (coords[0] > 90 || coords[0] < -90) {
        return null;
    }

    if (coords[1] > 360 || coords[1] < -360) {
        return null;
    }

    return coords;
}

UIControlSearch.prototype.onChange = function() {
    let value = this.input.getElement().value;
    value = value.trim();

    //console.log("value: " + value + "  last-value: " + this.lastSearch);

    if (value == this.lastSearch) {
        //console.log("value-same");
        return;
    }

    this.lastSearch = value;

    if (value == '') {
        //console.log("value-null");
        this.hideList();
    }

    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    //sort list with polygons
    const pos = map.getPosition();
    const refFrame = map.getReferenceFrame();
    const navigationSrsId = refFrame['navigationSrs'];
    const navigationSrs = map.getSrsInfo(navigationSrsId);
    const proj4 = this.browser.getProj4();
    let srs = this.browser.config.controlSearchSrs || this.coordsSrs;
    srs = this.solveSRS(srs);

    const coords = proj4(navigationSrs['srsDef'], srs, pos.getCoords());


    this.coords = this.parseLatLon(value);

    const url = this.processTemplate(this.browser.config.controlSearchUrl || this.urlTemplate, { 'value':value, 'lat':coords[1], 'long':coords[0] });
    //console.log(url);
    this.searchCounter++;
    this.itemIndex = -1;

    utils.loadJSON(url, this.onListLoaded.bind(this, this.searchCounter), this.onListLoadError.bind(this));
};


UIControlSearch.prototype.onDrag2 = function() {
    this.ignoreDrag = true;
};


UIControlSearch.prototype.onDrag = function() {
    if (this.ignoreDrag) {
        this.ignoreDrag = false;
        return;
    }

    const element = this.input.getElement();
    element.value = this.lastSearch;
    element.blur(); //defocus'
    this.hideList();
};


UIControlSearch.prototype.update = function() {
    if (this.initialValueUsed && this.browser.mapLoaded) {
        this.initialValueUsed = false;
        this.onSelectItem(0);
    }
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlSearch);


/***/ }),

/***/ "./src/browser/ui/control/space.js":
/*!*****************************************!*\
  !*** ./src/browser/ui/control/space.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utility/dom */ "./src/browser/utility/dom.js");
/* harmony import */ var _control_mode_map_observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../control-mode/map-observer */ "./src/browser/control-mode/map-observer.js");




//get rid of compiler mess
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_0__["default"];
const constrainMapPosition = _control_mode_map_observer__WEBPACK_IMPORTED_MODULE_1__["constrainMapPosition"];


const UIControlSpace = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('space',
      '<div id="vts-space"'
      + ' class="vts-space">'

        + '<img id="vts-space-2d"'
          + ' class="vts-space-button"'
          + ' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAABqElEQVRIx+2UsWoUURSGv3Nn1sIiaKMBSbD0AdRBdmbdB7DMA0gaSSVRbFRYiGAaUWJhEAQVEey10yacO/gAwqZNSKWwhShs4ew9NtewTDI6sRCE/at7h8P/nfnvuRdmmum/lkxvut1u5pwbAOfNrAMMzWy9LMt3v2qKorCaRwC+A9vApqq+bITkeX4Z+CAiab3IzJa9988bIPXaR977G9Pf3NT6joikZvYmSZL5JElOAPcBRORu3UxVRVVlNBodCyEsmtkAMBFZjQ3va79rETluZl+rqrrpvf8c41t3zt0GFpo6Hw6HP4A9YK0oinlgRUSuAVsHIKqaH8hSJIsR7LQ54KqqNtI0XTGzS01xURuCBeBZhD1pAzGz3Vh/+o+QXq93zjnnReSsmb1W1Y0jTm3yW0ie5xdDCB5YNLMX4/H4KmAtzc/EP/py6MHH8bwAvAfmgDXv/eAo7Xc6nSsxro+HQrIsO2Vmb0VkDrilqg9aert+v39yMpksAfciZLPpMj4UkdUmJ1WVNpcReKyq15viWvrLp8mAb8CnEMLTsixfzV7rmf6dfgKmzKAWE7bqxgAAAABJRU5ErkJggg==">'

        + '<img id="vts-space-3d"'
          + ' class="vts-space-button"'
          + ' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAB8klEQVRIx+1Uv4sTQRT+3mRygyDInYXFabaxsRNOIiG7mEPQxsJCLQVF8AeiaCNWigrWiniCVfA/0Eo4ONnZ4P4FURAL9yyCEMQfRMzs7LOZk2HZxNgIQr7qzbw373t838wAc8zxX4P8RbvdPimEuMLM+4loAcAmM3eTJLkHgAEgiiIu9SgAfAfwBsCa1rpbJqltBWEYXhBCdAE0HEENwBIRrQZBQFmWvQKAIAhuVwyqAOwGcLzRaOzIsuylXyB+VxKdc+FTY8yyMWZbURSn3N7l8nRaa9Ja03A4XCiKosHMtwAwEV0Lw/BQJYnW+oAxZu9oNLqUpulASrmdiPa49GCS3v1+3/R6vc0kSe4AeOIGPu/XSH+Rpul7J906ER0GAGYeADgzi8F5nj+QUl5k5tZEEk+6fV6sfO+mgZk/uDO7KuUqYcUYswTgGYBFAPf/8tbW/kiitR6kafqZma+7CVdmbL7s6j9VyhVF0QtmbuV5fnDLm/F4rJRSICKehaFerx9zcr2uJGHmn0S0U0r5uNlsnlVKWQCPXG5jSm/R6XQWrbUnANx1JGuTjL/JzEeJ6IhS6qNH/kUIcaPc2X/51lo/9TCO441KT5IkeWetXQWwDuAHgG/M/BxAK47jt9MuFYCvAHpFUZzWWl+d/9Zz/Dv8ApJPyD0fWCwOAAAAAElFTkSuQmCC">'

     + ' </div>', visible, visibleLock);

    this.button2D = this.control.getElement('vts-space-2d');
    this.button2D.on('click', this.onSwitch.bind(this));
    this.button2D.on('dblclick', this.onDoNothing.bind(this));

    this.button3D = this.control.getElement('vts-space-3d');
    this.button3D.on('click', this.onSwitch.bind(this));
    this.button3D.on('dblclick', this.onDoNothing.bind(this));

    this.space3D = true;
    this.display3D = this.space3D;

    if (this.space3D) {
        this.button2D.setStyle('display', 'block');
        this.button3D.setStyle('display', 'none');
    } else {
        this.button2D.setStyle('display', 'none');
        this.button3D.setStyle('display', 'block');
    }
};


UIControlSpace.prototype.onDoNothing = function(event) {
    dom.stopPropagation(event);
};


UIControlSpace.prototype.onSwitch = function() {
    this.space3D = !this.space3D;

    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    if (this.browser.autopilot) { //stop autorotation
        this.browser.autopilot.setAutorotate(0);
        this.browser.autopilot.setAutopan(0,0);
    }

    let pos = map.getPosition();
    let orientation = pos.getOrientation();

    if (this.space3D) {
        orientation[0] = 45;
        orientation[1] = -60;
        //pos = map.setPositionFov(pos, 90);
        pos.setOrientation(orientation);
    } else {
        orientation[0] = 0;
        orientation[1] = -90;
        //pos = map.setPositionFov(pos, 5);
        pos.setOrientation(orientation);
    }

    pos = constrainMapPosition(this.browser, pos);
    map.setPosition(pos);

    this.update();
};


UIControlSpace.prototype.update = function() {
    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    const pos = map.getPosition();
    const orientation = pos.getOrientation();

    const space3D = (Math.abs(orientation[1]+90) > 0.1);

    if (space3D != this.display3D) {
        if (space3D) {
            this.button2D.setStyle('display', 'block');
            this.button3D.setStyle('display', 'none');
        } else {
            this.button2D.setStyle('display', 'none');
            this.button3D.setStyle('display', 'block');
        }

        this.space3D = space3D;
        this.display3D = space3D;
    }
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlSpace);


/***/ }),

/***/ "./src/browser/ui/control/sync.js":
/*!****************************************!*\
  !*** ./src/browser/ui/control/sync.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utility/dom */ "./src/browser/utility/dom.js");



//get rid of compiler mess
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_0__["default"];

const UIControlSync = function(ui, visible, visibleLock) {
    this.ui = ui;

    this.clinets = [];

    let html = '<div>';
    const hues = [0, 32, 96, 192, 224, 64]

    if (this.ui.browser.config.syncId == '.enter') {
        html += '<div id="vts-sync-popup" style="position:absolute; left:0px; top:0px; width:100%; height: 100%; background-color: rgba(255,255,255,0.7); z-index: 5;">';
        html += '<div class="vts-search-input" style="left:calc(50% - 108px); top:calc(50% - 20px)"><input style="font-size: 20px; z-index:6; padding: 5px;" autofocus type="text" id="vts-sync-input" autocomplete="off" spellcheck="false" placeholder="Enter your name ..."></div>';
        html += '</div>';
    }


    for (let i = 0, li = hues.length; i < li; i++) {
        html += '<div id="vts-sync' + i + '" class="vts-sync" style="background: radial-gradient(circle, hsl(' + hues[i] + ',100%,50%,0) 45%, hsl(' + hues[i] + ',100%,50%,1) 50%, hsl(' + hues[i] + ',100%,50%,-1) 55%);">';
        html += '<div id="vts-sync-id' + i + '" class="vts-sync-label"></div>';
        html += '</div>';
    }

    html += '</div>';

    this.control = this.ui.addControl("sync", html, visible, visibleLock);

    const mapElement = this.ui.getMapElement();

    if (this.ui.browser.config.syncId == '.enter') {
        this.input = this.control.getElement('vts-sync-input');
        this.input.on("change", this.onUsername.bind(this));
    }

    //this.divRect = this.div.getRect();

    this.onMouseMoveCall = this.onMouseMove.bind(this);
    this.onMouseLeaveCall = this.onMouseLeave.bind(this);

    mapElement.on('mousemove', this.onMouseMoveCall);
    mapElement.on('mouseleave', this.onMouseLeaveCall);


};

UIControlSync.prototype.onDoNothing = function(event) {
    dom.stopPropagation(event);
};

UIControlSync.prototype.onMouseLeave = function(/*event*/) {

    const browser = this.ui.browser;
    //const screenSize = browser.getRenderer().getCanvasSize();

    if (browser.ws && browser.ws.readyState == 1) {

        //const coords = event.getMouseCoords();

        browser.ws.send('{ "command":"hide-cursor", "id": ' + browser.wsId + '  }');
    }

};

UIControlSync.prototype.onMouseMove = function(event) {

    const browser = this.ui.browser;
    const screenSize = browser.getRenderer().getCanvasSize();

    if (browser.ws && browser.ws.readyState == 1) {

        const coords = event.getMouseCoords();

        browser.ws.send('{ "command":"cursor", "id": ' + browser.wsId + ', "label": "' + browser.config.syncId + '", "pos":[' + ((coords[0] - screenSize[0] * 0.5) / screenSize[1]) +  ',' + coords[1]/screenSize[1] + ']  }');
    }

};

UIControlSync.prototype.onUsername = function(/*event*/) {

    if (this.input && this.input.element.value != '') {
        this.ui.browser.config.syncId = this.input.element.value;
        this.control.getElement('vts-sync-popup').element.style.display = "none";
    }

};

UIControlSync.prototype.updateCursor = function(event) {

    if (event.color > 5) {
        event.color = 5;
    }

    const div = document.getElementById('vts-sync' + event.color)

    if (div) {

        if (event.command == 'cursor') {
            const screenSize = this.ui.browser.getRenderer().getCanvasSize();

            if (event.label != "") {
                const div2 = document.getElementById('vts-sync-id' + event.color);

                if (div2 && div2.innerHTML != event.label) {
                    div2.innerHTML = event.label;
                    div2.style.display = 'block';
                }

            }

            div.style.display = 'block';
            div.style.left = '' + (event.pos[0]*screenSize[1]+screenSize[0]*0.5-20) + 'px';
            div.style.top = '' + (event.pos[1]*screenSize[1]-20) + 'px';
        } else {
            div.style.display = 'none';
        }

    }

};

/* harmony default export */ __webpack_exports__["default"] = (UIControlSync);


/***/ }),

/***/ "./src/browser/ui/control/zoom.js":
/*!****************************************!*\
  !*** ./src/browser/ui/control/zoom.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utility/dom */ "./src/browser/utility/dom.js");



//get rid of compiler mess
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_0__["default"];


const UIControlZoom = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('zoom',
      '<div id="vts-zoom"'
      + ' class="vts-zoom">'

        + '<div id="vts-zoom-plus" class="vts-zoom-plus">'
            + '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAASUlEQVRIx+2Tyw0AIAhDq0d2KsMzFFddQBO9+En6rqR5kFBAiBVINpJtJ1NPLCbJe5IyG7j78IMyEwBgZsNcRJQrl6gnkgjxIx12Cg3wDaLBUAAAAABJRU5ErkJggg==">'
        + '</div>'

        + '<div id="vts-zoom-minus" class="vts-zoom-minus">'
          + '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAALUlEQVRIx2NgGAWjYBSMAqoCRlwSdnZ2/8kx8NChQxhmMo2G8ygYBaNgFGAHAElYBARpOBYqAAAAAElFTkSuQmCC">'
        + '</div>'

     + ' </div>', visible, visibleLock);

    const plus = this.control.getElement('vts-zoom-plus');
    plus.on('click', this.onZoomIn.bind(this));
    plus.on('dblclick', this.onDoNothing.bind(this));

    const minus = this.control.getElement('vts-zoom-minus');
    minus.on('click', this.onZoomOut.bind(this));
    minus.on('dblclick', this.onDoNothing.bind(this));
};


UIControlZoom.prototype.onDoNothing = function(event) {
    dom.preventDefault(event);
    dom.stopPropagation(event);
};


UIControlZoom.prototype.onZoomIn = function() {
    this.repeat(7, 0.96, 50);
};


UIControlZoom.prototype.onZoomOut = function() {
    this.repeat(7, 1.04, 50);
};


UIControlZoom.prototype.repeat = function(count, factor, delay) {
    if (count <= 0) {
        return;
    }

    const map = this.browser.getMap();
    if (!map) {
        return;
    }

    if (this.browser.autopilot) { //stop autorotation
        this.browser.autopilot.setAutorotate(0);
        this.browser.autopilot.setAutopan(0,0);
    }

    const controller = this.browser.controlMode.getCurrentController();

    if (controller.viewExtentDeltas) {
        controller.viewExtentDeltas.push(factor);
    }

    setTimeout(this.repeat.bind(this, --count, factor, delay), delay);
};


/* harmony default export */ __webpack_exports__["default"] = (UIControlZoom);


/***/ }),

/***/ "./src/browser/ui/element/element.js":
/*!*******************************************!*\
  !*** ./src/browser/ui/element/element.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event */ "./src/browser/ui/element/event.js");
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utility/dom */ "./src/browser/utility/dom.js");
/* harmony import */ var _core_utils_platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/utils/platform */ "./src/core/utils/platform.js");





//get rid of compiler mess
const UIEvent = _event__WEBPACK_IMPORTED_MODULE_0__["default"];
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_1__["default"];
const platform = _core_utils_platform__WEBPACK_IMPORTED_MODULE_2__["platform"];


const UIElement = function(control, element) {
    this.control = control;
    this.ui = this.control.ui;
    this.element = element;
    this.events = [];
    this.dragBeginCall = this.onDragBegin.bind(this, false);
    this.dragBeginCallTouch = this.onDragBegin.bind(this, true);
    this.dragMoveCall = this.onDragMove.bind(this, false);
    this.dragMoveCallTouch = this.onDragMove.bind(this, true);
    this.dragEndCall = this.onDragEnd.bind(this, false);
    this.dragEndCallTouch = this.onDragEnd.bind(this, true);
    this.firstDragDistance = 0;
    this.lastDragDistance = 0;
    this.lastWheelTimer = 0;
    this.lastWheelTimer2 = 0;
    this.dragStartPos = [0,0];
    this.dragCurrentPos = [0,0];
    this.dragLastPos = [0,0];
    this.dragAbsMoved = [0,0];
    this.zoomDrag = false;
    this.wheelTimes = [];
    this.id = this.ui.elementIdCounter++;
};


UIElement.prototype.setStyle = function(key, value) {
    this.element.style[key] = value;
};


UIElement.prototype.getStyle = function(key) {
    return this.element.style[key];
};


UIElement.prototype.setClass = function(name) {
    dom.setClass(this.element, name);
    return this;
};


UIElement.prototype.getClass = function() {
    dom.getClass(this.element);
    return this;
};


UIElement.prototype.hasClass = function(name) {
    return dom.hasClass(this.element, name);
};


UIElement.prototype.addClass = function(name) {
    dom.addClass(this.element, name);
    return this;
};


UIElement.prototype.removeClass = function(name) {
    dom.removeClass(this.element, name);
    return this;
};


UIElement.prototype.getRect = function() {
    const rect = this.element.getBoundingClientRect();
    const rect2 = this.ui.map.getMapElement().element.getBoundingClientRect();
    const offsetX = window.pageXOffset || 0;
    const offsetY = window.pageYOffset || 0;
    return {
        'left' : (rect.left + offsetX) - (rect2.left + offsetX),
        'top' : (rect.top + offsetY) - (rect2.top + offsetY),
        'fromRight' : rect2.right - ((rect.left + offsetX) - (rect2.left + offsetX)),
        'fromBottom' : rect2.height - ((rect.top + offsetY) - (rect2.top + offsetY)),
        'width' : rect.width,
        'height' : rect.height
    };
};


UIElement.prototype.getPageRect = function() {
    const rect = this.element.getBoundingClientRect();
    const offsetX = window.pageXOffset || 0;
    const offsetY = window.pageYOffset || 0;
    return {
        'left' : (rect.left + offsetX),
        'top' : (rect.top + offsetY),
        'width' : rect.width,
        'height' : rect.height
    };
};


UIElement.prototype.setHtml = function(html) {
    this.element.innerHTML = html;

    const allElements = this.element.getElementsByTagName('*');

    //store all elements with id attribute to the table
    for (let i = 0, li = allElements.length; i < li; i++) {
        const id = allElements[i].getAttribute('id');

        if (id !== null) {
            //store element to the table
            this.control.elementsById[id] = new UIElement(this, allElements[i]);
        }
    }
};


UIElement.prototype.getHtml = function() {
    return this.element.innerHTML;
};


UIElement.prototype.getElement = function() {
    return this.element;
};


UIElement.prototype.on = function(type, call, externalElement) {
    this.addEvent(type, call, externalElement);
};


UIElement.prototype.once = function(type, call, externalElement) {
    const removeEventCall = (function() {
        this.removeEvent(type, call, externalElement);
    }).bind(this);

    const handler = function(e) {
        call(e);
        removeEventCall();
    };

    this.addEvent(type, handler, externalElement);
};


UIElement.prototype.off = function(type, call, externalElement) {
    this.removeEvent(type, call, externalElement);
};


UIElement.prototype.fire = function(type, event) {
    const hooks = this.events[type];

    if (hooks != null) {
        for (let hook in hooks) {
            hooks[hook](event);
        }
    }
};


UIElement.prototype.addEvent = function(type, call, externalElement) {
    const id = type + '-' + dom.stamp(call)
               + (externalElement ? ('-' + dom.stamp(externalElement)) : '');

    const handler = (function(e) {
        if (this.ui.killed) {
            return; //todo remove event
        }

        if (type == 'mousewheel' && platform.getOS().toLowerCase().indexOf('mac') != -1) {

            if (this.ui.browser.config.separatePanAndZoom &&
                (this.dragAbsMoved[0] * this.dragAbsMoved[0] + this.dragAbsMoved[1] * this.dragAbsMoved[1]) > 20 ) {
                return;
            }

            const timer = Date.now();

            //console.log('wheel: ');

            const bigInterval = 500;
            const bigInterval2 = 500;
            let time = timer - this.lastWheelTimer2;

            this.wheelTimes.push(timer);

            let avrg = 0;

            for (let i = 0; i < this.wheelTimes.length;) {
                if (timer - this.wheelTimes[i] > bigInterval2) {
                    this.wheelTimes.splice(i, 1);
                } else {
                    avrg += (timer - this.wheelTimes[i]);
                    i++;
                }
            }

            // eslint-disable-next-line
            avrg = this.wheelTimes.length ? avrg / this.wheelTimes.length : 0;

            //console.log('wheel count: ' + this.wheelTimes.length);
            //console.log('wheel avrg: ' + avrg);

            if (time > bigInterval) {
                this.lastWheelTimer2 = timer;
                time = 0;
            }

            //const x = time / (bigInterval);
            //const lag = Math.min((x * x * x) * this.ui.browser.config.wheelInputLag, this.ui.browser.config.wheelInputLag);
            //const lag = Math.min((x * x * x) * this.wheelTimes.length, this.ui.browser.config.wheelInputLag);
            //const lag = Math.min((x) * this.wheelTimes.length*2, this.ui.browser.config.wheelInputLag);
            const lag = Math.min(this.wheelTimes.length * this.ui.browser.config.wheelInputLag[1], this.ui.browser.config.wheelInputLag[0]);
            //const lag = Math.max(0,Math.min(avrg - (0.5-(1-x)*0.5) * this.wheelTimes.length*2, this.ui.browser.config.wheelInputLag));
            //const lag = Math.min(avrg, this.ui.browser.config.wheelInputLag);
            //lag = this.wheelTimes.length; //this.ui.browser.config.wheelInputLag;
            //console.log('lag: ' + lag + '  ' +x);

            if ((timer - this.lastWheelTimer) < lag) {
              //this.ui.fireWheel[this.id] = { element: this, event: e || window.event, call: call};
                return;
            }

            //console.log('interval: ' + (timer - this.lastWheelTimer));

            this.lastWheelTimer = timer;

            //console.log('mousewheel ' + timer);
            //console.log('',e);
            //console.log('type: ' + e.type + '  phase: ' + e.eventPhase);
        }

        call(new UIEvent(type, this, e || window.event));
    }).bind(this);

    const element =  externalElement || this.element;
    element.addEventListener(this.getEventName(type), handler, false);

    if (type == 'mousewheel') {
        element.addEventListener('DOMMouseScroll', handler, false);
    }

    this.events[type] = this.events[type] || [];
    this.events[type][id] = handler;
};


UIElement.prototype.removeEvent = function(type, call, externalElement) {
    const id = type + '-' + dom.stamp(call)
               + (externalElement ? ('-' + dom.stamp(externalElement)) : '');

    const handler = this.events[type] && this.events[type][id];

    if (handler != null) {
        delete this.events[type][id];

        const element =  externalElement || this.element;
        element.removeEventListener(this.getEventName(type), handler, false);
    }
};


UIElement.prototype.getEventName = function(type) {
    return type;
};


UIElement.prototype.setDraggableState = function(state) {
    if (state) {
        this.on('mousedown', this.dragBeginCall);
        this.on('touchstart', this.dragBeginCallTouch);
    } else if (this.dragable){
        this.off('mousedown', this.dragBeginCall);
        this.off('mousemove', this.dragMoveCall, document);
        //this.off("mouseup", this.onDragEnd.bind(this));
        this.off('mouseup', this.dragEndCall, document);

        this.off('touchstart', this.dragBeginCallTouch);
        this.off('touchmove', this.dragMoveCallTouch, document);
        this.off('touchend', this.dragEndCallTouch, document);

        this.dragging = false;
    }

    this.dragStartPos = [0,0];
    this.dragCurrentPos = [0,0];
    this.dragLastPos = [0,0];
    this.dragAbsMoved = [0,0];
    this.dragTouchCount = 0;
    this.dragTouches = [];
    this.dragTouches2 = [];
    this.resetPos = false;

    this.dragable = state;
    this.dragButtons = {
        'left' : false,
        'right' : false,
        'middle' : false
    };
};


UIElement.prototype.getDraggableState = function() {
    return this.dragable;
};


UIElement.prototype.getDraggingState = function() {
    return {
        'dragging' : this.dragging,
        'buttonLeft' : this.dragButtons['left'],
        'buttonRight' : this.dragButtons['right'],
        'buttonMiddle' : this.dragButtons['middle'],
        'startPos' : this.dragStartPos.slice(),
        'lastPos' : this.dragLastPos.slice(),
        'currentPos' : this.dragCurrentPos.slice(),
        'absMoved' : this.dragAbsMoved.slice()
    };
};


UIElement.prototype.onDragBegin = function(touchUsed, event) {
    //console.log("bergin: 1#:  " + JSON.stringify(this.dragButtons));

    this.dragButtons[event.getMouseButton()] = true;

    //console.log("bergin: 2#:  " + JSON.stringify(this.dragButtons));

    //if (event.getTouchesCount() == 2) {
    this.dragTouches = [];
    this.dragTouches2 = [];
    this.dragTouches.push(event.getTouchCoords(0));
    this.dragTouches2.push(event.getTouchCoords(1));
    //}

    if (touchUsed) {
        this.resetPos = true;
        this.firstDragDistance = 0;
        this.lastDragDistance = 0;
        this.zoomDrag = false;
    }

    if (!this.dragging) {
        this.dragging = true;
        const pos = event.getMouseCoords();//true);
        this.dragStartPos = [pos[0], pos[1]];
        this.dragCurrentPos = [pos[0], pos[1]];
        this.dragLastPos = [pos[0], pos[1]];
        this.dragAbsMoved = [0,0];

        this.on('mousemove', this.dragMoveCall, document);
        this.on('mouseup', this.dragEndCall, document);
        //this.on("mouseup", this.onDragEnd.bind(this), document);

        this.on('touchmove', this.dragMoveCallTouch, document);
        this.on('touchend', this.dragEndCallTouch, document);

        dom.disableTextSelection();
        dom.disableImageDrag();
        //dom.disableContexMenu();
        dom.preventDefault(event);

        this.dragLastPos[0] = pos[0];
        this.dragLastPos[1] = pos[1];

        this.fire('dragstart', {
            'clientX' : pos[0],
            'clientY' : pos[1],
            'pageX' : pos[0],
            'pageY' : pos[1]
        });
    } else {
        this.dragLastPos = event.getMouseCoords();
    }
};


UIElement.prototype.onDragMove = function(touchUsed, event) {
    const pos = event.getMouseCoords();

    if (event.getTouchesCount() != -1) {
        this.updateDragButtonsState(event, true);
    }

    dom.preventDefault(event);

    let mode = '';
    let zoom = 0;
    let rotateDelta = 0;
    let panDelta = [0,0];
    let distanceDelta = 0;
    let touchCount = 0;

    //cont el = document.getElementById("debug123");

    if (touchUsed) {

        touchCount = event.getTouchesCount();
        if (touchCount != this.dragTouchCount) {
            this.dragLastPos[0] = pos[0];
            this.dragLastPos[1] = pos[1];
            this.dragTouchCount = touchCount;
        }

        if (this.resetPos) {
            this.dragCurrentPos = [pos[0], pos[1]];
            this.dragLastPos[0] = pos[0];
            this.dragLastPos[1] = pos[1];
            this.resetPos = false;
        }

        if (touchCount == 2) {
            this.dragTouches.push(event.getTouchCoords(0));
            this.dragTouches2.push(event.getTouchCoords(1));

            if (this.dragTouches.length >= 7) {
                this.dragTouches.shift();
                this.dragTouches2.shift();
            }

            if (this.dragTouches.length == 6) {

                //get vector for touch #1
                let t = this.dragTouches;
                const v1x = (t[5][0] - t[4][0]) + (t[4][0] - t[3][0]) + (t[3][0] - t[2][0]) + (t[2][0] - t[1][0]) + (t[1][0] - t[0][0]);
                const v1y = (t[5][1] - t[4][1]) + (t[4][1] - t[3][1]) + (t[3][1] - t[2][1]) + (t[2][1] - t[1][1]) + (t[1][1] - t[0][1]);

                //get vector for touch #2
                let t2 = this.dragTouches2;
                const v2x = (t2[5][0] - t2[4][0]) + (t2[4][0] - t2[3][0]) + (t2[3][0] - t2[2][0]) + (t2[2][0] - t2[1][0]) + (t2[1][0] - t2[0][0]);
                const v2y = (t2[5][1] - t2[4][1]) + (t2[4][1] - t2[3][1]) + (t2[3][1] - t2[2][1]) + (t2[2][1] - t2[1][1]) + (t2[1][1] - t2[0][1]);

                //get distance of each vector
                let d1 = Math.sqrt(v1x * v1x + v1y * v1y);
                let d2 = Math.sqrt(v2x * v2x + v2y * v2y);
                let cosAngle, cosAngle2;

                mode = 'pan';

                if (d1 > d2 * 5 || d2 > d1 * 5) { //dectec situation where only one finger is closing to another

                    let p1, p2, p3;

                    //make first vector from non moving point to beginnig position of moving point
                    //make seconf vector from non moving point to ending position of moving point
                    if (d1 > d2 * 5) {
                        p1 = t2[0];
                        p2 = t[0];
                        p3 = t[5];
                    } else {
                        p1 = t[0];
                        p2 = t2[0];
                        p3 = t2[5];
                    }

                    const v1 = [p2[0] - p1[0], p2[1] - p1[1]];
                    const v2 = [p3[0] - p1[0], p3[1] - p1[1]];

                    //normalize vectors
                    let d =  Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
                    v1[0] /= d;
                    v1[1] /= d;

                    d =  Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
                    v2[0] /= d;
                    v2[1] /= d;

                    //measure angle between vectors
                    cosAngle = v1[0] * v2[0] + v1[1] * v2[1];
                    cosAngle2 = -v1[1] * v2[0] + v1[0] * v2[1]; //v1 is rotated by 90deg

                    rotateDelta = (Math.acos(cosAngle2) * (180.0/Math.PI)) - 90;

                    if (cosAngle > 0.9999) { //are vectors in same line?
                        mode = 'zoom';
                    } else {
                        panDelta = [(v1x + v2x) *0.5, (v1y + v2y) *0.5];
                    }

                } else if (d1 > 1 && d2 > 1) { //are bouth vectors in motion

                    //normalize vectors
                    const nv1x = v1x / d1;
                    const nv1y = v1y / d1;

                    const nv2x = v2x / d2;
                    const nv2y = v2y / d2;

                    //do vectors move in same direction
                    cosAngle = nv1x * nv2x + nv1y * nv2y;

                    if (cosAngle < 0.2) {
                        mode = 'zoom';
                    } else {
                        panDelta = [(v1x + v2x) *0.5, (v1y + v2y) *0.5];
                    }
                }

                //if (mode == "zoom") {
                t = this.dragTouches;
                t2 = this.dragTouches2;

                //get distance between points at the beginig
                let dx = (t2[0][0] - t[0][0]);
                let dy = (t2[0][1] - t[0][1]);
                d1 = Math.sqrt(dx * dx + dy * dy);

                /*
                //get distance between points at the end
                dx = (t2[5][0] - t[5][0]);
                dy = (t2[5][1] - t[5][1]);
                d2 = Math.sqrt(dx * dx + dy * dy);

                //get delta betwwen distances
                distanceDelta = d2 - d1;
                */

                distanceDelta = 0;

                for (let i = 1; i < 6; i++) {

                    //get distance between points at the end
                    dx = (t2[i][0] - t[i][0]);
                    dy = (t2[i][1] - t[i][1]);
                    d2 = Math.sqrt(dx * dx + dy * dy);

                    //get delta between distances
                    distanceDelta += d2 - d1;
                    d1 = d2;
                }

                //}
            }
        }
    }

    this.fire('drag', {
        'clientX' : pos[0],
        'clientY' : pos[1],
        'pageX' : pos[0],
        'pageY' : pos[1],
        'deltaX' : pos[0] - this.dragLastPos[0],
        'deltaY' : pos[1] - this.dragLastPos[1],
        'left' : this.dragButtons['left'],
        'right' : this.dragButtons['right'],
        'middle' : this.dragButtons['middle'],
        'zoom' : zoom,
        'touchMode' : mode,
        'touchPanDelta' : panDelta,
        'touchRotateDelta' : rotateDelta,
        'touchDistanceDelta' : distanceDelta,
        'touches' : (touchUsed) ? touchCount : 0
    });

    //
    //el.innerHTML = "rotDelta" + rotateDelta;

    this.dragLastPos = this.dragCurrentPos;
    this.dragCurrentPos = [pos[0], pos[1]];
    this.dragAbsMoved[0] += Math.abs(pos[0] - this.dragLastPos[0]);
    this.dragAbsMoved[1] += Math.abs(pos[1] - this.dragLastPos[1]);
};

//var debugCoutner = 0;

UIElement.prototype.onDragEnd = function(touchUsed, event) {
    //this.dragButtons[event.getMouseButton()] = false;
    //console.log("end: 1#:  " + JSON.stringify(this.dragButtons));

    const left = this.dragButtons['left'];
    const right = this.dragButtons['right'];
    const middle = this.dragButtons['middle'];

    this.updateDragButtonsState(event, false);

    //if (event.getTouchesCount() == 2) {
    this.dragTouches = [];
    this.dragTouches2 = [];
    this.dragTouches.push(event.getTouchCoords(0));
    this.dragTouches2.push(event.getTouchCoords(1));
    this.dragAbsMoved = [0,0];

    //}

    //console.log("end: 2#:  " + JSON.stringify(this.dragButtons));

    if (touchUsed) {
        this.resetPos = true;
        this.firstDragDistance = 0;
        this.lastDragDistance = 0;
        this.zoomDrag = false;
    }

    if (this.dragging) {
        let pos = event.getMouseCoords();
        this.dragLastPos = pos;

        if (!this.dragButtons['left'] &&
            !this.dragButtons['right'] &&
            !this.dragButtons['middle'] ) {

            this.dragging = false;
            pos = this.dragCurrentPos;//event.getMouseCoords();
            this.off('mousemove', this.dragMoveCall, document);
            this.off('mouseup', this.dragEndCall, document);
            //this.off("mouseup", this.onDragEnd.bind(this), document);

            this.off('touchmove', this.dragMoveCallTouch, document);
            this.off('touchend', this.dragEndCallTouch, document);

            dom.enableTextSelection();
            dom.enableImageDrag();
            //dom.enableContexMenu();
            dom.preventDefault(event);

            this.fire('dragend', {
                'clientX' : pos[0],
                'clientY' : pos[1],
                'pageX' : pos[0],
                'pageY' : pos[1],
                'left' : left,
                'right' : right,
                'middle' : middle
            });
        }
    }
};


UIElement.prototype.updateDragButtonsState = function(event, state) {
    switch(event.getTouchesCount()) {
    case -1: this.dragButtons[event.getMouseButton()] = state; break;
    case 0: this.dragButtons = { 'left' : false, 'right' : false, 'middle' : false }; break;
    case 1: this.dragButtons = { 'left' : true, 'right' : false, 'middle' : false }; break;
    case 2: this.dragButtons = { 'left' : false, 'right' : true, 'middle' : false }; break;
    case 3: this.dragButtons = { 'left' : false, 'right' : false, 'middle' : true }; break;
    }
};



/* harmony default export */ __webpack_exports__["default"] = (UIElement);


/***/ }),

/***/ "./src/browser/ui/element/event.js":
/*!*****************************************!*\
  !*** ./src/browser/ui/element/event.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const UIEvent = function(type, element, event) {
    this.type = type;
    this.event = event;
    this.element = element;
};


UIEvent.prototype.getMouseButton = function() {
    switch (this.type) {
    case 'touchstart':
    case 'touchend':
    case 'touchmove':
        {
            const touches = this.event['touches'];

            if (touches) {
                switch(touches.length) {
                case 1: return 'left';
                case 2: return 'right';
                case 3: return 'middle';
                }
            }

            return '';
        }

    default:

        if (this.event.which) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
                //right = e.which == 3;

            switch(this.event.which) {
            case 1: return 'left';
            case 2: return 'middle';
            case 3: return 'right';
            }

        } else if (this.event.button) { // IE, Opera
                //right = e.button == 2;

            switch(this.event.button) {
            case 1: return 'left';
            case 2: return 'right';
            case 3: return 'middle';
            }
        }

    }

    return '';
};


UIEvent.prototype.getMouseCoords = function(absolute) {
    let pos = [0,0];

    switch (this.type) {
    case 'touchstart':
    case 'touchend':
    case 'touchmove':
        {
            const touches = this.event['touches'];
            if (!touches || touches.length == 0) {
                break;
            }

            let i, li;

            for (i = 0, li = touches.length; i < li; i++) {
                const pos2 = this.getEventCoords(this.event['touches'][i], absolute);
                pos[0] += pos2[0];
                pos[1] += pos2[1];
            }

            pos[0] /= li;
            pos[1] /= li;
        }
        break;

    case 'mousedown':
    case 'mouseup':
    case 'mousemove':
    case 'mouseenter':
    case 'mouseover':
    case 'mouseleave':
    case 'click':
    case 'dblclick':
    case 'dragstart':
    case 'dragend':
    case 'drag':

        pos = this.getEventCoords(this.event, absolute);
        break;
    }

    return pos;
};


UIEvent.prototype.getEventCoords = function(event, absolute) {
//    if (this.element.getBoundingClientRect == null || absolute) {
    if (this.element.getPageRect == null || absolute) {
        return [ event['clientX'],
                 event['clientY'] ];
    } else {
        const rect = this.element.getPageRect();

        return [ event['pageX'] - rect.left,
                 event['pageY'] - rect.top ];
    }
};


UIEvent.prototype.getDragDelta = function() {
    switch (this.type) {
    case 'drag':

        return [ this.event['deltaX'],
                 this.event['deltaY'] ];
    }

    return [0,0];
};


UIEvent.prototype.getDragZoom = function() {
    switch (this.type) {
    case 'drag':
        return this.event['zoom'];
    }

    return 1.0;
};


UIEvent.prototype.getDragTouches = function() {
    switch (this.type) {
    case 'drag':
        return this.event['touches'];
    }

    return 0;
};


UIEvent.prototype.getModifierKey = function(key) {
    switch (this.type) {
    case 'mouseup':
    case 'mousedown':
    case 'dblclick':
    case 'keyup':
    case 'keydown':
    case 'keypress':

        switch(key) {
        case 'alt':   return this.event.altKey;
        case 'ctrl':  return this.event.ctrlKey;
        case 'shift': return this.event.shiftKey;
        }
    }

    return false;
};


UIEvent.prototype.getKeyCode = function() {
    switch (this.type) {
    case 'keyup':
    case 'keydown':
    case 'keypress':

        if (this.event.keyCode) {         // eg. IE
            return this.event.keyCode;
        } else if (this.event.which) {   // eg. Firefox
            return this.event.which;
        } else {
            return this.event.charCode;
        }
    }

    return null;
};


UIEvent.prototype.getDragButton = function(button) {
    switch(button) {
    case 'left':
    case 'right':
    case 'middle':

        switch(this.getTouchesCount()) {
        case -1: return this.event[button];
        case 0: return false;
        case 1: return button == 'left';
        case 2: return button == 'right';
        case 3: return button == 'middle';
        }

    }

    return false;
};


UIEvent.prototype.getWheelDelta = function() {
    switch (this.type) {
    case 'mousewheel':
        {
            let delta = 0;

            if (this.event.wheelDelta) {
                delta = this.event.wheelDelta / 120;
            }
            if (this.event.detail) {
                delta = -this.event.detail / 3;
            }

            return delta;
        }
    }

    return 0;
};


UIEvent.prototype.getTouchesCount = function() {
    switch (this.type) {
    case 'touchstart':
    case 'touchend':
    case 'touchmove':
        {
            let touches = this.event['touches'];
            if (!touches) {
                break;
            }

            return this.event['touches'].length;
        }
    }

    return -1;
};


UIEvent.prototype.getTouchParameter = function(name) {
    switch (this.type) {
    case 'drag':
        return this.event[name];
    }

    return null;
};


UIEvent.prototype.getTouchCoords = function(index, absolute) {
    switch (this.type) {
    case 'touchstart':
    case 'touchend':
    case 'touchmove':
        {
            const touches = this.event['touches'];
            if (!touches) {
                break;
            }

            const event = this.event['touches'][index];
            if (!event) {
                break;
            }

            if (this.element.getPageRect == null || absolute) {
                return [ event['clientX'],
                         event['clientY'] ];
            } else {
                const rect = this.element.getPageRect();

                return [ event['pageX'] - rect.left,
                         event['pageY'] - rect.top ];
            }
        }
    }

    return [0,0];
};


UIEvent.prototype.getType = function() {
    return this.type;
};


/* harmony default export */ __webpack_exports__["default"] = (UIEvent);


/***/ }),

/***/ "./src/browser/ui/ui.js":
/*!******************************!*\
  !*** ./src/browser/ui/ui.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utility_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utility/dom */ "./src/browser/utility/dom.js");
/* harmony import */ var _core_utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _control_holder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./control/holder */ "./src/browser/ui/control/holder.js");
/* harmony import */ var _control_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./control/map */ "./src/browser/ui/control/map.js");
/* harmony import */ var _control_compass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./control/compass */ "./src/browser/ui/control/compass.js");
/* harmony import */ var _control_credits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./control/credits */ "./src/browser/ui/control/credits.js");
/* harmony import */ var _control_fullscreen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./control/fullscreen */ "./src/browser/ui/control/fullscreen.js");
/* harmony import */ var _control_zoom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./control/zoom */ "./src/browser/ui/control/zoom.js");
/* harmony import */ var _control_space__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./control/space */ "./src/browser/ui/control/space.js");
/* harmony import */ var _control_search__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./control/search */ "./src/browser/ui/control/search.js");
/* harmony import */ var _control_link__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./control/link */ "./src/browser/ui/control/link.js");
/* harmony import */ var _control_github__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./control/github */ "./src/browser/ui/control/github.js");
/* harmony import */ var _control_layers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./control/layers */ "./src/browser/ui/control/layers.js");
/* harmony import */ var _control_fallback__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./control/fallback */ "./src/browser/ui/control/fallback.js");
/* harmony import */ var _control_popup__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./control/popup */ "./src/browser/ui/control/popup.js");
/* harmony import */ var _control_loading__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./control/loading */ "./src/browser/ui/control/loading.js");
/* harmony import */ var _control_measure__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./control/measure */ "./src/browser/ui/control/measure.js");
/* harmony import */ var _control_measure_lite__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./control/measure-lite */ "./src/browser/ui/control/measure-lite.js");
/* harmony import */ var _control_sync__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./control/sync */ "./src/browser/ui/control/sync.js");






















//get rid of compiler mess
const dom = _utility_dom__WEBPACK_IMPORTED_MODULE_0__["default"];
const utils = _core_utils_utils__WEBPACK_IMPORTED_MODULE_1__["utils"];
const UIControlHolder = _control_holder__WEBPACK_IMPORTED_MODULE_2__["default"];
const UIControlMap = _control_map__WEBPACK_IMPORTED_MODULE_3__["default"];

const UIControlCompass = _control_compass__WEBPACK_IMPORTED_MODULE_4__["default"];
const UIControlCredits = _control_credits__WEBPACK_IMPORTED_MODULE_5__["default"];
const UIControlFullscreen = _control_fullscreen__WEBPACK_IMPORTED_MODULE_6__["default"];
const UIControlZoom = _control_zoom__WEBPACK_IMPORTED_MODULE_7__["default"];
const UIControlSpace = _control_space__WEBPACK_IMPORTED_MODULE_8__["default"];
const UIControlSearch = _control_search__WEBPACK_IMPORTED_MODULE_9__["default"];
const UIControlLink = _control_link__WEBPACK_IMPORTED_MODULE_10__["default"];
const UIControlGithub = _control_github__WEBPACK_IMPORTED_MODULE_11__["default"];
const UIControlMeasure = _control_measure__WEBPACK_IMPORTED_MODULE_16__["UIControlMeasure"];
const UIControlMeasureLite = _control_measure_lite__WEBPACK_IMPORTED_MODULE_17__["default"];
const UIControlLayers = _control_layers__WEBPACK_IMPORTED_MODULE_12__["default"];
const UIControlFallback = _control_fallback__WEBPACK_IMPORTED_MODULE_13__["default"];
const UIControlPopup = _control_popup__WEBPACK_IMPORTED_MODULE_14__["default"];
const UIControlLoading = _control_loading__WEBPACK_IMPORTED_MODULE_15__["default"];
const UIControlSync = _control_sync__WEBPACK_IMPORTED_MODULE_18__["default"];


const UI = function(browser, element) {
    this.browser = browser;
    this.config = browser.config;
    this.rootElement = element;
    this.element = null;
    this.controls = [];
    this.killed = false;
    this.init();
    this.instanceId = utils.instanceCounter++;

    Object.defineProperty(this, 'dom', {
        get: function() {
            if (this.killed) return null;
            return dom;
        }
    });
};


UI.prototype.init = function() {
    //create browser wrapper
    this.elementIdCounter = 1;
    this.element = document.createElement('div');
    this.element.className = 'vts-browser';
    this.rootElement.appendChild(this.element);

    //create map cotrol
    this.map = new UIControlMap(this);

    //create other ui controls
    const loading = this.config.controlLoading;
    this.compass = new UIControlCompass(this, (!loading && this.config.controlCompass), loading);
    this.credits = new UIControlCredits(this, (!loading && this.config.controlCredits), loading);
    //this.logo = new UIControlLogo(this, this.config.controlLogo);
    this.fullscreen = new UIControlFullscreen(this, (!loading && this.config.controlFullscreen), loading);
    this.zoom = new UIControlZoom(this, (!loading && this.config.controlZoom), loading);
    this.space = new UIControlSpace(this, (!loading && this.config.controlSpace), loading);
    this.search = new UIControlSearch(this, (!loading && this.config.controlSearch), loading);
    this.link = new UIControlLink(this, (!loading && this.config.controlLink), loading);
    this.github = new UIControlGithub(this, (!loading && this.config.controlGithub), loading);
    this.measure = new UIControlMeasure(this, (!loading && this.config.controlMeasure), loading);
    this.measure2 = new UIControlMeasureLite(this, (!loading && this.config.controlMeasureLite), loading);
    //this.navigator = new UIControlNavigation(this, this.config.controlNavigator);
    this.layers = new UIControlLayers(this, (!loading && this.config.controlLayers), loading);
    this.fallback = new UIControlFallback(this);
    this.popup = new UIControlPopup(this, false);
    this.loading = new UIControlLoading(this, this.config.controlLoading);

    if (this.config.syncCursor) {
        this.sync = new UIControlSync(this, this.config.syncCursor);
    }

    dom.disableContexMenu(this.element);
};


UI.prototype.kill = function() {
    this.killed = true;

    for (let key in this.controls) {
        delete this.controls[key];
    }

    this.rootElement.removeChild(this.element);
    delete this.element;
    this.element = null;
};


UI.prototype.addControl = function(id, html, visible, visibleLock, parentElement) {
    const control = new UIControlHolder(this, html, visible, visibleLock, parentElement);
    this.controls[id] = control;
    return control;
};


UI.prototype.removeControl = function(id) {
    if (this.controls[id] != null) {
        delete this.controls[id];
    }
};


UI.prototype.setControlHtml = function(id, html) {
    if (this.controls[id] != null) {
        this.controls[id].setHTML(html);
    }
};


UI.prototype.setControlVisible = function(id, state, lockState) {
    if (this.controls[id] != null) {
        if (typeof lockState !== 'undefined') {
            this.controls[id].setVisibleLock(lockState);
        }

        const renderer = this.browser.getRenderer();
        let flags = renderer.getMarginFlags();

        if (id == 'compass') flags |= 1;
        if (id == 'search') flags |= 2;

        if (this.config.bigScreenMargins) {
            flags |= 4096;
        }

        renderer.setMarginFlags(flags);

        this.controls[id].setVisible(state);
    }
};


UI.prototype.getControlVisible = function(id) {
    if (this.controls[id] != null) {
        this.controls[id].getVisible();
    }
};


UI.prototype.getControl = function(id) {
    return this.controls[id];
};


UI.prototype.getMapControl = function() {
    return this.map;
};


UI.prototype.getMapElement = function() {
    return this.map.getMapElement();
};


UI.prototype.setParam = function(key) {
    switch (key) {
    case 'controlCompass':     this.setControlVisible('compass', this.config.controlCompass); break;
    case 'controlZoom':        this.setControlVisible('zoom', this.config.controlZoom); break;
        //case "controlMeasure":     this.setControlVisible(this.config.controlCompass); break;
    case 'controlScale':       this.setControlVisible('scale', this.config.controlScale); break;
    case 'controlLayers':      this.setControlVisible('layers', this.config.controlLayers); break;
    case 'controlSpace':       this.setControlVisible('space', this.config.controlSpace); break;
    case 'controlSearch':      this.setControlVisible('search', this.config.controlSearch); break;
    case 'controlLink':        this.setControlVisible('link', this.config.controlLink); break;
    case 'controlMeasure':     this.setControlVisible('measure', this.config.controlMeasure); break;
    case 'controlLogo':        this.setControlVisible('logo', this.config.controlLogo); break;
    case 'controlFullscreen':  this.setControlVisible('fullscreeen', this.config.controlFullscreen); break;
    case 'controlCredits':     this.setControlVisible('credits', this.config.controlCredits); break;
        //case "controlLoading":     this.setControlVisible("loading", this.config.controlLogo); break;
    }
};


UI.prototype.tick = function(dirty) {
    if (dirty) {
        this.compass.update();
        this.space.update();
        this.credits.update();
        this.link.updateLink();
        this.search.update();
    }

    if (this.loading.control.getVisible()) {
        this.loading.update();
    }
};


/* harmony default export */ __webpack_exports__["default"] = (UI);


/***/ }),

/***/ "./src/browser/utility/dom.js":
/*!************************************!*\
  !*** ./src/browser/utility/dom.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ui_element_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ui/element/event */ "./src/browser/ui/element/event.js");



//get rid of compiler mess
const UIEvent = _ui_element_event__WEBPACK_IMPORTED_MODULE_0__["default"];


//Dom.dragging = false;
const Dom = {};

Dom.hasClass = function(element, name) {
    if (element.classList !== undefined) {
        return element.classList.contains(name);
    }
    const className = Dom.getClass(element);
    return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
};


Dom.addClass = function(element, name) {
    if (element.classList !== undefined) {
        const classes = name.trim().split(/\s+/);
        for (let i = 0, li = classes.length; i < li; i++) {
            element.classList.add(classes[i]);
        }
    } else if (!Dom.hasClass(element, name)) {
        const className = Dom.getClass(element);
        Dom.setClass(element, (className ? className + ' ' : '') + name);
    }
};


Dom.removeClass = function(element, name) {
    if (element.classList !== undefined) {
        element.classList.remove(name);
    } else {
        Dom.setClass(element, ((' ' + Dom.getClass(element) + ' ').replace(' ' + name + ' ', ' ')).trim() );
    }
};


Dom.setClass = function(element, name) {
    if (element.className.baseVal === undefined) {
        element.className = name;
    } else {
        element.className.baseVal = name;
    }
};


Dom.getClass = function(element) {
    return element.className.baseVal === undefined ? element.className : element.className.baseVal;
};


Dom.preventDefault = function(e) {
    e = e instanceof UIEvent ? e.event : e;
    if (e.preventDefault) {
        e.preventDefault();
    } else {
        e.returnValue = false;
    }
};


Dom.stopPropagation = function(e) {
    e = e instanceof UIEvent ? e.event : e;
    e.stopPropagation();
};


Dom.disableTextSelection = function() {
    window.addEventListener('selectstart', Dom.preventDefault);
};


Dom.enableTextSelection = function() {
    window.removeEventListener('selectstart', Dom.preventDefault);
};


Dom.disableImageDrag = function() {
    window.addEventListener('dragstart', Dom.preventDefault);
};


Dom.enableImageDrag = function() {
    window.removeEventListener('dragstart', Dom.preventDefault);
};


Dom.disableContexMenu = function(element) {
    element.addEventListener('contextmenu', Dom.preventDefault);
};


Dom.enableContexMenu = function(element) {
    element.removeEventListener('contextmenu', Dom.preventDefault);
};


Dom.getSupportedProperty = function(properties) {
    const style = document.documentElement.style;

    for (let i = 0, li = properties.length; i < li; i++) {
        if (properties[i] in style) {
            return properties[i];
        }
    }

    return false;
};


Dom.stampCounter = 0;


Dom.stamp = function(obj) {
    obj.vtsStamp = obj.vtsStamp || ++Dom.stampCounter;
    return obj.vtsStamp;
};


Dom.TRANSFORM = Dom.getSupportedProperty(
            ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);


/* harmony default export */ __webpack_exports__["default"] = (Dom);


/***/ }),

/***/ "./src/core/core.js":
/*!**************************!*\
  !*** ./src/core/core.js ***!
  \**************************/
/*! exports provided: Core, getCoreVersion, checkSupport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Core", function() { return Core; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCoreVersion", function() { return getCoreVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkSupport", function() { return checkSupport; });
/* harmony import */ var _map_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map/map */ "./src/core/map/map.js");
/* harmony import */ var _inspector_inspector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inspector/inspector */ "./src/core/inspector/inspector.js");
/* harmony import */ var _renderer_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderer/renderer */ "./src/core/renderer/renderer.js");
/* harmony import */ var _renderer_interface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderer/interface */ "./src/core/renderer/interface.js");
/* harmony import */ var _map_position__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map/position */ "./src/core/map/position.js");
/* harmony import */ var _map_interface__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./map/interface */ "./src/core/map/interface.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _utils_url__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/url */ "./src/core/utils/url.js");
/* harmony import */ var _utils_platform__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/platform */ "./src/core/utils/platform.js");
//import Proj4 from 'melowntech-proj4';










//get rid of compiler mess
const Map = _map_map__WEBPACK_IMPORTED_MODULE_0__["default"];
const Inspector = _inspector_inspector__WEBPACK_IMPORTED_MODULE_1__["default"];
const Renderer = _renderer_renderer__WEBPACK_IMPORTED_MODULE_2__["default"];
const RendererInterface = _renderer_interface__WEBPACK_IMPORTED_MODULE_3__["default"];
const MapPosition = _map_position__WEBPACK_IMPORTED_MODULE_4__["default"];
const MapInterface = _map_interface__WEBPACK_IMPORTED_MODULE_5__["default"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_6__["utils"];
const utilsUrl = _utils_url__WEBPACK_IMPORTED_MODULE_7__["utilsUrl"];
const platform = _utils_platform__WEBPACK_IMPORTED_MODULE_8__["platform"];


const Core = function(element, config, coreInterface) {
    const lang = navigator.languages ? navigator.languages[0] : (navigator.language || navigator.userLanguage);
    this.killed = false;
    this.config = {
        map : null,
        mapCache : 1500, //old value 900
        mapGPUCache : 990, //old value 500, 360
        mapMetatileCache : 60,
        mapTexelSizeFit : 1.1,
        mapMaxHiresLodLevels : 2,
        mapDownloadThreads : 20,
        mapMaxProcessingTime : 10, //1000*20,
        mapMaxGeodataProcessingTime : 10,
        mapMobileMode : false,
        mapMobileModeAutodect : true,
        mapMobileDetailDegradation : 1,
        mapNavSamplesPerViewExtent : 4,
        mapIgnoreNavtiles : false,
        mapVirtualSurfaces : true,
        mapAllowHires : true,
        mapAllowLowres : true,
        mapAllowSmartSwitching : true,
        mapDisableCulling : false,
        mapPreciseCulling : true,
        mapHeightLodBlend : true,
        mapHeightNodeBlend : true,
        mapBasicTileSequence : false,
        mapPreciseBBoxTest : false,
        mapPreciseDistanceTest : false,
        mapHeightfiledWhenUnloaded : true,
        mapForceMetatileV3 : false,
        mapSmartNodeParsing : true,
        mapLoadErrorRetryTime : 3000,
        mapLoadErrorMaxRetryCount : 3,
        mapLoadMode : 'topdown', // 'topdown', 'downtop', 'fit', 'fitonly'
        mapGeodataLoadMode : 'fit', // 'fitonly'
        mapSplitMeshes : true, // used for topdown load mode
        mapSplitMargin : 0.0025, // used for topdown load mode
        mapSplitSpace : null, // used octant spliting demo
        mapSplitLods : false, // used octant spliting demo
        mapGridMode : 'linear', // 'flat'
        mapGridSurrogatez : false,
        mapGridUnderSurface: 0,
        mapGridTextureLevel: -1,
        mapGridTextureLayer: null, // 'bing",
        mapXhrImageLoad : true,
        mapStoreLoadStats : false,
        mapRefreshCycles : 3,
        mapSoftViewSwitch : true,
        mapSortHysteresis : true,
        mapHysteresisWait : 0,
        mapSeparateLoader : true,
        mapGeodataBinaryLoad : true,
        mapPackLoaderEvents : true,
        mapParseMeshInWorker : true,
        mapPackGeodataEvents : true,
        mapCheckTextureSize : false,
        mapTraverseToMeshNode : true,
        mapNormalizeOctantTexelSize : true,

        mapFeatureStickMode : [1,1],

        map16bitMeshes : true,
        //mapOnlyOneUVs : true,
        mapOnlyOneUVs : false,
        mapIndexBuffers : true,
        mapAsyncImageDecode : true,

        mapFeatureGridCells : 31,
        mapFeaturesPerSquareInch : 0.25, //0.6614,
        mapFeaturesSortByTop : false,

        mapFeaturesReduceMode : 'scr-count1', //have to be 'scr-count1' because of legacy https://rigel.mlwn.se/store/map-config/high-terrain/
        mapFeaturesReduceParams : null,
        mapFeaturesReduceFactor : 1,
        mapFeaturesReduceFactor2 : 1,

        mapDMapSize : 1024,
        mapDMapMode : 1,

        mapDegradeHorizon : false,
        mapDegradeHorizonParams : [1, 1500, 97500, 3500], //[1, 3000, 15000, 7000],
        mapDefaultFont : '//cdn.melown.com/libs/vtsjs/fonts/noto-basic/1.0.0/noto.fnt',
        //mapDefaultFont : '../fonts/basic.fnt',
        mapFog : true,
        mapNoTextures: false,
        mapMetricUnits : !(lang == 'en' || lang.indexOf('en-') == 0),
        mapLanguage : lang,
        mapForceFrameTime: 0,
        mapForcePipeline: 0,
        mapLogGeodataStyles: true,
        mapBenevolentMargins: false,
        mapForceCredentials: false,

        rendererDevice : 'webgl',
        rendererAnisotropic : 0,
        rendererAntialiasing : true,
        rendererAllowScreenshots : false,
        inspector : true,
        authorization : null,
        mario : false
    };

    this.configStorage = {};
    this.element = element;
    this.coreInterface = coreInterface;
    //this.options = options;
    this.ready = false;
    this.listeners = [];
    this.listenerCounter = 0;
    this.tokenCookieHost = null;
    this.tokenIFrame = null;
    this.xhrParams = {};
    this.inspector = (Inspector != null) ? (new Inspector(this)) : null;
    this.setConfigParams(config);

    this.map = null;
    this.mapInterface = null;
    this.renderer = new Renderer(this, this.element, null, this.onResize.bind(this), this.config);
    this.rendererInterface = new RendererInterface(this.renderer);
    this.proj4 = this.coreInterface.proj4 ;//Proj4;
    this.contextLost = false;

    //platform detection
    platform.init();
    this.requestAnimFrame = (
               window.requestAnimationFrame ||
               window.webkitRequestAnimationFrame ||
               window.mozRequestAnimationFrame ||
               window.oRequestAnimationFrame ||
               window.msRequestAnimationFrame ||
               function(callback) {
                   window.setTimeout(callback, 1000/60);
               });

    window.performance = window.performance || {};
    performance.now = (function() {
        return performance.now       ||
               performance.mozNow    ||
               performance.msNow     ||
               performance.oNow      ||
               performance.webkitNow ||
               function() { return new Date().getTime(); };
    })();

    this.loadMap(this.config.map);

    this.requestAnimFrame.call(window, this.onUpdate.bind(this));
};


Core.prototype.onResize = function() {
    if (this.map != null) {
        this.map.markDirty();
    }
};


Core.prototype.loadMap = function(path) {
    if (this.map != null) {
        this.destroyMap();
    }

    if (path == null) {
        return;
    }

    path = utilsUrl.getProcessUrl(path, window.location.href);

    this.tokenCookieLoaded = true;
    this.mapConfigData = null;
    this.tokenExpiration = null;
    this.tokenExpirationCallback = null;
    this.tokenExpirationLoop = false;
    this.tokenCanBeSkiped = true;
    this.mapRunnig = false;

    const onLoaded = (function() {
        if (!(this.tokenCookieLoaded || this.tokenCanBeSkiped) || !this.mapConfigData || this.mapRunnig) {
            return;
        }

        this.mapRunnig = true;
        const data = this.mapConfigData;

        this.callListener('map-mapconfig-loaded', data);

        this.map = new Map(this, data, path, this.config, this.configStorage);
        this.mapInterface = new MapInterface(this.map);
        this.setConfigParams(this.map.browserOptions, true);
        this.setConfigParams(this.configStorage);

        if (this.config.position) {
            this.map.setPosition(this.config.position);
            this.config.position = null;
        }

        if (this.config.view) {
            this.map.setView(this.config.view);
            this.config.view = null;
        }

    }).bind(this);

    const onMapConfigLoaded = (function(data) {
        this.mapConfigData = data;
        onLoaded();
    }).bind(this);

    const onMapConfigError = (function() {
    }).bind(this);

    //this.tokenLoaded = true;

    const onAutorizationLoaded = (function(data) {
        if (!data || (data && data['status'])) {
            if (this.tokenCanBeSkiped) {
                onLoadMapconfig(path);
            }
            return;
        }

        this.tokenLoaded = true;
        this.xhrParams['token'] = data['token'];
        this.xhrParams['tokenHeader'] = data['header'];
        this.tokenExpiration = data['expires'] * 1000;
        this.tokenExpirationCallback = (function(){
            //this.tokenLoaded = false;
            //this.tokenCookieLoaded = false;
            this.tokenExpiration = null;
            this.tokenExpirationLoop = true;
            if (typeof this.config.authorization === 'string') {
                utils.loadJSON(this.config.authorization, onAutorizationLoaded, onAutorizationError, null, utils.useCredentials, this.xhrParams);
            } else {
                this.config.authorization(onAutorizationLoaded);
            }
        }).bind(this);

        if (!this.tokenExpirationLoop) {
            onLoadMapconfig(path);
        }

        if (typeof this.config.authorization === 'string') {
            onLoadImageCookie(data['cookieInjector'], this.config.authorization);
        } else {
            onLoadImageCookie(data['cookieInjector'], path);
        }

    }).bind(this);

    const onAutorizationError = (function() {
        // eslint-disable-next-line
        console.log('auth token not loaded');

        if (this.tokenCanBeSkiped) {
            onLoadMapconfig(path);
        }
    }).bind(this);

    const onImageCookieLoaded = (function() {
        document.body.removeChild(this.tokenIFrame);
        this.tokenIFrame = null;
        this.tokenCookieLoaded = true;
        onLoaded();
    }).bind(this);

    /*const onImageCookieError = (function() {
        // eslint-disable-next-line
        console.log('auth cookie not loaded');
    }).bind(this);*/

    //const baseUrl = path.split('?')[0].split('/').slice(0, -1).join('/')+'/';

    const onLoadMapconfig = (function(path) {
        utils.loadJSON(path, onMapConfigLoaded, onMapConfigError, null, utils.useCredentials, this.xhrParams);
    }).bind(this);

    const onLoadImageCookie = (function(url, originUrl) {
        url = utilsUrl.getProcessUrl(url, originUrl);
        this.tokenCookieHost = utilsUrl.getHost(url);
        //utils.loadImage(url, onImageCookieLoaded, onImageCookieError);
        const iframe = document.createElement('iframe');
        this.tokenIFrame = iframe;
        iframe.onload = onImageCookieLoaded;
        iframe.src = url;
        iframe.style.display = 'none';
        document.body.appendChild(iframe);
    }).bind(this);

    //if (false && this.config.authorization) {
    if (this.config.authorization) {
        this.tokenCookieLoaded = false;

        if (typeof this.config.authorization === 'string') {
            utils.loadJSON(this.config.authorization, onAutorizationLoaded, onAutorizationError, null, utils.useCredentials, this.xhrParams);
        } else {
            this.config.authorization(onAutorizationLoaded);
        }
    } else {
        onLoadMapconfig(path);
    }
};


Core.prototype.destroy = function() {
    if (this.killed) {
        return;
    }

    this.destroyMap();
    if (this.renderer) {
        this.renderer.kill();
    }
    this.element = null;
    this.killed = true;
};


Core.prototype.destroyMap = function() {
    if (this.map) {
        this.map.kill();
        this.map = null;
        this.mapInterface = null;
        this.callListener('map-unloaded', {});
    }
};


Core.prototype.getMap = function() {
    return this.map;
};


Core.prototype.getMapInterface = function() {
    return this.mapInterface;
};


Core.prototype.getRenderer = function() {
    return this.renderer;
};


Core.prototype.getRendererInterface = function() {
    return this.rendererInterface;
};


Core.prototype.getProj4 = function() {
    return this.proj4;
};


Core.prototype.getOption = function(/*key, value*/) {
};


Core.prototype.setOption = function(/*key, value*/) {
};


Core.prototype.on = function(name, listener, wait, once) {
    if (this.killed) { // || this.renderer == null) {
        return;
    }

    if (listener == null) {
        return;
    }

    this.listenerCounter++;
    this.listeners.push({ name : name, listener : listener, id : this.listenerCounter, once: once, wait: wait ? wait : 0 });

    return (function(id){ this.removeListener(id); }).bind(this, this.listenerCounter);
};


Core.prototype.once = function(name, listener, wait) {
    this.on(name, listener, wait, true);
};


// private
Core.prototype.callListener = function(name, event, log) {
    for (let i = 0; i < this.listeners.length; i++) {
        if (this.listeners[i].name == name) {
            const listener = this.listeners[i];

            if (listener.wait > 0) {
                listener.wait--;
            } else {
                listener.listener(event);
                if (listener.once) {
                    this.listeners.splice(i, 1);
                    i--;
                }
            }
        }
    }

    if (log) {
        // eslint-disable-next-line
        console.log('event ' + name + ': ' + JSON.stringify(event));
    }
};

// private
Core.prototype.removeListener = function(id) {
    for (let i = 0; i < this.listeners.length; i++) {
        if (this.listeners[i].id == id) {
            //this.listeners[i].splice(i, 1);
            this.listeners.splice(i, 1);
            return;
        }
    }
};

Core.prototype.markDirty = function() {
    if (this.map != null) {
        this.map.markDirty();
    }
};

Core.prototype.onUpdate = function() {
    if (this.killed || this.contextLost) {
        return;
    }

    if (this.map != null) {
        if (!this.map.srsReady && this.map.isReferenceFrameReady()) {
            this.map.srsReady = true;
            this.callListener('map-loaded', { 'browserOptions':this.map.browserOptions});
        }

        this.map.update();
    }

    //TODO: detect view change
    //this.callListener("view-update", {"position": position, "orientaion":orientation,
    //                                  "fov": renderer.camera.getFov()});

    //this.callListener("render-update", { "dirty": true, "message": "DOM element does not exist" });

    this.callListener('tick', {});

    this.requestAnimFrame.call(window, this.onUpdate.bind(this));
};


Core.prototype.setConfigParams = function(params, solveStorage) {
    if (typeof params === 'object' && params !== null) {
        for (let key in params) {
            this.setConfigParam(key, params[key], solveStorage);
        }
    }
};


Core.prototype.setConfigParam = function(key, value, solveStorage) {
    switch(key) {
    case 'pos':
    case 'position':
    case 'view':

        if (this.getMap()) {
            if (key == 'view') {
                this.getMap().setView(value);
            } else {
                this.getMap().setPosition(new MapPosition(value));
            }
            if (this.configStorage[key]) {
                delete this.configStorage[key];
            }
        } else {
            this.configStorage[key] = value;
        }
        break;

    case 'map':
        this.config.map = utils.validateString(value, null); break;
    case 'mapVirtualSurfaces':
        this.config.mapVirtualSurfaces = utils.validateBool(value, true); break;
    case 'mapForcePipeline':
        this.config.mapForcePipeline = utils.validateNumber(value, -1, Number.MAXINTEGER, 0); break;
    case 'mapDMapSize':
        this.config.mapDMapSize = utils.validateNumber(value, 16, Number.MAXINTEGER, 512); break;
    case 'mapDMapMode':
        this.config.mapDMapMode = utils.validateNumber(value, 1, Number.MAXINTEGER, 1); break;
    case 'map16bitMeshes':
        this.config.map16bitMeshes = utils.validateBool(value, false); break;
    case 'mapForceCredentials':
        this.config.mapForceCredentials = utils.validateBool(value, false); utils.forceCredentials = this.config.mapForceCredentials; break
    case 'inspector':
        this.config.inspector = utils.validateBool(value, true); break;
    case 'authorization':
        this.config.authorization = ((typeof value === 'string') || (typeof value === 'function')) ? value : null;
         break;
    default:
        if (key.indexOf('map') == 0 || key == 'mario') {

            if (!solveStorage || (typeof this.configStorage[key] === 'undefined')) {
                this.configStorage[key] = value;
            }

            if (this.getMap() != null) {
                this.getMap().setConfigParam(key, value);
            }
        }

        if (key.indexOf('renderer') == 0) {
            if (!solveStorage || (typeof this.configStorage[key] === 'undefined')) {
                this.configStorage[key] = value;
            }

            this.setRendererConfigParam(key, value);
        }

        if (key.indexOf('debug') == 0) {
            this.configStorage[key] = value;
            if (this.getMap() != null) {
                this.inspector.setParameter(key, value);
            }
        }

        break;
    }

};


Core.prototype.getConfigParam = function(key) {
    if (key == 'map') {
        return this.config.map;
    } else if (key == 'inspector') {
        return this.config.inspector;
    } else {
        if (key.indexOf('map') == 0 && this.getMap() != null) {
            return this.getMap().getConfigParam(key);
        }

        if (key.indexOf('renderer') == 0) {
            return this.getRendererConfigParam(key);
        }
    }
};


Core.prototype.setRendererConfigParam = function(key, value) {
    switch (key) {
    case 'rendererDevice':             this.config.rendererDevice = utils.validateString(value, 'webgl'); break;
    case 'rendererAnisotropic':        this.config.rendererAnisotropic = utils.validateNumber(value, -1, 2048, 0); if (this.rederer) this.rederer.gpu.setAniso(this.config.rendererAnisotropic); break;
    case 'rendererAntialiasing':       this.config.rendererAntialiasing = utils.validateBool(value, true); break;
    case 'rendererAllowScreenshots':   this.config.rendererAllowScreenshots = utils.validateBool(value, false); break;
    }
};


Core.prototype.getRendererConfigParam = function(key) {
    switch (key) {
    case 'rendererDevice':             return this.config.rendererDevice;
    case 'rendererAnisotropic':        return this.config.rendererAnisotropic;
    case 'rendererAntialiasing':       return this.config.rendererAntialiasing;
    case 'rendererAllowScreenshots':   return this.config.rendererAllowScreenshots;
    }
};

/*
string getCoreVersion()

    Returns string with VTS version
*/

function getCoreVersion(full) {
    return (full ? 'Core: ' : '') + '2.30.8';
}


/*
bool checkSupport()

    Returns true if the environment is capable of running the WebGL browser, false otherwise.
*/

function checkSupport() {
    platform.init();

    //is webgl supported
    const canvas = document.createElement('canvas');

    if (canvas == null) {
        return false;
    }

    canvas.width = 1024;
    canvas.height = 768;

    if (canvas.getContext == null) {
        return false;
    }

    let gl = null;

    try {
        gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    } catch(e) {
        return false;
    }

    if (!gl) {
        return false;
    }

    return true;
}





/***/ }),

/***/ "./src/core/inspector/graphs.js":
/*!**************************************!*\
  !*** ./src/core/inspector/graphs.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const InspectorGraphs = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorGraphs.prototype.init = function() {
    const inspector = this.inspector;

    inspector.addStyle( ''
        + '#vts-graphs-panel {'
            + 'position:absolute;'
            + 'left:10px;'
            + 'top:10px;'
            + 'z-index: 7;'
            + 'background-color: #FFFFFF;'
            + 'padding: 5px;'
            + 'border-radius: 4px;'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'color:#000000;'
            + 'text-align: left;'
            + 'font-size: 12px;'
            + 'display:none;'
        + '}'

        + '.vts-graphs-canvas {'
            + 'border: solid 1px #bbb;'
            + 'image-rendering : pixelated;'
        + '}'

        + '.vts-graphs-info {'
            + 'padding: 5px 2px;'
            + 'font-size: 10px;'
        + '}'

        + '.vts-graphs-button {'
            + 'padding: 2px 5px;'
            + 'display:inline-block;'
            + 'margin-right: 4px;'
            + 'border-radius: 4px;'
            + 'cursor:pointer;'
        + '}'

        + '.vts-graphs-button:hover {'
            + 'box-shadow: 0 0 1px #0066ff;'
        + '}'
    );

    this.element = document.createElement('div');
    this.element.id = 'vts-graphs-panel';
    this.element.innerHTML = ''
        + '<canvas id="vts-graphs-render" class="vts-graphs-canvas" width="900" height="100" ></canvas>'
        + '<div id="vts-graphs-info" class="vts-graphs-info" >&FilledSmallSquare; Frame: 1234 &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Render: 1234 &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: 1234 &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Mesh: 1234 &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> GpuMesh: 1234</div>'
        + '<canvas id="vts-graphs-cache" class="vts-graphs-canvas" width="900" height="100" ></canvas>'
        + '<div id="vts-graphs-info2" class="vts-graphs-info" >&FilledSmallSquare; Cache: 1234 &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Used: 123 &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: 1234 &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> Mesh: &nbsp 1234</div>'
        + '<div id="vts-graphs-rec" class="vts-graphs-button" >Recording On</div>'
        + '<div id="vts-graphs-ref" class="vts-graphs-button" >Refresh On</div>'
        + '<div id="vts-graphs-res" class="vts-graphs-button" >Reset</div>'
        + '<div id="vts-graphs-zoom" class="vts-graphs-button" >Scale: Max value</div>'
        + '<div id="vts-graphs-magnify" class="vts-graphs-button" >Magnify Off</div>'
        + '<div id="vts-graphs-graph" class="vts-graphs-button" >Graph: Cache</div>';

    this.core.element.appendChild(this.element);
    this.canvasRender = document.getElementById('vts-graphs-render');
    this.canvasCache = document.getElementById('vts-graphs-cache');
    this.canvasRenderCtx = this.canvasRender.getContext('2d');
    this.canvasCacheCtx = this.canvasCache.getContext('2d');

    document.getElementById('vts-graphs-rec').onclick = this.recordingPressed.bind(this);

    document.getElementById('vts-graphs-rec').onclick = this.recordingPressed.bind(this);
    document.getElementById('vts-graphs-ref').onclick = this.refreshPressed.bind(this);
    document.getElementById('vts-graphs-res').onclick = this.resetPressed.bind(this);
    document.getElementById('vts-graphs-zoom').onclick = this.zoomPressed.bind(this);
    document.getElementById('vts-graphs-magnify').onclick = this.magnifyPressed.bind(this);
    document.getElementById('vts-graphs-graph').onclick = this.graphPressed.bind(this);

    document.getElementById('vts-graphs-render').onmousemove = this.onMouseMove.bind(this);
    document.getElementById('vts-graphs-render').onmouseout = this.onMouseOut.bind(this);
    document.getElementById('vts-graphs-cache').onmousemove = this.onMouseMove.bind(this);
    document.getElementById('vts-graphs-cache').onmouseout = this.onMouseOut.bind(this);

    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);
    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);

    this.zoom = 'max';
    this.graph = 'Cache';
    this.refresh = true;

    this.panelVisible = false;
};


InspectorGraphs.prototype.showPanel = function() {
    this.element.style.display = 'block';
    this.panelVisible = true;
    this.recordingPressed(true);
};


InspectorGraphs.prototype.hidePanel = function() {
    this.element.style.display = 'none';
    this.panelVisible = false;
    this.recordingPressed(true);
};


InspectorGraphs.prototype.switchPanel = function() {
    if (this.panelVisible) {
        this.hidePanel();
    } else {
        this.showPanel();
    }
};


InspectorGraphs.prototype.recordingPressed = function(state) {
    const map = this.core.getMap();

    if (!map) {
        return;
    }

    map.stats.recordGraphs = (state == null) ? state : !map.stats.recordGraphs;
    this.updateGraphsPanel();
    this.updateGraphs(null, true);
};


InspectorGraphs.prototype.refreshPressed = function() {
    this.refresh = !this.refresh;
    this.updateGraphsPanel();
    this.updateGraphs();
};


InspectorGraphs.prototype.resetPressed = function() {
    const map = this.core.getMap();

    if (!map) {
        return;
    }

    map.stats.resetGraphs();
    this.updateGraphs(null, true);
};


InspectorGraphs.prototype.zoomPressed = function() {
    switch (this.zoom) {
    case 'max':     this.zoom = '120avrg'; break;
    case '120avrg': this.zoom = '180avrg'; break;
    case '180avrg': this.zoom = 'max'; break;
    }

    this.updateGraphsPanel();
    this.updateGraphs();
};


InspectorGraphs.prototype.graphPressed = function() {
    switch (this.graph) {
    case 'Cache':      this.graph = 'Polygons'; break;
    case 'Polygons':   this.graph = 'Processing'; break;
    case 'Processing': this.graph = 'LODs'; break;
    case 'LODs':       this.graph = 'Flux'; break;
    case 'Flux':       this.graph = 'Cache'; break;
    }

    this.updateGraphsPanel();
    this.updateGraphs();
};


InspectorGraphs.prototype.magnifyPressed = function() {
    this.magnify = !this.magnify;

    if (this.magnify) {
        this.canvasRender.style.width = '1400px';
        this.canvasRender.style.height = '200px';
        this.canvasCache.style.width = '1400px';
        this.canvasCache.style.height = '200px';
        document.getElementById('vts-graphs-magnify').innerHTML = 'Magnify On';
    } else {
        this.canvasRender.style.width = '900px';
        this.canvasRender.style.height = '100px';
        this.canvasCache.style.width = '900px';
        this.canvasCache.style.height = '100px';
        document.getElementById('vts-graphs-magnify').innerHTML = 'Magnify Off';
    }

    this.updateGraphsPanel();
    this.updateGraphs();
};


InspectorGraphs.prototype.updateGraphsPanel = function() {
    const map = this.core.getMap();

    if (!map) {
        return;
    }

    if (map.stats.recordGraphs) {
        document.getElementById('vts-graphs-rec').innerHTML = 'Recording On';
    } else {
        document.getElementById('vts-graphs-rec').innerHTML = 'Recording Off';
    }

    if (this.refresh) {
        document.getElementById('vts-graphs-ref').innerHTML = 'Refresh On';
    } else {
        document.getElementById('vts-graphs-ref').innerHTML = 'Refresh Off';
    }

    switch (this.zoom) {
    case 'max':
        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: Max value';
        break;

    case '120avrg':
        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: 100% Avrg';
        break;

    case '180avrg':
        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: 50% Avrg';
        break;
    }

    document.getElementById('vts-graphs-graph').innerHTML = 'Graph: ' + this.graph;
};


InspectorGraphs.prototype.onMouseMove = function(event) {
    let x = event.clientX - this.canvasRender.getBoundingClientRect().left;
    this.showCursor = true;

    if (this.magnify) {
        x = Math.floor(x * 900/1400);
    }

    this.cursorIndex = x;

    const map = this.core.getMap();
    if (!map) {
        return;
    }

    if (!map.stats.recordGraphs) {
        this.updateGraphs(null);
    }
};


InspectorGraphs.prototype.onMouseOut = function() {
    this.showCursor = false;
    this.updateGraphs(null);
};


InspectorGraphs.prototype.updateGraphs = function(stats, ignoreRefresh) {
    const map = this.core.getMap();

    if (!map || (!this.refresh && !ignoreRefresh) || !this.panelVisible) {
        return;
    }

    stats = stats || map.stats;

    let width = this.canvasRender.width;
    let height = this.canvasRender.height;
    let ctx = this.canvasRenderCtx;

    const samples = stats.graphsTimeSamples;
    const samplesIndex = stats.graphsTimeIndex;

    let factorX = width / samples;

    ctx.clearRect(0, 0, width, height);

    let maxValue = 0;
    let totalFrame = 0;
    let totalRender = 0;
    let totalTexture = 0;
    let totalMeshes = 0;
    let totalGpuMeshes = 0;
    let realCount = 0, i, j, lj;
    let index, value, values, str, y, factorY, max, min;

    let valuesFrame = stats.graphsFrameTimes;
    let valuesRender = stats.graphsRenderTimes;
    let valuesTextures = stats.graphsCreateTextureTimes;
    let valuesMeshes = stats.graphsCreateMeshTimes;
    let valuesGpuMeshes = stats.graphsCreateGpuMeshTimes;
    let valuesGeodata;

    for (i = 0; i < samples; i++) {
        totalFrame += valuesFrame[i];
        totalRender += valuesRender[i];
        totalTexture += valuesTextures[i];
        totalMeshes += valuesMeshes[i];
        totalGpuMeshes += valuesGpuMeshes[i];

        const v = valuesFrame[i];

        if (v > maxValue) {
            maxValue = v;
        }

        if (v > 0) {
            realCount++;
        }
    }

    if (this.zoom == '120avrg') {
        maxValue = (totalFrame / realCount) * 1.0;
    }

    if (this.zoom == '180avrg') {
        maxValue = (totalFrame / realCount) * 0.5;
    }

    factorY = height / maxValue;

    for (i = 0; i < samples; i++) {
        index = samplesIndex + i;
        index %= samples;

        ctx.fillStyle='#000000';
        ctx.fillRect(i*factorX, height, 1, -(valuesFrame[index])*factorY);
        ctx.fillStyle='#ff0000';
        ctx.fillRect(i*factorX, height, 1, -(valuesRender[index])*factorY);

        ctx.fillStyle='#0000ff';
        ctx.fillRect(i*factorX, height, 1, -(valuesTextures[index])*factorY);

        y = height -(valuesTextures[index])*factorY;

        ctx.fillStyle='#007700';
        ctx.fillRect(i*factorX, y, 1, -(valuesMeshes[index])*factorY);

        y -= (valuesMeshes[index])*factorY;

        ctx.fillStyle='#00ff00';
        ctx.fillRect(i*factorX, y, 1, -(valuesGpuMeshes[index])*factorY);

    }

    if (this.showCursor) {
        ctx.fillStyle='#aa00aa';
        index = (this.cursorIndex) % samples;
        ctx.fillRect(Math.floor(index*factorX)-1, 0, 1, height);
        ctx.fillRect(Math.floor(index*factorX)+1, 0, 1, height);
        index = (this.cursorIndex + samplesIndex) % samples;

        str = '&FilledSmallSquare; Frame: ' + valuesFrame[index].toFixed(2) +
              ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Render: ' + valuesRender[index].toFixed(2) +
              ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: ' + valuesTextures[index].toFixed(2) +
              ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Meshes: ' + valuesMeshes[index].toFixed(2) +
              ' &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> GpuMeshes: ' + valuesGpuMeshes[index].toFixed(2) + '</div>';
    } else {
        str = '&FilledSmallSquare; Frame: ' + Math.round(totalFrame) +
              ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Render: ' + Math.round(totalRender) +
              ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: ' + Math.round(totalTexture) +
              ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Meshes: ' + Math.round(totalMeshes) +
              ' &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> GpuMeshes: ' + Math.round(totalGpuMeshes) +'</div>';
    }

    document.getElementById('vts-graphs-info').innerHTML = str;

    width = this.canvasCache.width;
    height = this.canvasCache.height;
    ctx = this.canvasCacheCtx;

    factorX = width / samples;

    ctx.clearRect(0, 0, width, height);

    switch (this.graph) {
    case 'Cache':
        {
            factorY = height / ((map.gpuCache.maxCost+map.resourcesCache.maxCost+map.metatileCache.maxCost));

            let maxMetatiles = 0;
            let maxResources = 0;
            let maxTextures = 0;
            let maxMeshes = 0;
            let maxGeodata = 0;
            let maxGpu = 0;

            let valuesMetatiles = stats.graphsCpuMemoryMetatiles;
            let valuesResources = stats.graphsCpuMemoryUsed;
            let valuesGpu = stats.graphsGpuMemoryRender;
            valuesGeodata = stats.graphsGpuMemoryGeodata;
            valuesTextures = stats.graphsGpuMemoryTextures;
            valuesMeshes = stats.graphsGpuMemoryMeshes;

            for (i = 0; i < samples; i++) {
                maxMetatiles = valuesMetatiles[i] > maxMetatiles ? valuesMetatiles[i] : maxMetatiles;
                maxResources = valuesResources[i] > maxResources ? valuesResources[i] : maxResources;
                maxTextures = valuesTextures[i] > maxTextures ? valuesTextures[i] : maxTextures;
                maxMeshes = valuesMeshes[i] > maxMeshes ? valuesMeshes[i] : maxMeshes;
                maxGeodata = valuesGeodata[i] > maxGeodata ? valuesGeodata[i] : maxGeodata;
                maxGpu = valuesGpu[i] > maxGpu ? valuesGpu[i] : maxGpu;
            }

            for (i = 0; i < samples; i++) {
                index = samplesIndex + i;
                index %= samples;

                value = valuesMetatiles[index] + valuesMeshes[index] + valuesTextures[index] + valuesGeodata[index] + valuesResources[index];
                ctx.fillStyle='#000000';
                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);
                value -= valuesResources[index];

                ctx.fillStyle='#0000ff';
                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);
                value -= valuesTextures[index];

                ctx.fillStyle='#009999';
                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);
                value -= valuesGeodata[index];

                ctx.fillStyle='#007700';
                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);
                value -= valuesMeshes[index];

                ctx.fillStyle='#ff0000';
                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);

                value = valuesGpu[index];
                ctx.fillStyle='#ffff00';
                ctx.fillRect(i*factorX, height -(value)*factorY, 1, 1);
            }

            if (this.showCursor) {
                index = (this.cursorIndex + samplesIndex) % samples;
                str = '<span style="color:#555">&FilledSmallSquare;</span> Total: ' + Math.ceil((valuesMetatiles[index] + valuesResources[index] + valuesTextures[index] + valuesMeshes[index])/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#000000">&FilledSmallSquare;</span> CPU: ' + Math.ceil(valuesResources[index]/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#000000">&FilledSmallSquare;</span> GPU: ' + Math.ceil((valuesTextures[index] + valuesMeshes[index])/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Te: ' + Math.ceil(valuesTextures[index]/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Me: ' + Math.ceil(valuesMeshes[index]/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#009999">&FilledSmallSquare;</span> Ge: ' + Math.ceil(valuesGeodata[index]/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Met: ' + Math.ceil(valuesMetatiles[index]/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#ffff00">&FilledSmallSquare;</span> Render: ' + Math.ceil(valuesGpu[index]/(1024*1024)) + 'MB' +'</div>';
            } else {
                str = '<span style="color:#555">&FilledSmallSquare;</span> Total: ' + Math.round((maxMetatiles + maxResources + maxTextures + maxMeshes)/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#000000">&FilledSmallSquare;</span> CPU: ' + Math.ceil(maxResources/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#000000">&FilledSmallSquare;</span> GPU: ' + Math.ceil((maxTextures + maxMeshes)/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Te ' + Math.ceil(maxTextures/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Me: ' + Math.ceil(maxMeshes/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#009999">&FilledSmallSquare;</span> Ge: ' + Math.ceil(maxGeodata/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Met: ' + Math.ceil(maxMetatiles/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#ffff00">&FilledSmallSquare;</span> Render: ' + Math.ceil(maxGpu/(1024*1024)) + 'MB' +'</div>';
            }

        }
        break;


    case 'Polygons':
    case 'Processing':
        {
            max = 0;
            min = 99999999999;
            realCount = 0;
            values = (this.graph == 'Polygons') ? stats.graphsPolygons : stats.graphsBuild;
            let total = 0;

            for (i = 0; i < samples; i++) {
                max = values[i] > max ? values[i] : max;

                if (values[i] > 0) {
                    min = values[i] < min ? values[i] : min;
                    total += values[i];
                    realCount++;
                }
            }

            factorY = height / max;

            for (i = 0; i < samples; i++) {
                index = samplesIndex + i;
                index %= samples;

                ctx.fillStyle='#007700';
                ctx.fillRect(i*factorX, height, 1, -(values[index])*factorY);
            }

            if (this.showCursor) {
                index = (this.cursorIndex + samplesIndex) % samples;
                str = '<span style="color:#007700">&FilledSmallSquare;</span> ' + this.graph + ' Max: ' + Math.round(values[index]) +'</div>';
            } else {
                str = '<span style="color:#007700">&FilledSmallSquare;</span> ' + this.graph + ' Max: ' + max +'</div>';
                str += ' &nbsp Min: ' + min;
                str += ' &nbsp Avrg: ' + Math.round(total / realCount) +'</div>';
            }
        }
        break;


    case 'LODs':
        {
            max = 0;
            values = stats.graphsLODs;

            for (i = 0; i < samples; i++) {
                max = values[i][0] > max ? values[i][0] : max;
            }

            factorY = height / max;

            ctx.fillStyle='#000000';
            ctx.fillRect(0, 0, width, height);

            let lods;

            for (i = 0; i < samples; i++) {
                index = samplesIndex + i;
                index %= samples;

                //ctx.fillStyle="#000000";
                //ctx.fillRect(i*factorX, height, 1, -(values[index][0])*factorY);

                y = height;

                lods = values[index][1];

                for (j = 0, lj = lods.length; j < lj; j++) {
                    if (lods[j]) {
                        ctx.fillStyle='hsl('+((j*23)%360)+',100%,50%)';
                        value = Math.round((lods[j])*factorY);
                        ctx.fillRect(i*factorX, y, 1, -value);
                        y -= value;
                    }
                }

            }

            if (this.showCursor) {
                index = (this.cursorIndex + samplesIndex) % samples;

                str = 'LODs:' + values[index][0];
                lods = values[index][1];

                for (j = 0, lj = lods.length; j < lj; j++) {
                    if (lods[j]) {
                        str += '<span style="color:hsl('+((j*23)%360)+',100%,50%)">&FilledSmallSquare;</span>'+j+':'+lods[j];
                    }
                }

            } else {
                str = 'LODs:' + values[index][0];
            }

            str += '</div>';
        }
        break;

    case 'Flux':
        {
            let maxCount = 0;
            let maxSize = 0;

            let maxTexPlusCount = 0;
            let maxTexPlusSize = 0;
            let maxTexMinusCount = 0;
            let maxTexMinusSize = 0;

            let maxMeshPlusCount = 0;
            let maxMeshPlusSize = 0;
            let maxMeshMinusCount = 0;
            let maxMeshMinusSize = 0;

            let maxGeodataPlusCount = 0;
            let maxGeodataPlusSize = 0;
            let maxGeodataMinusCount = 0;
            let maxGeodataMinusSize = 0;

            valuesTextures = stats.graphsFluxTextures;
            valuesMeshes = stats.graphsFluxMeshes;
            valuesGeodata = stats.graphsFluxGeodatas;

            for (i = 0; i < samples; i++) {
                let tmp = valuesTextures[i][0][0] + valuesMeshes[i][0][0];
                maxCount = tmp > maxCount ? tmp : maxCount;
                tmp = valuesTextures[i][1][0] + valuesMeshes[i][1][0];
                maxCount = tmp > maxCount ? tmp : maxCount;

                tmp = valuesTextures[i][0][1] + valuesMeshes[i][0][1];
                maxSize = tmp > maxSize ? tmp : maxSize;
                tmp = valuesTextures[i][1][1] + valuesMeshes[i][1][1];
                maxSize = tmp > maxSize ? tmp : maxSize;

                maxTexPlusCount = valuesTextures[i][0][0] > maxTexPlusCount ? valuesTextures[i][0][0] : maxTexPlusCount;
                maxTexPlusSize = valuesTextures[i][0][1] > maxTexPlusSize ? valuesTextures[i][0][1] : maxTexPlusSize;
                maxTexMinusCount = valuesTextures[i][1][0] > maxTexMinusCount ? valuesTextures[i][1][0] : maxTexMinusCount;
                maxTexMinusSize = valuesTextures[i][1][1] ? valuesTextures[i][1][1] : maxTexMinusSize;

                maxMeshPlusCount = valuesMeshes[i][0][0] > maxMeshPlusCount ? valuesMeshes[i][0][0] : maxMeshPlusCount;
                maxMeshPlusSize = valuesMeshes[i][0][1] > maxMeshPlusSize ? valuesMeshes[i][0][1] : maxMeshPlusSize;
                maxMeshMinusCount = valuesMeshes[i][1][0] > maxMeshMinusCount ? valuesMeshes[i][1][0] : maxMeshMinusCount;
                maxMeshMinusSize = valuesMeshes[i][1][1] > maxMeshMinusSize ? valuesMeshes[i][1][1] : maxMeshMinusSize;

                maxGeodataPlusCount = valuesGeodata[i][0][0] > maxGeodataPlusCount ? valuesGeodata[i][0][0] : maxGeodataPlusCount;
                maxGeodataPlusSize = valuesGeodata[i][0][1] > maxGeodataPlusSize ? valuesGeodata[i][0][1] : maxGeodataPlusSize;
                maxGeodataMinusCount = valuesGeodata[i][1][0] > maxGeodataMinusCount ? valuesGeodata[i][1][0] : maxGeodataMinusCount;
                maxGeodataMinusSize = valuesGeodata[i][1][1] > maxGeodataMinusSize ? valuesGeodata[i][1][1] : maxGeodataMinusSize;
            }

            factorY = (height*0.25-2) / maxCount;
            let factorY2 = (height*0.25-2) / maxSize;

            let base = Math.floor(height*0.25);
            let base2 = Math.floor(height*0.75);

            for (i = 0; i < samples; i++) {
                index = samplesIndex + i;
                index %= samples;

                let y1Up = base;
                let y1Down = base+1;
                let y2Up = base2;
                let y2Down = base2+1;

                ctx.fillStyle='#0000aa';
                ctx.fillRect(i*factorX, y1Up, 1, -(valuesTextures[index][0][0])*factorY);
                ctx.fillRect(i*factorX, y1Down, 1, (valuesTextures[index][1][0])*factorY);

                ctx.fillRect(i*factorX, y2Up, 1, -(valuesTextures[index][0][1])*factorY2);
                ctx.fillRect(i*factorX, y2Down, 1, (valuesTextures[index][1][1])*factorY2);

                y1Up -= (valuesTextures[index][0][0])*factorY;
                y1Down += (valuesTextures[index][1][0])*factorY;
                y2Up -= (valuesTextures[index][0][1])*factorY2;
                y2Down += (valuesTextures[index][1][1])*factorY2;

                ctx.fillStyle='#007700';
                ctx.fillRect(i*factorX, y1Up, 1, -(valuesMeshes[index][0][0])*factorY);
                ctx.fillRect(i*factorX, y1Down, 1, (valuesMeshes[index][1][0])*factorY);

                ctx.fillRect(i*factorX, y2Up, 1, -(valuesMeshes[index][0][1])*factorY2);
                ctx.fillRect(i*factorX, y2Down, 1, (valuesMeshes[index][1][1])*factorY2);

                y1Up -= (valuesMeshes[index][0][0])*factorY;
                y1Down += (valuesMeshes[index][1][0])*factorY;
                y2Up -= (valuesMeshes[index][0][1])*factorY2;
                y2Down += (valuesMeshes[index][1][1])*factorY2;

                ctx.fillStyle='#009999';
                ctx.fillRect(i*factorX, y1Up, 1, -(valuesGeodata[index][0][0])*factorY);
                ctx.fillRect(i*factorX, y1Down, 1, (valuesGeodata[index][1][0])*factorY);

                ctx.fillRect(i*factorX, y2Up, 1, -(valuesGeodata[index][0][1])*factorY2);
                ctx.fillRect(i*factorX, y2Down, 1, (valuesGeodata[index][1][1])*factorY2);

                ctx.fillStyle='#aaaaaa';
                ctx.fillRect(0, Math.floor(height*0.5), width, 1);
                ctx.fillStyle='#dddddd';
                ctx.fillRect(0, base, width, 1);
                ctx.fillRect(0, base2, width, 1);
            }


            if (this.showCursor) {
                index = (this.cursorIndex + samplesIndex) % samples;
                str = '<span style="color:#007700">&FilledSmallSquare;</span> Textures Count +/-: ' + valuesTextures[index][0][0] + '/' + valuesTextures[index][1][0];
                str += ' &nbsp Size +/-: ' + (valuesTextures[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesTextures[index][1][1]/1024/1024).toFixed(2);
                str += ' &nbsp <span style="color:#0000aa">&FilledSmallSquare;</span> Meshes Count +/-: ' + valuesMeshes[index][0][0] + '/' + valuesMeshes[index][1][0];
                str += ' &nbsp Size +/-: ' + (valuesMeshes[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesMeshes[index][1][1]/1024/1024).toFixed(2);
                str += ' &nbsp <span style="color:#009999">&FilledSmallSquare;</span> Geodata Count +/-: ' + valuesGeodata[index][0][0] + '/' + valuesGeodata[index][1][0];
                str += ' &nbsp Size +/-: ' + (valuesGeodata[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesGeodata[index][1][1]/1024/1024).toFixed(2);
                str += '</div>';
            } else {
                str = '<span style="color:#007700">&FilledSmallSquare;</span> Textures Count +/-: ' + maxTexPlusCount + '/' + maxTexMinusCount;
                str += ' &nbsp Size +/-: ' + (maxTexPlusSize/1024/1024).toFixed(2) + '/' + (maxTexMinusSize/1024/1024).toFixed(2);
                str += ' &nbsp <span style="color:#0000aa">&FilledSmallSquare;</span> Meshes Count +/-: ' + maxMeshPlusCount + '/' + maxMeshMinusCount;
                str += ' &nbsp Size +/-: ' + (maxMeshPlusSize/1024/1024).toFixed(2) + '/' + (maxMeshMinusSize/1024/1024).toFixed(2);
                str += ' &nbsp <span style="color:#009999">&FilledSmallSquare;</span> Geodata Count +/-: ' + maxGeodataPlusCount + '/' + maxGeodataMinusCount;
                str += ' &nbsp Size +/-: ' + (maxGeodataPlusSize/1024/1024).toFixed(2) + '/' + (maxGeodataMinusSize/1024/1024).toFixed(2);
                str += '</div>';
            }

        }
        break;

    }

    if (this.showCursor) {
        ctx.fillStyle='#aa00aa';
        index = (this.cursorIndex) % samples;
        ctx.fillRect(Math.floor(index*factorX)-1, 0, 1, height);
        ctx.fillRect(Math.floor(index*factorX)+1, 0, 1, height);
    }

    document.getElementById('vts-graphs-info2').innerHTML = str;
};


/* harmony default export */ __webpack_exports__["default"] = (InspectorGraphs);


/***/ }),

/***/ "./src/core/inspector/input.js":
/*!*************************************!*\
  !*** ./src/core/inspector/input.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


const InspectorInput = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorInput.prototype.init = function() {
    //mouse events
    //document.addEventListener("click", this.onKeyClick.bind(this), false);

    //keyboard events
    document.addEventListener('keyup', this.onKeyUp.bind(this), false);
    document.addEventListener('keypress', this.onKeyPress.bind(this), false);
    document.addEventListener('keydown', this.onKeyDown.bind(this), false);
};


//keyboard events
InspectorInput.prototype.onKeyDown = function(event) {
    if (typeof event == 'undefined') {
        event = window.event;
    }

    this.altDown = event.altKey;
    this.ctrlDown = event.ctrlKey;
    this.shiftDown = event.shiftKey;

    this.onKeyUp(event, true);
};


InspectorInput.prototype.onKeyPress = function(event) {
    this.onKeyUp(event, true);
};


InspectorInput.prototype.onKeyUp = function(event, press) {
    if (typeof event == 'undefined') {
        event = window.event;
    }

    const map = this.core.getMap();
    const inspector = this.inspector;

    if (!map) {
        return;
    }

    const debug = map.draw.debug;

    this.altDown = event.altKey;
    this.ctrlDown = event.ctrlKey;
    this.shiftDown = event.shiftKey;

    let hit = false;
    let blockHit = true;

    if (event) {
        let keyCode;

        if (window.event) {         // eg. IE
            keyCode = window.event.keyCode;
        } else if (event.which) {   // eg. Firefox
            keyCode = event.which;
        } else {
            keyCode = event.charCode;
        }

        if (this.shiftDown) {
            if (this.ctrlDown) {
                switch(keyCode) {
                case 68:
                case 100:
                    inspector.preventDefault(event); break;  //key D pressed
                }
            }
        }

        if (this.shiftDown && press !== true) {

            switch(keyCode) {
            case 76:
            case 108:
                /*this.showMenu(); this.toolbarItemSelected('link'); done();*/  break;  //key L pressed

            case 71:
            case 103:
                /*this.showMenu(); this.toolbarItemSelected('position'); done();*/ break; //key G pressed
            }

            if (this.ctrlDown) {

                switch(keyCode) {
                case 68:
                case 100:

                    inspector.enableInspector();
                    this.diagnosticMode = true; hit = true; break;  //key D pressed
                }
            }

            if (this.diagnosticMode) {
                blockHit = true;

                switch(keyCode) {

                case 67:
                case 99:
                        inspector.shakeCamera = !inspector.shakeCamera;

                        //map.config.mapDegradeHorizon = !map.config.mapDegradeHorizon;
                        //this.measureMode = !this.measureMode;
                        //this.measurePoints = [];
                        //const pos = this.core.hitTest(this.mouseX, this.mouseY, "all");
                        //console.log("hit pos: " + pos[0] + " " + pos[1] + " " + pos[2] + " " + pos[3] + " d " + pos[4]); //key T pressed

                    break; //key C pressed

                case 49: /*this.core.setControlMode("manual"); done();*/  break;  //key 1 pressed
                case 50: /*this.core.setControlMode("drone"); done();*/   break;  //key 2 pressed
                case 51: /*this.core.setControlMode("observer"); done();*/ break; //key 3 pressed

                case 48:  //key 0 pressed
                        /*this.core.setOption("noForwardMovement" , !this.core.getOption("noForwardMovement"));*/
                    break;

                    //case 84: //key T pressed
                    //case 116:
                        /*const pos = this.core.hitTest(this.mouseX, this.mouseY, "all");
                        console.log("hit pos: " + pos[0] + " " + pos[1] + " " + pos[2] + " " + pos[3] + " d " + pos[4]); //key T pressed
                        this.core.logTile(pos);*/
                        //break;

                case 72:
                case 104:
                    debug.heightmapOnly = !debug.heightmapOnly;

                        /*
                        const pos = map.getPosition();
                        pos.setHeight(pos.setHeight() * 0.9);
                        map.setPosition(pos);*/

                    break;  //key H pressed

                case 81:
                case 113:
                    {
                        const pos = map.getPosition();
                        // eslint-disable-next-line
                        console.log('pos-before: ' + JSON.stringify(pos.pos));
                        map.convert.convertPositionViewMode(pos, (pos.getViewMode() == 'obj') ? 'subj' : 'obj');
                        // eslint-disable-next-line
                        console.log('new mode: ' + pos.getViewMode());
                        // eslint-disable-next-line
                        console.log('pos-after: ' + JSON.stringify(pos.pos));
                        map.setPosition(pos);
                        /*this.core.saveScreenshot(pos);*/

                        if (this.altDown && pos.getViewMode() != 'obj') {
                            map.camera.near = 0.1;
                        } else {
                            map.camera.near = 2;
                        }

                        inspector.preventDefault(event);
                    }
                    break;  //key Q pressed

                case 80:
                case 112:
                    map.renderer.saveScreenshot('file', 'vts-screenshot.png', 'png'); break;  //key P pressed

                case 83:
                case 115:
                    inspector.stats.switchPanel(); break; //key S pressed

                case 86:
                case 118:
                    inspector.layers.switchPanel(); break; //key V pressed

                case 69:
                case 101:
                    inspector.stylesheets.switchPanel(); break; //key E pressed

                case 84:
                case 116:
                    inspector.replay.switchPanel(); break; //key T pressed

                case 66:
                case 98:
                    debug.drawBBoxes = !debug.drawBBoxes; break; //key B pressed

                case 65:
                case 97:
                    debug.drawLabelBoxes = !debug.drawLabelBoxes; break; //key A pressed

                case 75:
                case 107:
                   debug.drawAllLabels = !debug.drawAllLabels; break; //key K pressed

                case 73:
                case 105:
                    debug.drawHiddenLabels = !debug.drawHiddenLabels; break; //key I pressed
                    //debug.drawGridCells = !debug.drawGridCells; break; //key I pressed

                case 87:
                case 119:

                    if (debug.drawWireframe == 3) {
                        debug.drawWireframe = 1;
                    } else {
                        const value = debug.drawWireframe + 1;
                        debug.drawWireframe = value > 2 ? 0 : value;
                    }
                    break; //key W pressed

                case 70:
                case 102:
                    debug.drawWireframe = debug.drawWireframe != 3 ? 3 : 0;
                    break; //key F pressed

                case 85:
                case 117:
                    map.renderer.setSuperElevationState(!map.renderer.useSuperElevation);
                    break; //key U pressed

                case 71:
                case 103:
                    debug.meshStats = !debug.meshStats; hit = true;
                    break; //key G pressed

                case 77:
                case 109:
                    map.loaderSuspended = !map.loaderSuspended;
                    // eslint-disable-next-line
                    console.log('loader state ' + map.loaderSuspended);

                    break; //key M pressed

                case 74:
                case 106:
                    debug.drawEarth = !debug.drawEarth; hit = true; break; //key J pressed

                case 88:
                case 120:
                    debug.drawFog = !debug.drawFog; hit = true; break; //key X pressed

                case 89:
                case 121:
                    map.config.mapSplitLods = !map.config.mapSplitLods; hit = true; break; //key Y pressed

                case 82:
                case 114:
                    inspector.graphs.switchPanel(); break; //key R pressed

                case 79:
                case 111:
                    map.camera.camera.setOrtho(!map.camera.camera.getOrtho()); break; //key O pressed

                case 76:
                case 108:
                    inspector.drawRadar = !inspector.drawRadar; break; //key L pressed

                case 90:
                case 122:
                    debug.maxZoom = !debug.maxZoom; break; //key Z pressed

                case 78:
                case 110:
                    debug.drawNBBoxes = !debug.drawNBBoxes; break; //key N pressed

                default:
                    blockHit = false;
                    break;

                }

                if (blockHit) {
                    hit = true;
                }
            }
        }

        if (this.diagnosticMode && debug.drawWireframe && !press) {
            if (keyCode >= 96 && keyCode <= 105) {
                if (this.altDown) {
                    debug.drawTestData = keyCode - 96;
                    if (this.ctrlDown) {
                        debug.drawTestData += 10;
                    }
                } else {
                    debug.drawTestMode = keyCode - 96;
                }

                hit = true;
            }
        }

        if (this.diagnosticMode && inspector.drawRadar && !this.shiftDown && !press) {
            blockHit = true;

            switch(keyCode) {
            case 43:
            case 107:
                if (inspector.radarLod == null) { inspector.radarLod = 8;}
                inspector.radarLod++; /*console.log("radarLOD: " + this.radarLod);*/ break; //key mun + pressed

            case 45:
            case 109:
                if (inspector.radarLod == null) { inspector.radarLod = 8;}
                inspector.radarLod = Math.max(0,inspector.radarLod-1); /*console.log("radarLOD: " + this.radarLod);*/ break; //key mun - pressed

            case 42:
            case 106:
                inspector.radarLod = null; /*console.log("radarLOD: auto");*/ break; //key mun * pressed

            default:
                blockHit = false;
                break;
            }

            if (blockHit) {
                hit = true;
            }
        }

        if (this.diagnosticMode && (debug.drawBBoxes || debug.drawNBBoxes) && !this.shiftDown && !press) {
            blockHit = true;

            switch(keyCode) {
            case 76:
            case 108:
                debug.drawLods = !debug.drawLods; break; //key L pressed

            case 80:
            case 112:
                debug.drawPositions = !debug.drawPositions; break; //key P pressed

            case 85:
            case 117:
                debug.drawOctants = !debug.drawOctants; break;  //key U pressed

            case 84:
            case 116:
                debug.drawTextureSize = !debug.drawTextureSize; break; //key T pressed

            case 70:
            case 102:
                debug.drawFaceCount = !debug.drawFaceCount; break; //key F pressed

            case 71:
            case 103:
                debug.drawGeodataOnly = !debug.drawGeodataOnly; break; //key G pressed

            case 68:
            case 100:
                debug.drawDistance = !debug.drawDistance; break; //key D pressed

            case 86:
            case 118:
                debug.drawSpaceBBox = !debug.drawSpaceBBox; break; //key V pressed

            case 78:
            case 110:
                debug.drawNodeInfo = !debug.drawNodeInfo; break; //key N pressed

            case 77:
            case 109:
                debug.drawMeshBBox = !debug.drawMeshBBox; break; //key M pressed

            case 73:
            case 105:
                debug.drawIndices = !debug.drawIndices; break; //key I pressed

            case 66:
            case 98:
                debug.drawBoundLayers = !debug.drawBoundLayers; break; //key B pressed

            case 82:
            case 114:
                debug.drawResources = !debug.drawResources; break; //key R pressed

            case 83:
            case 115:
                debug.drawSurfaces = !debug.drawSurfaces; break; //key S pressed

            case 90:
            case 122:
                debug.drawSurfaces2 = !debug.drawSurfaces2; break; //key Z pressed

            case 67:
            case 99:
                debug.drawCredits = !debug.drawCredits; break; //key C pressed

            case 79:
            case 111:
                debug.drawOrder = !debug.drawOrder; break; //key O pressed

            case 69:
            case 101:
                debug.debugTextSize = (debug.debugTextSize == 2.0) ? 3.0 : 2.0; break; //key E pressed

            case 88:
            case 120:
                map.config.mapPreciseBBoxTest = !map.config.mapPreciseBBoxTest; break; //key X pressed

            case 87:
            case 119:
                debug.drawPolyWires = !debug.drawPolyWires; break; //key W pressed

            /*case 90:
            case 122:
                map.config.mapPreciseDistanceTest = !map.config.mapPreciseDistanceTest; break; //key Z pressed*/

            case 75:
            case 107:
                debug.drawGPixelSize = !debug.drawGPixelSize; break; //key K pressed

            default:
                blockHit = false;
                break;
            }

            if (blockHit) {
                hit = true;
            }
        }

    }

    if (hit) {
        map.markDirty();
        inspector.preventDefault(event);
    }

    //console.log("key" + keyCode);
};


InspectorInput.prototype.setParameter = function(key, value) {
    const map = this.core.getMap();
    const inspector = this.inspector;

    if (!map) {
        return;
    }

    const debug = map.draw.debug;
    const getBool = (function(a){ return (a === true || a == 'true' || a == '1') });

    switch(key) {
        case 'debugMode': this.diagnosticMode = true; break;
        case 'debugBBox':
            debug.drawBBoxes = true;
            // eslint-disable-next-line
        case 'debugNBBox':
            {
                if (key == 'debugNBBox') debug.drawNBBoxes = true;
                const has = (function(a){ return (value.indexOf(a)!=-1); });
                if (has('L')) debug.drawLods = true;
                if (has('P')) debug.drawPositions = true;
                if (has('T')) debug.drawTextureSize = true;
                if (has('F')) debug.drawFaceCount = true;
                if (has('G')) debug.drawGeodataOnly = true;
                if (has('D')) debug.drawDistance = true;
                if (has('N')) debug.drawNodeInfo = true;
                if (has('V')) debug.drawSpaceBBox = true;
                if (has('M')) debug.drawMeshBBox = true;
                if (has('I')) debug.drawIndices = true;
                if (has('U')) debug.drawOctants = true;
                if (has('B')) debug.drawBoundLayers = true;
                if (has('S')) debug.drawSurfaces = true;
                if (has('Z')) debug.drawSurfaces2 = true;
                if (has('C')) debug.drawCredits = true;
                if (has('O')) debug.drawOrder = true;
                if (has('E')) debug.debugTextSize = 3.0;
                if (has('K')) debug.drawGPixelSize = true;
            }
            break;
        case 'debugLBox': debug.drawLabelBoxes = getBool(value); break;
        case 'debugNoEarth': debug.drawEarth = !getBool(value); break;
        case 'debugShader': debug.drawWireframe = parseInt(value); break;
        case 'debugHeightmap': debug.heightmapOnly = getBool(value); break;
        case 'debugGridCells': debug.drawGridCells = getBool(value); break;
        case 'debugRadar':
            inspector.enableInspector();
            inspector.drawRadar = true;
            inspector.radarLod = parseInt(value);
            if (isNaN(inspector.radarLod)) {
                inspector.radarLod = null;
            }
            break;

    }

    map.markDirty();
};

/* harmony default export */ __webpack_exports__["default"] = (InspectorInput);


/***/ }),

/***/ "./src/core/inspector/inspector.js":
/*!*****************************************!*\
  !*** ./src/core/inspector/inspector.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./input */ "./src/core/inspector/input.js");
/* harmony import */ var _stats__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stats */ "./src/core/inspector/stats.js");
/* harmony import */ var _graphs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./graphs */ "./src/core/inspector/graphs.js");
/* harmony import */ var _layers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./layers */ "./src/core/inspector/layers.js");
/* harmony import */ var _replay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./replay */ "./src/core/inspector/replay.js");
/* harmony import */ var _stylesheets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stylesheets */ "./src/core/inspector/stylesheets.js");



//import {utils as utils_} from '../utils/utils';







//get rid of compiler mess
const mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_1__["math"];
//const utils = utils_;
const InspectorInput = _input__WEBPACK_IMPORTED_MODULE_2__["default"];
const InspectorStats = _stats__WEBPACK_IMPORTED_MODULE_3__["default"];
const InspectorGraphs = _graphs__WEBPACK_IMPORTED_MODULE_4__["default"];
const InspectorLayers = _layers__WEBPACK_IMPORTED_MODULE_5__["default"];
const InspectorReplay = _replay__WEBPACK_IMPORTED_MODULE_6__["default"];
const InspectorStylesheets = _stylesheets__WEBPACK_IMPORTED_MODULE_7__["default"];


const Inspector = function(core) {
    this.core = core;
    this.enabled = false;
    this.input = new InspectorInput(this);
    this.stats = new InspectorStats(this);
    this.graphs = new InspectorGraphs(this);
    this.layers = new InspectorLayers(this);
    this.replay = new InspectorReplay(this);
    this.stylesheets = new InspectorStylesheets(this);

    if (this.core.config.inspector) {
        this.input.init();
    }

    this.shakeCamera = false;
    this.drawReplayCamera = false;
    this.drawRadar = false;
    this.radarLod = null;
    this.debugValue = 0;
    this.measureMode = false;
    this.measurePoints = [];
};


Inspector.prototype.enableInspector = function() {
    if (!this.enabled) {
        this.stats.init();
        this.graphs.init();
        this.layers.init();
        this.replay.init();
        this.stylesheets.init();

        //load image
        if (!this.circleImage) {
            /*
            this.circleImage = utils.loadImage(
                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QAAAAAAAD5Q7t/AAAACW9GRnMAAAAgAAAA4ACD+EAUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/UlEQVRYw+2VPwqDMBTG3dz1Am56EnH2XLroETxGuwc3Z7cOdhY8QJpfSUBspUvStJAPPggvD973/uQligICAgL+DKViqygUV02hbaXLwJlio7gpyhNu2idzEXwwgfI8H+u6vnZdN/V9P3EuimLcCRlsiyArGcfxjWDLsmzyAGzc4aNFNDZ7/iw7AeQH4LNrh5WZYLgkJTaZCyHuVVVdkiSZ0zSdOWMzlaBFWkRrQ4A4Zk/A4wBie1MFYUMAz0wybCYAmR8FUAlzj6+2r18TgM2VAO8tOB1Cyk7mrofQ+zP0voheVjHtIBjDxjrmvCu7k1Xs/TP6ie84ICDAGR5uCYdPo0MWiAAAAABJRU5ErkJggg==',
                    //"http://maps.google.com/mapfiles/kml/shapes/placemarkcircle.png",
                    (function(){
                        this.circleTexture = this.core.getRendererInterface().createTexture({ 'source': this.circleImage });
                    }).bind(this)
                );
                */
        }

        this.core.on('map-update', this.onMapUpdate.bind(this));
        this.enabled = true;
    }
};


Inspector.prototype.setParameter = function(key, value) {
    this.input.setParameter(key, value);
};

Inspector.prototype.addStyle = function(string) {
    const style = document.createElement('style');
    style.type = 'text/css';
    style.innerHTML = string;
    document.getElementsByTagName('head')[0].appendChild(style);
};


//used to block mouse events
Inspector.prototype.doNothing = function(e) {
    e.stopPropagation();
    return false;
};


Inspector.prototype.preventDefault = function(e) {
    if (e.preventDefault) {
        e.preventDefault();
    } else {
        e.returnValue = false;
    }
};


Inspector.prototype.onMapUpdate = function() {
    const map = this.core.getMapInterface();
    if (!map) {
        return;
    }

    if (this.shakeCamera) {
        map.redraw();
    }

    /*if (this.measureMode) {
        const renderer = this.core.getRenderer();
        const p = map.convertCoordsFromPhysToNav(this.measurePoints[0]);
        map.convertCoordsFromPhysToCanvas(this.measurePoints[0]);
    }*/

    const renderer = this.core.getRendererInterface();
    let i, li, j, lj, lines, slines, p;

    if (this.replay.drawGlobe) {
        p = map.convertCoordsFromPhysToCameraSpace([0,0,0]);
        const renderer2 = this.core.getRenderer();
        renderer2.draw.drawTBall(p, 12742000 * 0.5, renderer2.progStardome, this.replay.globeTexture, 12742000 * 0.5, true);
    }

    if (this.replay.drawCamera) {
        lines = this.replay.cameraLines;
        slines = [];
        //for (i = 0, li = lines.length; i < li; i++) {
          //  slines.push(map.convertCoordsFromPhysToCanvas(lines[i]));
        //}

        renderer.drawLineString({
            points : lines,
            size : 2.0,
            color : [0,128,255,255],
            depthTest : false,
            screenSpace : false,
            blend : false
        });

        lines = this.replay.cameraLines3;
        for (i = 0, li = lines.length; i < li; i++) {
            slines = [];
            for (j = 0, lj = lines[i].length; j < lj; j++) {
                //slines.push(map.convertCoordsFromPhysToCanvas(lines[i][j]));
                slines.push(lines[i][j]);
            }

            renderer.drawLineString({
                points : slines,
                size : 2.0,
                color : [0,255,128,255],
                depthTest : false,
                screenSpace : false,
                blend : false
            });
        }

        lines = this.replay.cameraLines2;
        for (i = 0, li = lines.length; i < li; i++) {
            slines = [];
            for (j = 0, lj = lines[i].length; j < lj; j++) {
                //slines.push(map.convertCoordsFromPhysToCanvas(lines[i][j]));
                slines.push(lines[i][j]);
            }

            renderer.drawLineString({
                points : slines,
                size : 2.0,
                color : [0,255,255,255],
                depthTest : false,
                screenSpace : false,
                blend : false
            });
        }


        const cameInfo = map.getCameraInfo();
        const p1 = map.convertCoordsFromPhysToCameraSpace(this.replay.cameraLines[0]);

        //const map2 = this.core.getMap();

        //const m2 = map2.camera.getRotationviewMatrix();
        const mv = mat4.create(this.replay.cameraMatrix);
        //mat4.inverse(m2, mv);

        //matrix which tranforms mesh position and scale
        /*
        const mv = [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            p1[0], p1[1], p1[2], 1
        ];*/
        mv[12] = p1[0];
        mv[13] = p1[1];
        mv[14] = p1[2];

        //setup material
        const material = [
            255,128,128, 0, //ambient,
            0,0,0,0, //diffuse
            0,0,0,0, //specular
            0,0.5,0,0 //shininess, alpha,0,0
        ];

        //multiply cube matrix with camera view matrix
        mat4.multiply(cameInfo.viewMatrix, mv, mv);

        const norm = [
            0,0,0,
            0,0,0,
            0,0,0
        ];

        //normal transformation matrix
        mat4.toInverseMat3(mv, norm);

        renderer.setState(this.replay.frustumState);

        //draw cube
        renderer.drawMesh({
            mesh : this.replay.frustumMesh,
            texture : null,
            shader : 'shaded',
            shaderVariables : {
                'uMV' : ['mat4', mv],
                'uNorm' : ['mat3', norm],
                'uMaterial' : ['mat4', material]
            }
        });
    }

    if (this.drawRadar && this.circleTexture) {
        //const renderer = this.core.getRendererInterface();
        const pos = map.getPosition();
        const count = 16;
        const step = pos.getViewExtent() / (count * 4);

        const cbuffer = new Array(count * count);

/*
        const coords = pos.getCoords();

        for (let j = 0; j < count; j++) {
            for (let i = 0; i < count; i++) {
                const screenCoords = map.convertCoordsFromNavToCanvas([coords[0] + i*step - count*0.5*step,
                                                                       coords[1] + j*step - count*0.5*step, 0], "float", this.radarLod);

                cbuffer[j * count + i] = screenCoords;
            }
        }
*/


        for (j = 0; j < count; j++) {
            for (i = 0; i < count; i++) {
                const dx =  i*step - count*0.5*step;
                const dy =  j*step - count*0.5*step;
                const a = Math.atan2(dy, dx);
                const l = Math.sqrt(dx*dx + dy*dy);

                const pos2 = map.movePositionCoordsTo(pos, math.degrees(a), l);
                const coords = pos2.getCoords();

                const screenCoords = map.convertCoordsFromNavToCanvas([coords[0], coords[1], 0], 'float', this.radarLod);

                cbuffer[j * count + i] = screenCoords;
            }
        }


        const lbuffer = new Array(count);

        for (j = 0; j < count; j++) {
            for (i = 0; i < count; i++) {
                lbuffer[i] =  cbuffer[j * count + i];
            }

            renderer.drawLineString({
                points : lbuffer,
                size : 2.0,
                screenSpace : true,
                color : [0,255,255,255],
                depthTest : false,
                blend : false
            });
        }


        for (i = 0; i < count; i++) {
            for (j = 0; j < count; j++) {
                lbuffer[j] =  cbuffer[j * count + i];
            }

            renderer.drawLineString({
                points : lbuffer,
                size : 2.0,
                screenSpace : true,
                color : [0,255,255,255],
                depthTest : false,
                blend : false
            });
        }

        for (i = 0, li = cbuffer.length; i < li; i++) {
            p = cbuffer[i];
            renderer.drawImage({
                rect : [p[0]-10, p[1]-10, 20, 20],
                texture : this.circleTexture,
                color : [255,0,255,255],
                depth : p[2],
                depthTest : false,
                blend : true
            });
        }
    }
};


/* harmony default export */ __webpack_exports__["default"] = (Inspector);


/***/ }),

/***/ "./src/core/inspector/layers.js":
/*!**************************************!*\
  !*** ./src/core/inspector/layers.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const InspectorLayers = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorLayers.prototype.init = function() {
    const inspector = this.inspector;
    inspector.addStyle(
        '#vts-layers-panel {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'display: none;'
            + 'padding:15px;'
            + 'font-size: 14px;'
            + 'position: absolute;'
            + 'right: 10px;'
            + 'bottom: 10px;'
            + 'cursor: default;'
            + 'background-color: rgba(255,255,255,0.95);'
            + 'border-radius: 5px;'
            + 'border: solid 1px #ccc;'
            + 'text-align: left;'
            + 'z-index: 7;'
            + 'padding: 10px;'
        + '}'

        + '#vts-layers-panel button {'
            + 'max-width: 23px;'
            + 'max-height: 21px;'
        + '}'

        + '#vts-layers-panel-title {'
            + 'margin-bottom: 3px;'
        + '}'

        + '#vts-layers-views-panel {'
            + 'margin-top: 5px;'
            + 'float: left;'
        + '}'

        + '#vts-layers-views-items {'
            + 'width: 191px;'
            + 'overflow-y: scroll;'
            + 'overflow-x: hidden;'
            + 'height: 200px;'
            + 'border: 1px solid #ddd;'
        + '}'

        + '#vts-layers-surfaces-panel {'
            + 'margin-top: 5px;'
            + 'float: left;'
        + '}'

        + '#vts-layers-surfaces-items {'
            + 'width: 150px;'
            + 'overflow-y: scroll;'
            + 'overflow-x: hidden;'
            + 'height: 200px;'
            + 'border-top: 1px solid #ddd;'
            + 'border-bottom: 1px solid #ddd;'
        + '}'

        + '#vts-layers-boundlayers-panel {'
            + 'margin-top: 5px;'
            + 'float: left;'
        + '}'

        + '#vts-layers-boundlayers-items {'
            + 'width: 275px;'
            + 'overflow-y: scroll;'
            + 'overflow-x: hidden;'
            + 'height: 200px;'
            + 'border: 1px solid #ddd;'
            + 'border-right: none;'
        + '}'

        + '#vts-layers-freelayers-panel {'
            + 'margin-top: 5px;'
            + 'float: left;'
        + '}'

        + '#vts-layers-freelayers-items {'
            + 'width: 150px;'
            + 'overflow-y: scroll;'
            + 'overflow-x: hidden;'
            + 'height: 200px;'
            + 'border: 1px solid #ddd;'
        + '}'

        + '#vts-layers-fl-properties-panel {'
            + 'margin-top: 5px;'
            + 'float: left;'
        + '}'

        + '#vts-layers-fl-properties-items {'
            + 'width: 250px;'
            + 'overflow-y: scroll;'
            + 'overflow-x: hidden;'
            + 'height: 200px;'
            + 'border: 1px solid #ddd;'
            + 'border-right: none;'
        + '}'

        + '#vts-layers-json-panel {'
            + 'margin-top: 5px;'
            + 'float: right;'
        + '}'

        + '#vts-layers-json-text {'
            + 'width: 200px;'
            + 'resize: none;'
            + 'height: 180px;'
            + 'border: 1px solid #ddd;'
            + 'white-space: pre;'
            + 'padding: 0px;'
        + '}'

        + '#vts-layers-json-text2 {'
            + 'width: 200px;'
            + 'height: 21px;'
            + 'border: 1px solid #ddd;'
        + '}'

        + '.vts-layers-panel-title {'
            + 'margin: 0px;'
            + 'margin-bottom: 5px;'
        + '}'

        + '.vts-layers-item {'
            + 'width: 100%;'
        + '}'

        + '.vts-layers-item input[type=number]{'
            + 'width: 43px;'
        + '}'

        + '.vts-layers-name {'
            + 'width: 120px;'
            + 'display: inline-block;'
            + 'overflow: hidden;'
            + 'text-overflow: ellipsis;'
            + 'white-space: nowrap;'
        + '}'

        + '.vts-layers-name2 {'
            + 'width: 126px;'
            + 'display: inline-block;'
            + 'overflow: hidden;'
            + 'text-overflow: ellipsis;'
            + 'white-space: nowrap;'
        + '}'

        + '#vts-layers-fl-properties-style {'
            + 'width: 175px;'
            + 'height: 21px;'
        + '}'

        + '.vts-surface-item {'
            + 'width: 100%;'
            + 'overflow: hidden;'
            + 'text-overflow: ellipsis;'
            + 'white-space: nowrap;'
        + '}'

    );

    this.element = document.createElement('div');
    this.element.id = 'vts-layers-panel';
    this.element.innerHTML = ''
        + '<div id="vts-layers-views-panel"><p class="vts-layers-panel-title">Named Views:</p>'
           + '<div id="vts-layers-views-items"></div></div>'
        + '<div id="vts-layers-surfaces-panel"><p class="vts-layers-panel-title">Surfaces:</p>'
           + '<div id="vts-layers-surfaces-items"></div></div>'
        + '<div id="vts-layers-boundlayers-panel"><p class="vts-layers-panel-title">Surface Bound Layers:</p>'
           + '<div id="vts-layers-boundlayers-items"></div></div>'
        + '<div id="vts-layers-freelayers-panel"><p class="vts-layers-panel-title">Free Layers:</p>'
           + '<div id="vts-layers-freelayers-items"></div></div>'
        + '<div id="vts-layers-fl-properties-panel"><p class="vts-layers-panel-title">Free Layer Properties:</p>'
           + '<div id="vts-layers-fl-properties-items"></div></div>'
        + '<div id="vts-layers-json-panel"><p class="vts-layers-panel-title">Definition:</p>'
           + '<textarea id="vts-layers-json-text" cols="48"></textarea><br/>'
           + '<input id="vts-layers-json-text2" type="text"></div>';

    this.core.element.appendChild(this.element);
    this.viewItems = document.getElementById('vts-layers-views-items');
    this.surfacesItems = document.getElementById('vts-layers-surfaces-items');
    this.boundLayersItems = document.getElementById('vts-layers-boundlayers-items');
    this.freeLayersItems = document.getElementById('vts-layers-freelayers-items');
    this.freeLayersPropertiesItems = document.getElementById('vts-layers-fl-properties-items');
    this.jsonText = document.getElementById('vts-layers-json-text');
    this.jsonText2 = document.getElementById('vts-layers-json-text2');

    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);
    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);

    this.views = [];

    this.panelVisible = false;
    this.panelInitialized = false;
    this.currentView = '';
    this.currentSurface = '';
    this.currentFreeLayer = '';
};


InspectorLayers.prototype.initViews = function() {
    const map = this.core.getMap();
    if (!map) {
        return;
    }

    let views = map.getNamedViews(), freeLayer;
    let id = '--initial--';
    let i, li, j, lj, layers, states, index, view, surfaces, skey, surface;


    this.views[id] = {
        surfaces : {},
        freeLayers : {},
        options : {},
        original : JSON.parse(JSON.stringify(map.getView()))
    };

    for (i = 0, li = views.length; i < li; i++) {
        view = views[i];
        this.views[view] = {
            surfaces : {},
            freeLayers : {},
            options : {},
            original : JSON.parse(JSON.stringify(map.getNamedView(view).getInfo()))
        };
    }

    this.currentView = id;
    views = this.views;

    for (let key in views) {
        view = views[key];
        surfaces = map.getSurfaces();

        for (i = 0, li = surfaces.length; i < li; i++) {
            id = surfaces[i];
            surface = map.getSurface(id);
            layers = map.getBoundLayers();
            states = [];

            for (j = 0, lj = layers.length; j < lj; j++) {
                //layer = map.getBoundLayerById(layers[j]);

                states.push({
                    id : layers[j],
                    alpha : 100,
                    options : "{}",
                    enabled : false
                });
            }

            view.surfaces[id] = {
                enabled : false,
                layers : states
            };
        }

        const freeLayers = map.getFreeLayers();

        for (i = 0, li = freeLayers.length; i < li; i++) {
            id = freeLayers[i];
            layers = map.getBoundLayers();
            states = [];

            for (j = 0, lj = layers.length; j < lj; j++) {
                //layer = map.getBoundLayerById(layers[j]);

                states.push({
                    id : layers[j],
                    alpha : 100,
                    options : "{}",
                    enabled : false
                });
            }

            freeLayer = map.getFreeLayer(id);
            const freeLayerInfo = freeLayer.getInfo();

            view.freeLayers[id] = {
                enabled : false,
                style : null,
                originalStyle : freeLayerInfo['style'],
                depthShift : 0,
                depthShift2 : 0,
                depthShift3 : 0,
                layers : states
            };
        }

        let viewSurfaces = view.original['surfaces'];

        for (skey in viewSurfaces) {
            layers = viewSurfaces[skey];

            if (view.surfaces[skey]) {
                const surface = view.surfaces[skey];
                surface.enabled = true;

                for (i = 0, li = layers.length; i < li; i++) {
                    if (typeof layers[i] === 'string') {
                        index = this.findIdInArray(surface.layers, layers[i]);
                        if (index != -1 && surface.layers[index]) {
                            surface.layers[index].enabled = true;
                            surface.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);
                        }
                    } else {
                        id = layers[i]['id'];
                        index = this.findIdInArray(surface.layers, id);
                        if (index != -1 && surface.layers[index]) {
                            surface.layers[index].enabled = true;
                            surface.layers[index].alpha = layers[i]['alpha'] ? (parseFloat(layers[i]['alpha'])*100) : 100;
                            surface.layers[index].options = layers[i]['options'] ? JSON.stringify(layers[i]['options']) : "{}";
                            surface.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);
                        }
                    }
                }
            }
        }

        let viewfreeLayers = view.original['freeLayers'];

        for (skey in viewfreeLayers) {
            const freeLayerProperties = viewfreeLayers[skey];

            if (view.freeLayers[skey]) {
                freeLayer = view.freeLayers[skey];
                freeLayer.enabled = true;
                const depthShift = freeLayerProperties['depthOffset'] || [0,0,0];
                freeLayer.depthShift = depthShift[0];
                freeLayer.depthShift2 = depthShift[1];
                freeLayer.depthShift3 = depthShift[2];
                freeLayer.style = freeLayerProperties['style'];
                //freeLayer.originalStyle = freeLayer.style;

                layers = freeLayerProperties['boundLayers'] || [];
                //freeLayer.layers = layers;

                for (i = 0, li = layers.length; i < li; i++) {
                    if (typeof layers[i] === 'string') {
                        index = this.findIdInArray(freeLayer.layers, layers[i]);
                        if (index != -1 && freeLayer.layers[index]) {
                            freeLayer.layers[index].enabled = true;
                            freeLayer.layers.splice(i, 0, freeLayer.layers.splice(index, 1)[0]);
                        }
                    } else {
                        id = layers[i]['id'];
                        index = this.findIdInArray(freeLayer.layers, id);
                        if (index != -1 && surface.layers[index]) {
                            freeLayer.layers[index].enabled = true;
                            freeLayer.layers[index].alpha = layers[i]['alpha'] ? (parseFloat(layers[i]['alpha'])*100) : 100;
                            freeLayer.layers[index].options = layers[i]['options'] ? JSON.stringify(layers[i]['options']) : "{}";
                            freeLayer.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);
                        }
                    }
                }
            }
        }
    }
};


InspectorLayers.prototype.findIdInArray = function(array, id) {
    for (let i = 0, li = array.length; i < li; i++) {
        if (array[i].id == id) {
            return i;
        }
    }

    return -1;
};


InspectorLayers.prototype.buildViews = function() {
    const map = this.core.getMap();
    if (!map) {
        return;
    }

    const views = this.views;
    let html = '';

    for (let key in views) {
        html += '<div class="vts-views-item" id="vts-views-item-' + key + '">'
                 + '<div class="vts-layers-name2">' + key + '</div>'
                 + '<button id="vts-views-cbutton-' + key + '" type="button" title="Clone">C</button>'
                 + '<button id="vts-views-xbutton-' + key + '" type="button" title="Remove">X</button>'
                 + '</div>';
    }

    this.viewItems.innerHTML = html;

    for (let key in views) {
        let htmlId = 'vts-views-cbutton-' + key;
        document.getElementById(htmlId).onclick = this.switchView.bind(this, key, htmlId, 'clone');
        htmlId = 'vts-views-xbutton-' + key;
        document.getElementById(htmlId).onclick = this.switchView.bind(this, key, htmlId, 'remove');
        htmlId = 'vts-views-item-' + key;
        document.getElementById(htmlId).onclick = this.selectView.bind(this, key);
    }
};


InspectorLayers.prototype.buildSurfaces = function() {
    const view = this.views[this.currentView];
    const surfaces = view.surfaces;
    let html = '', htmlId;
    let firstKey = null, key;

    for (key in surfaces) {
        html += '<div id="vts-surface-item-' + key + '" class="vts-surface-item"><input id="vts-surface-checkbox-'
                 + key + '" type="checkbox"/><span title=' + key + '>' + key + '</span></div>';

        if (firstKey === null) {
            firstKey = key;
        }
    }

    this.surfacesItems.innerHTML = html;
    this.currentSurface = firstKey;

    for (key in surfaces) {
        if (surfaces[key].enabled) {
            htmlId = 'vts-surface-checkbox-' + key;
            document.getElementById(htmlId).checked = true;
        }
    }

    for (key in surfaces) {
        htmlId = 'vts-surface-checkbox-' + key;
        document.getElementById(htmlId).onchange = this.switchSurface.bind(this, key, htmlId);
        htmlId = 'vts-surface-item-' + key;
        document.getElementById(htmlId).onclick = this.selectSurface.bind(this, key);
    }
};


InspectorLayers.prototype.buildBoundLayers = function(id) {
    const view = this.views[this.currentView];
    let html = '', layers;

    if (view.surfaces[id]) {
        layers = view.surfaces[id].layers;

        for (let i = 0, li = layers.length; i < li; i++) {
            const layer = layers[i];

            html += '<div class="vts-layers-item"><input id="vts-boundlayer-checkbox-' + layer.id + '" type="checkbox" ' + (layer.enabled ? 'checked' : '')   + '/>'
                     + '<div class="vts-layers-name">' + layer.id + '</div>'
                     + '<input id="vts-boundlayer-spinner-' + layer.id + '" type="number" title="Alpha" min="0" max="100" step="10" value="' + layer.alpha + '">'
                     + '<button id="vts-boundlayer-obutton-' + layer.id + '" type="button" title="Options">O</button>'
                     + '<button id="vts-boundlayer-ubutton-' + layer.id + '" type="button" title="Move Above">&uarr;</button>'
                     + '<button id="vts-boundlayer-dbutton-' + layer.id + '" type="button" title="Move Bellow">&darr;</button>'
                     + '</div>';
        }
    }

    this.boundLayersItems.innerHTML = html;

    if (view.surfaces[id]) {
        for (let i = 0, li = layers.length; i < li; i++) {
            let htmlId = 'vts-boundlayer-checkbox-' + layers[i].id;
            document.getElementById(htmlId).onchange = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'enable');
            htmlId = 'vts-boundlayer-spinner-' + layers[i].id;
            document.getElementById(htmlId).onchange = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'alpha');
            htmlId = 'vts-boundlayer-obutton-' + layers[i].id;
            document.getElementById(htmlId).onclick = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'options');
            htmlId = 'vts-boundlayer-ubutton-' + layers[i].id;
            document.getElementById(htmlId).onclick = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'up');
            htmlId = 'vts-boundlayer-dbutton-' + layers[i].id;
            document.getElementById(htmlId).onclick = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'down');
        }
    }
};


InspectorLayers.prototype.buildFreeLayers = function() {
    const view = this.views[this.currentView];
    const layers = view.freeLayers;
    let html = '';

    for (let key in layers) {
        html += '<div class="vts-surface-item" id="vts-freelayer-item-' + key
                  + '"><input id="vts-freelayer-checkbox-' + key + '" type="checkbox" '
                  + (layers[key].enabled ? 'checked' : '') + '/><span title=' + key + '>' + key + '</span></div>';
    }

    this.freeLayersItems.innerHTML = html;

    for (let key in layers) {
        let htmlId = 'vts-freelayer-checkbox-' + key;
        document.getElementById(htmlId).onchange = this.switchFreeLayer.bind(this, key, htmlId);
        htmlId = 'vts-freelayer-item-' + key;
        document.getElementById(htmlId).onclick = this.selectFreeLayer.bind(this, key);
    }
};


InspectorLayers.prototype.buildFreeLayerProperties = function(id) {
    const map = this.core.getMap();
    const view = this.views[this.currentView];
    const layers = view.freeLayers[id].layers;
    let html = '', i, li, htmlId;

    if (!map || !map.getFreeLayer(id)) {
        return;
    }

    const layerInfo = map.getFreeLayer(id).getInfo();
    const layerType = layerInfo['type'];

    switch(layerType) {
    case 'mesh':
    case 'mesh-tiles':

        html += '<div class="vts-layers-item"><div class="vts-layers-name" style="width:90px">' + 'DepthOffset:' + '</div>'
                     + '<input id="vts-fl-properties-depth-shift" type="number" min="-100" max="100" step="1" value="' + view.freeLayers[id].depthShift + '">'
                     + '<input id="vts-fl-properties-depth-shift2" type="number" min="-100" max="100" step="1" value="' + view.freeLayers[id].depthShift2 + '">'
                     + '<input id="vts-fl-properties-depth-shift3" type="number" min="-100" max="100" step="1" value="' + view.freeLayers[id].depthShift3 + '">'
                     + '</div>';

        html += '<div class="vts-layers-item"><div class="vts-layers-name">' + 'BoundLayers:' + '</div></div>';

        for (i = 0, li = layers.length; i < li; i++) {
            const layer = layers[i];

            html += '<div class="vts-layers-item"><input id="vts-fl-properties-checkbox-' + layer.id + '" type="checkbox" ' + (layer.enabled ? 'checked' : '')   + '/>'
                         + '<div class="vts-layers-name">' + layer.id + '</div>'
                         + '<input id="vts-fl-properties-spinner-' + layer.id + '" type="number" title="Alpha" min="0" max="100" step="10" value="' + layer.alpha + '">'
                         + '<button id="vts-fl-properties-ubutton-' + layer.id + '" type="button" title="Move Above">&uarr;</button>'
                         + '<button id="vts-fl-properties-dbutton-' + layer.id + '" type="button" title="Move Bellow">&darr;</button>'
                         + '</div>';
        }

        this.freeLayersPropertiesItems.innerHTML = html;

        htmlId = 'vts-fl-properties-depth-shift';
        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift');
        htmlId = 'vts-fl-properties-depth-shift2';
        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift2');
        htmlId = 'vts-fl-properties-depth-shift3';
        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift3');

        for (i = 0, li = layers.length; i < li; i++) {
            htmlId = 'vts-fl-properties-checkbox-' + layers[i].id;
            document.getElementById(htmlId).onchange = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'enable');
            htmlId = 'vts-fl-properties-spinner-' + layers[i].id;
            document.getElementById(htmlId).onchange = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'alpha');
            htmlId = 'vts-fl-properties-ubutton-' + layers[i].id;
            document.getElementById(htmlId).onclick = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'up');
            htmlId = 'vts-fl-properties-dbutton-' + layers[i].id;
            document.getElementById(htmlId).onclick = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'down');
        }

        break;

    case 'geodata':
    case 'geodata-tiles':
        {
            html += '<div class="vts-layers-item"><div class="vts-layers-name" style="width:50px">' + 'Style:' + '</div>'
                        + '<select id="vts-layers-fl-properties-style">';

            const styles = map.getStylesheets();
            const index = styles.indexOf(view.freeLayers[id].style || view.freeLayers[id].originalStyle); // || layerInfo["style"]);

            for (i = 0, li = styles.length; i < li; i++) {
                html += '<option value="' + styles[i] + '" ' + ((i == index) ? 'selected' : '') + '>' + styles[i] + '</option>';
            }

            html += '</select>' + '</div>';

            this.freeLayersPropertiesItems.innerHTML = html;

            htmlId = 'vts-layers-fl-properties-style';
            document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'style');
        }
        break;
    }
};


InspectorLayers.prototype.selectView = function(id) {
    if (!this.views[id]) {
        return;
    }

    let element;

    //deselect previous
    if (this.currentView) {
        element = document.getElementById('vts-views-item-' + this.currentView);
        if (element) {
            element.style.backgroundColor = 'initial';
        }
    }

    //select new one
    element = document.getElementById('vts-views-item-' + id);
    element.style.backgroundColor = '#ddd';
    this.currentView = id;
    //this.buildBoundLayers(this.currentSurface);

    this.buildSurfaces();
    this.selectSurface(this.currentSurface);
    this.buildFreeLayers();
    this.applyMapView();
};


InspectorLayers.prototype.switchView = function(id, htmlId, action) {
    const views = this.views;

    for (let key in this.views) {
        if (key == id) {
            switch(action) {
            case 'clone':
                {
                        //layers[i].enabled = element.checked;
                    let i = 2;

                    // eslint-disable-next-line
                    while(true) {
                        if (!views[id + ' #' + i]) {
                            views[id + ' #' + i] = JSON.parse(JSON.stringify(views[id]));
                            break;
                        }
                        i++;
                    }

                    this.buildViews();
                }
                break;
            case 'remove':
                {
                    let count = 0;

                    for (key in views) {
                        count++;
                    }

                    if (count > 1) {
                        delete views[id];
                        this.buildViews();

                        if (this.currentView == id) {
                            for (key in views) {
                                this.selectView(key);
                                break;
                            }
                        } else {
                            this.selectView(this.currentView);
                        }
                    }
                }
                break;
            }

            break;
        }
    }
};


InspectorLayers.prototype.switchSurface = function(id, htmlId) {
    const element = document.getElementById(htmlId);
    const view = this.views[this.currentView];
    view.surfaces[id].enabled = element.checked;
    this.applyMapView();
};


InspectorLayers.prototype.selectSurface = function(id) {
    let element;
    //deselect previous
    if (this.currentSurface) {
        element = document.getElementById('vts-surface-item-' + this.currentSurface);
        element.style.backgroundColor = 'initial';
    }

    //select new one
    element = document.getElementById('vts-surface-item-' + id);
    if (element) {
        element.style.backgroundColor = '#ddd';
    }
    this.currentSurface = id;
    this.buildBoundLayers(this.currentSurface);
};


InspectorLayers.prototype.switchBoundLayer = function(id, htmlId, action) {
    const element = document.getElementById(htmlId);
    const view = this.views[this.currentView];
    const layers = view.surfaces[this.currentSurface].layers;

    for (let i = 0, li = layers.length; i < li; i++) {
        if (layers[i].id == id) {
            switch(action) {
            case 'enable':
                layers[i].enabled = element.checked;
                break;
            case 'alpha':
                layers[i].alpha = parseInt(element.value, 10);
                break;
            case 'options':
                //display popup
                break;
            case 'up':
                layers.splice(Math.max(0,i-1), 0, layers.splice(i, 1)[0]);
                this.selectSurface(this.currentSurface);
                break;
            case 'down':
                layers.splice(Math.max(0,i+1), 0, layers.splice(i, 1)[0]);
                this.selectSurface(this.currentSurface);
                break;
            }

            break;
        }
    }

    this.applyMapView();
};


InspectorLayers.prototype.switchFreeLayer = function(id, htmlId) {
    const element = document.getElementById(htmlId);
    const view = this.views[this.currentView];
    view.freeLayers[id].enabled = element.checked;
    this.applyMapView();
};


InspectorLayers.prototype.selectFreeLayer = function(id) {
    let element;
    //deselect previous
    if (this.currentFreeLayer) {
        element = document.getElementById('vts-freelayer-item-' + this.currentFreeLayer);
        element.style.backgroundColor = 'initial';
    }

    //select new one
    element = document.getElementById('vts-freelayer-item-' + id);
    element.style.backgroundColor = '#ddd';
    this.currentFreeLayer = id;
    this.buildFreeLayerProperties(this.currentFreeLayer);
};


InspectorLayers.prototype.switchFreeLayerBoundLayer = function(id, htmlId, action) {
    const element = document.getElementById(htmlId);
    const view = this.views[this.currentView];
    const layers = view.freeLayers[this.currentFreeLayer].layers;

    for (let i = 0, li = layers.length; i < li; i++) {
        if (layers[i].id == id) {
            switch(action) {
            case 'enable':
                layers[i].enabled = element.checked;
                break;
            case 'alpha':
                layers[i].alpha = parseInt(element.value, 10);
                break;
            case 'up':
                layers.splice(Math.max(0,i-1), 0, layers.splice(i, 1)[0]);
                this.selectFreeLayer(this.currentFreeLayer);
                break;
            case 'down':
                layers.splice(Math.max(0,i+1), 0, layers.splice(i, 1)[0]);
                this.selectFreeLayer(this.currentFreeLayer);
                break;
            }

            break;
        }
    }

    this.applyMapView();
};


InspectorLayers.prototype.switchFreeLayerProperty = function(htmlId, action) {
    const element = document.getElementById(htmlId);
    const view = this.views[this.currentView];
    const layer = view.freeLayers[this.currentFreeLayer];

    switch(action) {
    case 'depthShift':  layer.depthShift = parseInt(element.value, 10); break;
    case 'depthShift2': layer.depthShift2 = parseInt(element.value, 10); break;
    case 'depthShift3': layer.depthShift3 = parseInt(element.value, 10); break;
    case 'style':       layer.style = element.value; break;
    }

    this.applyMapView();
};


InspectorLayers.prototype.applyMapView = function(jsonOnly) {
    const view = {
        'surfaces' : {},
        'freeLayers' : {},
        'options' : {}
    };

    const sourceView = this.views[this.currentView];
    let surfaces = sourceView.surfaces, i, li, layers;

    view['options'] = JSON.parse(JSON.stringify(sourceView.options));

    for (let key in surfaces) {
        if (surfaces[key].enabled) {
            const surfaceBoundLayers = [];
            layers = surfaces[key].layers; //bound layers

            for (i = 0, li = layers.length; i < li; i++) {
                if (layers[i].enabled) {

                    const options = JSON.parse(JSON.stringify(layers[i].options));
                    const options2 = JSON.stringify(options);

                    if (layers[i].alpha < 100) {
                        const item = {'id':layers[i].id, 'alpha':(layers[i].alpha*0.01).toFixed(2)};
                        if (options2 != '{}') {
                            item.options = options;
                        }
                        surfaceBoundLayers.push(item);
                    } else {
                        surfaceBoundLayers.push(layers[i].id);
                    }
                }
            }

            view['surfaces'][key] = surfaceBoundLayers;
        }
    }

    const freeLayers = sourceView.freeLayers;

    for (let key in freeLayers) {
        if (freeLayers[key].enabled) {
            const freeLayerBoundLayers = [];
            layers = freeLayers[key].layers; //bound layers

            for (i = 0, li = layers.length; i < li; i++) {
                if (layers[i].enabled) {

                    if (layers[i].alpha < 100) {
                        const item = {'id':layers[i].id, 'alpha':(layers[i].alpha*0.01).toFixed(2)};
                        /*if (options2 != '{}') {    //???????
                            item.options = options;
                        }*/
                        freeLayerBoundLayers.push(item);
                    } else {
                        freeLayerBoundLayers.push(layers[i].id);
                    }
                }
            }

            view['freeLayers'][key] = {};

            if (freeLayerBoundLayers.length > 0) {
                view['freeLayers'][key]['boundLayers'] = freeLayerBoundLayers;
            }

            if (freeLayers[key].style && freeLayers[key].style != freeLayers[key].originalStyle) {
                view['freeLayers'][key]['style'] = freeLayers[key].style;
            }

            if (!(freeLayers[key].depthShift == 0 && freeLayers[key].depthShift2 == 0 && freeLayers[key].depthShift3 == 0)) {
                view['freeLayers'][key]['depthOffset'] = [
                    parseFloat((freeLayers[key].depthShift).toFixed(2)),
                    parseFloat((freeLayers[key].depthShift2).toFixed(2)),
                    parseFloat((freeLayers[key].depthShift3).toFixed(2)) ];
            }

        }
    }

    this.jsonText.value = JSON.stringify(view, null, '  ');
    this.jsonText2.value = encodeURIComponent(JSON.stringify(view));

    if (!jsonOnly) {
        const map = this.core.getMap();
        if (!map) {
            return;
        }

        map.setView(view, null, true);
    }
};


InspectorLayers.prototype.showPanel = function() {
    this.element.style.display = 'block';
    this.panelVisible = true;
    this.updatePanel();
};


InspectorLayers.prototype.hidePanel = function() {
    this.element.style.display = 'none';
    this.panelVisible = false;
};


InspectorLayers.prototype.switchPanel = function() {
    if (this.panelVisible) {
        this.hidePanel();
    } else {
        this.showPanel();
    }
};


InspectorLayers.prototype.updatePanel = function() {
    if (!this.panelInitialized) {
        this.panelInitialized = false;
        this.initViews();
        this.buildViews();
        this.selectView(this.currentView);
        /*
        this.buildSurfaces();
        this.selectSurface(this.currentSurface);
        this.buildFreeLayers();
        this.applyMapView(true);
        */
    }
};


/* harmony default export */ __webpack_exports__["default"] = (InspectorLayers);


/***/ }),

/***/ "./src/core/inspector/replay.js":
/*!**************************************!*\
  !*** ./src/core/inspector/replay.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");

//import GpuTexture_ from '../renderer/gpu/texture';



//get rid of compiler mess
const math = _utils_math__WEBPACK_IMPORTED_MODULE_0__["math"];
//const GpuTexture = GpuTexture_;
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"], mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_1__["mat4"];


const InspectorReplay = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorReplay.prototype.init = function() {
    const inspector = this.inspector;
    inspector.addStyle(
        '#vts-replay-panel {'
            + 'font-family: Arial, \'Helvetica Neue\', Helvetica, sans-serif;'
            + 'display: none;'
            + 'padding:15px;'
            + 'width: 618px;'
            + 'font-size: 14px;'
            + 'position: absolute;'
            + 'right: 10px;'
            + 'top: 10px;'
            + 'cursor: default;'
            + 'background-color: rgba(255,255,255,0.95);'
            + 'border-radius: 5px;'
            + 'border: solid 1px #ccc;'
            + 'text-align: left;'
            + 'z-index: 7;'
            + 'padding: 10px;'
        + '}'

        + '#vts-replay-panel-left {'
            + 'width: 253px;'
            + 'height: 100%;'
            + 'float: left;'
        + '}'

        + '#vts-replay-panel-right {'
            + 'width: 340px;'
            + 'height: 100%;'
            + 'float: right;'
        + '}'

        + '#vts-replay-items {'
            + 'width: 240px;'
            + 'overflow-x: hidden;'
            + 'border: 1px solid #ddd;'
            + 'padding-right: 5px;'
        + '}'

        + '.vts-replay-item {'
            + 'width: 100%;'
            + 'overflow: hidden;'
            + 'text-overflow: ellipsis;'
            + 'white-space: nowrap;'
        + '}'

        + '#vts-replay-lod-slider {'
            + 'width: 240px;'
        + '}'

        + '#vts-replay-lod-text {'
            + 'width: 60px;'
            + 'margin-left: 10px;'
            + 'margin-right: 10px;'
        + '}'

        + '#vts-replay-lod-single {'
            + 'margin-left: 10px;'
        + '}'

        + '#vts-replay-time-slider {'
            + 'width: 330px;'
        + '}'

        + '#vts-replay-time-text {'
            + 'width: 60px;'
            + 'margin-left: 10px;'
            + 'margin-right: 10px;'
        + '}'

        + '#vts-replay-time-single {'
            + 'margin-left: 10px;'
        + '}'

        + '#vts-replay-panel-gtime canvas{'
            + 'border: 1px solid #555;'
        + '}'

        + '#vts-replay-panel-gtime span{'
            + 'font-size: 10px;'
        + '}'

        + '#vts-replay-info {'
            + 'width: 240px;'
            + 'height: 140px;'
            + 'overflow-x: hidden;'
            + 'border: 1px solid #ddd;'
            + 'padding-right: 5px;'
            + 'margin-top: 10px;'
            + 'font-size: 12px;'
            + 'word-wrap: break-word;'
        + '}'

    );

    this.element = document.createElement('div');
    this.element.id = 'vts-replay-panel';
    this.element.innerHTML =
            '<div id="vts-replay-panel-left">'
            + '<div id="vts-replay-items"></div>'
            + '<div id="vts-replay-panel-lod">'
                + '<input id="vts-replay-lod-slider" type="range" min="0" max="30" step="1" value="30" /><br/>'
                + '<span>LOD:</span>'
                + '<input id="vts-replay-lod-text" type="text" value="30"/>'
                + '<input id="vts-replay-lod-up" type="button" value="<"/>'
                + '<input id="vts-replay-lod-down" type="button" value=">"/>'
                + '<input id="vts-replay-lod-single" type="checkbox"/>'
                + '<span>Single</span>'
            + '</div>'
            + '<div id="vts-replay-info"></div>'
          + '</div>'
          + '<div id="vts-replay-panel-right">'
            + '<div id="vts-replay-panel-gtime">'
                + '<span id="vts-replay-info-meshes">Meshes Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-meshes" width=340 height=30></canvas><br/>'
                + '<span id="vts-replay-info-textures">Internal Textures Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-textures" width=340 height=30></canvas><br/>'
                + '<span id="vts-replay-info-textures2">External Textures Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-textures2" width=340 height=30></canvas><br/>'
                + '<span id="vts-replay-info-geodata">Geodata Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-geodata" width=340 height=30></canvas><br/>'
                + '<span id="vts-replay-info-metatiles">Metatiles Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-metatiles" width=340 height=30></canvas><br/>'
                + '<span id="vts-replay-info-intervals">Interval Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-intervals" width=340 height=30></canvas><br/>'
                + '<span id="vts-replay-info-threads">Threads Min/Max: 0/0 Avg. 0 </span><br/>'
                + '<canvas id="vts-replay-canvas-threads" width=340 height=30></canvas><br/>'
            + '</div>'

            + '<div id="vts-replay-panel-time">'
                + '<input id="vts-replay-time-slider" type="range" min="0" max="2000" value="0" /><br/>'
                + '<span>File:</span>'
                + '<input id="vts-replay-time-text" type="text" value="0"/>'
                + '<input id="vts-replay-time-up" type="button" value="<"/>'
                + '<input id="vts-replay-time-down" type="button" value=">"/>'
                + '<input id="vts-replay-time-single" type="checkbox"/>'
                + '<span>Single</span>'
            + '</div>'
          + '</div>';

    this.core.element.appendChild(this.element);

    this.items = document.getElementById('vts-replay-items');

    this.lodSlider = document.getElementById('vts-replay-lod-slider');
    this.lodSlider.onchange = this.onSliderChange.bind(this, 'lod');
    this.lodSlider.oninput = this.onSliderChange.bind(this, 'lod');

    this.lodText = document.getElementById('vts-replay-lod-text');
    this.lodText.onchange = this.onTextChange.bind(this, 'lod');

    document.getElementById('vts-replay-lod-up').onclick = this.onSliderChange.bind(this, 'lod', 'down');
    document.getElementById('vts-replay-lod-down').onclick = this.onSliderChange.bind(this, 'lod', 'up');
    document.getElementById('vts-replay-lod-single').onclick = this.onSliderChange.bind(this, 'lod', 'single');

    this.timeSlider = document.getElementById('vts-replay-time-slider');
    this.timeSlider.onchange = this.onSliderChange.bind(this, 'time');
    this.timeSlider.oninput = this.onSliderChange.bind(this, 'time');

    this.timeText = document.getElementById('vts-replay-time-text');
    this.timeText.onchange = this.onTextChange.bind(this, 'time');

    this.timeInfo = document.getElementById('vts-replay-info');

    document.getElementById('vts-replay-time-up').onclick = this.onSliderChange.bind(this, 'time', 'down');
    document.getElementById('vts-replay-time-down').onclick = this.onSliderChange.bind(this, 'time', 'up');
    document.getElementById('vts-replay-time-single').onclick = this.onSliderChange.bind(this, 'time', 'single');

    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);
    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);

    this.infoMeshes = document.getElementById('vts-replay-info-meshes');
    this.ctxMeshes = document.getElementById('vts-replay-canvas-meshes').getContext('2d');
    this.infoTextures = document.getElementById('vts-replay-info-textures');
    this.ctxTextures = document.getElementById('vts-replay-canvas-textures').getContext('2d');
    this.infoTextures2 = document.getElementById('vts-replay-info-textures2');
    this.ctxTextures2 = document.getElementById('vts-replay-canvas-textures2').getContext('2d');
    this.infoGeodata = document.getElementById('vts-replay-info-geodata');
    this.ctxGeodata = document.getElementById('vts-replay-canvas-geodata').getContext('2d');
    this.infoMetatiles = document.getElementById('vts-replay-info-metatiles');
    this.ctxMetatiles = document.getElementById('vts-replay-canvas-metatiles').getContext('2d');
    this.infoIntervals = document.getElementById('vts-replay-info-intervals');
    this.ctxIntervals = document.getElementById('vts-replay-canvas-intervals').getContext('2d');
    this.infoThreads = document.getElementById('vts-replay-info-threads');
    this.ctxThreads = document.getElementById('vts-replay-canvas-threads').getContext('2d');

    this.cameraLines = [];
    this.cameraLines2 = [];
    this.cameraLines3 = [];
    this.cameraGenarated = false;

    this.panelVisible = false;
};


InspectorReplay.prototype.showPanel = function() {
    this.buildReplayCombo();
    this.element.style.display = 'block';
    this.panelVisible = true;

    const map = this.core.getMap();
    if (!map) {
        return;
    }

    const replay = map.draw.replay;
    this.updateFileInfo(replay.loadedIndex);
    this.updateLoadGraphs();
};


InspectorReplay.prototype.hidePanel = function() {
    this.element.style.display = 'none';
    this.panelVisible = false;
};


InspectorReplay.prototype.switchPanel = function() {
    if (this.panelVisible) {
        this.hidePanel();
    } else {
        this.showPanel();
    }
};


InspectorReplay.prototype.onSliderChange = function(type, button) {
    if (type == 'lod') {
        switch (button) {
        case 'up':
            this.lodSlider.stepUp();
            this.lodText.value = this.lodSlider.value;
            break;

        case 'down':
            this.lodSlider.stepDown();
            this.lodText.value = this.lodSlider.value;
            break;

        default:
            this.lodText.value = this.lodSlider.value;
        }
    } else {
        switch (button) {
        case 'up':
            this.timeSlider.stepUp();
            this.timeText.value = this.timeSlider.value;
            break;

        case 'down':
            this.timeSlider.stepDown();
            this.timeText.value = this.timeSlider.value;
            break;

        default:
            this.timeText.value = this.timeSlider.value;
        }
    }

    const map = this.core.getMap();
    if (!map) {
        return;
    }

    const replay = map.draw.replay;

    if (type == 'lod') {
        replay.lod = parseFloat(this.lodText.value);
        replay.singleLod = document.getElementById('vts-replay-lod-single').checked;
    } else {
        replay.loadedIndex = parseFloat(this.timeText.value);
        replay.singleLodedIndex = document.getElementById('vts-replay-time-single').checked;
        this.updateFileInfo(replay.loadedIndex);
        this.updateLoadGraphs();
    }

    map.markDirty();
};


InspectorReplay.prototype.onTextChange = function(type) {
    if (type == 'lod') {
        this.lodSlider.value = this.lodText.value;
    } else {
        this.timeSlider.value = this.timeText.value;
    }

    const map = this.core.getMap();
    if (!map) {
        return;
    }

    const replay = map.draw.replay;

    if (type == 'lod') {
        replay.lod = parseFloat(this.lodText.value);
    } else {
        replay.loadedIndex = parseFloat(this.timeText.value);
        this.updateFileInfo(replay.loadedIndex);
        this.updateLoadGraphs();
    }

    map.markDirty();
};


InspectorReplay.prototype.generateCameraLines = function(camera) {
    const renderer = this.core.getRendererInterface();
    let p1 = camera.position;
    const p2 = camera.center;

    this.cameraLines = [p1, p2];
/*
    const screenSize = renderer.getCanvasSize();

    const v1 = map.getScreenRay(0+1,0+1);
    const v2 = map.getScreenRay(screenSize[0]-1,0+1);
    const v3 = map.getScreenRay(screenSize[0]-1,screenSize[1]-1);
    const v4 = map.getScreenRay(0+1,screenSize[1]-1);
    const v5 = map.getScreenRay(screenSize[0]*0.5,screenSize[1]*0.5);

    const l = camera.distance;

    //l = map.getPositionViewExtent(pos);

    vec3.scale(v1, l*10);
    //vec3.scale(v2, l);
    //vec3.scale(v3, l);
    //vec3.scale(v4, l);
    //vec3.scale(v5, l);

    vec3.add(v1, p1);
    //vec3.add(v2, p1);
    //vec3.add(v3, p1);
    //vec3.add(v4, p1);
    //vec3.add(v5, p1);

    this.cameraLines3 = [p1, v1]; //, p1, v2, p1, v3, p1, v4, v1, v2, v3, v4];//, v5, p1];
    */
/*
    this.cameraLines2 = [p1];

    for (let y = 0; y < screenSize[1]*0.5; y += 100) {
        for (let x = screenSize[0]*0.5; x < screenSize[0]; x += 100) {

            const v1 = map.getScreenRay(x,y);
            vec3.scale(v1, l);
            vec3.add(v1, p1);

            this.cameraLines2.push(v1);
        }
    }
*/
    this.cameraLines2 = [[p1], [p1], [p1], [p1]];

    let segments = 16;

    const map2 = this.core.getMap();

    const m2 = map2.camera.getRotationviewMatrix();
    const m = mat4.create();
    mat4.inverse(m2, m);

    this.cameraMatrix = m;

    const a = Math.tan(math.radians(map2.camera.getFov()));
    const b = a * map2.camera.getAspect();
    const c = Math.sqrt(a*a + b*b);

    const dfov = Math.atan(c/1);

    let l = camera.cameraDistance / segments;
    let l2 = 0.5 * l * Math.tan(dfov);
    let l3 = l2 * map2.camera.getAspect();
    let v1, v2, v3, v4;

    for (let i = 0; i < segments; i++) {
        v1 = [-l3, -l2, -l];
        v2 = [l3, -l2, -l];
        v3 = [l3, l2, -l];
        v4 = [-l3, l2, -l];

        vec3.scale(v1, (i+1));
        vec3.scale(v2, (i+1));
        vec3.scale(v3, (i+1));
        vec3.scale(v4, (i+1));

        mat4.multiplyVec3(m, v1);
        mat4.multiplyVec3(m, v2);
        mat4.multiplyVec3(m, v3);
        mat4.multiplyVec3(m, v4);

        vec3.add(v1, p1);
        vec3.add(v2, p1);
        vec3.add(v3, p1);
        vec3.add(v4, p1);

        this.cameraLines2[0].push(v1);
        this.cameraLines2[1].push(v2);
        this.cameraLines2[2].push(v3);
        this.cameraLines2[3].push(v4);
    }

    this.cameraLines3 = [[p1], [p1], [p1], [p1]];

    segments = 256;
    l = (camera.distance + 12742000 * 1.1) / segments;
    //l = (camera.distance * 20.1) / segments;
    l2 = 0.5 * l * Math.tan(dfov);
    l3 = l2 * map2.camera.getAspect();

    for (let i = 0; i < segments; i++) {
        v1 = [-l3, -l2, -l];
        v2 = [l3, -l2, -l];
        v3 = [l3, l2, -l];
        v4 = [-l3, l2, -l];

        vec3.scale(v1, (i+1));
        vec3.scale(v2, (i+1));
        vec3.scale(v3, (i+1));
        vec3.scale(v4, (i+1));

        mat4.multiplyVec3(m, v1);
        mat4.multiplyVec3(m, v2);
        mat4.multiplyVec3(m, v3);
        mat4.multiplyVec3(m, v4);

        vec3.add(v1, p1);
        vec3.add(v2, p1);
        vec3.add(v3, p1);
        vec3.add(v4, p1);

        this.cameraLines3[0].push(v1);
        this.cameraLines3[1].push(v2);
        this.cameraLines3[2].push(v3);
        this.cameraLines3[3].push(v4);
    }

    v1 = [-l3, -l2, -l];
    v2 = [l3, -l2, -l];
    v3 = [l3, l2, -l];
    v4 = [-l3, l2, -l];

    vec3.scale(v1, segments);
    vec3.scale(v2, segments);
    vec3.scale(v3, segments);
    vec3.scale(v4, segments);

    p1 = [0,0,0];

    const vertices = [ p1[0], p1[1], p1[2],
        v1[0], v1[1], v1[2],
        v2[0], v2[1], v2[2],

        p1[0], p1[1], p1[2],
        v2[0], v2[1], v2[2],
        v3[0], v3[1], v3[2],

        p1[0], p1[1], p1[2],
        v3[0], v3[1], v3[2],
        v4[0], v4[1], v4[2],

        p1[0], p1[1], p1[2],
        v4[0], v4[1], v4[2],
        v1[0], v1[1], v1[2]
    ];

    const uvs = [ 0,0, 0,0, 0,0,
        0,0, 0,0, 0,0,
        0,0, 0,0, 0,0,
        0,0, 0,0, 0,0 ];

    const normals = [ 0,0,1, 0,0,1, 0,0,1,
        0,0,1, 0,0,1, 0,0,1,
        0,0,1, 0,0,1, 0,0,1,
        0,0,1, 0,0,1, 0,0,1 ];

    this.frustumState = renderer.createState({
        'blend' : true,
        'zwrite' : false,
        'ztest' : true,
        'culling' : false
    });

    this.frustumMesh = renderer.createMesh({ 'vertices': vertices, 'uvs': uvs, 'normals': normals });
    this.cameraGenarated = true;
};


InspectorReplay.prototype.itemButton = function(item, button) {
    const map = this.core.getMap();
    if (!map) {
        return;
    }

    const replay = map.draw.replay;

    switch (item) {
    case 'DrawnTiles':
        replay.storeTiles = true;
        break;

    case 'DrawnTilesFreeLayers':
        replay.storeFreeTiles = true;
        break;

    case 'TracedNodes':
        replay.storeNodes = true;
        break;

    case 'TracedNodesFreeLayers':
        replay.storeFreeNodes = true;
        break;

    case 'LoadSequence':
        replay.storeLoaded = (button == 'S');

        if (button == 'S') {
            replay.loadedIndex = 0;
            replay.loaded = [];
        } else {
            this.updateFileInfo(replay.loadedIndex);
            this.updateLoadGraphs();
        }
        break;

    case 'Camera':

        if (button == 'S') {
            const camera = replay.camera = {
                distance : map.camera.distance,
                position : map.camera.position.slice(),
                vector : map.camera.vector.slice(),
                center : map.camera.center.slice(),
                height : map.camera.height
            };

            replay.cameraPos = map.getPosition();
            this.generateCameraLines(camera);
        } else {
            if (replay.cameraPos) {
                map.setPosition(replay.cameraPos);
            }
        }

        break;

    case 'Globe':

        break;
    }

    map.markDirty();
};


InspectorReplay.prototype.switchItem = function(item, htmlId) {
    const element = document.getElementById(htmlId);
    //element.checked;
    //this.applyMapView();
    const map = this.core.getMap();
    if (!map) {
        return;
    }

    const replay = map.draw.replay;

    switch (item) {
    case 'DrawnTiles':
        replay.drawTiles = element.checked;
        break;

    case 'DrawnTilesFreeLayers':
        replay.drawFreeTiles = element.checked;
        break;

    case 'TracedNodes':
        replay.drawNodes = element.checked;
        break;

    case 'TracedNodesFreeLayers':
        replay.drawFreeNodes = element.checked;
        break;

    case 'LoadSequence':
        replay.drawLoaded = element.checked;
        break;

    case 'Camera':

        if (!this.cameraGenarated) {
            this.itemButton('Camera');
        }

        this.drawCamera = element.checked;
        break;

    case 'Globe':
        {
            const renderer = this.core.getRenderer();

            if (!this.globeTexture) {
                const texture = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAMAAADyTj5VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Mzk4RkVFMzlGNjUxMUU2OTBDM0I0OEM1NjU0RURBMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Mzk4RkVFNDlGNjUxMUU2OTBDM0I0OEM1NjU0RURBMyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQzOThGRUUxOUY2NTExRTY5MEMzQjQ4QzU2NTRFREEzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQzOThGRUUyOUY2NTExRTY5MEMzQjQ4QzU2NTRFREEzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+5rvbhAAAAAZQTFRFwcHBLS0tMDfv/wAAAiZJREFUeNrs2LENAEEIA0HTf9ME5DTgIZn8ta+TnLjymzuW6kMIwIcQgA8hAAqAAmBdAM4O4E/wBPgQAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACoAAoANoBnB2AngAKgAKgACgACoB2AGcHoCeAAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACoAAoANoBnB2AngAKgAKgACgACoB2AGcHoCeAAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACEIAPIQAfwg7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABSAAH0IAPoQAfAgB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQAPxcAQYAZt2IEFFJhxsAAAAASUVORK5CYII=';
                //this.globeTexture = new GpuTexture(renderer.gpu, texture, this.core, null, true);
                this.globeTexture = renderer.gpu.createTexture({ image: texture, repeat: true});
            }

            this.drawGlobe = element.checked;
            //this.drawGlobe = this.drawGlobe;
        }
        break;
    }

    map.markDirty();
};


InspectorReplay.prototype.updateLoadGraphs = function() {
    const map = this.core.getMap();
    if (!map) {
        return;
    }

    const replay = map.draw.replay;
    const loaded = replay.loaded;
    let index = replay.loadedIndex;

    this.timeSlider.max = loaded.length;

    let ctx;
    const lx = 340;
    const ly = 30;

    this.ctxMeshes.fillStyle = '#000000';
    this.ctxMeshes.fillRect(0, 0, lx, ly);
    this.ctxTextures.fillStyle = '#000000';
    this.ctxTextures.fillRect(0, 0, lx, ly);
    this.ctxTextures2.fillStyle = '#000000';
    this.ctxTextures2.fillRect(0, 0, lx, ly);
    this.ctxGeodata.fillStyle = '#000000';
    this.ctxGeodata.fillRect(0, 0, lx, ly);
    this.ctxMetatiles.fillStyle = '#000000';
    this.ctxMetatiles.fillRect(0, 0, lx, ly);
    this.ctxIntervals.fillStyle = '#000000';
    this.ctxIntervals.fillRect(0, 0, lx, ly);
    this.ctxThreads.fillStyle = '#000000';
    this.ctxThreads.fillRect(0, 0, lx, ly);

    let i = Math.floor(replay.loadedIndex / lx) * lx, li = (lx-1);
    let shift = i, file;

    for (i = 0; i < li; i++) {
        file = loaded[i + shift];

        if (file) {
            switch(file.kind) {
            case 'mesh':       ctx = this.ctxMeshes; break;
            case 'texture-in': ctx = this.ctxTextures; break;
            case 'texture-ex': ctx = this.ctxTextures2; break;
            case 'geodata':    ctx = this.ctxGeodata; break;
            case 'metatile':   ctx = this.ctxMetatiles; break;
            default:
                continue;
            }

            let grey = Math.round(Math.min(255, 60+20 * Math.max(1, file.duration / 300)));
            ctx.fillStyle='rgb('+grey+','+grey+','+grey+')';

            let  h = (file.duration / 300) * 30;
            ctx.fillRect(i, ly, 1, -h);

            //interval
            grey = Math.round(Math.min(255, 60+20 * Math.max(1, file.interval / 300)));
            this.ctxIntervals.fillStyle='rgb('+grey+','+grey+','+grey+')';
            h = (file.interval / 300) * 30;
            this.ctxIntervals.fillRect(i, ly, 1, -h);

            //interval
            this.ctxThreads.fillStyle='rgb(80,80,80)';
            h = (file.threads / map.config.mapDownloadThreads) * 30;
            this.ctxThreads.fillRect(i, ly, 1, -h);
        }
    }

    let minMeshes = Number.MAX_VALUE, maxMeshes = 0, avgMeshes = 0, avgMeshesCount = 0;
    let minTextures = Number.MAX_VALUE, maxTextures = 0, avgTextures = 0, avgTexturesCount = 0;
    let minTextures2 = Number.MAX_VALUE, maxTextures2 = 0, avgTextures2 = 0, avgTextures2Count = 0;
    let minGeodata = Number.MAX_VALUE, maxGeodata = 0, avgGeodata = 0, avgGeodataCount = 0;
    let minMetatiles = Number.MAX_VALUE, maxMetatiles = 0, avgMetatiles = 0, avgMetatilesCount = 0;
    let minThreads = Number.MAX_VALUE, maxThreads = 0, avgThreads = 0, avgThreadsCount = 0;
    let minIntervals = Number.MAX_VALUE, maxIntervals = 0, avgIntervals = 0, avgIntervalsCount = 0;

    li = loaded.length;

    for (i = 0; i < li; i++) {
        file = loaded[i];

        if (file) {

            switch(file.kind) {
            case 'mesh':
                if (file.duration < minMeshes) minMeshes = file.duration;
                if (file.duration > maxMeshes) maxMeshes = file.duration;
                avgMeshes += file.duration;
                avgMeshesCount++;
                break;

            case 'texture-in':
                if (file.duration < minTextures) minTextures = file.duration;
                if (file.duration > maxTextures) maxTextures = file.duration;
                avgTextures += file.duration;
                avgTexturesCount++;
                break;

            case 'texture-ex':
                if (file.duration < minTextures2) minTextures2 = file.duration;
                if (file.duration > maxTextures2) maxTextures2 = file.duration;
                avgTextures2 += file.duration;
                avgTextures2Count++;
                break;

            case 'geodata':
                if (file.duration < minGeodata) minGeodata = file.duration;
                if (file.duration > maxGeodata) maxGeodata = file.duration;
                avgGeodata += file.duration;
                avgGeodataCount++;
                break;

            case 'metatile':
                if (file.duration < minMetatiles) minMetatiles = file.duration;
                if (file.duration > maxMetatiles) maxMetatiles = file.duration;
                avgMetatiles += file.duration;
                avgMetatilesCount++;
                break;

            default:
                continue;
            }

            if (file.threads < minThreads) minThreads = file.threads;
            if (file.threads > maxThreads) maxThreads = file.threads;
            avgThreads += file.threads;
            avgThreadsCount++;

            if (file.threads < minIntervals) minIntervals = file.threads;
            if (file.threads > maxIntervals) maxIntervals = file.threads;
            avgIntervals += file.threads;
            avgIntervalsCount++;
        }
    }

    index -= shift;

    this.ctxMeshes.fillStyle = '#ff0000';
    this.ctxMeshes.fillRect(index - 1, 0, 1, ly);
    this.ctxMeshes.fillRect(index + 1, 0, 1, ly);
    this.ctxTextures.fillStyle = '#ff0000';
    this.ctxTextures.fillRect(index - 1, 0, 1, ly);
    this.ctxTextures.fillRect(index + 1, 0, 1, ly);
    this.ctxTextures2.fillStyle = '#ff0000';
    this.ctxTextures2.fillRect(index - 1, 0, 1, ly);
    this.ctxTextures2.fillRect(index + 1, 0, 1, ly);
    this.ctxGeodata.fillStyle = '#ff0000';
    this.ctxGeodata.fillRect(index - 1, 0, 1, ly);
    this.ctxGeodata.fillRect(index + 1, 0, 1, ly);
    this.ctxMetatiles.fillStyle = '#ff0000';
    this.ctxMetatiles.fillRect(index - 1, 0, 1, ly);
    this.ctxMetatiles.fillRect(index + 1, 0, 1, ly);
    this.ctxIntervals.fillStyle = '#ff0000';
    this.ctxIntervals.fillRect(index - 1, 0, 1, ly);
    this.ctxIntervals.fillRect(index + 1, 0, 1, ly);
    this.ctxThreads.fillStyle = '#ff0000';
    this.ctxThreads.fillRect(index - 1, 0, 1, ly);
    this.ctxThreads.fillRect(index + 1, 0, 1, ly);

    if (!avgMeshesCount) { minMeshes = 0, maxMeshes = 0; }
    if (!avgTexturesCount) { minTextures = 0, maxTextures = 0; }
    if (!avgTextures2Count) { minTextures2 = 0, maxTextures2 = 0; }
    if (!avgGeodataCount) { minGeodata = 0, maxGeodata = 0; }
    if (!avgMetatilesCount) { minMetatiles = 0, maxMetatiles = 0; }
    if (!avgThreadsCount) { minThreads = 0, maxThreads = 0; }
    if (!avgIntervalsCount) { minIntervals = 0, maxIntervals = 0; }

    avgMeshes = avgMeshesCount ? (avgMeshes/avgMeshesCount) : 0;
    avgTextures = avgTexturesCount ? (avgTextures/avgTexturesCount) : 0;
    avgTextures2 = avgTextures2Count ? (avgTextures2/avgTextures2Count) : 0;
    avgGeodata = avgGeodataCount ? (avgGeodata/avgGeodataCount) : 0;
    avgMetatiles = avgMetatilesCount ? (avgMetatiles/avgMetatilesCount) : 0;
    avgIntervals = avgIntervalsCount ? (avgIntervals/avgIntervalsCount) : 0;
    avgThreads = avgThreadsCount ? (avgThreads/avgThreadsCount) : 0;

    this.infoMeshes.innerHTML = 'Meshes Min/Max/Avg/Count: ' + minMeshes.toFixed(0) + '/' + maxMeshes.toFixed(0) + '/' + avgMeshes.toFixed(1) + '/' + avgMeshesCount;
    this.infoTextures.innerHTML = 'Internal Textures Min/Max/Avg/Count: ' + minTextures.toFixed(0) + '/' + maxTextures.toFixed(0) + '/' + avgTextures.toFixed(1) + '/' + avgTexturesCount;
    this.infoTextures2.innerHTML = 'External Textures Min/Max/Avg/Count: ' + minTextures2.toFixed(0) + '/' + maxTextures2.toFixed(0) + '/' + avgTextures2.toFixed(1) + '/' + avgTextures2Count;
    this.infoGeodata.innerHTML = 'Geodata Min/Max/Avg/Count: ' + minGeodata.toFixed(0) + '/' + maxGeodata.toFixed(0) + '/' + avgGeodata.toFixed(1) + '/' + avgGeodataCount;
    this.infoMetatiles.innerHTML = 'Metatiles Min/Max/Avg/Count: ' + minMetatiles.toFixed(0) + '/' + maxMetatiles.toFixed(0) + '/' + avgMetatiles.toFixed(1) + '/' + avgMetatilesCount;
    this.infoIntervals.innerHTML = 'Intervals Min/Max/Avg: ' + minIntervals.toFixed(0) + '/' + maxIntervals.toFixed(0) + '/' + avgIntervals.toFixed(1);
    this.infoThreads.innerHTML = 'Threads Min/Max/Avg: ' + minThreads + '/' + maxThreads + '/' + avgThreads.toFixed(1);
};


InspectorReplay.prototype.updateFileInfo = function(index) {
    const map = this.core.getMap();
    if (!map) {
        return;
    }

    const replay = map.draw.replay;
    const file = replay.loaded[index];

    if (file) {
        this.timeInfo.innerHTML = ''
            + 'Resource Kind: ' + file.kind + '<br/>'
            + 'Time: ' + file.time.toFixed(2) + '<br/>'
            + 'Duration: ' + file.duration.toFixed(2) + '<br/>'
            + 'Interval: ' + file.interval.toFixed(2) + '<br/>'
            + 'Priority: ' + file.priority.toFixed(2) + '<br/>'
            + 'Threads: ' + file.threads + '<br/>'
            + '' + file.url;
    } else {
        this.timeInfo.innerHTML = '';
    }
};


InspectorReplay.prototype.buildReplayCombo = function() {
    const map = this.core.getMap();
    if (!map) {
        return;
    }

    const items = [
        ['Drawn Tiles',1],
        ['Drawn Tiles - Free Layers',1],
        ['Traced Nodes',1],
        ['Traced Nodes - Free Layers',1],
        ['Load Sequence',2],
        ['Camera',2],
        ['Globe',0]
    ];

    const keys = [
        'DrawnTiles',
        'DrawnTilesFreeLayers',
        'TracedNodes',
        'TracedNodesFreeLayers',
        'LoadSequence',
        'Camera',
        'Globe'
    ];

    let html = '', i, li, htmlId;

    for (i = 0, li = items.length; i < li; i++) {
        html += '<div id="vts-replay-item-' + keys[i] + '" class="vts-replay-item">'
                 + '<input id="vts-replay-checkbox-' + keys[i] + '" type="checkbox"/>'
                 + '<span title=' + items[i][0] + '>' + items[i][0] + '&nbsp;&nbsp;</span>';

        if (items[i][1] > 0) {
            html += '<input id="vts-replay-sbutton-' + keys[i] + '" type="button" value="S"/>';
        }

        if (items[i][1] > 1) {
            html += '<input id="vts-replay-fbutton-' + keys[i] + '" type="button" value="' + ((keys[i] == 'Camera') ? 'R' : 'F') + '"/>';
        }

        html += '</div>';
    }

    this.items.innerHTML = html;
    //this.currentItem = keys[0];

    for (i = 0, li = items.length; i < li; i++) {
        htmlId = 'vts-replay-checkbox-' + keys[i];
        document.getElementById(htmlId).onchange = this.switchItem.bind(this, keys[i], htmlId);
        //htmlId = "vts-replay-item-" + keys[i];
        //document.getElementById(htmlId).onclick = this.selectReplayItem.bind(this, keys[i]);

        if (items[i][1] > 0) {
            htmlId = 'vts-replay-sbutton-' + keys[i];
            document.getElementById(htmlId).onclick = this.itemButton.bind(this, keys[i], 'S');
        }

        if (items[i][1] > 1) {
            htmlId = 'vts-replay-fbutton-' + keys[i];
            document.getElementById(htmlId).onclick = this.itemButton.bind(this, keys[i], ((keys[i] == 'Camera') ? 'R' : 'F'));
        }
    }
};


/* harmony default export */ __webpack_exports__["default"] = (InspectorReplay);


/***/ }),

/***/ "./src/core/inspector/stats.js":
/*!*************************************!*\
  !*** ./src/core/inspector/stats.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core */ "./src/core/core.js");





const InspectorStats = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorStats.prototype.init = function() {
    const inspector = this.inspector;
    inspector.addStyle(
        '#vts-stats-panel {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'display: none;'
            + 'padding:15px;'
            + 'width: 305px;'
            + 'font-size: 14px;'
            + 'position: absolute;'
            + 'right: 10px;'
            + 'top: 10px;'
            + 'cursor: default;'
            + 'background-color: rgba(255,255,255,0.95);'
            + 'border-radius: 5px;'
            + 'border: solid 1px #ccc;'
            + 'text-align: left;'
            + 'z-index: 7;'
            + 'padding: 10px;'
        + '}'

        + '#vts-stats-panel-info {'
            + 'margin-top: 5px;'
            + 'margin-bottom: 3px;'
            + 'overflow: hidden;'
        + '}'

        + '#vts-stats-panel-info table {'
            + 'color:#000000;'
            + 'text-align: left;'
            + 'font-size: 12px;'
        + '}'

        + '#vts-stats-panel-info table td {'
            + 'vertical-align: top;'
        + '}'

        + '#vts-stats-panel-pos {'
            + 'width: 100%;'
        + '}'
    );

    this.element = document.createElement('div');
    this.element.id = 'vts-stats-panel';
    this.element.innerHTML =
        '<span id="vts-stats-panel-title">Render statistics &nbsp;&nbsp;&nbsp;v' + Object(_core__WEBPACK_IMPORTED_MODULE_0__["getCoreVersion"])() + '</h3>'+
        '<p id="vts-stats-panel-info"></p>'+
        '<input id="vts-stats-panel-pos" type="text">';

    this.core.element.appendChild(this.element);
    this.infoElement = document.getElementById('vts-stats-panel-info');
    this.posElement = document.getElementById('vts-stats-panel-pos');

    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);
    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);

    this.panelVisible = false;
};


InspectorStats.prototype.showPanel = function() {
    this.element.style.display = 'block';
    this.panelVisible = true;
};


InspectorStats.prototype.hidePanel = function() {
    this.element.style.display = 'none';
    this.panelVisible = false;
};


InspectorStats.prototype.switchPanel = function() {
    if (this.panelVisible) {
        this.hidePanel();
    } else {
        this.showPanel();
    }
};


InspectorStats.prototype.updateStatsPanel = function(stats) {
    if (!this.infoElement || !this.panelVisible) {
        return;
    }
    const inspector = this.inspector;

    let text2 =
            'FPS: ' + Math.round(stats.fps) + '<br/>' +
            'Render time: ' + Math.round(stats.renderTime*1000) + '<br/>' +
            ' - resources: ' + Math.round(stats.gpuRenderUsed/(1024*1024)) + 'MB<br/>' +
            ' - topdown: ' + Math.round(stats.gpuNeeded/(1024*1024)) + 'MB<br/>' +
            //" - resources: " + (stats.gpuRenderUsed) + " --- " + (stats.gpuRenderUsed / stats.drawnTiles) + "<br/>" +
            'GPU Cache: ' + Math.round(stats.gpuUsed/(1024*1024)) + 'MB<br/>' +
            ' - textures: ' + Math.round(stats.gpuTextures/(1024*1024)) + 'MB<br/>' +
            ' - meshes: ' + Math.round(stats.gpuMeshes/(1024*1024)) + 'MB<br/>' +
            ' - geodata: ' + Math.round(stats.gpuGeodata/(1024*1024)) + 'MB<br/>' +
            'CPU Cache: ' + Math.round(stats.resourcesUsed/(1024*1024)) + 'MB<br/>' +
            'Metatile Cache: ' + Math.round(stats.metaUsed/(1024*1024)) + 'MB<br/>' +
//            "FOV: " + Math.round(this.core.getOption("fov")) + " deg<br/>" +
//            "viewHeight: " + Math.round(this.core.getOption("viewHeight")) + " m<br/>" +
//            "distance: " + Math.round(this.core.renderer.cameraDistance) + " m<br/>" +
            'Draw calls: ' + (stats.drawCalls) + '<br/>' +
            'Polygons: ' + (stats.drawnFaces) + '<br/><br/>' +
            'Terrain Height: ' + (stats.heightTerrain.toFixed(2)) + '<br/>' +
            '- float: ' + (stats.heightDelta.toFixed(2)) + '<br/>' +
            '- desired lod: ' + (stats.heightLod.toFixed(2)) + '<br/>' +
            '- used lod: ' + (stats.heightNode.toFixed(2)) + '<br/>' +
            '- used source: ' + ((stats.heightClass == 2 ? 'navtile' : stats.heightClass == 1 ? 'node': '---') ) + '<br/>' +
            'Terrain Radar Lod: ' + (inspector.radarLod) + '<br/><br/>' +
            'Loaded/Errors: ' + (stats.loadedCount) + ' / ' + (stats.loadErrorCount) + '<br/>' +
            'Load time: ' + ((stats.loadLast - stats.loadFirst)*0.001).toFixed(2) + 's <br/>';

    const renderer = this.core.renderer;

    if (renderer) {
        text2 += '<br/>Render jobs: ' + renderer.totalJobs + '<br/>' +
                 'Drawn jobs: ' + renderer.drawnJobs + '<br/>' +
                 'Jobs total time: ' +  Math.round((renderer.jobsTimer2 - renderer.jobsTimer1)*1000) + '<br/>' +
                 'Jobs reduce time: ' + Math.round((renderer.jobsTimer4)*1000) + '<br/>';
    }

    if (stats.debugStr) {
        text2 += stats.debugStr + '<br/>';
    }

    let device = "WebGL"

    if (renderer.device == 2) {
        device = "Three"
    }

    let text3 =  'Device: ' + device +'<br/>'+
                 'PixelRatio: ' + (window.devicePixelRatio || 1).toFixed(3) +'<br/>'+
                 'BFRate: ' + Math.round(1000 / (stats.frameTime+0.00001)) +'<br/><br/>';

    const map = this.core.getMap();

    if (map) {
        text3 += 'ReduceMode: ' +'<br/>'+ map.config.mapFeaturesReduceMode +'<br/>'+
                 'ReduceParams: ' +'<br/>'+ JSON.stringify(map.config.mapFeaturesReduceParams) +'<br/><br/>';

        if (map.draw.debug.meshStats) {
            text3 += 'TexelsPerPoly: ' + (stats.meshesUVArea / Math.max(1,stats.meshesFaces)).toFixed(2) +'<br/><br/>';
        }
    }

    text3 += 'Metatiles: ' + (stats.processedMetatiles) +'<br/>'+
             'Metanodes: ' + (stats.processedNodes) + ' / ' + (stats.usedNodes) + '<br/>'+
             'GeodataTiles: ' + (stats.drawnGeodataTiles) + '<br/>';

    if (stats.octoNodes) {
        text3 += 'OctoNodes: ' + (stats.octoNodes) +'<br/>'+
                 'OctoNodesMem: ' + Math.round(stats.octoNodesMemSize/(1024*1024)) + 'MB<br/>';
    }

    text3 += '<br/>';

    if (renderer) {
        text3 += 'Nodes: ' + (renderer.drawnNodes) +'<br/><br/>';
    }

    text3 += 'Tiles: ' + (stats.drawnTiles) +'<br/>';

    for (let i =0, li = stats.renderedLods.length; i < li; i++) {
        if (stats.renderedLods[i]) {
            text3 += 'LOD ' + i + ': ' + (stats.renderedLods[i]) +'<br/>';
        }
    }


    const text = '<table style="width:305px"><tr><td>' + text2 + '</td><td>' + text3 + '</td></tr></table>';

    this.infoElement.innerHTML = text;

    if (map) {
        const p = map.getPosition();
        let s = '';
        s += p.getViewMode() + ',';
        const c = p.getCoords();
        s += c[0] + ',' + c[1] + ',' + p.getHeightMode() + ',' + c[2].toFixed(2) + ',';
        const o = p.getOrientation();
        s += o[0].toFixed(2) + ',' + o[1].toFixed(2) + ',' + o[2].toFixed(2) + ',';
        s += p.getViewExtent().toFixed(2) + ',' + p.getFov().toFixed(2);

        //const value = JSON.stringify(p.pos);

        if (this.posElement.value != s) {
            this.posElement.value = s;
        }
    }
};


/* harmony default export */ __webpack_exports__["default"] = (InspectorStats);


/***/ }),

/***/ "./src/core/inspector/stylesheets.js":
/*!*******************************************!*\
  !*** ./src/core/inspector/stylesheets.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const InspectorStylesheets = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorStylesheets.prototype.init = function() {
    const inspector = this.inspector;
    inspector.addStyle(
        '#vts-stylesheets-panel * {'
            + 'all: initial;'
        + '}'

        + '#vts-stylesheets-panel {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'display: none;'
            + 'padding:15px;'
            + 'width: 1200px;'
            + 'height: 350px;'
            + 'font-size: 14px;'
            + 'position: absolute;'
            + 'right: 10px;'
            + 'bottom: 10px;'
            + 'cursor: default;'
            + 'background-color: rgba(255,255,255,0.95);'
            + 'border-radius: 5px;'
            + 'border: solid 1px #ccc;'
            + 'text-align: left;'
            + 'z-index: 7;'
            + 'padding: 10px;'
        + '}'

        + '#vts-stylesheets-panel-header {'
            + 'width: 100%;'
            + 'height: 28px;'
        + '}'

        + '#vts-stylesheets-panel-combo {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'font-size: 13px;'
            + 'border: 1px solid #a9a9a9;'
            + 'width: 1070px;'
            + 'height: 17px;'
            + 'padding: 2px;'
            + 'margin-bottom: 5px;'
            + '-webkit-appearance: menulist;'
            + '-moz-appearance: menulist;'
        + '}'

        + '#vts-stylesheets-panel-combo option {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'font-size: 13px;'
        + '}'

        + '#vts-stylesheets-panel-update-button {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'font-size: 14px;'
            + 'float: right;'
            + 'background-color: #dedede;'
            + 'padding: 3px 2px 2px 2px;'
            + 'border: 1px solid #a0a0a0;'
            + 'border-radius: 2px;'
            + 'margin-right: 5px;'
        + '}'

        + '#vts-stylesheets-panel-hide-button {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'font-size: 14px;'
            + 'float: right;'
            + 'background-color: #dedede;'
            + 'padding: 3px 2px 2px 2px;'
            + 'border: 1px solid #a0a0a0;'
            + 'border-radius: 2px;'
        + '}'

        + '#vts-stylesheets-panel-text {'
            + 'font-family: monospace;'
            + 'border: 1px solid #a9a9a9;'
            + 'padding: 2px 0px 0px 2px;'
            + 'width: 100%;'
            + 'height: 300px;'
            + 'resize: none;'
            + 'white-space: pre;'
        + '}'
    );

    this.element = document.createElement('div');
    this.element.id = 'vts-stylesheets-panel';
    this.element.innerHTML =
            '<div id="vts-stylesheets-panel-header">'
            + '<select id="vts-stylesheets-panel-combo"></select>'
            + '<button id="vts-stylesheets-panel-hide-button" type="button" title="Hide">Hide</button>'
            + '<button id="vts-stylesheets-panel-update-button" type="button" title="Update">Update</button>'
          + '</div>'
          + '<textarea id="vts-stylesheets-panel-text" rows="4" cols="50">aa\naa\n</textarea>';

    //this.inspectorElement.appendChild(this.element);
    this.core.element.appendChild(this.element);

    this.optionsElement = document.getElementById('vts-stylesheets-panel-combo');
    this.optionsElement.onchange = this.onComboSwitched.bind(this);

    this.textElement = document.getElementById('vts-stylesheets-panel-text');

    document.getElementById('vts-stylesheets-panel-update-button').onclick = this.onUpdate.bind(this);
    document.getElementById('vts-stylesheets-panel-hide-button').onclick = this.hidePanel.bind(this);

    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);
    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);

    this.textElement.addEventListener('keyup', inspector.doNothing.bind(this), false);
    this.textElement.addEventListener('keydown', inspector.doNothing.bind(this), false);

    this.panelVisible = false;
};


InspectorStylesheets.prototype.showPanel = function() {
    this.buildStylesheetsCombo();
    this.element.style.display = 'block';
    this.panelVisible = true;
};


InspectorStylesheets.prototype.hidePanel = function() {
    this.element.style.display = 'none';
    this.panelVisible = false;
};


InspectorStylesheets.prototype.switchPanel = function() {
    if (this.panelVisible) {
        this.hidePanel();
    } else {
        this.showPanel();
    }
};


InspectorStylesheets.prototype.onComboSwitched = function() {
    const map = this.core.getMap();
    if (!map) {
        return;
    }

    const stylesheet = map.getStylesheet(this.optionsElement.value);
    this.textElement.value = this.niceStyleFormat(stylesheet);
};


InspectorStylesheets.prototype.onUpdate = function() {
    const map = this.core.getMap();
    if (!map) {
        return;
    }

    map.setStylesheetData(this.optionsElement.value, JSON.parse(this.textElement.value));
};


InspectorStylesheets.prototype.niceStyleFormat = function(data) {
    if (!data || !data.data) {
        return '';
    }

    data = data.data;

    //return JSON.stringify(data, null, "  ");

    let tmp = '';
    tmp += '{\n';

    const elements = [];

    if (data['constants']) {
        elements.push('constants');
    }

    if (data['bitmaps']) {
        elements.push('bitmaps');
    }

    if (data['fonts']) {
        elements.push('fonts');
    }

    if (data['layers']) {
        elements.push('layers');
    }

    for (let j = 0, lj = elements.length; j < lj; j++) {
        const type = elements[j];
        tmp += '  "' + type + '": {\n';

        const element = data[type];

        const buff = [];
        for (let key in element) {
            buff.push(key);
        }

        for (let i = 0, li = buff.length; i < li; i++) {
            if (type == 'layers') {

                const element2 = element[buff[i]];

                const buff2 = [];
                for (let key2 in element2) {
                    buff2.push(key2);
                }

                tmp += '    "' + buff[i] + '": {\n';

                for (let k = 0, lk = buff2.length; k < lk; k++) {
                    tmp += '      "' + buff2[k] + '": ' + JSON.stringify(element2[buff2[k]]) + (k == (lk - 1) ? '' : ',') + '\n';
                }

                tmp += '    }'  + (i == (li - 1) ? '' : ',\n');
            } else {
                tmp += '    "' + buff[i] + '": ' + JSON.stringify(element[buff[i]]) + (i == (li - 1) ? '' : ',') + '\n';
            }
        }

        tmp += '\n  }' + (j == (lj - 1) ? '' : ',\n');
    }

    tmp += '\n}';

    return tmp;
};


InspectorStylesheets.prototype.buildStylesheetsCombo = function() {
    const map = this.core.getMap();
    if (!map) {
        return;
    }

    let html = '';

    const styles = map.getStylesheets();

    for (let i = 0, li = styles.length; i < li; i++) {
        html += '<option value="' + styles[i] + '">' + styles[i] + '</option>';
    }

    this.optionsElement.innerHTML = html;

    const stylesheet = map.getStylesheet(styles[0]);
    this.textElement.value = this.niceStyleFormat(stylesheet);
};


/* harmony default export */ __webpack_exports__["default"] = (InspectorStylesheets);


/***/ }),

/***/ "./src/core/interface.js":
/*!*******************************!*\
  !*** ./src/core/interface.js ***!
  \*******************************/
/*! exports provided: CoreInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoreInterface", function() { return CoreInterface; });
/* harmony import */ var melowntech_proj4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! melowntech-proj4 */ "./node_modules/melowntech-proj4/lib/index.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core */ "./src/core/core.js");




//import {CoreInterface as CoreInterface_} from './interface';

//get rid of compiler mess
//const CoreInterface = CoreInterface_;
const Core = _core__WEBPACK_IMPORTED_MODULE_2__["Core"];
const proj4 = melowntech_proj4__WEBPACK_IMPORTED_MODULE_0__["default"];


const CoreInterface = function(element, config) {
    this.proj4 = proj4;
    this.earcut = earcut__WEBPACK_IMPORTED_MODULE_1___default.a;
    this.core = new Core(element, config, this);

    Object.defineProperty(this, 'map', {
        get: function() {
            if (!this.core) { return null; }
            return this.core.getMapInterface();
        }
    });

    Object.defineProperty(this, 'renderer', {
        get: function() {
            if (!this.core) { return null; }
            return this.core.getRendererInterface();
        }
    });

    Object.defineProperty(this, 'proj4', {
        get: function() {
            if (!this.core) { return null; }
            return proj4;
        }
    });

    Object.defineProperty(this, 'earcut', {
        get: function() {
            if (!this.core) { return null; }
            return earcut__WEBPACK_IMPORTED_MODULE_1___default.a;
        }
    });
};


CoreInterface.prototype.destroy = function() {
    this.core.destroy();
    this.core = null;
};


CoreInterface.prototype.loadMap = function(path) {
    if (!this.core) { return null; }
    return this.core.loadMap(path);
};


CoreInterface.prototype.destroyMap = function() {
    if (!this.core) { return null; }
    return this.core.destroyMap();
};


/*CoreInterface.prototype.getMap = function() {
    if (!this.core) { return null; }
    return this.core.getMapInterface();
};


CoreInterface.prototype.getRenderer = function() {
    if (!this.core) { return null; }
    return this.core.getRendererInterface();
};


CoreInterface.prototype.getProj4 = function() {
    if (!this.core) { return null; }
    return this.core.getProj4();
};*/


CoreInterface.prototype.on = function(eventName, call) {
    if (!this.core) { return null; }
    return this.core.on(eventName, call);
};

CoreInterface.prototype.once = function(eventName, call, wait) {
    if (!this.core) { return null; }
    return this.core.once(eventName, call, wait);
};

CoreInterface.prototype.callListener = function(name, event) {
    if (!this.core) { return null; }
    this.core.callListener(name, event);
};





/***/ }),

/***/ "./src/core/map/body.js":
/*!******************************!*\
  !*** ./src/core/map/body.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const MapBody = function(map, json) {
    //this.map = map;
    //this.id = json["id"] || null;
    this.parse(json);
};


MapBody.prototype.parse = function(json) {
    this.class = json['class'] || '';
    this.comment = json['comment'] || '';
    this.parent = json['parent'] || '';
    this.atmosphere = json['atmosphere'] || null;

    if (this.atmosphere) {
        if (!this.atmosphere['colorHorizon']) this.atmosphere['colorHorizon'] = [0,0,0,0];
        if (!this.atmosphere['colorZenith']) this.atmosphere['colorZenith'] = [0,0,0,0];
        if (!this.atmosphere['thickness'])  this.atmosphere['thickness'] = 100000;
        if (!this.atmosphere['visibility'])  this.atmosphere['visibility'] = 100000;
    }
};


MapBody.prototype.getInfo = function() {
    return {
        'class' : this.class,
        'comment' : this.comment,
        'parent' : this.parent,
        'atmosphere' : JSON.parse(JSON.stringify(this.atmosphere)),
    };
};


/* harmony default export */ __webpack_exports__["default"] = (MapBody);


/***/ }),

/***/ "./src/core/map/bound-layer.js":
/*!*************************************!*\
  !*** ./src/core/map/bound-layer.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _credit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./credit */ "./src/core/map/credit.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _utils_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/url */ "./src/core/utils/url.js");





//get rid of compiler mess
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_1__["utils"];
const utilsUrl = _utils_url__WEBPACK_IMPORTED_MODULE_2__["utilsUrl"];
const MapCredit = _credit__WEBPACK_IMPORTED_MODULE_0__["default"];


const MapBoundLayer = function(map, json, id) {
    this.map = map;
    this.id = id;
    this.currentAlpha = 1.0;

    this.tileSize = [256,256];
    this.lodRange = [0,100];
    this.credits = [];
    this.tileRange = [[0,0],[0,0]];
    this.jsonUrl = null;
    this.baseUrl = this.map.url.baseUrl;
    this.baseUrlSchema = this.map.url.baseUrlSchema;
    this.baseUrlOrigin = this.map.url.baseUrlOrigin;
    this.ready = false;
    this.dataType = 0;
    this.shaderFilters = null;

    //hack
    if (id == 'esri-world-imagery') {
        json['availability'] = {
             // "type" : "negative-type",
             // "mime": "image/png"
             // "type" : "negative-code",
             // "codes": [301, 302, 404]
            'type' : 'negative-size',
            'size': 2521
        };
    }

    if (typeof json === 'string') {
        this.jsonUrl = this.map.url.processUrl(json);
        this.baseUrl = utilsUrl.getBase(this.jsonUrl);
        this.baseUrlSchema = utilsUrl.getSchema(this.jsonUrl);
        this.baseUrlOrigin = utilsUrl.getOrigin(this.jsonUrl);

        const onLoaded = (function(data){
            this.parseJson(data);
            this.ready = true;
            this.map.refreshView();
        }).bind(this);

        const onError = (function(){ }).bind(this);

        utils.loadJSON(this.jsonUrl, onLoaded, onError, null, (utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
        //utils.loadJSON(this.url, onLoaded, onError, null, utils.useCredentials);
    } else {
        this.parseJson(json);
        this.ready = true;
    }

};


MapBoundLayer.prototype.parseJson = function(json) {
    this.numberId = json['id'] || null;
    this.type = json['type'] || 'raster';
    this.url = this.processUrl(json['url'], '');
    this.tileSize = json['tileSize'] || [256,256];
    this.lodRange = json['lodRange'] || [0,0];
    this.tileRange = json['tileRange'] || [[0,0],[0,0]];
    this.metaUrl = this.processUrl(json['metaUrl']);
    this.maskUrl = this.processUrl(json['maskUrl']);
    this.isTransparent = json['isTransparent'] || false;
    this.options = json['options'] || {};
    this.credits = json['credits'] || [];
    this.creditsUrl = null;

    this.shaderFilter = this.options['shaderFilter'] || null;

    switch(json['dataType']) {
        default:
        case 'color':          this.dataType = 0;  break;
        case 'height':         this.dataType = 1; break;
        case 'classification': this.dataType = 2;  break;
    }

    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));

    this.availability = json['availability'] ? {} : null;

    if (this.availability) {
        const p = json['availability'];

        switch(p['type']) {
            case 'negative-type': this.availability.type = 2; break;
            case 'negative-code': this.availability.type = 3; break;
            case 'negative-size': this.availability.type = 4; break;
        }

        this.availability.mime = p['mime'];
        this.availability.codes = p['codes'];
        this.availability.size = p['size'];
        //this.availability.coverageUrl = p["coverageUrl"];
    }

    if (this.metaUrl && this.maskUrl) {
        this.availability = {
            type : 1
        };
    }

    switch(typeof this.credits) {
    case 'string':
        this.creditsUrl = this.credits;
        this.credits = [];
        break;

    case 'object':

        if (!Array.isArray(this.credits)) {
            const credits = this.credits;
            this.credits = [];

            for (let key in credits){
                this.map.addCredit(key, new MapCredit(this.map, credits[key]));
                this.credits.push(key);
            }
        }

        /*
        for (let i = 0, li = this.credits.length; i < li; i++) {
            const credit = this.map.getCreditById(this.credits[i]);
                //this.creditsNumbers.push(credit ? credit.id : null);
        }*/

        break;
    }
};


MapBoundLayer.prototype.kill = function() {
};


MapBoundLayer.prototype.setOptions = function() {
};


MapBoundLayer.prototype.getOptions = function() {
    return this.getInfo();
};


MapBoundLayer.prototype.getInfo = function() {
    return {
        'type' : this.type,
        'url' : this.url,
        'tileSize' : this.tileSize,
        'credits' : this.credits,
        'lodRange' : this.lodRange,
        'tileRange' : this.tileRange,
        'mataUrl' : this.metaUrl,
        'maskUrl' : this.maskUrl,
        'isTransparent' : this.isTransparent
    };
};


MapBoundLayer.prototype.processUrl = function(url, fallback) {
    if (!url) {
        return fallback;
    }

    url = url.trim();

    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return this.baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return this.baseUrlOrigin + url;
    } else {  //relative
        return this.baseUrl + url;
    }
};


MapBoundLayer.prototype.hasTile = function(id) {
    const shift = id[0] - this.lodRange[0];

    if (shift < 0) {
        return false;
    }

    const x = id[1] >> shift;
    const y = id[2] >> shift;

    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||
        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
        return false;
    }

    return true;
};


MapBoundLayer.prototype.hasTileOrInfluence = function(id) {
    const shift = id[0] - this.lodRange[0];

    if (shift < 0) {
        return false;
    }

    const x = id[1] >> shift;
    const y = id[2] >> shift;

    if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
        return 0;
    }

    return (id[0] > this.lodRange[1]) ? 1 : 2;
};


MapBoundLayer.prototype.getUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.url, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


MapBoundLayer.prototype.getMetatileUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


MapBoundLayer.prototype.getMaskUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.maskUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


/* harmony default export */ __webpack_exports__["default"] = (MapBoundLayer);


/***/ }),

/***/ "./src/core/map/cache.js":
/*!*******************************!*\
  !*** ./src/core/map/cache.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


const MapCache = function(map, maxCost) {
    this.map = map;
    this.maxCost = (maxCost != null) ? maxCost : Number.MAX_VALUE;
    this.skipCostCheck = false;
    this.last = null;
    this.first = null;

    this.totalCost = 0;
    this.totalItems = 0;
};


MapCache.prototype.updateItem = function(item) {
    if (item == null) {
        return;
    }

    if (this.first == item) {
        return;
    }

    //remove item from list
    if (item.prev != null) {
        item.prev.next = item.next;
    }

    if (item.next != null) {
        item.next.prev = item.prev;
    }

    if (this.last == item) {
        this.last = item.prev;
    }

    const first = this.first;

    //add item as first
    this.first = item;
    this.first.next = first;
    this.first.prev = null;

    first.prev = this.first;
};


MapCache.prototype.getMaxCost = function() {
    return this.maxCost;
};


MapCache.prototype.setMaxCost = function(cost) {
    this.maxCost = cost;
    this.checkCost();
};


MapCache.prototype.clear = function() {
    let item = this.first;

    while (item != null) {
        if (item.destructor != null) {
            item.destructor();
        }
        item = item.next;
    }

    this.last = null;
    this.first = null;

    this.totalCost = 0;
    this.totalItems = 0;
};


MapCache.prototype.insert = function(destructor, cost) {
    this.totalItems++;

    //console.log("insert: " + hash + " items: " + this.totalItems);

    const item = { destructor:destructor, cost:cost, prev: null, next:this.first };

    if (this.first != null) {
        this.first.prev = item;
    }

    //add item as first in list
    this.first = item;

    if (this.last == null) {
        this.last = item;
    }

    this.totalCost += cost;

    //console.log("MapCache.prototype.insert:" + this.totalCost + " / " + this.maxCost);

    this.checkCost();

    return item;
};


MapCache.prototype.remove = function(item) {
    this.totalItems++;
    let hit = false;

    if (item == this.first) {
        this.first = item.next;
        hit = true;

        if (this.first != null) {
            this.first.prev = null;
        }
    }

    if (item == this.last) {
        this.last = item.prev;
        hit = true;

        if (this.last != null) {
            this.last.next = null;
        }
    }

    if (!hit) {
    //if (item != this.last && item != this.first) {

        if (!item.prev) {
            //debugger;
        } else {
            item.prev.next = item.next;
        }

        if (!item.next) {
            //debugger;
        } else {
            item.next.prev = item.prev;
        }

    }

    this.totalCost -= item.cost;

    //destroy item
    item.destructor();

    //console.log("MapCache.prototype.remove:" + this.totalCost + " / " + this.maxCost);

    this.checkCost();
};


MapCache.prototype.checkCost = function() {
    if (this.skipCostCheck) {
        return;
    }

    while (this.totalCost > this.maxCost) {

        this.totalItems--;

        //console.log("remove: " + this.last.hash + " prev: " + this.last.prev + " items: " + this.totalItems);

        const last = this.last;

        if (last != null) {
            //set new last
            this.last = this.last.prev;

            if (this.last != null) {
                this.last.next = null;
            }

            this.totalCost -= last.cost;

            //destroy item
            last.destructor();

        } else {
            break;
        }
    }
};


MapCache.prototype.addItem = function(cost, destructor) {
    return this.insert(destructor, cost);
};


MapCache.prototype.removeItem = function(item) {
    return this.remove(item);
};


MapCache.prototype.itemUsed = function(item) {
    return this.updateItem(item);
};

/*
MapCache.prototype["addItem"] = MapCache.prototype.addItem;
MapCache.prototype["removeItem"] = MapCache.prototype.removeItem;
MapCache.prototype["itemUsed"] = MapCache.prototype.itemUsed;
*/

/* harmony default export */ __webpack_exports__["default"] = (MapCache);


/***/ }),

/***/ "./src/core/map/camera.js":
/*!********************************!*\
  !*** ./src/core/map/camera.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");




//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_1__["math"];


const MapCamera = function(map) {
    this.map = map;
    this.camera = map.renderer.camera;
    this.distance = 10;
    this.distance2 = 10;
    this.position = [0,0,0];
    this.vector = [0,0,1];
    this.vector2 = [0,0,1,1];
    this.center = [0,0,0];
    this.height = 0;
    this.terrainHeight = 0;
    this.lastTerrainHeight = 0;
    this.near = 2;
};


MapCamera.prototype.update = function() {
    const map = this.map;

    //check position orientaion ...
    map.position.check();

    //const height = 227;
    let height = map.position.getHeight();

    const lod =  map.measure.getOptimalHeightLod(map.position.getCoords(), map.position.getViewExtent(), map.config.mapNavSamplesPerViewExtent);
    //const surfaceHeight = [226,true,true]; //map.getSurfaceHeight(map.position.getCoords(), lod, true);
    const surfaceHeight = map.measure.getSurfaceHeight(map.position.getCoords(), lod, true);

    map.stats.heightTerrain = surfaceHeight[0];
    map.stats.heightDelta = height;

    //console.log("terrain height:" + surfaceHeight[0] + "  pos height:" + map.position.getHeight());

    if (map.position.getHeightMode() == 'float') {
        height += surfaceHeight[0];
    }

    if (map.renderer.useSuperElevation) {
        height = map.renderer.getSuperElevatedHeight(height);
    }

    const camInfo = map.measure.getPositionCameraInfo(map.position, map.getNavigationSrs().isProjected());

    this.camera.setPosition(camInfo.orbitCoords);
    this.camera.setRotationMatrix(camInfo.rotMatrix);
    this.vector = camInfo.vector;
    this.vector2 = camInfo.vector2;
    this.position = camInfo.orbitCoords;
    this.height = camInfo.orbitHeight + height;
    this.terrainHeight = this.height - surfaceHeight[0];

    //console.log(''+this.height + ' ' + this.terrainHeight + ' ' + surfaceHeight[0]);

    //get camera distance
    this.distance2 = map.position.getViewDistance();
    this.distance = Math.max(this.terrainHeight, this.distance2);
    this.distance = math.clamp(this.distance, 0.1, this.camera.getFar());

    this.distanceFactor = Math.tan(math.radians(map.position.getFov()*0.5));

    this.perceivedDistance = Math.max(this.terrainHeight, this.distance2 * this.distanceFactor);

    //this.renderer.cameraDistance = camInfo.distance; //needed for fog
    map.renderer.cameraDistance = this.distance; //needed for fog
    map.renderer.viewExtent = map.position.getViewExtent();

    this.camera.setViewHeight(map.position.getViewExtent());
    //this.camera.setOrtho(true);

    //convert nav coords to physical
    const coords = map.position.getCoords();
    const worldPos = map.convert.convertCoords([coords[0], coords[1], height], 'navigation', 'physical');
    this.center = [worldPos[0], worldPos[1], worldPos[2]];
    worldPos[0] += camInfo.orbitCoords[0];
    worldPos[1] += camInfo.orbitCoords[1];
    worldPos[2] += camInfo.orbitCoords[2];
    this.camera.setPosition([0,0,0]); //always zeros
    this.position = worldPos;

    this.vector2 = [-worldPos[0], -worldPos[1], -worldPos[2], 1];
    vec3.normalize(this.vector2);

    this.mapIsProjected = map.getNavigationSrs().isProjected();

    if (!this.mapIsProjected) { //HACK!!!!!!!!
        this.geocentDistance = vec3.length(this.position);

        const n = [0,0,0];
        vec3.normalize(this.position, n);
        this.geocentNormal = n;
    } else {
        this.vector2[3] = 0;
    }

    //console.log("word-pos: " + JSON.stringify(worldPos));

    //set near and far of camera by distance of orbit
    let factor = Math.max(this.height, this.distance) / 600000;

    const near = Math.max(this.near, this.near * (factor * 20));
    factor = Math.max(1.0, factor);
    const far = 600000 * (factor * 10);

    //console.log("near: " + near + "  far: " + far);

    this.camera.setParams(map.position.getFov()*0.5, near, far * 2.0);

    return camInfo;
};


MapCamera.prototype.getCameraHeight = function() {
    //TODO: get camera height
    //const cameraPos = this.camera.position;
    //return (this.camera.getPosition()[2] - this.planet.surfaceHeight([this.position[0] + cameraPos[0], this.position[1] + cameraPos[1]])[0]);

    //hack - distance intead of height
    //return this.cameraDistance;
    return this.cameraHeight;
};


MapCamera.prototype.getMvpMatrix = function() {
    return this.camera.getMvpMatrix();
};


MapCamera.prototype.getRotationMatrix = function() {
    return this.camera.getRotationMatrix();
};


MapCamera.prototype.getRotationviewMatrix = function() {
    return this.camera.getRotationviewMatrix();
};


MapCamera.prototype.getFar = function() {
    return this.camera.getFar();
};


MapCamera.prototype.getFov = function() {
    return this.camera.getFov();
};


MapCamera.prototype.getAspect = function() {
    return this.camera.getAspect();
};


/* harmony default export */ __webpack_exports__["default"] = (MapCamera);


/***/ }),

/***/ "./src/core/map/config.js":
/*!********************************!*\
  !*** ./src/core/map/config.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bound_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bound-layer */ "./src/core/map/bound-layer.js");
/* harmony import */ var _credit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./credit */ "./src/core/map/credit.js");
/* harmony import */ var _refframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./refframe */ "./src/core/map/refframe.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./view */ "./src/core/map/view.js");
/* harmony import */ var _srs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./srs */ "./src/core/map/srs.js");
/* harmony import */ var _body__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./body */ "./src/core/map/body.js");
/* harmony import */ var _surface__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./surface */ "./src/core/map/surface.js");
/* harmony import */ var _virtual_surface__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./virtual-surface */ "./src/core/map/virtual-surface.js");
/* harmony import */ var _stylesheet__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./stylesheet */ "./src/core/map/stylesheet.js");











//get rid of compiler mess
const MapCredit = _credit__WEBPACK_IMPORTED_MODULE_1__["default"];
const MapBoundLayer = _bound_layer__WEBPACK_IMPORTED_MODULE_0__["default"];
const MapRefFrame = _refframe__WEBPACK_IMPORTED_MODULE_2__["default"];
const MapView = _view__WEBPACK_IMPORTED_MODULE_3__["default"];
const MapSrs = _srs__WEBPACK_IMPORTED_MODULE_4__["default"];
const MapBody = _body__WEBPACK_IMPORTED_MODULE_5__["default"];
const MapSurface = _surface__WEBPACK_IMPORTED_MODULE_6__["default"];
const MapVirtualSurface = _virtual_surface__WEBPACK_IMPORTED_MODULE_7__["default"];
const MapStylesheet = _stylesheet__WEBPACK_IMPORTED_MODULE_8__["default"];


const MapConfig = function(map, config) {
    this.map = map;
    this.mapConfig = config;
    this.parseConfig();
};


MapConfig.prototype.parseConfig = function() {
    if (!(this.parseSrses() && this.parseBodies() && this.parseReferenceFrame() &&
          this.parseCredits() && this.parseStylesheets() &&
          this.parseSurfaces() && this.parseGlues() &&
          this.parseVirtualSurfaces() && this.parseBoundLayers() &&
          this.parseFreeLayers() && this.parseViews() &&
          this.parseParams() && this.parseBrowserOptions() )) {
        //wrong config file
    }

    const stats = this.map.stats;
    stats.loadedCount = 0;
    stats.loadErrorCount = 0;
    stats.loadFirst = performance.now();
    stats.loadLast = this.map.loadFirst;
};


MapConfig.prototype.afterConfigParsed = function() {
    if (this.mapConfig['position'] != null) {
        this.map.setPosition(this.mapConfig['position'], false);
    }

    this.map.setView(this.map.initialView);
};


MapConfig.prototype.parseSrses = function() {
    const srses = this.mapConfig['srses'];
    this.map.srses = {};

    if (srses == null) {
        return false;
    }

    for (let key in srses) {
        this.map.addSrs(key, new MapSrs(this.map, key, srses[key]));
    }

    return true;
};


MapConfig.prototype.parseBodies = function() {
    const bodies = this.mapConfig['bodies'];
    this.map.bodies = {};

    if (bodies == null) {
        return true;//false;
    }

    for (let key in bodies) {
        this.map.addBody(key, new MapBody(this.map, bodies[key]));
    }

    return true;
};


MapConfig.prototype.parseReferenceFrame = function() {
    const rf = this.mapConfig['referenceFrame'];

    if (rf == null) {
        return false;
    }

    this.map.referenceFrame = new MapRefFrame(this.map, rf);

    if (!this.map.referenceFrame.valid) {
        return false;
    }

    return true;
};


MapConfig.prototype.parseCredits = function() {
    const credits = this.mapConfig['credits'];
    this.map.credits = {};

    if (credits == null) {
        return false;
    }

    for (let key in credits) {
        this.map.addCredit(key, new MapCredit(this.map, credits[key]));
    }

    return true;
};


MapConfig.prototype.parseSurfaces = function() {
    const surfaces = this.mapConfig['surfaces'];
    this.map.surfaces = [];

    if (surfaces == null) {
        return false;
    }

    for (let i = 0, li = surfaces.length; i < li; i++) {
        const surface = new MapSurface(this.map, surfaces[i]);
        this.map.addSurface(surface.id, surface);
    }

    return true;
};


MapConfig.prototype.parseVirtualSurfaces = function() {
    const surfaces = this.mapConfig['virtualSurfaces'];
    this.map.virtualSurfaces = [];

    if (!this.map.config.mapVirtualSurfaces) {
        return true;
    }

    if (surfaces == null) {
        return true;
    }

    for (let i = 0, li = surfaces.length; i < li; i++) {
        const surface = new MapVirtualSurface(this.map, surfaces[i]);
        this.map.virtualSurfaces[surface.strId] = surface;
    }

    return true;
};


MapConfig.prototype.parseViews = function() {
    const views = this.mapConfig['namedViews'];
    this.map.namedViews = [];

    if (views) {
        for (let key in views) {
            this.map.addNamedView(key, new MapView(this.map, views[key], true));
        }
    }

    let view = this.mapConfig['view'];

    if (typeof view === 'string') {
        view = this.map.namedViews[view];
    }

    if (!view) {
        return true;
    }

    view = new MapView(this.map, view, true);

    this.map.initialView = view.getInfo();
    return true;
};


MapConfig.prototype.parseGlues = function() {
    const glues = this.mapConfig['glue'];
    this.map.glues = [];

    if (glues == null) {
        return true;
    }

    for (let i = 0, li = glues.length; i < li; i++) {
        const surface = new MapSurface(this.map, glues[i], 'glue');
        this.map.addGlue(surface.id.join(';'), surface);
    }

    return true;
};


MapConfig.prototype.parseBoundLayers = function() {
    const layers = this.mapConfig['boundLayers'];
    this.map.boundLayers = [];

    if (layers == null) {
        return true;
    }

    for (let key in layers) {
        const layer = new MapBoundLayer(this.map, layers[key], key);
        this.map.addBoundLayer(key, layer);
    }

    return true;
};


MapConfig.prototype.parseFreeLayers = function() {
    const layers = this.mapConfig['freeLayers'];
    this.map.freeLayers = [];

    if (layers == null) {
        return true;
    }

    for (let key in layers) {
        const layer = new MapSurface(this.map, layers[key], 'free');
        this.map.addFreeLayer(key, layer);
    }

    return true;
};


MapConfig.prototype.parseStylesheets = function() {
    const styles = this.mapConfig['stylesheets'];
    this.map.stylesheets = [];

    if (styles == null) {
        return true;
    }

    for (let key in styles) {
        const style = new MapStylesheet(this.map, key, styles[key]);
        this.map.addStylesheet(key, style);
    }

    return true;
};


MapConfig.prototype.parseParams = function() {
    return true;
};


MapConfig.prototype.parseBrowserOptions = function() {
    const options = this.mapConfig['browserOptions'];
    this.map.browserOptions = {};

    if (options == null) {
        return true;
    }

    this.map.browserOptions = JSON.parse(JSON.stringify(options));
    return true;
};


MapConfig.prototype.cloneConfig = function() {
    const json = JSON.parse(JSON.stringify(this.mapConfig));
    return json;
};


/* harmony default export */ __webpack_exports__["default"] = (MapConfig);


/***/ }),

/***/ "./src/core/map/convert.js":
/*!*********************************!*\
  !*** ./src/core/map/convert.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");



//import GeographicLib_ from 'geographiclib';

//get rid of compiler mess
const mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_1__["math"];
//const GeographicLib = GeographicLib_;


const MapConvert = function(map) {
    this.map = map;
    this.renderer = map.renderer;
    this.config = map.config;
    this.measure = map.measure;
    this.isProjected = this.map.getNavigationSrs().isProjected();
};


MapConvert.prototype.convertCoords = function(coords, source, destination) {
    return this.map.referenceFrame.convertCoords(coords, source, destination);
};


MapConvert.prototype.movePositionCoordsTo = function(position, azimuth, distance, azimuthCorrectionFactor) {
    const coords = position.getCoords();
    //const navigationSrsInfo = this.map.getNavigationSrs().getSrsInfo();
    azimuthCorrectionFactor = (azimuthCorrectionFactor == null) ? 1 : azimuthCorrectionFactor;

    if (this.isProjected) {
        const yaw = math.radians(azimuth);
        const forward = [-Math.sin(yaw), Math.cos(yaw)];

        position.setCoords2([coords[0] + (forward[0]*distance),
            coords[1] + (forward[1]*distance)]);
    } else {
        const geod = this.measure.getGeodesic();

        const r = geod.Direct(coords[1], coords[0], azimuth, distance);
        position.setCoords2([r.lon2, r.lat2]);

        const orientation = position.getOrientation();

        //console.log("corerction: " + (r.azi1 - r.azi2));

        orientation[0] -= (r.azi1 - r.azi2) * azimuthCorrectionFactor;
        //orientation[0] -= (r.azi1 - r.azi2);

        //if (!skipOrientation) {
        position.setOrientation(orientation);
        //}

        //console.log("azimuthCorrection: " + azimuthCorrectionFactor);
        //console.log("oldpos: " + JSON.stringify(this));
        //console.log("newpos: " + JSON.stringify(pos2));
    }

    return position;
};


MapConvert.prototype.convertPositionViewMode = function(position, mode) {
    if (mode == position.pos[0]) {
        return position;
    }

    if (mode == 'obj') {
        let convertToFloat = false;

        if (position.getHeightMode() == 'float') {
            convertToFloat = true;
            this.convertPositionHeightMode(position, 'fix', true);
        }

        let distance = position.getViewDistance();
        const orientation = position.getOrientation();
        let coords;

        //get height delta
        const pich = math.radians(-orientation[1]);
        const heightDelta = distance * Math.sin(pich);

        //reduce distance by pich
        distance *= Math.cos(pich);

        if (this.isProjected) {
            //get forward vector
            const yaw = math.radians(orientation[0]);
            const forward = [-Math.sin(yaw), Math.cos(yaw)];

            //get center coords
            coords = position.getCoords();
            coords[0] = coords[0] + (forward[0] * distance);
            coords[1] = coords[1] + (forward[1] * distance);
        } else {
            this.movePositionCoordsTo(position, -orientation[0], distance);
            coords = position.getCoords();
        }

        coords[2] -= heightDelta;
        position.setCoords(coords);

        if (convertToFloat) {
            this.convertPositionHeightMode(position, 'float', true);
        }

    } else if (mode == 'subj') {
        let coords = this.getPositionCameraCoords(position, position.getHeightMode());
        position.setCoords(coords);

        //TODO: take in accout planet ellipsoid
    }

    position.pos[0] = mode;

    return position;
};


MapConvert.prototype.convertPositionHeightMode = function(position, mode, noPrecisionCheck) {
    if (position.pos[3] == mode) {
        return position;
    }

    const lod =  this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
    const height = this.measure.getSurfaceHeight(position.getCoords(), lod);

    if (!height[1] && !noPrecisionCheck) {
        //return null;
    }

    //set new height
    if (mode == 'float') {
        position.pos[3] = mode;
        position.pos[4] = position.pos[4] - height[0];
    } else if (mode == 'fix') {
        position.pos[3] = mode;
        position.pos[4] = position.pos[4] + height[0];
    }

    return position;
};


MapConvert.prototype.getPositionCameraCoords = function(position, heightMode) {
    const orientation = position.getOrientation();
    const rotMatrix = mat4.create();
    mat4.multiply(math.rotationMatrix(2, math.radians(-orientation[0])), math.rotationMatrix(0, math.radians(orientation[1])), rotMatrix);

    let coords, terrainHeight = 0, surfaceHeight, lod = -1;

    if (position.getViewMode() == 'obj') {
        coords = position.getCoords();

        //convert height to fix
        if (position.getHeightMode() == 'float') {
            lod = this.measure.getOptimalHeightLod(coords, position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
            surfaceHeight = this.measure.getSurfaceHeight(coords, lod);
            terrainHeight = surfaceHeight[0];
        }

        const camInfo = this.measure.getPositionCameraInfo(position, this.isProjected);

        if (this.isProjected) {
            //const distance = (this.getViewExtent()) / Math.tan(math.radians(this.getFov()*0.5));
            //const orbitPos = [0, -distance, 0];
            //math.mat4.multiplyVec3(rotMatrix, orbitPos);

            coords[0] += camInfo.orbitCoords[0];
            coords[1] += camInfo.orbitCoords[1];
            coords[2] += camInfo.orbitCoords[2] + terrainHeight;
        } else {
            const worldPos = this.convertCoords([coords[0], coords[1], coords[2] + terrainHeight], 'navigation', 'physical');
            worldPos[0] += camInfo.orbitCoords[0];
            worldPos[1] += camInfo.orbitCoords[1];
            worldPos[2] += camInfo.orbitCoords[2];// + terrainHeight;

            coords = this.convertCoords(worldPos, 'physical', 'navigation');
        }

        if (heightMode == 'fix') {
            return coords;
        } else {
            //get float height for new coords
            if (lod == -1) {
                lod =  this.measure.getOptimalHeightLod(coords, position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
            }

            surfaceHeight = this.measure.getSurfaceHeight(coords, lod);
            coords[2] -= surfaceHeight[0];

            return coords;
        }

    } else {

        if (position.getHeightMode() == heightMode) {
            return position.getCoords();
        } else {
            lod =  this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
            surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);
            //height += surfaceHeight[0];

            coords = position.getCoords();

            if (heightMode == 'fix') {
                coords[2] += surfaceHeight[0];
            } else {
                coords[2] -= surfaceHeight[0];
            }

            return coords;
        }
    }
};


MapConvert.prototype.getPositionNavCoordsFromPublic = function(position, lod) {
    const coords = position.getCoords();

    if (position.getHeightMode() == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
        const surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);
        coords[2] += surfaceHeight[0];
    }

    return this.convertCoords(coords, 'public', 'navigation');
};

MapConvert.prototype.getPositionPublicCoords = function(position, lod) {
    const coords = position.getCoords();

    if (position.getHeightMode() == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
        const surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);
        coords[2] += surfaceHeight[0];
    }

    return this.convertCoords(coords, 'navigation', 'public');
};


MapConvert.prototype.getPositionPhysCoords = function(position, lod, includeSE) {
    const coords = position.getCoords();

    if (position.getHeightMode() == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
        const surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);
        coords[2] += surfaceHeight[0];
    }

    if (this.renderer.useSuperElevation && includeSE) {
        coords[2] = this.renderer.getSuperElevatedHeight(coords[2]);
    }

    return this.convertCoords(coords, 'navigation', 'physical');
};


MapConvert.prototype.getPositionCameraSpaceCoords = function(position, lod) {
    const coords = position.getCoords();

    if (position.getHeightMode() == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
        const surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);
        coords[2] += surfaceHeight[0];
    }

    if (this.renderer.useSuperElevation) {
        coords[2] = this.renderer.getSuperElevatedHeight(coords[2]);
    }

    const worldPos = this.convertCoords(coords, 'navigation', 'physical');
    const camPos = this.map.camera.position;
    worldPos[0] -= camPos[0];
    worldPos[1] -= camPos[1];
    worldPos[2] -= camPos[2];

    return worldPos;
};


MapConvert.prototype.getPositionCanvasCoords = function(position, lod, physical, containsSE) {
    let worldPos;
    if (physical) {
        const camPos = this.map.camera.position;
        let coords = position.getCoords();

        if (this.renderer.useSuperElevation && !containsSE) {
            coords = this.renderer.transformPointBySE(coords);
        }

        worldPos = [coords[0] - camPos[0], coords[1] - camPos[1], coords[2] - camPos[2]];
    } else {
        worldPos = this.getPositionCameraSpaceCoords(position, lod);
    }

    return this.map.renderer.project2(worldPos, this.map.camera.getMvpMatrix());
};


MapConvert.prototype.transformPhysCoordsBySE = function(coords) {
    if (!this.renderer.useSuperElevation) {
        return coords;
    }

    return this.renderer.transformPointBySE(coords);
};


MapConvert.prototype.convertCoordsFromPhysToNav = function(coords, mode, lod, containsSE) {
    coords = this.convertCoords(coords, 'physical', 'navigation');

    if (this.renderer.useSuperElevation && containsSE) {
        coords[2] = this.renderer.getUnsuperElevatedHeight(coords[2]);
    }

    if (mode == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(coords, 10, this.config.mapNavSamplesPerViewExtent);
        const surfaceHeight = this.measure.getSurfaceHeight(coords, lod);
        coords[2] -= surfaceHeight[0];
    }

    return coords;
};


// eslint-disable-next-line
MapConvert.prototype.getGeodesicLinePoints = function(coords, coords2, height, density) {
    let geod, r, length, azimuth, minStep, d;
    const navigationSrsInfo = this.measure.navigationSrsInfo;
    const dx = coords2[0] - coords[0];
    const dy = coords2[1] - coords[1];
    const dz = coords2[2] - coords[2];

    if (this.isProjected) {
        length = Math.sqrt(dx*dx + dy*dy + dz*dz);
        minStep = 1000000; //just big number
    } else {
        geod = this.measure.getGeodesic();
        r = geod.Inverse(coords[1], coords[0], coords2[1], coords2[0]);
        length = r.s12;
        azimuth = r.azi1;
        minStep = 10 * ((navigationSrsInfo['a'] * 2 * Math.PI) / 4007.5); //aprox 100km for earth
    }

    const points = [coords];
    let distance = minStep;

    for (;distance < length; distance += minStep) {
        d = distance / length;

        if (this.isProjected) {
            points.push([ coords[0] + dx * d, coords[1] + dy * d, coords[2] + dz * d ]);
        } else {
            r = geod.Direct(coords[1], coords[0], azimuth, distance);
            points.push([r.lon2, r.lat2, coords[2] + dz * d]);
        }
    }

    points.push(coords2);

    return points;
};

/* harmony default export */ __webpack_exports__["default"] = (MapConvert);


/***/ }),

/***/ "./src/core/map/credit.js":
/*!********************************!*\
  !*** ./src/core/map/credit.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");



//get rid of compiler mess
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["utils"];

const MapCredit = function(map, json) {
    this.map = map;
    this.id = json['id'] || null;
    this.notice = json['notice'] || null;
    this.copyrighted = json['copyrighted'] || true;
    this.url = json['url'] || null;
    this.html = utils.simpleWikiLinks(this.notice);
    this.plain = utils.simpleWikiLinks(this.notice);
};


MapCredit.prototype.getInfo = function() {
    return {
        'id' : this.id,
        'notice' : this.notice,
        //"copyrighted" : this.copyrighted,
        //"url" : this.url
        'html' : this.html,
        'plain' : this.plain
    };
};


/* harmony default export */ __webpack_exports__["default"] = (MapCredit);


/***/ }),

/***/ "./src/core/map/division-node.js":
/*!***************************************!*\
  !*** ./src/core/map/division-node.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const MapDivisionNode = function(map, id, srs, extents, heightRange, partitioning) {
    this.map = map;
    this.id = id;
    this.srs = this.map.getMapsSrs(srs);
    this.extents = extents;
    this.heightRange =  heightRange;
    this.partitioning = partitioning;
    this.isPole = (id[0] == 1 && ((id[1] == 0 && id[2] == 1)||(id[1] == 1 && id[2] == 0)));
};


MapDivisionNode.prototype.getInnerCoords = function (coords) {
    return this.srs.convertCoordsFrom(coords, this.map.getNavigationSrs());
};


MapDivisionNode.prototype.getOuterCoords = function (coords) {
    return this.srs.convertCoordsTo(coords, this.map.getNavigationSrs());
};


MapDivisionNode.prototype.getPhysicalCoords = function (coords, skipVerticalAdjust) {
    return this.srs.convertCoordsTo(coords, this.map.getPhysicalSrs(), skipVerticalAdjust);
};


MapDivisionNode.prototype.getPhysicalCoordsFast = function (coords, skipVerticalAdjust, coords2, index, index2) {
    return this.srs.convertCoordsToFast(coords, this.map.getPhysicalSrs(), skipVerticalAdjust, coords2, index, index2);
};


MapDivisionNode.prototype.getExtents = function (coords) {
    return this.srs.convertCoordsFrom(coords, this.map.getNavigationSrs());
};


/* harmony default export */ __webpack_exports__["default"] = (MapDivisionNode);


/***/ }),

/***/ "./src/core/map/draw-tiles.js":
/*!************************************!*\
  !*** ./src/core/map/draw-tiles.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geodata_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geodata-view */ "./src/core/map/geodata-view.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");




//get rid of compiler mess
const MapGeodataView = _geodata_view__WEBPACK_IMPORTED_MODULE_0__["default"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_1__["utils"];


const MapDrawTiles = function(map, draw) {
    this.map = map;
    this.config = map.config;
    this.isProjected = this.map.getNavigationSrs().isProjected();
    this.stats = map.stats;
    this.draw = draw;
    this.debug = draw.debug;
    this.core = map.core;
    this.camera = map.camera;

    this.renderer = map.renderer;

    this.getTextSize = this.renderer.gpu.draw.getTextSize.bind(this.renderer.gpu.draw);
    this.drawText = this.renderer.gpu.draw.drawText.bind(this.renderer.gpu.draw);
};


MapDrawTiles.prototype.drawSurfaceTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {
    if (this.stats.gpuRenderUsed >= this.draw.maxGpuUsed) {
        return false;
    }

    tile.renderReady = false;

    let ret;

    if (tile.surface) {
        if (node.hasGeometry()) {

            if (this.debug.drawBBoxes && !preventRedener) {
                if (tile.surface.geodata || !this.debug.drawGeodataOnly) {
                    this.drawTileInfo(tile, node, cameraPos, tile.surfaceMesh, pixelSize);
                }
            }

            if (this.debug.heightmapOnly && !preventRedener) {
                if (!tile.surface.geodata) {
                    tile.drawGrid(cameraPos);
                }
                return true;
            }

            if (!preventRedener) {
                this.stats.renderedLods[tile.id[0]]++;
                this.stats.drawnTiles++;

                if (tile.surface.geodata && this.renderer.drawnGeodataTilesUsed) {    //used in scr-count2 !!! legacy mode, do not remove

                    const pp = this.renderer.project2(
                        [(node.bbox2[12] + node.bbox2[15] + node.bbox2[18] + node.bbox2[21])*0.25 - cameraPos[0],
                         (node.bbox2[13] + node.bbox2[16] + node.bbox2[19] + node.bbox2[22])*0.25 - cameraPos[1],
                         (node.bbox2[14] + node.bbox2[17] + node.bbox2[20] + node.bbox2[23])*0.25 - cameraPos[2]],
                         this.camera.getMvpMatrix());

                    if (!(pp[0] < 0 || pp[1] < 0 || pp[0] > this.renderer.curSize[0] || pp[1] > this.renderer.curSize[1])) {
                        this.stats.drawnGeodataTilesPerLayer++;
                        this.stats.drawnGeodataTilesFactor += Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), 0.5);
                    }

                    this.stats.drawnGeodataTiles++;
                }
            }

            let count = 0;

            do {

                if (tile.resetDrawCommands) {
                    tile.drawCommands = [[], [], []];
                    tile.updateBounds = true;

                    if (tile.bounds) {
                        for (let key in tile.bounds) {
                            tile.bounds[key].viewCoutner = 0;
                        }
                    }

                    tile.resetDrawCommands = false;
                }

                if (!tile.surface.geodata) {
                    ret = this.drawMeshTile(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu);
                } else {
                    ret = this.drawGeodataTile(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu);
                }

                //if (count > 0) console.log('loop: ' + count);

                count++;

                if (count > 10) {
                    break; //prevent infinite loop
                }

            } while(tile.resetDrawCommands);

            return ret;
        } else {
            return true;
        }
    } else {
        if (!preventRedener && tile.lastRenderState) {
            const channel = this.draw.drawChannel;
            this.draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);
            this.map.applyCredits(tile);
            return true;
        }
    }
};



MapDrawTiles.prototype.drawMeshTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {
    let path;

    if (!tile.surfaceMesh) {
        if (tile.resourceSurface.virtual) {
            return true;
        }

        path = tile.resourceSurface.getMeshUrl(tile.id);
        tile.surfaceMesh = tile.resources.getMesh(path, tile);
    }

    const draw = this.draw, channel = draw.drawChannel;
    let texture, layer, credits, ret = false;

    //we have commnad so we can draw them
    if (tile.drawCommands[channel].length > 0 && this.draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {
        if (!preventRedener) {
            draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);
            this.map.applyCredits(tile);
        }

        tile.lastRenderState = null;
        return true;
    } else if (tile.lastRenderState){ //we do not have cammnds or command are not redy yet, so we can draw last state if present and ready

        if (tile.surfaceMesh.isReady(true, priority, doNotCheckGpu) && tile.drawCommands[channel].length > 0) {
            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {
                if (!preventRedener) {
                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);
                    this.map.applyCredits(tile);
                }
                return true; // commands are generated so we can return from function here
            } // else ret = false
        } else {
            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {
                if (!preventRedener) {
                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);
                    this.map.applyCredits(tile);
                }
                ret = true;
            }
        }
    }

    if (tile.drawCommands[channel].length > 0) {  //command are generated but not ready, we can return from the function

        if (this.config.mapHeightfiledWhenUnloaded && !preventRedener) {
            tile.drawGrid(cameraPos);
            return false;
        } else {
            return false;
        }
    }

    // information about support for extarnal or internal textures are present in the mesh,
    // so we have to wait until is mesh ready and then we can generate commands
    if (tile.surfaceMesh.isReady(preventLoad, priority, doNotCheckGpu) && !preventLoad) {
        const submeshes = tile.surfaceMesh.submeshes;

        tile.drawCommands = [[], [], []]; //??
        tile.imageryCredits = {};
        tile.boundsDebug = {}; //used for inspector

        let specificity = 0;
        let i, li, j, lj, k, lk, surface;

        surface = tile.resourceSurface;

        if (!surface) {
            surface = tile.surface;
        }

        if (surface.glue) {

            const surfaces = surface.id;
            for (i = 0, li = surfaces.length; i < li; i++) {
                const surface2 = this.map.getSurface(surfaces[i]);
                if (surface2) {
                    specificity = Math.max(specificity, surface2.specificity);
                }
            }

            //set credits
            for (k = 0, lk = node.credits.length; k < lk; k++) {
                tile.glueImageryCredits[node.credits[k]] = specificity;
            }

        } else {

            specificity = surface.specificity;

            //set credits
            for (k = 0, lk = node.credits.length; k < lk; k++) {
                tile.imageryCredits[node.credits[k]] = specificity;
            }
        }


        for (i = 0, li = submeshes.length; i < li; i++) {

            const submesh = submeshes[i];

            //debug bbox
            if (this.debug.drawBBoxes && this.debug.drawMeshBBox && !preventRedener) {
                submesh.drawBBox(cameraPos);
            }

            if (submesh.externalUVs) {
                if (tile.updateBounds) {
                    tile.updateBounds = false;

                    this.updateTileBounds(tile, submeshes);
                }

                surface = tile.resourceSurface;
                if (tile.resourceSurface.glue /*&& submesh.surfaceReference != 0*/) { //glue have multiple surfaces per tile
                    surface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);
                }

                if (surface != null) {
                    const bounds = tile.bounds[surface.id];

                    if (bounds) {
                        if (submesh.externalUVs) {

                            //draw bound layers
                            if (bounds.sequence.length > 0) {
                                if (bounds.transparent) {
                                    if (submesh.internalUVs) {  //draw surface
                                        if (tile.surfaceTextures[i] == null) {
                                            path = tile.resourceSurface.getTextureUrl(tile.id, i);
                                            tile.surfaceTextures[i] = tile.resources.getTexture(path, 0, null, null, tile, true);
                                        }

                                        tile.drawCommands[0].push({
                                            type : 2,
                                            mesh : tile.surfaceMesh,
                                            submesh : i,
                                            texture : tile.surfaceTextures[i],
                                            material : 5
                                        });
                                    }

                                    tile.drawCommands[0].push({
                                        type : 1,
                                        state : draw.drawBlendedTileState
                                    });

                                    const layers = bounds.sequence;
                                    for (j = 0, lj = layers.length; j < lj; j++) {
                                        texture = tile.boundTextures[layers[j]];
                                        if (texture) {

                                            //debug stuff
                                            if (!tile.boundsDebug[surface.id]) {
                                                tile.boundsDebug[surface.id] = [];
                                            }
                                            tile.boundsDebug[surface.id].push(layers[j]);

                                            //set credits
                                            layer = tile.boundLayers[layers[j]];
                                            credits = layer.credits;
                                            for (k = 0, lk = credits.length; k < lk; k++) {
                                                tile.imageryCredits[credits[k]] = layer.specificity;
                                            }

                                            tile.drawCommands[0].push({
                                                type : 2,
                                                mesh : tile.surfaceMesh,
                                                submesh : i,
                                                texture : texture,
                                                alpha : bounds.alpha[layers[j]][1],
                                                material : 7,
                                                layer : layer,
                                                surface : surface
                                            });
                                        }
                                    }

                                    tile.drawCommands[0].push({
                                        type : 2,
                                        mesh : tile.surfaceMesh,
                                        submesh : i,
                                        texture : null,
                                        material : 3
                                    });

                                    tile.drawCommands[0].push({
                                        type : 1,
                                        state : draw.drawTileState
                                    });
                                } else {
                                    const layerId = bounds.sequence[bounds.sequence.length-1];
                                    texture = tile.boundTextures[layerId];
                                    if (texture) {

                                        //debug stuff
                                        if (!tile.boundsDebug[surface.id]) {
                                            tile.boundsDebug[surface.id] = [];
                                        }
                                        tile.boundsDebug[surface.id].push(layerId);

                                        //set credits
                                        layer = tile.boundLayers[layerId];
                                        credits = layer.credits;
                                        for (k = 0, lk = credits.length; k < lk; k++) {
                                            tile.imageryCredits[credits[k]] = layer.specificity;
                                        }

                                        tile.drawCommands[0].push({
                                            type : 2,
                                            mesh : tile.surfaceMesh,
                                            submesh : i,
                                            texture : texture,
                                            material : 6,
                                            layer : layer,
                                            surface : surface
                                        });
                                    }
                                }

                            } else {
                                if (submesh.textureLayer) {

                                    layer = this.map.getBoundLayerByNumber(submesh.textureLayer);

                                    if (layer) {
                                        texture = tile.boundTextures[layer.id];

                                        if (texture) {

                                            //debug stuff
                                            if (!tile.boundsDebug[surface.id]) {
                                                tile.boundsDebug[surface.id] = [];
                                            }
                                            tile.boundsDebug[surface.id].push(layer.id);

                                            //set credits
                                            layer = tile.boundLayers[layer.id];
                                            credits = layer.credits;
                                            for (k = 0, lk = credits.length; k < lk; k++) {
                                                tile.imageryCredits[credits[k]] = layer.specificity;
                                            }

                                            //draw mesh
                                            tile.drawCommands[0].push({
                                                type : 2,
                                                mesh : tile.surfaceMesh,
                                                submesh : i,
                                                texture : texture,
                                                material : 6,
                                                layer : layer,
                                                surface : surface
                                            });
                                        }
                                    }

                                } else {

                                    if (submesh.internalUVs) {  //draw surface
                                        if (tile.surfaceTextures[i] == null) {
                                            path = tile.resourceSurface.getTextureUrl(tile.id, i);
                                            tile.surfaceTextures[i] = tile.resources.getTexture(path, 0, null, null, tile, true);
                                        }

                                        //draw mesh
                                        tile.drawCommands[0].push({
                                            type : 2,
                                            mesh : tile.surfaceMesh,
                                            submesh : i,
                                            surface: surface,
                                            texture : tile.surfaceTextures[i],
                                            material : 4
                                        });
                                    } else {
                                        tile.drawCommands[0].push({
                                            type : 2,
                                            mesh : tile.surfaceMesh,
                                            submesh : i,
                                            texture : null,
                                            material : 2
                                        });
                                    }

                                }
                            }

                        } else if (submesh.internalUVs) {

                            if (tile.surfaceTextures[i] == null) {
                                path = tile.resourceSurface.getTextureUrl(tile.id, i);
                                tile.surfaceTextures[i] = tile.resources.getTexture(path, 0, null, null, tile, true);
                            } //else {
                            tile.drawCommands[0].push({
                                type : 2,
                                mesh : tile.surfaceMesh,
                                submesh : i,
                                surface: surface,
                                texture : tile.surfaceTextures[i],
                                material : 4
                            });
                            //}
                        }
                    }
                }
            } else if (submesh.internalUVs) {

                if (tile.surfaceTextures[i] == null) {
                    path = tile.resourceSurface.getTextureUrl(tile.id, i);
                    tile.surfaceTextures[i] = tile.resources.getTexture(path, 0, null, null, tile, true);
                } //else {
                tile.drawCommands[0].push({
                    type : 2,
                    mesh : tile.surfaceMesh,
                    submesh : i,
                    surface: surface,
                    texture : tile.surfaceTextures[i],
                    material : 4
                });
                //}
            }

            //depth path
            tile.drawCommands[1].push({
                type : 2,
                mesh : tile.surfaceMesh,
                submesh : i,
                material : 1
            });

        }

        if (surface.pipeline > 0) {
            this.updateTileHmap(tile, node);

            for (j = 0; j < 2; j++) {
                const commands = tile.drawCommands[j];
                for (i = 0, li = commands.length; i < li; i++) {
                    if (commands[i].type == 2) {
                        commands[i].pipeline = surface.pipeline;
                        commands[i].hmap = tile.hmap;
                    }
                }
            }
        }

        if (tile.resetDrawCommands) {
            return false;
        }

        if (draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {

            if (tile.resetDrawCommands) {
                return false;
            }

            if (!preventRedener) {
                draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);
                this.map.applyCredits(tile);
            }

            tile.lastRenderState = null;
            ret = true;
        } else if (tile.lastRenderState) {

            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {
                if (!preventRedener) {
                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);
                    this.map.applyCredits(tile);
                }
                ret = true;
            } //else ret = false
        } else {

            if (this.config.mapHeightfiledWhenUnloaded && !preventRedener) {

                //node.drawPlane(cameraPos, tile);
                tile.drawGrid(cameraPos);
                ret = !(tile.drawCommands[channel].length > 0);
            }
        }

    } else {

        if (!tile.lastRenderState && this.config.mapHeightfiledWhenUnloaded && !preventRedener) {
            //node.drawPlane(cameraPos, tile);

            tile.drawGrid(cameraPos);
            ret = !(tile.drawCommands[channel].length > 0);
        }
    }

    return ret;
};


MapDrawTiles.prototype.drawGeodataTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {
    if (tile.id[0] <= 1) {
        return true;
    }

    if (tile.surfaceGeodata == null) {
        let path;

        if (tile.surface.geodataNavtileInfo) {  //remove this code??? no longer used
            const navtile = this.tree.findNavTile(tile.id);

            if (navtile && navtile.surface) {
                const navtileStr = navtile.surface.getNavUrl(navtile.id) + ';'
                                  + navtile.id[0] + '-' + navtile.id[1] + '-' + navtile.id[2] + ';'
                                  + navtile.metanode.minHeight + ';' + navtile.metanode.maxHeight;
                path = tile.surface.getGeodataUrl(tile.id, encodeURIComponent(navtileStr));
            }
        }

        if (!path) {
            path = tile.resourceSurface.getGeodataUrl(tile.id, '');
        }

        tile.surfaceGeodata = tile.resources.getGeodata(path, {tile:tile, surface:tile.surface});
    }

    const channel = this.draw.drawChannel;

    if (tile.geodataCounter != tile.surface.geodataCounter) {
        tile.drawCommands = [[],[],[]];

        if (tile.surfaceGeodataView != null) {
            tile.surfaceGeodataView.kill();
        }

        tile.surfaceGeodataView = null;
        tile.geodataCounter = tile.surface.geodataCounter;
    }

    if (tile.drawCommands[channel].length > 0 && this.draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {
        if (!preventRedener) {
            this.draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);
            this.map.applyCredits(tile);
        }
        tile.lastRenderState = null;
        return true;
    }

    if (!tile.surfaceGeodataView) {
        if (tile.surfaceGeodata.isReady(preventLoad, priority, doNotCheckGpu) && !preventLoad) {
            tile.surfaceGeodataView = new MapGeodataView(this.map, tile.surfaceGeodata, {tile:tile, surface:tile.surface});
        }
    }

    if (tile.surfaceGeodataView) {
        tile.mapdataCredits = {};

        const specificity = (tile.surface) ? tile.surface.specificity : 0;

        //set credits
        for (let k = 0, lk = node.credits.length; k < lk; k++) {
            tile.mapdataCredits[node.credits[k]] = specificity;
        }

        tile.drawCommands[channel][0] = {
            type : 3,
            geodataView : tile.surfaceGeodataView
        };

        return tile.surfaceGeodataView.isReady();
    }

    return false;
};


MapDrawTiles.prototype.updateTileHmap = function(tile, node) {
    if (node && node.hasNavtile() && tile.surface) {

        if (!tile.surface || !tile.resourceSurface) { //surface.virtual) {
            return false; //is it best way how to do it?
        }

        if (!tile.resourceSurface.getHMapUrl) { //virtual surface is as resource surface. Is it bug??!!
            return false; //is it best way how to do it?
        }

        const path = tile.resourceSurface.getHMapUrl(tile.id, true);
        tile.hmap = tile.resources.getTexture(path);

        //const path = tile.surface.getNavUrl(tile.id);
        //tile.hmap = tile.resources.getTexture(path, null, null, null, tile, true);
    } else {

        //get parent with nav tile
        let parent = tile.parent;
        let extraBound = null;

        while(parent && parent.id[0] > 0) {
            if (parent.metanode && parent.metanode.hasNavtile()) {
                extraBound = {
                    sourceTile : parent,
                    sourceTexture : null,
                    hmap : true,
                    tile : tile
                };

                break;
            }

            parent = parent.parent;
        }

        //does parent with navtile exist
        if (extraBound) {
            const path = tile.resourceSurface.getHMapUrl(tile.id, true);
            tile.hmap = tile.resources.getTexture(path, null, extraBound, {tile: tile, hmap: true}, tile, false);

            if (tile.hmap.neverReady) {
                tile.hmap = null;
            }
        } else {
            tile.hmap = null;
        }
    }
};


MapDrawTiles.prototype.updateTileBounds = function(tile, submeshes) {
    for (let i = 0, li = submeshes.length; i < li; i++) {
        const submesh = submeshes[i];

        if (submesh.externalUVs) {
            let submeshSurface = tile.resourceSurface;

            //if (tile.resourceSurface.glue) { //glue have multiple surfaces per tile
              //  submeshSurface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);
            //}

            if (tile.resourceSurface.glue) { //glue have multiple surfaces per tile
                submeshSurface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);
            }


            if (submeshSurface) {
                let bounds = tile.bounds[submeshSurface.id];

                if (!bounds) {
                    bounds = {
                        sequence : [],
                        alpha : [],
                        transparent : false,
                        viewCoutner : 0
                    };

                    tile.bounds[submeshSurface.id] = bounds;
                }

                if (bounds.viewCoutner != tile.viewCoutner) {
                    this.updateTileSurfaceBounds(tile, submesh, submeshSurface, bounds, bounds.viewCoutner != tile.viewCoutner);
                    //bounds.viewCoutner = tile.viewCoutner;
                }
            }
        }
    }

    for (let key in tile.bounds) {
        tile.bounds[key].viewCoutner = tile.viewCoutner;
    }
};


MapDrawTiles.prototype.getParentTile = function(tile, lod) {
    while(tile && tile.id[0] > lod) {
        tile = tile.parent;
    }

    return tile;
};


MapDrawTiles.prototype.getTileTextureTransform = function(sourceTile, targetTile) {
    const shift = targetTile.id[0] - sourceTile.id[0];
    const x = sourceTile.id[1] << shift;
    const y = sourceTile.id[2] << shift;
    const s = 1.0 / Math.pow(2.0, shift);
    return [ s, s, (targetTile.id[1] - x) * s, (targetTile.id[2] - y) * s ];
};


MapDrawTiles.prototype.updateTileSurfaceBounds = function(tile, submesh, surface, bound, fullUpdate) {
    let path, extraBound, layer, texture;

    if (this.config.mapNoTextures) {
        return;
    }

    //search map view
    if (surface.boundLayerSequence.length > 0) {
        if (fullUpdate) {
            bound.sequence = [];
            const sequenceFullAndOpaque = [];
            const sequenceMaskPosible = [];
            let fullAndOpaqueCounter = 0;

            for (let j = 0, lj = surface.boundLayerSequence.length; j < lj; j++) {
                layer = surface.boundLayerSequence[j][0];

                if (layer && layer.ready && layer.hasTileOrInfluence(tile.id) && surface.boundLayerSequence[j][1] > 0) {
                    extraBound = null;

                    if (tile.id[0] > layer.lodRange[1]) {
                        extraBound = {
                            sourceTile : this.getParentTile(tile, layer.lodRange[1]),
                            sourceTexture : null,
                            layer : layer,
                            tile : tile
                        };
                    }

                    texture = tile.boundTextures[layer.id];

                    if (!texture) { //TODO: make sure that we load only textures which we need
                        path = layer.getUrl(tile.id);
                        texture = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);

                        if (texture.checkType == 1) {
                            texture.checkMask = true;
                        }

                        texture.isReady(true); //check for mask but do not load
                        tile.boundTextures[layer.id] = texture;
                    }

                    if (texture.neverReady) {
                        continue; //do not use this layer
                    }

                    let maskPosible = false;
                    let skipOther = false;

                    if (texture.isMaskPosible()) {
                        if (texture.isMaskInfoReady()) {
                            if (texture.getMaskTexture()) {
                                bound.transparent = true;
                                maskPosible = true;
                            }
                        } else {
                            skipOther = true;
                            maskPosible = true;
                        }
                    }

                    sequenceMaskPosible.push(maskPosible);

                    //const fullAndOpaque = !((surface.boundLayerSequence[j][1] < 1.0) || texture.extraBound || texture.getMaskTexture() || layer.isTransparent);
                    const fullAndOpaque = !((surface.boundLayerSequence[j][1] < 1.0) || maskPosible || layer.isTransparent);
                    if (fullAndOpaque) {
                        fullAndOpaqueCounter++;
                    }

                    sequenceFullAndOpaque.push(fullAndOpaque);

                    bound.sequence.push(layer.id);
                    bound.alpha[layer.id] = surface.boundLayerSequence[j];
                    tile.boundLayers[layer.id] = layer;
                    if (bound.alpha[layer.id][1] < 1.0 || layer.isTransparent) {
                        bound.transparent = true;
                    }

                    if (skipOther) {
                        break; //wait until mask info is loaded
                    }
                }
            }

            //filter out extra bounds if they are not needed
            //and remove all layer after first FullAndOpaque
            if (fullAndOpaqueCounter > 0) {
                const newSequence = [];

                for (let i = bound.sequence.length - 1; i >= 0; i--) {
                    const layerId = bound.sequence[i];

                    if (sequenceFullAndOpaque[i]) {
                        newSequence.unshift(layerId);
                        break;
                    } else {
                        texture = tile.boundTextures[layerId];

                        if (bound.alpha[layerId][1] < 1.0 ||
                            tile.boundLayers[layerId].isTransparent ||
                            (sequenceMaskPosible[i] /*texture.getMaskTexture() /*&& !texture.extraBound*/)) {
                            newSequence.unshift(layerId);
                        }
                    }
                }

                bound.sequence = newSequence;
            }

        }
    } else if (surface.textureLayer != null) { //search surface
        if (fullUpdate) {
            layer = this.map.getBoundLayerById(surface.textureLayer);
            if (layer && layer.hasTileOrInfluence(tile.id)) {
                extraBound = null;

                if (tile.id[0] > layer.lodRange[1]) {
                    extraBound = {
                        sourceTile : this.getParentTile(tile, layer.lodRange[1]),
                        sourceTexture : null,
                        layer : layer,
                        tile : tile
                    };
                }

                bound.sequence.push(layer.id);
                tile.boundLayers[layer.id] = layer;
                if (!tile.boundTextures[layer.id]) {
                    path = layer.getUrl(tile.id);
                    tile.boundTextures[layer.id] = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);
                }
            }
        }
    } else { //search submeshes
        if (submesh.textureLayer != 0) {
            layer = this.map.getBoundLayerByNumber(submesh.textureLayer);

            if (layer && layer.hasTileOrInfluence(tile.id)) {
                extraBound = null;

                if (tile.id[0] > layer.lodRange[1]) {
                    extraBound = {
                        sourceTile : this.getParentTile(tile, layer.lodRange[1]),
                        sourceTexture : null,
                        layer : layer,
                        tile : tile
                    };
                }

                //submeshes[j].textureLayerId = tile.id;
                tile.boundLayers[layer.id] = layer;
                if (!tile.boundTextures[layer.id]) {
                    path = layer.getUrl(tile.id);
                    tile.boundTextures[layer.id] = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);
                }
            }
        }
    }
};


MapDrawTiles.prototype.drawTileInfo = function(tile, node, cameraPos, mesh) {
    const debug = this.debug;
    let pos;

    if (!debug.drawMeshBBox) {
        node.drawBBox(cameraPos);
    }

    //get screen pos of node
    if (node.metatile.useVersion < 4) {
        const min = node.bbox.min;
        const max = node.bbox.max;

        pos =  this.core.getRendererInterface().getCanvasCoords(
            [(min[0] + (max[0] - min[0])*0.5) - cameraPos[0],
                (min[1] + (max[1] - min[1])*0.5) - cameraPos[1],
                (max[2]) - cameraPos[2]],
             this.camera.getMvpMatrix());

        pos[2] = pos[2] * 0.9992;
    } else {
        const dx = node.bbox2[3] - node.bbox2[0];
        const dy = node.bbox2[4] - node.bbox2[1];
        const dz = node.bbox2[5] - node.bbox2[2];

        const d = Math.sqrt(dx*dx + dy*dy + dz*dz);

        pos =  this.core.getRendererInterface().getCanvasCoords(
            [(node.bbox2[12] + node.bbox2[15] + node.bbox2[18] + node.bbox2[21])*0.25 + node.diskNormal[0] * d*0.1 - cameraPos[0],
                (node.bbox2[13] + node.bbox2[16] + node.bbox2[19] + node.bbox2[22])*0.25 + node.diskNormal[1] * d*0.1 - cameraPos[1],
                (node.bbox2[14] + node.bbox2[17] + node.bbox2[20] + node.bbox2[23])*0.25 + node.diskNormal[2] * d*0.1 - cameraPos[2]],
             this.camera.getMvpMatrix());

        /*
            const pos =  this.core.getRendererInterface().getCanvasCoords(
                            [(node.diskPos[0] + node.diskNormal[0] * node.bboxHeight) - cameraPos[0],
                             (node.diskPos[1] + node.diskNormal[1] * node.bboxHeight) - cameraPos[1],
                             (node.diskPos[2] + node.diskNormal[2] * node.bboxHeight) - cameraPos[2]],
                             this.camera.getMvpMatrix());
        */
    }

    let factor = debug.debugTextSize, text, i, li,c;

    //draw lods
    if (debug.drawLods) {
        text = '' + tile.id[0]; // + ' ta:' + Math.abs(tile.tiltAngle).toFixed(3);
        //text = '' + tile.id[0] + ' c:' + (50*(Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), VTS_TILE_COUNT_FACTOR) / Math.max(0.00001, this.renderer.drawnGeodataTilesFactor))).toFixed(3) +
          //     ' l:' + Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), VTS_TILE_COUNT_FACTOR).toFixed(3) + ' g:' + this.renderer.drawnGeodataTilesFactor.toFixed(3);
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-4*factor), 4*factor, text, [1,0,0,1], pos[2]);
    }

    //draw indices
    if (debug.drawIndices) {
        text = '' + tile.id[1] + ' ' + tile.id[2];
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-11*factor), 4*factor, text, [0,1,1,1], pos[2]);
    }

    //draw positions
    if (debug.drawPositions) {
        //text = "" + min[0].toFixed(1) + " " + min[1].toFixed(1) + " " + min[2].toFixed(1);
        //text = "" + Math.floor(node.corners[0]) + " " + Math.floor(node.corners[1]) + " " + Math.floor(node.corners[2]) + " " + Math.floor(node.corners[3]);

        let b = node.border2;
        if (b) {
            text = '' + Math.floor(b[0]) + ' ' + Math.floor(b[1]) + ' ' + Math.floor(b[2]) + ' ' + Math.floor(b[3]) + ' ' + Math.floor(b[4]) + ' ' + Math.floor(b[5]) + ' ' + Math.floor(b[6]) + ' ' + Math.floor(b[7]) + ' ' + Math.floor(b[8]);
            this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [0,1,1,1], pos[2]);
        }

        b = node.border;
        if (b) {
            this.draw.getDrawCommandsGpuSize(tile.drawCommands[this.draw.drawChannel] || tile.lastRenderState.drawCommands[this.draw.drawChannel]); Math.floor(b[0]) + ' ' + Math.floor(b[1]) + ' ' + Math.floor(b[2]) + ' ' + Math.floor(b[3]) + ' ' + Math.floor(b[4]) + ' ' + Math.floor(b[5]) + ' ' + Math.floor(b[6]) + ' ' + Math.floor(b[7]) + ' ' + Math.floor(b[8]);
            this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,1,1], pos[2]);
        }

        //text = 'llx:' + Math.floor(node.llx) + ' lly:' + Math.floor(node.lly) + ' urx:' + Math.floor(node.urx) + ' ury:' + Math.floor(node.ury);
        //this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [0,1,1,1], pos[2]);
    }

    //draw resources
    if (debug.drawResources && mesh) {
        text = '' + (this.draw.getDrawCommandsGpuSize(tile.drawCommands[0] || tile.lastRenderState.drawCommands[0])/(1024*1024)).toFixed(2) + 'MB';
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);
    }

    //draw face count
    if (debug.drawFaceCount && mesh) {
        text = '' + mesh.faces + ' - ' + mesh.submeshes.length + ((tile.surface && tile.surface.glue) ? ' - 1' : ' - 0');
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);
    }

    //draw geodata pixel size
    if (debug.drawGPixelSize) {
        text = '' + ((Math.tan(tile.metanode.diskAngle2A) * tile.metanode.diskDistance * 0.70710678118) / node.displaySize).toFixed(2);
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);
    }

    //draw order
    if (debug.drawOrder) {
        text = '' + this.drawTileCounter + ' cmds: ' + (tile.drawCommands[0].length);
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);
    }

    if (debug.drawSurfaces || debug.drawSurfaces2) {
        text = JSON.stringify(tile.surface.id);

        if (debug.drawSurfaces2) {
            //c = utils.getHashColor(text);
            c = utils.getHashColor2(tile.surface.surfaceCounter);
            //c = [c[0]/255,c[1]/255,c[2]/255,1];
            c = [c[0],c[1],c[2],1];
        } else {
            c = [1,1,1,1];
        }

        if (node.alien) {
            text = '[A]' + text;
        }

        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, c, pos[2]);
    }

    if (debug.drawBoundLayers) {
        if (tile.boundsDebug) {
            const surface = tile.resourceSurface;
            if (surface.glue) {

                for (i = 0, li = surface.id.length; i < li; i++) {
                    if (tile.boundsDebug[surface.id[i]]) {
                        text = '< ' + surface.id[i] + ' >';
                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(10+i*7*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);
                        text = JSON.stringify(tile.boundsDebug[surface.id[i]]);
                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*7*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);
                    }
                }

            } else if (tile.boundsDebug[surface.id]) {
                text = '< ' + surface.id + ' >';
                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [1,1,1,1], pos[2]);

                text = JSON.stringify(tile.boundsDebug[surface.id]);
                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+17*factor), 4*factor, text, [1,1,1,1], pos[2]);
            }
        }
    }

    if (debug.drawCredits) {
        text = '{ ';

        for (let key in tile.imageryCredits) {
            if (tile.imageryCredits[key]) {
                text += key + ':' + tile.imageryCredits[key] + ', ';
            }
        }

        for (let key in tile.glueImageryCredits) {
            if (!tile.imageryCredits[key]) {
                text += key + ':' + tile.glueImageryCredits[key] + ', ';
                //text += key + ", ";
            }
        }

        text += '}';

        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [1,1,1,1], pos[2]);
    }

    //draw distance
    if (debug.drawDistance) {
        text = '' + tile.distance.toFixed(2) + '  ' + tile.texelSize.toFixed(3) + '  ' + node.pixelSize.toFixed(3);
        text += '--' + tile.texelSize2.toFixed(3);
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+17*factor), 4*factor, text, [1,0,1,1], pos[2]);
    }

    //draw node info
    if (debug.drawNodeInfo) {
        const children = ((node.flags & ((15)<<4))>>4);
        text = 'v' + node.metatile.version + '-' + node.flags.toString(2) + '-' + ((children & 1) ? '1' : '0') + ((children & 2) ? '1' : '0') + ((children & 4) ? '1' : '0') + ((children & 8) ? '1' : '0');
        text += '-' + node.minHeight + '/' + node.maxHeight+ '-' + Math.floor(node.minZ) + '/' + Math.floor(node.maxZ)+ '-' + Math.floor(node.surrogatez);
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-18*factor), 4*factor, text, [1,0,1,1], pos[2]);
    }

    //draw texture size
    if (debug.drawTextureSize && mesh) {
        const submeshes = mesh.submeshes;
        for (i = 0, li = submeshes.length; i < li; i++) {

            if (submeshes[i].internalUVs) {
                const texture = tile.surfaceTextures[i];
                if (texture) {
                    const gpuTexture = texture.getGpuTexture();
                    if (gpuTexture) {
                        text = '[' + i + ']: ' + gpuTexture.width + ' x ' + gpuTexture.height;
                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);
                    }
                }
            } else {
                text = '[' + i + ']: 256 x 256';
                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);
            }
        }
    }

};


/* harmony default export */ __webpack_exports__["default"] = (MapDrawTiles);


/***/ }),

/***/ "./src/core/map/draw.js":
/*!******************************!*\
  !*** ./src/core/map/draw.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var _geodata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geodata */ "./src/core/map/geodata.js");
/* harmony import */ var _geodata_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geodata-view */ "./src/core/map/geodata-view.js");
/* harmony import */ var _draw_tiles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./draw-tiles */ "./src/core/map/draw-tiles.js");







//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_1__["math"];
const MapDrawTiles = _draw_tiles__WEBPACK_IMPORTED_MODULE_4__["default"];
const MapGeodataView = _geodata_view__WEBPACK_IMPORTED_MODULE_3__["default"];
const MapGeodata = _geodata__WEBPACK_IMPORTED_MODULE_2__["default"];

const MapDraw = function(map) {
    this.map = map;
    this.config = map.config;
    this.isProjected = map.getNavigationSrs().isProjected();
    this.isGeocent = map.isGeocent;

    this.renderer = map.renderer;
    this.stats = map.stats;
    this.camera = map.camera;
    this.tree = map.tree;

    this.ndcToScreenPixel = this.renderer.curSize[0] * 0.5;

    this.debug = {
        heightmapOnly : false,
        blendHeightmap : true,
        drawBBoxes : false,
        drawNBBoxes : false,
        drawSpaceBBox : false,
        drawMeshBBox : false,
        drawLods : false,
        drawPositions : false,
        drawTexelSize : false,
        drawWireframe : 0,
        drawTestMode : 0,
        drawTestData : 0,
        drawFaceCount : false,
        drawDistance : false,
        drawMaxLod : false,
        drawGeodataOnly : false,
        drawTextureSize : false,
        drawNodeInfo : false,
        drawLayers : true,
        drawBoundLayers : false,
        drawSurfaces : false,
        drawCredits : false,
        drawOrder : false,
        drawOctants : false,
        drawLabelBoxes : false,
        drawAllLabels : false,
        drawHiddenLabels : false,
        drawEarth : true,
        drawGridCells : false,
        drawTileCounter : 0,
        drawPolyWires : false,
        drawFog : this.config.mapFog,
        drawGPixelSize : false,
        debugTextSize : 2.0,
        ignoreTexelSize : false,
        maxZoom : false
    };

    this.gridFlat = false;
    this.gridGlues = false;
    this.gridSkipped = false;

    this.atmoColor = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];
    this.atmoColor2 = [72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0];
    this.atmoHeight = 50000;
    this.atmoHeightFactor = 1; //this.atmoHeight / 50000;
    this.atmoDensity = 1; //this.atmoHeight / 50000;

    this.fogDensity = 0;
    this.zFactor = 0;
    //this.zFactor2 = 0.000012;
    this.zFactor2 = 0.003;
    this.zbufferOffset = null;
    this.zShift = 0;
    this.zLastShift = 0;
    this.bestMeshTexelSize = 1;
    this.bestGeodataTexelSize = 1;
    this.log8 = Math.log(8);
    this.log2 = Math.log(2);

    this.geodataTilesPerLayer = 0;

    this.drawCounter = 0;
    this.drawChannel = 0;
    this.drawChannelNames = ['base', 'hit'];

    this.planetRadius = this.isGeocent ? map.getNavigationSrs().getSrsInfo()['a'] : 100;
    this.tileBuffer = new Array(500);
    this.processBuffer = new Array(60000);
    this.processBuffer2 = new Array(60000);
    this.drawBuffer = new Array(60000);
    this.drawBuffer2 = new Array(60000);
    this.tmpVec3 = new Array(3);
    this.tmpVec5 = new Array(5);
    this.bboxBuffer = new Float32Array(8*3);
    this.planeBuffer = new Float32Array(9*3);
    //this.drawBufferIndex = 0;

    const gpu = this.renderer.gpu;
    this.drawTileState = gpu.createState({});
    this.drawStardomeState = gpu.createState({zwrite:false, ztest:false});
    this.drawBlendedTileState = gpu.createState({zequal:true, blend:true});
    this.drawAuraState = gpu.createState({zwrite:false, blend:true});
    this.drawAtmoState = gpu.createState({zwrite:false, ztest:false, blend:true});
    this.drawAtmoState2 = gpu.createState({zwrite:false, ztest:true, blend:false});

    this.degradeHorizonFactor = 0;
    this.degradeHorizonTiltFactor = 0;

    this.replay = {
        camera : null,
        drawnTiles : null,
        drawnFreeTiles : null,
        nodeBuffer : null,
        tracedNodes : null,
        tracedFreeNodes : null,
        storeTiles : false,
        storeFreeTiles : false,
        storeNodes : false,
        storeFreeNodes : false,
        storeLoaded : this.config.mapStoreLoadStats,
        drawGlobe : false,
        drawTiles : false,
        drawNodes : false,
        drawFreeTiles : false,
        drawFreeNodes : false,
        drawLoaded : false,
        lod : 30,
        singleLod : false,
        loadedIndex : 0,
        singleLodedIndex : 0,
        loaded : [],
        loadFirst : 0,
        loadLast : 0
    };

    this.drawTiles = new MapDrawTiles(map, this);
};


MapDraw.prototype.drawMap = function(skipFreeLayers) {
    const map = this.map;
    const renderer = this.renderer;
    const camera = this.camera;
    const replay = this.replay;
    const gpu = renderer.gpu;
    const debug = this.debug;

    if (this.drawChannel != 1) {
        gpu.setViewport();

        map.visibleCredits = {
            imagery : {},
            glueImagery : {},
            mapdata : {}
        };
    }

    const projected = this.isProjected;

    switch (this.config.mapGridMode) {
        case 'none':       this.gridSkipped = true; this.gridFlat = false; this.gridGlues = false;  break;
        case 'flat':       this.gridSkipped = false; this.gridFlat = true; this.gridGlues = false;  break;
        case 'linear':     this.gridSkipped = false; this.gridFlat = false; this.gridGlues = true;  break;
        case 'fastlinear': this.gridSkipped = false; this.gridFlat = false; this.gridGlues = false; break;
    }

    const drawTiles = this.drawTiles;
    const camInfo = camera.update();
    //const renderer = this.renderer;

    renderer.debugStr = 'AsyncImageDecode: ' + this.config.mapAsyncImageDecode;
    renderer.dirty = true;
    renderer.drawFog = this.debug.drawFog;
    renderer.debug = this.debug;
    renderer.mapHack = map;
    renderer.benevolentMargins = this.config.mapBenevolentMargins;

    if (this.config.mapForceFrameTime) {
        if (this.config.mapForceFrameTime != -1) {
            renderer.frameTime = this.config.mapForceFrameTime;
        } else {
            renderer.frameTime = 0;
        }
    } else {
        renderer.frameTime = this.stats.frameTime;
    }

    renderer.hoverFeatureCounter = 0;
    renderer.hoverFeatureList = map.hoverFeatureList;
    renderer.hoverFeature = map.hoverFeature;

    renderer.cameraPosition = camera.position;
    renderer.cameraOrientation = map.position.getOrientation();
    renderer.cameraTiltFator = Math.cos(math.radians(renderer.cameraOrientation[1]));
    renderer.cameraVector = camera.vector;
    renderer.cameraViewExtent = map.position.getViewExtent();
    renderer.cameraViewExtent2 = Math.pow(2.0, Math.max(1.0, Math.floor(Math.log(map.position.getViewExtent()) / Math.log(2))));
    renderer.drawLabelBoxes = this.debug.drawLabelBoxes;
    renderer.drawGridCells = this.debug.drawGridCells;
    renderer.drawAllLabels = this.debug.drawAllLabels;
    renderer.drawHiddenLabels = this.debug.drawHiddenLabels;
    renderer.debug = this.debug;
    renderer.fmaxDist = Number.NEGATIVE_INFINITY;
    renderer.fminDist = Number.POSITIVE_INFINITY;


    if (projected) {
        const yaw = math.radians(renderer.cameraOrientation[0]);
        renderer.labelVector = [-Math.sin(yaw), Math.cos(yaw), 0, 0, 0];
    } else {
        const v = camInfo.vector;
        renderer.labelVector = [v[0], v[1], v[2], 0];
    }

    renderer.distanceFactor = 1 / Math.max(1,Math.log(camera.distance) / Math.log(1.04));
    renderer.tiltFactor = (Math.abs(renderer.cameraOrientation[1]/-90));
    renderer.localViewExtentFactor = 2 * Math.tan(math.radians(map.position.getFov()*0.5));

    this.degradeHorizonFactor = 200.0 * this.config.mapDegradeHorizonParams[0];
    this.degradeHorizonTiltFactor = 0.5*(1.0+Math.cos(math.radians(Math.min(180,Math.abs(renderer.cameraOrientation[1]*2*3)))));

    if (this.map.renderer.device === 2) {
        this.renderer.gpu.startRender();
    }

    if (this.drawChannel != 1) {
        if (debug.drawWireframe == 2) {
            gpu.clear(true, true, [255,255,255,255]);
        } else {
            gpu.clear(true, true, [0,0,0,255]);
        }
    } else { //render depth map
        gpu.clear(true, true, [255,255,255,255]);
    }

    gpu.setState(this.drawStardomeState);

    /*
    if (this.drawChannel != 1) {
        if (debug.drawWireframe == 2) {
            renderer.gpu.draw.drawSkydome(renderer.whiteTexture, gpu.progStardome);
        } else {
            renderer.gpu.draw.drawSkydome(renderer.blackTexture, gpu.progStardome);
        }
    }*/

    gpu.setState(this.drawTileState);

    this.setupDetailDegradation();

    map.loader.setChannel(0); //0 = hires channel
    this.zFactor = 0;

    this.ndcToScreenPixel = renderer.curSize[0] * 0.5;
    this.updateFogDensity();
    this.updateGridFactors();
    this.maxGpuUsed = Math.max(32*102*1204, map.gpuCache.getMaxCost() - 32*102*1204);
    //this.cameraCenter = this.position.getCoords();
    this.stats.renderBuild = 0;
    this.drawTileCounter = 0;
    const cameraPos = camera.position;
    let i, li, j, lj, tile, tiles, tmp, layer, drawnTiles, nodeBuffer;

    if (map.freeLayersHaveGeodata && this.drawChannel == 0) {
        renderer.gpu.draw.clearJobBuffer();
    }

    if (this.debug.drawEarth) {
        if (replay.storeNodes || replay.storeFreeNodes) {
            replay.nodeBuffer = [];
        }

        if (replay.drawGlobe || replay.drawTiles || replay.drawFreeTiles||
            replay.drawNodes || replay.drawFreeNodes || replay.drawLoaded) { //used only in inspector

            const lod = replay.lod;
            const single = replay.singleLod;

            if (replay.drawTiles && replay.drawnTiles) {
                tiles = replay.drawnTiles;
                for (i = 0, li = tiles.length; i < li; i++) {
                    if (!tiles[i][1]) { //skip grids
                        tile = tiles[i][0];
                        if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {
                            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);
                        }
                    } else {
                        tile = tiles[i][0];
                        if (drawTiles.debug.drawBBoxes) {
                            drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);
                        }

                        tile.drawGrid(cameraPos);
                    }
                }
            }

            if (replay.drawFreeTiles && replay.drawnFreeTiles) {
                tiles = replay.drawnFreeTiles;
                for (i = 0, li = tiles.length; i < li; i++) {
                    if (!tiles[i][1]) { //skip grids
                        tile = tiles[i][0];
                        if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {
                            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);
                        }
                    }
                }
            }

            if (replay.drawNodes && replay.tracedNodes) {
                tiles = replay.tracedNodes;
                tmp = debug.drawBBoxes;
                debug.drawBBoxes = true;
                for (i = 0, li = tiles.length; i < li; i++) {
                    tile = tiles[i];
                    if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {
                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);
                    }
                }
                debug.drawBBoxes = tmp;
            }

            if (replay.drawFreeNodes && replay.tracedFreeNodes) {
                tiles = replay.tracedFreeNodes;
                tmp = debug.drawBBoxes;
                debug.drawBBoxes = true;
                for (i = 0, li = tiles.length; i < li; i++) {
                    tile = tiles[i];
                    if ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod)) {
                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);
                    }
                }
                debug.drawBBoxes = tmp;
            }

            const index = replay.loadedIndex;
            const singleIndex = replay.singleLodedIndex;

            if (replay.drawLoaded && replay.loaded) {
                const  loaded = replay.loaded;
                debug.drawBBoxes = true;
                for (i = 0, li = loaded.length; i < li; i++) {
                    const file = loaded[i];
                    if (file && file.tile && file.tile.id) {
                        tile = file.tile;
                        if (((singleIndex && i == index) || (!singleIndex && i <= index)) &&
                             ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod)) ) {
                            if (tile.metanode) {
                                if (tile.metanode.hasGeometry()) {
                                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);
                                } else {
                                    drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);
                                }
                            }
                        }
                    }
                }
                debug.drawBBoxes = tmp;
            }

            if ((replay.drawFreeTiles && replay.drawnFreeTiles) ||
                (replay.drawLoaded && replay.loaded)) {

                if (this.freeLayersHaveGeodata && this.drawChannel == 0) {
                    renderer.drawnGeodataTiles = this.stats.drawnGeodataTilesPerLayer; //drawnGeodataTiles;
                    renderer.drawnGeodataTilesFactor = this.stats.drawnGeodataTilesFactor;
                    renderer.gpu.draw.drawGpuJobs();
                }
            }

            return;
        }

        for (i = 0, li = this.tileBuffer.length; i < li; i++) {  //todo remove this
            this.tileBuffer[i] = null;
        }

        if (this.tree.surfaceSequence.length > 0) {
            this.tree.draw();
        }

        if (replay.storeTiles) { //used only in inspectors
            drawnTiles = [];

            for (i = 0, li = this.tileBuffer.length; i < li; i++) {
                tiles = this.tileBuffer[i];

                if (tiles) {
                    for (j = 0, lj = tiles.length; j < lj; j++) {
                        drawnTiles.push(tiles[j]);
                    }
                }
            }

            replay.cameraPos = cameraPos;
            replay.drawnTiles = drawnTiles;
            replay.storeTiles = false;
        }

        if (replay.storeNodes) { //used only in inspector
            nodeBuffer = [];

            for (i = 0, li = replay.nodeBuffer.length; i < li; i++) {
                tile = replay.nodeBuffer[i];
                nodeBuffer.push(tile);
            }

            replay.cameraPos = cameraPos;
            replay.tracedNodes = nodeBuffer;
            replay.storeNodes = false;
        }

        //draw free layers
        for (i = 0, li = map.freeLayerSequence.length; i < li; i++) {
            layer = map.freeLayerSequence[i];
            if (layer.ready && layer.tree &&
                (!layer.geodata || (layer.stylesheet && layer.stylesheet.isReady())) && (this.drawChannel == 0 || (this.drawChannel == 1 && layer.hitable))) {

                if (layer.zFactor) {
                    this.zbufferOffset = layer.zFactor;
                }

                if (layer.type == 'geodata') {
                    this.drawMonoliticGeodata(layer);
                } else {
                    layer.tree.draw();
                }

                this.zbufferOffset = null;
            }
        }

        if (replay.storeFreeTiles) { //used only in inspector
            drawnTiles = [];

            for (i = 0, li = this.tileBuffer.length; i < li; i++) {
                tiles = this.tileBuffer[i];

                if (tiles) {
                    for (j = 0, lj = tiles.length; j < lj; j++) {
                        tile = tiles[j];
                        if (tile.surface && tile.surface.free) { //do no draw free layers
                            drawnTiles.push(tile);
                        }
                    }
                }
            }

            replay.cameraPos = cameraPos;
            replay.drawnFreeTiles = drawnTiles;
            replay.storeFreeTiles = false;
        }

        if (replay.storeFreeNodes) { //used only in inspector
            nodeBuffer = [];

            for (i = 0, li = replay.nodeBuffer.length; i < li; i++) {
                tile = replay.nodeBuffer[i];
                if (tile.surface && tile.surface.free) { //do no draw free layers
                    nodeBuffer.push(tile);
                }
            }

            replay.cameraPos = cameraPos;
            replay.tracedFreeNodes = nodeBuffer;
            replay.storeFreeNodes = false;
        }
    }

    const body = map.referenceFrame.body;

    //draw skydome before geodata
    if (this.drawChannel != 1 && !projected && debug.drawFog &&
        ((body && body.atmosphere) || map.referenceFrame.id == 'melown2015' || map.referenceFrame.id == 'mars-qsc' || map.referenceFrame.id == 'earth-qsc')/* &&
    gpu.progAtmo.isReady() && gpu.progAtmo2.isReady()*/) {

        const navigationSrsInfo = map.getNavigationSrs().getSrsInfo();
        const earthRadius =  navigationSrsInfo['a'];
        const earthRadius2 =  navigationSrsInfo['b'];
        const atmoSize = this.atmoHeight;
        renderer.earthRadius = earthRadius;
        renderer.earthRadius2 = earthRadius2;
        renderer.earthERatio = earthRadius / earthRadius2;

        const cameraPosToEarthCenter = [0,0,0,0];
        vec3.normalize(camera.position, cameraPosToEarthCenter);

        const pos = map.getPosition();
        //const orientation = pos.getOrientation();
        //const tiltFactor = (Math.max(5,-orientation[1])/90);

        //const cameraHeight = Math.max(atmoSize * 0.1, camera.geocentDistance - earthRadius);
        const heightFactor = 1-math.clamp(Math.max(atmoSize * 0.1, camera.geocentDistance - earthRadius) / (atmoSize*(10)), 0, 1);

        let params = [Math.max(2,heightFactor*128),0,0,0], params2, params3;

        /*
        if (cameraHeight > earthRadius*2) { //prevent foggy earth from larger distance
            params[0] = 2-Math.min(1.0, (camera.height - earthRadius*2) / (earthRadius*2));
        }*/

        //gpu.setState(this.drawAtmoState);
        //renderer.gpu.draw.drawBall([-camera.position[0], -camera.position[1], -camera.position[2]],
          //                       earthRadius + 3000, earthRadius2 + 3000, gpu.progAtmo2, params,  cameraPosToEarthCenter, null, this.atmoColor3, this.atmoColor2, true);// this.cameraHeight > atmoSize ? 1 : -1);

        const safetyFactor = 2.0;
        params = [safetyFactor, safetyFactor * ((earthRadius + atmoSize) / earthRadius), 0.25, safetyFactor* ((earthRadius + atmoSize) / earthRadius)];
        const factor = (1 / (earthRadius) ) * safetyFactor;
        params2 = [camera.position[0] * factor, camera.position[1] * factor, camera.position[2] * factor, 1];

        const distance = (pos.getViewExtent()*0.5) / Math.tan(math.radians(pos.getFov()*0.5));
        const a1 = (earthRadius / (distance + earthRadius)); //get angle to horion

        //const n2 = 10.05;
        const n2 = 5.00;

        const t1 = math.mix(4.4, 1.01, a1);
        const t2 = math.mix(n2, 1.05, a1); // * 1.0176;

        params3 = [t1, 1 ,t2,0];

        //console.log("a1: " + a1 + " t2: " + t2);

        gpu.setState(this.drawAuraState);
        renderer.gpu.draw.drawBall([-camera.position[0], -camera.position[1], -camera.position[2]],
                                 earthRadius + atmoSize, earthRadius2 + atmoSize, gpu.progAtmo, params,  params2, params3, this.atmoColor, this.atmoColor2);// this.camera.height > atmoSize ? 1 : -1);

        gpu.setState(this.drawTileState);
    }

    if (debug.drawEarth) {
        if (!skipFreeLayers) {
            if (map.freeLayersHaveGeodata && this.drawChannel == 0) {
                renderer.drawnGeodataTiles = this.stats.drawnGeodataTilesPerLayer; //drawnGeodataTiles;
                renderer.drawnGeodataTilesFactor = this.stats.drawnGeodataTilesFactor;
                renderer.gpu.draw.drawGpuJobs();
            }
        }
    }


    if (this.map.renderer.device === 2) {
        this.renderer.gpu.finishRender();
    }

    if (this.config.mapForceFrameTime) {
        if (this.config.mapForceFrameTime != -1) {
            renderer.frameTime = 0;
            this.config.mapForceFrameTime = -1;
        }
    }
};

MapDraw.prototype.drawToTexture = function(texture) {
    this.renderer.switchToFramebuffer('texture', texture);
    this.drawChannel = 0;
    this.map.renderSlots.processRenderSlots();
    this.renderer.switchToFramebuffer('base');
};


MapDraw.prototype.drawHitmap = function() {
    this.drawChannel = 1;
    this.renderer.switchToFramebuffer('depth');
    this.map.renderSlots.processRenderSlots();
    this.renderer.switchToFramebuffer('base');

    if (this.renderer.hitmapMode > 2) {
        this.renderer.copyHitmap();
    }

    this.drawChannel = 0;
    this.map.hitMapDirty = false;
};


MapDraw.prototype.drawGeodataHitmap = function() {

    if (this.map.renderer.device === 2) {
        return;
    }

    this.renderer.gpu.setState(this.drawTileState);
    this.renderer.switchToFramebuffer('geo');
    this.renderer.gpu.draw.drawGpuJobs();

    if (this.renderer.advancedPassNeeded) {
        this.renderer.switchToFramebuffer('geo2');
        this.renderer.gpu.draw.drawGpuJobs();
    }

    this.renderer.switchToFramebuffer('base');
    this.map.geoHitMapDirty = false;
};

MapDraw.prototype.getDrawCommandsGpuSize = function(commands) {
    let gpuNeeded = 0;

    for (let i = 0, li = commands.length; i < li; i++) {
        const command = commands[i];

        switch (command.type) {
        case 2:
            {
                const mesh = command.mesh;
                const texture = this.config.mapNoTextures ? 0 : command.texture;

                if (mesh) {
                    gpuNeeded += mesh.gpuSize;
                }

                if (texture && !(this.config.mapNoTextures || this.debug.drawWireframe)) {
                    gpuNeeded += texture.getGpuSize();
                }
            }
            break;

        case 3:
            {
                const geodataView = command.geodataView;

                if (geodataView) {
                    gpuNeeded += geodataView.size;
                }
            }
            break;
        }
    }

    return gpuNeeded;
};


MapDraw.prototype.areDrawCommandsReady = function(commands, priority, doNotLoad, doNotCheckGpu) {
    let ready = true;
    const checkGpu = doNotCheckGpu ? true : false;

    for (let i = 0, li = commands.length; i < li; i++) {
        const command = commands[i];

        switch (command.type) {
        case 2:
            {
                const pipeline = command.pipeline;
                if (pipeline) {
                    const hmap = command.hmap;

                    if (!(hmap && hmap.isReady(doNotLoad, priority))) {
                        ready = false;
                    }

                    if (this.debug.drawTestMode == 9) {
                        const texture = command.texture;
                        const textureReady = this.config.mapNoTextures ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority, checkGpu)));

                        if (!textureReady) {
                            ready = false;
                        }
                    }

                    break;
                }

                const mesh = command.mesh;
                const texture = command.texture;

                const meshReady = (mesh && mesh.isReady(doNotLoad, priority, checkGpu));
                const textureReady = (this.config.mapNoTextures || this.debug.drawWireframe) ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority, checkGpu)));

                if (!(meshReady && textureReady) ) {
                    ready = false;
                }
            }
            break;

        case 3:
            {
                const geodataView = command.geodataView;

                if (!(geodataView && geodataView.isReady(doNotLoad, priority, checkGpu))) {
                    ready = false;
                }
            }
            break;
        }
    }

    return ready;
};


MapDraw.prototype.processDrawCommands = function(cameraPos, commands, priority, doNotLoad, tile) {
    if (commands.length > 0) {
        this.drawTileCounter++;
    }

    for (let i = 0, li = commands.length; i < li; i++) {
        const command = commands[i];

        switch (command.type) {
        case 1:
            this.renderer.gpu.setState(command.state);
            break;

        case 2:
            {
                const pipeline = command.pipeline;
                if (pipeline) {
                    const hmap = command.hmap;

                    if (this.debug.drawTestMode == 9) {
                        const texture = command.texture;
                        const textureReady = this.config.mapNoTextures ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority)));

                        if (textureReady) {
                            if (hmap && hmap.isReady(doNotLoad, priority)) {
                                tile.drawHmapTile(cameraPos, null, null, pipeline, texture);
                            }
                        }
                    } else {
                        if (hmap && hmap.isReady(doNotLoad, priority)) {
                            tile.drawHmapTile(cameraPos, null, null, pipeline);
                        }
                    }

                    return;
                }

                const mesh = command.mesh;
                let texture = command.texture;

                let meshReady = (mesh && mesh.isReady(doNotLoad, priority)), textureReady;

                if (this.config.mapNoTextures) {
                    textureReady = true;
                    texture = null;
                } else {
                    textureReady = (!texture || (texture && texture.isReady(doNotLoad, priority)));
                }

                if (meshReady && textureReady) {
                        //debug bbox
                    if (this.debug.drawBBoxes && this.debug.drawMeshBBox) {
                        mesh.submeshes[command.submesh].drawBBox(cameraPos);
                    }

                    if (!texture) {
                        let material = command.material;
                        switch (material) {
                                //case "fog":
                        case 6:
                        case 4:
                            material = 2;
                            break;
                        }
                        mesh.drawSubmesh(cameraPos, command.submesh, texture, material, command.alpha, command.layer, command.surface, tile.splitMask);
                    } else {
                        //tile.renderHappen = true;
                        mesh.drawSubmesh(cameraPos, command.submesh, texture, command.material, command.alpha, command.layer, command.surface, tile.splitMask);
                    }

                }
            }
            break;

        case 3:
            {
                const geodataView = command.geodataView;
                //tile.renderHappen = true;

                if (geodataView && geodataView.isReady(doNotLoad, priority, true)) {
                    geodataView.draw(cameraPos);
                }
            }
            break;
        }
    }
};


MapDraw.prototype.drawMonoliticGeodata = function(surface) {
    if (!surface || (this.drawChannel != 0 && !(this.drawChannel == 1 && surface.hitable))) {
        return;
    }

    if (!this.camera.camera.bboxVisible(surface.extents, this.camera.position)) {
        return;
    }

    let path;

    if (surface.monoGeodata == null) {
        if (typeof surface.geodataUrl === 'object') {
            path = surface.geodataUrl;
        } else {
            path = surface.getMonoGeodataUrl(surface.id);
        }

        surface.monoGeodata = new MapGeodata(this.map, path, {tile:null, surface:surface});
    }

    if (surface.monoGeodataCounter != surface.geodataCounter) {
        surface.monoGeodataView = null;
        surface.monoGeodataCounter = surface.geodataCounter;
    }

    if (surface.monoGeodata.isReady(null, null, null, surface.options.fastParse)) {

        if (!surface.monoGeodataView) {
            surface.monoGeodataView = new MapGeodataView(this.map, surface.monoGeodata, {tile:null, surface:surface});
        }

        if (surface.monoGeodataView.isReady()) {
            const mapdataCredits = this.map.visibleCredits.mapdata

            for (let i = 0, li = surface.credits.length; i < li; i++) {
                const key = surface.credits[i]
                const value = 10; //fixed specificity
                const value2 = mapdataCredits[key];

                if (value2) {
                    mapdataCredits[key] = value > value2 ? value : value2;
                } else {
                    mapdataCredits[key] = value;
                }
            }

            surface.monoGeodataView.draw(this.camera.position);
        }
    }
};


MapDraw.prototype.updateFogDensity = function() {
    // the fog equation is: exp(-density*distance), this gives the fraction
    // of the original color that is still visible at some distance

    // we define visibility as a distance where only 5% of the original color
    // is visible; from this it is easy to calculate the correct fog density

    //const density = Math.log(0.05) / this.core.coreConfig.cameraVisibility;
    const pos = this.map.getPosition();
    const orientation = pos.getOrientation();

    const cameraVisibility = this.camera.getFar();

    const tiltFactor = (Math.max(5,-orientation[1])/90);
    let density = Math.log(0.05) / ((this.atmoDensity * cameraVisibility * this.atmoHeightFactor * Math.max(1,this.camera.height*0.0001))* tiltFactor);
    density *= (5.0) / (Math.min(50000, Math.max(this.camera.distance, 1000)) /5000);

    if (!this.debug.drawFog) {
        density = 0;
    }

    //reduce fog when camera is facing down
    //density *= 1.0 - (-this.orientation[0]/90)

    this.fogDensity = density;
    this.renderer.fogDensity = density;
};


MapDraw.prototype.updateGridFactors = function() {
    const nodes = this.map.referenceFrame.getSpatialDivisionNodes();

    for (let i = 0, li = nodes.length; i < li; i++) {
        const node = nodes[i];
        const embed = 8;

        const altitude = Math.max(10, this.camera.distance + 20);
        //const altitude = Math.max(1.1, this.cameraDistance);
        const maxDistance = (node.extents.ur[0] - node.extents.ll[0])*2;
        const gridMax = Math.log(maxDistance) / this.log8;
        let gridSelect = Math.log(Math.min(maxDistance,altitude)) / this.log8;

        gridSelect = gridMax - gridSelect;

        node.gridBlend = (gridSelect - Math.floor(gridSelect));

        gridSelect = Math.floor(Math.floor(gridSelect))+1;
        node.gridStep1 = Math.pow(embed, gridSelect);
        node.gridStep2 = node.gridStep1 * 8;
    }
};


MapDraw.prototype.setupDetailDegradation = function(degradeMore) {
    let factor = 0;

    if (this.map.mobile) {
        factor = this.config.mapMobileDetailDegradation;
    }

    if (degradeMore) {
        factor += degradeMore;
    }

    const dpiRatio = 1; //(window.devicePixelRatio || 1);

    this.texelSizeFit = this.config.mapTexelSizeFit * Math.pow(2,factor) * dpiRatio;
};


/* harmony default export */ __webpack_exports__["default"] = (MapDraw);


/***/ }),

/***/ "./src/core/map/geodata-builder.js":
/*!*****************************************!*\
  !*** ./src/core/map/geodata-builder.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geodata_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geodata-geometry */ "./src/core/map/geodata-geometry.js");
/* harmony import */ var _geodata_import_geojson__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geodata-import/geojson */ "./src/core/map/geodata-import/geojson.js");
/* harmony import */ var _geodata_import_vts_geodata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geodata-import/vts-geodata */ "./src/core/map/geodata-import/vts-geodata.js");
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");

//import Delaunator_ from './geodata-utils';



//import MapGeodataImport3DTiles_ from './geodata-import/3dtiles';
//import GeographicLib_ from 'geographiclib';


//get rid of compiler mess
//const Delaunator = Delaunator_;
const MapGeodataGeometry = _geodata_geometry__WEBPACK_IMPORTED_MODULE_0__["default"];
const MapGeodataImportGeoJSON = _geodata_import_geojson__WEBPACK_IMPORTED_MODULE_1__["default"];
const MapGeodataImportVTSGeodata = _geodata_import_vts_geodata__WEBPACK_IMPORTED_MODULE_2__["default"];
//const MapGeodataImport3DTiles = MapGeodataImport3DTiles_;

//const GeographicLib = GeographicLib_;
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_3__["vec3"];
//const mat4 = mat4_;


const MapGeodataBuilder = function(map) {
    this.map = map;
    this.groups = [];
    this.nodes = [];
    this.currentGroup = null;
    this.bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
    this.bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];

    this.navSrs = this.map.getNavigationSrs();
    //this.navSrs = this.map.getPublicSrs();
    this.physSrs = this.map.getPhysicalSrs();

    this.heightsToProcess = 0;
    this.heightsProcessBuffer = null;
    this.heightsProcessBufferFirst = null;
    this.heightsProcessBufferLast = null;

    this.heightsLod = 8;
    this.heightsSource = "heightmap-by-precision";
    this.updateCallback = null;
    this.processingHeights = false;
    this.processHeightsCalls = [];
};


MapGeodataBuilder.prototype.addToHeightsBuffer = function(coords) {

    const item = { coords: coords, prev: null, next: this.heightsProcessBufferFirst };

    if (this.heightsProcessBufferFirst != null) {
        this.heightsProcessBufferFirst.prev = item;
    }

    //add item as first in list
    this.heightsProcessBufferFirst = item;

    if (this.heightsProcessBufferLast == null) {
        this.heightsProcessBufferLast = item;
    }
};


MapGeodataBuilder.prototype.removeFromHeightsBuffer = function(item) {
    let hit = false;

    if (item == this.heightsProcessBufferFirst) {
        this.heightsProcessBufferFirst = item.next;
        hit = true;

        if (this.heightsProcessBufferFirst != null) {
            this.heightsProcessBufferFirst.prev = null;
        }
    }

    if (item == this.heightsProcessBufferLast) {
        this.heightsProcessBufferLast = item.prev;
        hit = true;

        if (this.heightsProcessBufferLast != null) {
            this.heightsProcessBufferLast.next = null;
        }
    }

    if (!hit) {
        if (!item.prev) {
            //debugger;
        } else {
            item.prev.next = item.next;
        }

        if (!item.next) {
            //debugger;
        } else {
            item.next.prev = item.prev;
        }
    }
};


MapGeodataBuilder.prototype.addGroup = function(id) {
    this.groups.push({
        points: [],
        lines: [],
        polygons: [],
        id: id
    });

    this.currentGroup = this.groups[this.groups.length - 1];

    return this;
};


MapGeodataBuilder.prototype.addNode = function(parentNode, volume, precision, tileset) {
    const node = {
        meshes: [],
        precision : precision,
        volume : volume,
        tileset: tileset ? true : false,
        nodes : []
    };

    if(!parentNode) {
        parentNode = this;
    }

    parentNode.nodes.push(node);

    return node;
};


MapGeodataBuilder.prototype.addMesh = function(node, path) {
    if (node) {
        node.meshes.push(path);
    }
};


MapGeodataBuilder.prototype.addLoadNode = function(node, path) {
    if (node) {
        if (!node.loadNodes) {
            node.loadNodes = [];
        }

        node.loadNodes.push(path);
    }
};


MapGeodataBuilder.prototype.addPoint = function(point, heightMode, properties, id, srs, directCopy) {
    if (!this.currentGroup) {
        this.addGroup('some-group');
    }

    const floatHeight = (!heightMode || heightMode == "float");

    const feature = {
        id : id,
        properties : properties
    };

    if (floatHeight) {
        const coords = [point[0], point[1], point[2] || 0, feature, null, null ];
        this.addToHeightsBuffer(coords);

        feature.points = [ coords ];
        feature.floatHeights = true;
        feature.srs = srs ? srs : this.navSrs;
        feature.heightsToProcess = 1;
        this.heightsToProcess++;
    } else {
        if (directCopy) {
            feature.points = [ [point[0], point[1], point[2]] ];
        } else {
            feature.points = [ this.physSrs.convertCoordsFrom(point, srs ? srs : this.navSrs) ];
        }
    }

    this.currentGroup.points.push(feature);

    return this;
};


MapGeodataBuilder.prototype.addPointArray = function(points, heightMode, properties, id, srs, directCopy) {
    if (!this.currentGroup) {
        this.addGroup('some-group');
    }

    let floatHeight = (!heightMode || heightMode == "float"), i, li, point, coords;
    srs = srs ? srs : this.navSrs;

    const feature = {
        id : id,
        properties : properties
    };

    const featurePoints = new Array(points.length);

    if (floatHeight) {

        for (i = 0, li = points.length; i < li; i++) {
            point = points[i];
            coords = [point[0], point[1], point[2] || 0, feature, null, null ];
            this.addToHeightsBuffer(coords);

            featurePoints[i] = coords;
        }

        feature.floatHeights = true;
        feature.srs = srs;
        feature.heightsToProcess = li;
        this.heightsToProcess++;
    } else {
        if (directCopy) {
            for (i = 0, li = points.length; i < li; i++) {
                point = points[i];
                featurePoints[i] = [point[0], point[1], point[2]];
            }
        } else {
            for (i = 0, li = points.length; i < li; i++) {
                featurePoints[i] = this.physSrs.convertCoordsFrom(points[i], srs);
            }
        }
    }

    feature.points = featurePoints;
    this.currentGroup.points.push(feature);

    return this;
};


MapGeodataBuilder.prototype.addLineString = function(linePoints, heightMode, properties, id, srs, directCopy) {
    if (!this.currentGroup) {
        this.addGroup('some-group');
    }

    let floatHeight = (!heightMode || heightMode == "float"), i, li, point, coords;
    srs = srs ? srs : this.navSrs;

    const feature = {
        id : id,
        properties : properties
    };

    const featurePoints = new Array(linePoints.length);

    if (floatHeight) {

        for (i = 0, li = linePoints.length; i < li; i++) {
            point = linePoints[i];
            coords = [point[0], point[1], point[2] || 0, feature, null, null ];
            this.addToHeightsBuffer(coords);

            featurePoints[i] = coords;
        }

        feature.floatHeights = true;
        feature.srs = srs;
        feature.heightsToProcess = li;
        this.heightsToProcess += li;
    } else {
        if (directCopy) {
            for (i = 0, li = linePoints.length; i < li; i++) {
                point = linePoints[i];
                featurePoints[i] = [point[0], point[1], point[2]];
            }
        } else {
            for (i = 0, li = linePoints.length; i < li; i++) {
                featurePoints[i] = this.physSrs.convertCoordsFrom(linePoints[i], srs);
            }
        }
    }

    feature.lines = [featurePoints];
    this.currentGroup.lines.push(feature);

    return this;
};


MapGeodataBuilder.prototype.addLineStringArray = function(lines, heightMode, properties, id, srs, directCopy) {
    if (!this.currentGroup) {
        this.addGroup('some-group');
    }

    const floatHeight = (!heightMode || heightMode == "float");
    let subline, points, i, li, j, lj, point, coords;
    srs = srs ? srs : this.navSrs;

    const feature = {
        id : id,
        properties : properties
    };

    const featureLines = new Array(lines.length);

    if (floatHeight) {
        let totalHeights = 0;

        for (i = 0, li = lines.length; i < li; i++) {
            subline = lines[i];
            points = new Array(subline.length);

            for (j = 0, lj = subline.length; j < lj; j++) {
                point = subline[j];
                coords = [point[0], point[1], point[2] || 0, feature, null, null];
                this.addToHeightsBuffer(coords);
                points[j] = coords;
            }

            totalHeights += lj;
            featureLines[i] = points;
        }

        feature.floatHeights = true;
        feature.srs = srs;
        feature.heightsToProcess = totalHeights;
        this.heightsToProcess += totalHeights;
    } else {

        for (i = 0, li = lines.length; i < li; i++) {
            subline = lines[i];
            points = new Array(subline.length);

            if (directCopy) {
                for (j = 0, lj = subline.length; j < lj; j++) {
                    point = subline[j];
                    points[j] = [point[0], point[1], point[2]];
                }
            } else {
                for (j = 0, lj = subline.length; j < lj; j++) {
                    points[j] = this.physSrs.convertCoordsFrom(subline[j], srs);
                }
            }

            featureLines[i] = points;
        }
    }

    feature.lines = featureLines;
    this.currentGroup.lines.push(feature);

    return this;
};


MapGeodataBuilder.prototype.addPolygon = function(shape, holes, middle, heightMode, properties, id, srs, tesselation) {
    //older versions are in github history 2.20.x
    return this.addPolygon3(shape, holes, middle, heightMode, properties, id, srs, tesselation);
};


MapGeodataBuilder.prototype.getPolygonCenter = function(shape, projected, proj) {
    if (shape && !shape.length) {
        return [0,0];
    }

    let sumX = 0, sumY = 0, sumZ = 0, i, li, coords; //, convertLong = false;

    if (projected) {
        for (i = 0, li = shape.length; i < li; i++) {
            const coords = shape[i];
            sumX += coords[0];
            sumY += coords[1];
            sumZ += coords[2];
        }

        return [sumX / li, sumY / li, sumZ / li];
    } else {
        for (i = 0, li = shape.length; i < li; i++) {
            coords = shape[i];
            const coords2 = proj.forward(coords);
            sumX += coords2[0];
            sumY += coords2[1];
            sumZ += coords2[2];
        }

        const avgX = sumX / li;
        const avgY = sumY / li;
        const avgZ = sumZ / li;

        // convert average x, y, z coordinate to latitude and longtitude

        coords = proj.inverse([avgX, avgY, avgZ]);

        return [coords[0], coords[1], 0];
    }
};


MapGeodataBuilder.prototype.insidePolygon = function(point, vertices, verticesLength) {
    // ray-casting algorithm based on
    // https://github.com/substack/point-in-polygon/blob/master/index.js

    const x = point[0], y = point[1];

    verticesLength = (verticesLength || Math.round(vertices.length/3));

    let inside = false;
    for (let i = 0, j = verticesLength - 1, li = verticesLength; i < li; j = i++) {
        const xi = vertices[i*3], yi = vertices[i*3+1];
        const xj = vertices[j*3], yj = vertices[j*3+1];

        const intersect = ((yi > y) != (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }

    return inside;
};


//same as addPolygon but works on poles
/*
MapGeodataBuilder.prototype.addPolygon2 = function(shape, holes, middle, heightMode, properties, id, srs) {
    srs = srs ? srs : this.navSrs.srsProj4;
    holes = holes || [];

    const flatShape = shape, flatHoles = holes, i, li, j, lj, k, lk, l, hole, coords, coords2, proj, holesIndices, vertices;
    const projected = true;

    //convert shape and holes to flat space
    if (srs.indexOf('+proj=longlat') != -1) {
        projected = false;
        //proj = this.map.proj4(srs, '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');
        //proj = this.map.proj4(srs, '+proj=merc +lat_ts=' + center[1] + ' +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');
        proj = this.map.proj4(srs, '+proj=geocent +datum=WGS84 +units=m +no_defs');
    }

    const c = document.getElementById("dbg-canvas");
    const ctx = c.getContext("2d");
    const sx = 300;
    const fx = 300 / 7500000;


    for (i = 0, li = shape.length; i < li; i++) {
        shape[i][2] = shape[i][2] || 0; //add third coord
    }

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        totalPoints += hole.length*3;

        for (j = 0, lj = hole.length; j < lj; j++) {
            hole[j][2] = hole[j][2] || 0; //add third coord
        }
    }

    const center = this.getPolygonCenter(shape, projected, proj), north, east, dir;

    this.addPoint(center.slice(), 'fix', {}, 'aaa');

    const ned = this.map.measure.getNewNED(center);

    dir = ned.direction;
    north = ned.north;
    east = ned.east;

    const totalPoints = shape.length*3;

    for (i = 0, li = shape.length; i < li; i++) {
        shape[i][2] = shape[i][2] || 0; //add third coord
    }

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        totalPoints += hole.length*3;

        for (j = 0, lj = hole.length; j < lj; j++) {
            hole[j][2] = hole[j][2] || 0; //add third coord
        }
    }

    flatShape = new Array(totalPoints);
    vertices = new Array(totalPoints);
    j = 0;

    const borders = new Array(holes.length + 1);
    const border = new Array(shape.length);
    borders[0] = border;

    ctx.beginPath();

    for (i = 0, li = shape.length; i < li; i++) {
        border[i] = i;
        coords = shape[i];
        vertices[j] = coords[0];
        vertices[j+1] = coords[1];
        vertices[j+2] = coords[2];

        if (proj) {
            coords2 = proj.forward(shape[i]);
            coords= [ east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                      dir[0] * coords2[0] + dir[1] * coords2[1] + dir[2] * coords2[2], 0];
        } else {
            coords = shape[i];
        }

        if (i ==0) {
            ctx.moveTo(coords[0]*fx+sx,coords[1]*fx+sx);
        } else {
            ctx.lineTo(coords[0]*fx+sx,coords[1]*fx+sx);
        }

        flatShape[j] = coords[0];
        flatShape[j+1] = coords[1];
        flatShape[j+2] = coords[2];
        j+=3;
    }

    flatHoles = new Array(holes.length);
    holesIndices = new Array(holes.length);

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        holesIndices[i] = Math.round(j/3);

        border = new Array(hole.length);
        borders[i + 1] = border;

        l = Math.floor(j /3);

        for (k = 0, lk = hole.length; k < lk; k++) {
            coords = hole[k];
            vertices[j] = coords[0];
            vertices[j+1] = coords[1];
            vertices[j+2] = coords[2];

            if (proj) {
                coords2 = proj.forward(hole[k]);
                coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                          dir[0] * coords2[0] + dir[1] * coords2[1] + dir[2] * coords2[2], 0];
            } else {
                coords = hole[k];
            }

            if (k ==0) {
                ctx.moveTo(coords[0]*fx+sx,coords[1]*fx+sx);
            } else {
                ctx.lineTo(coords[0]*fx+sx,coords[1]*fx+sx);
            }


            flatShape[j] = coords[0];
            flatShape[j+1] = coords[1];
            flatShape[j+2] = coords[2];
            j+=3;
            border[k] = l++;
        }
    }

    ctx.strokeStyle = "#ff0000";
    ctx.stroke();


    const surface = vts.earcut(flatShape, holesIndices, 3);

    this.addPolygonRAW(vertices, surface, borders, middle, heightMode, properties, id, srs);

    ctx.beginPath();

    for (i = 0, li = surface.length; i < li; i+=3) {
        const v1 = surface[i]*3;
        const v2 = surface[i+1]*3;
        const v3 = surface[i+2]*3;

        ctx.moveTo(flatShape[v1]*fx+sx,flatShape[v1+1]*fx+sx);
        ctx.lineTo(flatShape[v2]*fx+sx,flatShape[v2+1]*fx+sx);
        ctx.lineTo(flatShape[v3]*fx+sx,flatShape[v3+1]*fx+sx);
        ctx.lineTo(flatShape[v1]*fx+sx,flatShape[v1+1]*fx+sx);
    }

    ctx.strokeStyle = "#0000ff";
    ctx.stroke();

    return this;
};
*/

//same as addPolygon3 but with Delaunator sudivision
/*
MapGeodataBuilder.prototype.addPolygon4 = function(shape, holes, middle, heightMode, properties, id, srs) {
    srs = srs ? srs : this.navSrs.srsProj4;
    holes = holes || [];
    holes = [];

    const flatShape = shape, flatHoles = holes, i, li, j, lj, k, lk, l, hole, coords = [], coords2 = [], proj, holesIndices, vertices;
    const projected = true, dx, dy, dz, dd, maxDistance = 0, maxDistanceCoords, flatCenter, trueHolesCount = holes.length;
    const density = 20;

    //convert shape and holes to flat space
    if (srs.indexOf('+proj=longlat') != -1) {
        projected = false;
        proj = this.map.proj4(srs, '+proj=geocent +datum=WGS84 +units=m +no_defs');
    }

    const totalPoints = shape.length*3;

    for (i = 0, li = shape.length; i < li; i++) {
        shape[i][2] = shape[i][2] || 0; //add third coord
    }

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        totalPoints += hole.length*3;

        for (j = 0, lj = hole.length; j < lj; j++) {
            hole[j][2] = hole[j][2] || 0; //add third coord
        }
    }

    const center = this.getPolygonCenter(shape, projected, proj), north, east, dir, geod;

    const ned = this.map.measure.getNewNED(center);

   // dir = ned.direction;
    north = ned.direction;
    east = ned.east;

     geod = this.map.measure.getGeodesic();

    flatShape = new Array(totalPoints);
    vertices = new Array(totalPoints);
    j = 0;

    const borders = new Array(holes.length + 1);
    const border = new Array(shape.length);
    borders[0] = border;


    const gcenter;

    if (proj) {
        gcenter = proj.forward(center);
    } else {
        gcenter = center;
    }

    for (i = 0, li = shape.length; i < li; i++) {
        border[i] = i;
        coords = shape[i];
        vertices[j] = coords[0];
        vertices[j+1] = coords[1];
        vertices[j+2] = coords[2];

        if (proj) {
            coords2 = proj.forward(shape[i]);
            coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                      north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];
        } else {
            coords2 = shape[i];
            coords = coords2;
        }

        dx = coords2[0] - gcenter[0];
        dy = coords2[1] - gcenter[1];
        dz = coords2[2] - gcenter[2];
        dd = dx * dx + dy * dy + dz*dz;
        if (dd > maxDistance) {
            maxDistance = dd;
            maxDistanceCoords = shape[i]
        }

        flatShape[j] = coords[0];
        flatShape[j+1] = coords[1];
        flatShape[j+2] = coords[2];
        j+=3;
    }

    maxDistance = Math.sqrt(maxDistance);

    const inPoints = new Array(density * density * 3);
    const inPointsFlat = new Array(density * density * 3);
    const inPointsIndex = 0;
    const inPointsFlatIndex = 0;

    if (proj) {

        if (!projected) {
            //maxDistanceCoords = proj.inverse(maxDistanceCoords); maxDistanceCoords[2] = 0;
            maxDistance = this.map.measure.getDistance(center, maxDistanceCoords, false)[0];
        }

        density = Math.round(density * 0.5);

        const r, ncoords, ecoords, lastJ = j;
        const geod = this.map.measure.getGeodesic();

        for (i = -density; i < density; i++) {
            r = geod.Direct(center[1], center[0], 0, (maxDistance / (density)) * i);
            ncoords = [r.lon2, r.lat2];

            for (j = -density; j < density; j++) {
                r = geod.Direct(ncoords[1], ncoords[0], 90, (maxDistance / (density)) * j);

                ecoords = [r.lon2, r.lat2, 0];
                coords2 = proj.forward(ecoords);
                coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                          north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];

                if (this.insidePolygon(coords, flatShape, shape.length)) {
                    //this.addPoint(ecoords.slice(), 'fix', {}, 'bbb', srs);
                    //holes.push([ecoords]);

                    inPoints[inPointsIndex] = ecoords[0];
                    inPoints[inPointsIndex+1] = ecoords[1];
                    inPoints[inPointsIndex+2] = ecoords[2];
                    inPointsIndex += 3;

                    inPointsFlat[inPointsFlatIndex] = coords[0];
                    inPointsFlat[inPointsFlatIndex+1] = coords[1];
                    inPointsFlat[inPointsFlatIndex+2] = coords[2];
                    inPointsFlatIndex += 3;

                } else {
                    //this.addPoint(ecoords.slice(), 'fix', {}, 'aaa', srs);
                }
            }
        }

        j = lastJ;

        inPoints = inPoints.slice(0, inPointsIndex);
        inPointsFlat = inPointsFlat.slice(0, inPointsFlatIndex);

        vertices = vertices.concat(inPoints);
        flatShape = flatShape.concat(inPointsFlat);

    }

    if (false) {
        flatHoles = new Array(holes.length);
        holesIndices = new Array(holes.length);

        for (i = 0, li = holes.length; i < li; i++) {
            hole = holes[i];
            holesIndices[i] = Math.round(j/3);

            if (i < trueHolesCount) {
                border = new Array(hole.length);
                borders[i + 1] = border;
            }

            l = Math.floor(j /3);

            for (k = 0, lk = hole.length; k < lk; k++) {
                coords = hole[k];
                vertices[j] = coords[0];
                vertices[j+1] = coords[1];
                vertices[j+2] = coords[2];

                if (proj) {
                    coords2 = proj.forward(hole[k]);
                    coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                              north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];
                } else {
                    coords = hole[k];
                }

                flatShape[j] = coords[0];
                flatShape[j+1] = coords[1];
                flatShape[j+2] = coords[2];
                j+=3;

                if (i < trueHolesCount) {
                    border[k] = l++;
                }
            }
        }
    }

    const flatShape2 = new Array((flatShape.length / 3) *2);

    for (i = 0, j =0, li = flatShape.length; i < li; i+=3, j+=2) {
        flatShape2[j] = flatShape[i];
        flatShape2[j+1] = flatShape[i+1];
    }

    const delaunay = new Delaunator(flatShape2);

    const surface2 = delaunay.triangles;
    const smax = 30;//vertices.length / 3;

    const surface = new Array(surface2.length);

    j = 0;

    for (i = 0, li = surface.length; i < li; i+=3) {
        const v1 = surface2[i]*2;
        const v2 = surface2[i+1]*2;
        const v3 = surface2[i+2]*2;

        const mid = [(flatShape2[v1]+flatShape2[v2]+flatShape2[v3])/3,
                   (flatShape2[v1+1]+flatShape2[v2+1]+flatShape2[v3+1])/3,0];

        if (this.insidePolygon(mid, flatShape, shape.length)) {
            surface[j] = surface2[i+2];
            surface[j+1] = surface2[i+1];
            surface[j+2] = surface2[i];
            j+=3;
        }
    }

    surface = surface.slice(0,j);

    //const surface = vts.earcut(flatShape, holesIndices, 3);
    //const surface = vts.earcut(flatShape2, holesIndices, 2);

    const c = document.getElementById("dbg-canvas");
    const ctx = c.getContext("2d");
    const sx = 300;
    const fx = 300 / 7500000; fx*=30;


    ctx.beginPath();

    for (i = 0, li = surface2.length; i < li; i+=3) {
        const v1 = surface2[i]*2;
        const v2 = surface2[i+1]*2;
        const v3 = surface2[i+2]*2;

        ctx.moveTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);
        ctx.lineTo(flatShape2[v2]*fx+sx,flatShape2[v2+1]*fx+sx);
        ctx.lineTo(flatShape2[v3]*fx+sx,flatShape2[v3+1]*fx+sx);
        ctx.lineTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);
    }

    ctx.strokeStyle = "#0000ff";
    ctx.stroke();


    ctx.beginPath();

    for (i = 0, li = surface.length; i < li; i+=3) {
        const v1 = surface[i]*2;
        const v2 = surface[i+1]*2;
        const v3 = surface[i+2]*2;

        ctx.moveTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);
        ctx.lineTo(flatShape2[v2]*fx+sx,flatShape2[v2+1]*fx+sx);
        ctx.lineTo(flatShape2[v3]*fx+sx,flatShape2[v3+1]*fx+sx);
        ctx.lineTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);
    }

    ctx.strokeStyle = "#ff00ff";
    ctx.stroke();

    this.addPolygonRAW(vertices, surface, borders, middle, heightMode, properties, id, srs);

    return this;
};*/

//same as addPolygon but works on poles and is subivided
MapGeodataBuilder.prototype.addPolygon3 = function(shape, holes, middle, heightMode, properties, id, srs, tesselation) {
    srs = srs ? srs : this.navSrs.srsProj4;
    holes = holes || [];

    let flatShape = shape, i, li, j, lj, k, lk, l, hole, coords = [], coords2 = [], proj, holesIndices, vertices;
    let projected = true, dx, dy, dz, dd, maxDistance = 0, maxDistanceCoords, trueHolesCount = holes.length;

    tesselation = tesselation || {};
    tesselation.mode = tesselation['mode'] || 'auto';

    if (tesselation.mode == 'by-length') {
        tesselation.length = tesselation['length'] || 200000;
    }

    let density = 19;

    //convert shape and holes to flat space
    if (srs.indexOf('+proj=longlat') != -1) {
        projected = false;
        proj = this.map.proj4(srs, '+proj=geocent +datum=WGS84 +units=m +no_defs');
        //proj = this.map.proj4(srs, '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');
    }

    let totalPoints = shape.length*3;

    for (i = 0, li = shape.length; i < li; i++) {
        shape[i][2] = shape[i][2] || 0; //add third coord
    }

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        totalPoints += hole.length*3;

        for (j = 0, lj = hole.length; j < lj; j++) {
            hole[j][2] = hole[j][2] || 0; //add third coord
        }
    }

    let center = this.getPolygonCenter(shape, projected, proj), north, east, dir;

    const ned = this.map.measure.getNewNED(center);

    dir = ned.direction;
    north = ned.direction;
    east = ned.east;

    flatShape = new Array(totalPoints);
    vertices = new Array(totalPoints);
    j = 0;

    const borders = new Array(holes.length + 1);
    let border = new Array(shape.length);
    borders[0] = border;

    let gcenter;

    if (proj) {
        gcenter = proj.forward(center);
    } else {
        gcenter = center;
    }

    for (i = 0, li = shape.length; i < li; i++) {
        border[i] = i;
        coords = shape[i];
        vertices[j] = coords[0];
        vertices[j+1] = coords[1];
        vertices[j+2] = coords[2];

        if (proj) {
            coords2 = proj.forward(shape[i]);
            coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                      north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];
        } else {
            coords2 = shape[i];
            coords = coords2;
        }

        dx = coords2[0] - gcenter[0];
        dy = coords2[1] - gcenter[1];
        dz = coords2[2] - gcenter[2];
        dd = dx * dx + dy * dy + dz*dz;
        if (dd > maxDistance) {
            maxDistance = dd;
            // eslint-disable-next-line
            maxDistanceCoords = shape[i]
        }

        flatShape[j] = coords[0];
        flatShape[j+1] = coords[1];
        flatShape[j+2] = coords[2];
        j+=3;
    }

    //check curve orientation (have to be clockwise)
    let angle = 0, x1, y1, x2, y2, index;
    for (i = 0, li = shape.length * 3; i < li; i+=3) {
        x1 = flatShape[i];
        y1 = flatShape[i+1];

        if (i < li - 3) {
            x2 = flatShape[i+3];
            y2 = flatShape[i+4];
        } else {
            x2 = flatShape[0];
            y2 = flatShape[1];
        }

        //angle += (x2 - x1) * (y2 + y1);
        angle += (x1 * y2);
        angle -= (x2 * y1);
    }

    if (angle < 0) { //convert to clokwise
        const vertices2 = vertices.slice();
        const flatShape2 = flatShape.slice();

        for (i = 0, li = shape.length * 3; i < li; i+=3) {
            vertices[i] = vertices2[li - i - 3];
            vertices[i+1] = vertices2[li - i - 2];
            vertices[i+2] = vertices2[li - i - 1];

            flatShape[i] = flatShape2[li - i - 3];
            flatShape[i+1] = flatShape2[li - i - 2];
            flatShape[i+2] = flatShape2[li - i - 1];
        }
    }


    //flatHoles = new Array(holes.length);
    holesIndices = new Array(holes.length);

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        index = Math.round(j/3);
        holesIndices[i] = index;

        if (i < trueHolesCount) {
            border = new Array(hole.length);
            borders[i + 1] = border;
        }

        l = index;

        for (k = 0, lk = hole.length; k < lk; k++) {
            coords = hole[k];
            vertices[j] = coords[0];
            vertices[j+1] = coords[1];
            vertices[j+2] = coords[2];

            if (proj) {
                coords2 = proj.forward(hole[k]);
                //cords = [coords2[0], coords2[1], 0];
                coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                          dir[0] * coords2[0] + dir[1] * coords2[1] + dir[2] * coords2[2], 0];
            } else {
                coords = hole[k];
            }

            flatShape[j] = coords[0];
            flatShape[j+1] = coords[1];
            flatShape[j+2] = coords[2];
            j+=3;

            if (i < trueHolesCount) {
                border[k] = l;
                l++;
            }
        }

        //check curve orientation (have to be clockwise)
        angle = 0;
        index *= 3;
        for (k = 0, lk = hole.length * 3; k < lk; k+=3) {
            x1 = flatShape[index + k];
            y1 = flatShape[index + k+1];

            if (k < lk - 3) {
                x2 = flatShape[index + k+3];
                y2 = flatShape[index + k+4];
            } else {
                x2 = flatShape[index + 0];
                y2 = flatShape[index + 1];
            }

            //angle += (x2 - x1) * (y2 + y1);
            angle += (x1 * y2);
            angle -= (x2 * y1);
        }

        if (angle > 0) { //convert to clokwise
            const vertices2 = vertices.slice();
            const flatShape2 = flatShape.slice();

            for (k = 0, lk = hole.length * 3; k < lk; k+=3) {
                vertices[index + k] = vertices2[index + lk - k - 3];
                vertices[index + k+1] = vertices2[index + lk - k - 2];
                vertices[index + k+2] = vertices2[index + lk - k - 1];

                flatShape[index + k] = flatShape2[index + lk - k - 3];
                flatShape[index + k+1] = flatShape2[index + lk - k - 2];
                flatShape[index + k+2] = flatShape2[index + lk - k - 1];
            }
        }

    }

    let surface = this.map.core.coreInterface.earcut(flatShape, holesIndices, 3);

    let maxFaceLength = Number.POSITIVE_INFINITY;

    switch (tesselation.mode) {
        case 'auto':      maxFaceLength = Math.sqrt(maxDistance) / density; break;
        case 'by-length': maxFaceLength = tesselation.length; break;
    }

    let v1, v2, v3, p1, p2, p3, p4, p5, p6, border2;

    //copy bordes
    const borders2 = new Array(borders.length);

    for (i = 0, li = borders.length; i < li; i++) {
        borders2[i] = borders[i].slice();
    }

    let sbuffer = new Array(65536*3);
    let sbuffer2 = new Array(65536*3);
    const sbuffer3 = new Array(65536*3);

    let sbufferIndex = 0, l1, l2, l3, vv1, vv2, vv3;
    let sbufferIndex2 = 0;//, i1, i2, i3;
    let sbufferIndex3 = 0;

    const vbuffer = new Array(65536*3);

    //copy vertices
    for (i = 0, li = vertices.length; i < li; i +=3) {
        vbuffer[i] = vertices[i];
        vbuffer[i+1] = vertices[i+1];
        vbuffer[i+2] = vertices[i+2];
    }

    let m = Math.round(li / 3);


    const lastMaxFaceLength = maxFaceLength;

    for (i = 0, li = surface.length; i < li; i +=3) {

        v1 = surface[i];
        v2 = surface[i+1];
        v3 = surface[i+2];
        sbufferIndex = 3;

        //find face edges in borders
        let edge1 = null, edge2 = null, edge3 = null;

        for (j = 0, lj = borders.length; j < lj; j++) {
            border = borders[j];
            border2 = borders2[j];

            for (k = 0, lk = border.length; k < lk; k++) {
                const k2 = (k < border.length - 1) ? k + 1 : 0;

                if ((v1 == border[k] && v2 == border[k2]) || (v1 == border[k2] && v2 == border[k])) {
                    border2[k] = [border[k]];
                    edge1 = border2[k];
                }

                if ((v2 == border[k] && v3 == border[k2]) || (v2 == border[k2] && v3 == border[k])) {
                    border2[k] = [border[k]];
                    edge2 = border2[k];
                }

                if ((v3 == border[k] && v1 == border[k2]) || (v1 == border[k2] && v3 == border[k])) {
                    border2[k] = [border[k]];
                    edge3 = border2[k];
                }
            }
        }

        sbuffer[0] = [v1, edge1];
        sbuffer[1] = [v2, edge2];
        sbuffer[2] = [v3, edge3];

        let depth = 0;

        //loop until subdivision is finished
        do {

            for (j = 0, lj = sbufferIndex; j < lj; j+=3) {
                //face indices//
                vv1 = sbuffer[j][0];
                vv2 = sbuffer[j+1][0];
                vv3 = sbuffer[j+2][0];
                //face edges
                edge1 = sbuffer[j][1];
                edge2 = sbuffer[j+1][1];
                edge3 = sbuffer[j+2][1];

                /*console.log('v1: ' + vv1 + ' v2:' + vv2 + ' v3:' + vv3);
                console.log('e1: ' + (Array.isArray(edge1) ? 'a' : '') + edge1 + ' e2:' + (Array.isArray(edge2) ? 'a' : '') + edge2 + ' e3:' + (Array.isArray(edge3) ? 'a' : '') + edge3);
                */

                //get face vertices
                p1 = [vbuffer[vv1*3], vbuffer[vv1*3+1], vbuffer[vv1*3+2]];
                p2 = [vbuffer[vv2*3], vbuffer[vv2*3+1], vbuffer[vv2*3+2]];
                p3 = [vbuffer[vv3*3], vbuffer[vv3*3+1], vbuffer[vv3*3+2]];

                //covert coords to geocent
                if (proj) {
                    p1 = proj.forward(p1);
                    p2 = proj.forward(p2);
                    p3 = proj.forward(p3);
                }

                //get face edges lengths
                l1 = vec3.length([p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]]);
                l2 = vec3.length([p2[0] - p3[0], p2[1] - p3[1], p2[2] - p3[2]]);
                l3 = vec3.length([p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]]);

                //get max length
                l = Math.max(l1,l2,l3);

                //console.log('ll:' + l);

                //is length below threshold
                if (l < maxFaceLength) {
                    //add to final buffer
                    sbuffer3[sbufferIndex3] = vv1;
                    sbuffer3[sbufferIndex3+1] = vv2;
                    sbuffer3[sbufferIndex3+2] = vv3;
                    sbufferIndex3 += 3;
                } else {

                    //crete new vertices in the midle of edges and convert coords back to long lat
                    //if (l1 > 200000 && !projected) {
                     //   r = geod.Inverse(vbuffer[vv1*3+1], vbuffer[vv1*3], vbuffer[vv2*3+1], vbuffer[vv2*3]);
                     //   r = geod.Direct(vbuffer[vv1*3+1], vbuffer[vv1*3], r.azi1, r.s12 *0.5);
                    //    p4 = [r.lon2, r.lat2, (vbuffer[vv1*3+2]+vbuffer[vv2*3+2])*0.5];
                    //} else {
                        p4 = [(p1[0]+p2[0])*0.5, (p1[1]+p2[1])*0.5, (p1[2]+p2[2])*0.5];
                    if (proj) {
                        p4 = proj.inverse(p4); p4[2] = (vbuffer[vv1 * 3 + 2] + vbuffer[vv2 * 3 + 2]) * 0.5;
                    }
                    //}

                    //if (l2 > 200000 && !projected) {
                     //   r = geod.Inverse(vbuffer[vv2*3+1], vbuffer[vv2*3], vbuffer[vv3*3+1], vbuffer[vv3*3]);
                     //   r = geod.Direct(vbuffer[vv2*3+1], vbuffer[vv2*3], r.azi1, r.s12 *0.5);
                     //   p5 = [r.lon2, r.lat2, (vbuffer[vv2*3+2]+vbuffer[vv3*3+2])*0.5];
                    //} else {
                        p5 = [(p2[0]+p3[0])*0.5, (p2[1]+p3[1])*0.5, (p2[2]+p3[2])*0.5];
                    if (proj) {
                        p5 = proj.inverse(p5); p5[2] = (vbuffer[vv2 * 3 + 2] + vbuffer[vv3 * 3 + 2]) * 0.5;
                    }
                    //}

                    //if (l3 > 200000 && !projected) {
                     //   r = geod.Inverse(vbuffer[vv3*3+1], vbuffer[vv3*3], vbuffer[vv1*3+1], vbuffer[vv1*3]);
                     //   r = geod.Direct(vbuffer[vv3*3+1], vbuffer[vv3*3], r.azi1, r.s12 *0.5);
                     //   p6 = [r.lon2, r.lat2, (vbuffer[vv3*3+2]+vbuffer[vv1*3+2])*0.5];
                    //} else {
                        p6 = [(p3[0]+p1[0])*0.5, (p3[1]+p1[1])*0.5, (p3[2]+p1[2])*0.5];
                    if (proj) {
                        p6 = proj.inverse(p6); p6[2] = (vbuffer[vv3 * 3 + 2] + vbuffer[vv1 * 3 + 2]) * 0.5;
                    }
                    //}

                    const mm = m * 3;

                    if (l1 == l) {
                        //console.log('l1');

                        //add new vertices to the buffer
                        vbuffer[mm] = p4[0];
                        vbuffer[mm+1] = p4[1];
                        vbuffer[mm+2] = p4[2];

                        //create new edges
                        if (edge1) {
                            edge1[0] = [[edge1[0]], [-m]];
                            edge1 = edge1[0];
                        }

                        l = sbufferIndex2;

                        //store new faces with edges
                        sbuffer2[l] = [vv1, edge1 ? edge1[0] : null];
                        sbuffer2[l+1] = [m, null];
                        sbuffer2[l+2] = [vv3, edge3 ? edge3 : null];
                        /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);
                        console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] +
                                   ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +
                                   ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/


                        sbuffer2[l+3] = [m, edge1 ? edge1[1] : null];
                        sbuffer2[l+4] = [vv2, edge2 ? edge2 : null];
                        sbuffer2[l+5] = [vv3, null];
                        /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);
                        console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] +
                                   ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +
                                   ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/

                    } else if (l2 == l) {
                        //console.log('l2');

                        //add new vertices to the buffer
                        vbuffer[mm] = p5[0];
                        vbuffer[mm+1] = p5[1];
                        vbuffer[mm+2] = p5[2];

                        //create new edges
                        if (edge2) {
                            edge2[0] = [[edge2[0]], [-m]];
                            edge2 = edge2[0];
                        }

                        l = sbufferIndex2;

                        //store new faces with edges
                        sbuffer2[l] = [vv1, edge1 ? edge1 : null];
                        sbuffer2[l+1] = [vv2, edge2 ? edge2[0] : null];
                        sbuffer2[l+2] = [m, null];
                        /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);
                        console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] +
                                   ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +
                                   ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/

                        sbuffer2[l+3] = [m, edge2 ? edge2[1] : null];
                        sbuffer2[l+4] = [vv3, edge3 ? edge3 : null];
                        sbuffer2[l+5] = [vv1, null];
                        /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);
                        console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] +
                                   ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +
                                   ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/

                    } else if (l3 == l) {
                        //console.log('l3');

                        //add new vertices to the buffer
                        vbuffer[mm] = p6[0];
                        vbuffer[mm+1] = p6[1];
                        vbuffer[mm+2] = p6[2];

                        //create new edges
                        if (edge3) {
                            edge3[0] = [[edge3[0]], [-m]];
                            edge3 = edge3[0];
                        }

                        l = sbufferIndex2;

                        //store new faces with edges
                        sbuffer2[l] = [vv1, edge1 ? edge1 : null];
                        sbuffer2[l+1] = [vv2, null];
                        sbuffer2[l+2] = [m, edge3 ? edge3[1] : null];
                        /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);
                        console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] +
                                   ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +
                                   ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/

                        sbuffer2[l+3] = [m, null];
                        sbuffer2[l+4] =  [vv2, edge2 ? edge2 : null];
                        sbuffer2[l+5] = [vv3, edge3 ? edge3[0] : null];
                        /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);
                        console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] +
                                   ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +
                                   ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/

                    }

                    m += 1;
                    sbufferIndex2 += 6;
                }
            }

            const tmp = sbuffer;
            sbuffer = sbuffer2;
            sbuffer2 = tmp;
            sbufferIndex = sbufferIndex2;
            sbufferIndex2 = 0;

            //if (sbufferIndex3 > 1000) {
                //break;
            //}

            // eslint-disable-next-line
            depth++;

            //if (depth == 1) {
              //  maxFaceLength = Number.POSITIVE_INFINITY;
            //}


        } while(sbufferIndex > 0);

        maxFaceLength = lastMaxFaceLength;

    }

    const ebuffer = new Array(65536*3);
    let ebufferIndex = 0;

    const unrollBorder = (function(borderArray) {
        for (let o = 0, lo = borderArray.length; o < lo; o++) {
            if (Array.isArray(borderArray[o])) {
                unrollBorder(borderArray[o]);
            } else {
                ebuffer[ebufferIndex] = borderArray[o];
                ebufferIndex++;
            }
        }
    });

    let lastEbufferIndex = 0;

    //unroll edges
    for (i = 0, li = borders2.length; i < li; i++) {
        unrollBorder(borders2[i]);
        borders2[i] = ebuffer.slice(lastEbufferIndex, ebufferIndex);
        lastEbufferIndex = ebufferIndex;
    }

    surface = new Array(sbufferIndex);

    for (i = 0, li = sbufferIndex3; i < li; i+=3) {
        surface[i] = sbuffer3[i];
        surface[i+1] = sbuffer3[i+1];
        surface[i+2] = sbuffer3[i+2];
    }

    vertices = new Array(m * 3);
    j = 0;

    for (i = 0, li = m*3; i < li; i+=3) {
        vertices[i] = vbuffer[i];
        vertices[i+1] = vbuffer[i+1];
        vertices[i+2] = vbuffer[i+2];
        //this.addPoint([vertices[i], vertices[i+1], vertices[i+2]], 'fix', {name:(''+j)}, 'aaa');
        j++;
    }

    this.addPolygonRAW(vertices, surface, borders2, middle, heightMode, properties, id, srs);
};


MapGeodataBuilder.prototype.addPolygonRAW = function(vertices, surface, borders, middle, heightMode, properties, id, srs, directCopy, transform) {
    if (!this.currentGroup) {
        this.addGroup('some-group');
    }

    const floatHeight = (!heightMode || heightMode == "float");
    let i, li, j = 0, coords;
    srs = srs ? srs : this.navSrs;

    const feature = {
        id : id,
        properties : properties
    };

    const featureVertices = new Array(Math.round(vertices.length/3));

    if (floatHeight) {
        for (i = 0, li = vertices.length; i < li; i+=3) {
            coords = [vertices[i], vertices[i+1], vertices[i+2], feature, null, null];
            this.addToHeightsBuffer(coords);
            featureVertices[j++] = coords;
        }

        feature.floatHeights = true;
        feature.srs = srs;
        feature.heightsToProcess = featureVertices.length;
        this.heightsToProcess += featureVertices.length;
    } else {

        for (i = 0, li = vertices.length; i < li; i+=3) {

            if (directCopy) {
                if (transform) {
                    featureVertices[j++] = [vertices[i]*transform.sx+transform.px, vertices[i+1]*transform.sy+transform.py, vertices[i+2]*transform.sz+transform.pz];
                } else {
                    featureVertices[j++] = [vertices[i], vertices[i+1], vertices[i+2]];
                }
            } else {
                featureVertices[j++] = this.physSrs.convertCoordsFrom([vertices[i], vertices[i+1], vertices[i+2]], srs);
            }
        }
    }

    const featureSurface = surface.slice();
    const featureBorders = new Array(borders.length);

    for (i = 0, li = borders.length; i < li; i++) {
        featureBorders[i] = borders[i].slice();
    }

    feature.vertices = featureVertices;
    feature.surface = featureSurface;
    feature.borders = featureBorders;
    this.currentGroup.polygons.push(feature);

    return this;
};


MapGeodataBuilder.prototype.importVTSGeodata = function(json, groupIdPrefix, dontCreateGroups) {
    const importer = new MapGeodataImportVTSGeodata(this, groupIdPrefix, dontCreateGroups);
    return importer.processJSON(json);
};


MapGeodataBuilder.prototype.importGeoJson = function(json, heightMode, srs, options) {
    const importer = new MapGeodataImportGeoJSON(this, heightMode, srs, options);
    return importer.processJSON(json);
};


MapGeodataBuilder.prototype.import3DTiles = function(json, options) {
    const importer = new MapGeodataImport3DTiles(this, options);
    return importer.processJSON(json);
};


MapGeodataBuilder.prototype.load3DTiles = function(path, options, onLoaded) {
    const importer = new MapGeodataImport3DTiles(this, options);
    importer.loadJSON(path, options, onLoaded);
};

// eslint-disable-next-line
MapGeodataBuilder.prototype.load3DTiles2 = function(path, options, onMapLoaded) {
    this.binPath = path;
    if (onMapLoaded) {
        onMapLoaded();
    }
};


MapGeodataBuilder.prototype.processHeights = function(heightsSource, precision, onProcessed) {
    if (this.heightsToProcess <= 0) {
        if (onProcessed) {
            onProcessed(this);
        }

        return;
    }

    if (this.processingHeights) {
        this.processHeightsCalls.push(this.processHeights.bind(this, heightsSource, precision));
    }

    this.processingHeights = true;
    this.heightsSource = heightsSource;
    this.heightsLod = precision;

    let item = this.heightsProcessBufferFirst, lastItem;
    let p, res, nodeOnly, heightsLod, coords, noSource;

    if (item) {

        switch (heightsSource) {
            case "node-by-precision":
                nodeOnly = true;
                // eslint-disable-next-line
            case "heightmap-by-precision":

                coords = item.coords;

                if (coords[3].srs) {
                    p = this.navSrs.convertCoordsFrom(coords, coords[3].srs);
                } else {
                    p = coords;
                }

                heightsLod = this.map.measure.getOptimalHeightLodBySampleSize(p, precision);
                break;

            case "node-by-lod":
                nodeOnly = true;
                precision -= 8;
                // eslint-disable-next-line
            case "heightmap-by-lod":
                heightsLod = precision;
                break;
            case "none":
                noSource = true;
                break;
        }

        do {
            coords = item.coords;

            if (!noSource && coords[4] == null) {
                if (coords[3].srs) {
                    p = this.navSrs.convertCoordsFrom(coords, coords[3].srs);
                } else {
                    p = coords;
                }

                res = this.map.measure.getSpatialDivisionNode(p);

                coords[4] = res[0];
                coords[5] = res[1];

                //coords[4] = p;
            }


            if (noSource) {
                res = [0,true,true];
            } else {
                res = this.map.measure.getSurfaceHeight(coords, heightsLod, null, coords[4], coords[5], null, nodeOnly);
            }

            //res = this.map.measure.getSurfaceHeight(coords[4], heightsLod, null, null, null, null, nodeOnly);

            //console.log(JSON.stringify(res));

            //if (res[1] || res[2]) { //precisin reached or not aviable
                //res = this.map.measure.getSurfaceHeight(coords[4], heightsLod, null, null, null, null, nodeOnly);
                //res = this.map.measure.getSurfaceHeight(coords, heightsLod, null, coords[4], coords[5], null, nodeOnly);
            //}

            if (res[1] || res[2]) { //precision reached or not aviable

                //console.log(JSON.stringify(res));

                coords[2] += res[0]; //convet float height to fixed
                this.removeFromHeightsBuffer(item, lastItem);
                coords[3].heightsToProcess--;
                this.heightsToProcess--;

                if (coords[3].heightsToProcess <= 0) { //this prevents multiple conversions
                    coords[3].floatHeights = false;
                }

                p = [coords[0], coords[1], coords[2]];

                //console.log(JSON.stringify(p) + "  srs  " + coords[3].srs);

                p = this.physSrs.convertCoordsFrom(p, coords[3].srs);

                coords[0] = p[0];
                coords[1] = p[1];
                coords[2] = p[2];
            }

            lastItem = item;
            item = item.next;

        } while(item);
    }

    if (this.heightsToProcess <= 0) {
        if (this.updateCallback) {
            this.updateCallback(); //remove callback
        }

        this.processingHeights = false;

        if (onProcessed) {
            onProcessed(this);
        }

        if (this.processHeightsCalls.length > 1) {
            (this.processHeightsCalls.shift())();
        }

    } else {
        if (!this.updateCallback) {
            this.updateCallback = this.map.core.on("map-update", this.processHeights.bind(this, this.heightsSource, this.heightsLod, onProcessed));
        }
    }

};

MapGeodataBuilder.prototype.extractGeometry = function(id) {
    let feature, i, li, j, lj, points, lines,
        vertexBuffer, indexBuffer, index, p;


    for (i = 0, li = this.groups.length; i < li; i++) {
        const group = this.groups[i];

        const groupPoints = group.points;
        const groupLines = group.lines;
        const groupPolygons = group.polygons;
        let j, lj;

        //get group bbox
        for (j = 0, lj = groupPoints.length; j < lj; j++) {
            if (groupPoints[j].id == id) {
                feature = groupPoints[j];
            }
        }

        for (j = 0, lj = groupLines.length; j < lj; j++) {
            if (groupLines[j].id == id) {
                feature = groupLines[j];
            }
        }

        for (j = 0, lj = groupPolygons.length; j < lj; j++) {
            if (groupPolygons[j].id == id) {
                feature = groupPolygons[j];
            }
        }
    }

    if (feature) {
        if (feature.points) {

            points = feature.points;

            if (points.length > 0) {
                vertexBuffer = new Float64Array(points.length * 3);

                for (i = 0, li = points.length; i < li; i++) {
                    index = i * 3;
                    p = points[i];
                    vertexBuffer[index] = p[0];
                    vertexBuffer[index+1] = p[1];
                    vertexBuffer[index+2] = p[2];
                }
            }

            return new MapGeodataGeometry(this.map, {'type': 'point-geometry', 'id':feature.id, 'geometryBuffer': vertexBuffer });

        } else if (feature.lines) {

            lines = feature.lines;

            if (lines.length > 0) {

                let totalPoints = 0;

                for (i = 0, li = lines.length; i < li; i++) {
                    totalPoints += lines[i].length;
                }

                vertexBuffer = new Float64Array(totalPoints * 3);
                indexBuffer = new Uint32Array(li);
                index = 0;

                for (i = 0, li = lines.length; i < li; i++) {

                    const points = lines[i];

                    for (j = 0, lj = points.length; j < lj; j++) {
                        p = points[j];
                        vertexBuffer[index] = p[0];
                        vertexBuffer[index+1] = p[1];
                        vertexBuffer[index+2] = p[2];
                        index += 3;
                    }
                }
            }

            return new MapGeodataGeometry(this.map, {'type': 'line-geometry', 'id':feature.id, 'geometryBuffer': vertexBuffer, 'indicesBuffer': indexBuffer });
        } else if (feature.vertices) {

            /*feature.vertices = featureVertices;
            feature.surface = featureSurface;
            feature.borders = featureBorders;*/

            return new MapGeodataGeometry(this.map, {'type': 'polygon-geometry', 'id':feature.id, 'geometryBuffer': feature.vertices, 'surface': feature.surface });
        }

        return;
    }

};


MapGeodataBuilder.prototype.compileGroup = function(group, resolution) {
    const bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
    const bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
    const geodataGroup = {};
    let groupPoints = group.points, points, p, feature, finalFeature;
    let groupLines = group.lines, lines, line, i, li, j, lj, k, lk;
    let groupPolygons = group.polygons, borders;

    geodataGroup.id = group.id;

    //get group bbox
    for (i = 0, li = groupPoints.length; i < li; i++) {
        points = groupPoints[i].points;

        for (j = 0, lj = points.length; j < lj; j++) {
            p = points[j];

            if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }
            if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }
            if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }

            if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }
            if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }
            if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }
        }
    }

    for (i = 0, li = groupLines.length; i < li; i++) {
        lines = groupLines[i].lines;

        for (j = 0, lj = lines.length; j < lj; j++) {
            line = lines[j];

            for (k = 0, lk = line.length; k < lk; k++) {
                p = line[k];

                if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }
                if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }
                if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }

                if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }
                if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }
                if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }
            }
        }
    }

    for (i = 0, li = groupPolygons.length; i < li; i++) {
        points = groupPolygons[i].vertices;

        for (j = 0, lj = points.length; j < lj; j++) {
            p = points[j];

            if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }
            if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }
            if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }

            if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }
            if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }
            if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }
        }
    }

    if (!resolution) {
        const maxDelta = Math.max((bboxMax[0] - bboxMin[0]) + 1, (bboxMax[1] - bboxMin[1]) + 1, (bboxMax[2] - bboxMin[2]) + 1);

        //25cm resolution
        resolution = maxDelta / 0.25;
        resolution = Math.max(resolution, 1024);
        resolution = Math.min(resolution, (2<<20));
    }

    geodataGroup.resolution = resolution;

    //process coords to resolution
    const bboxScaleFactor = [resolution/((bboxMax[0] - bboxMin[0]) + 1),
                           resolution/((bboxMax[1] - bboxMin[1]) + 1),
                           resolution/((bboxMax[2] - bboxMin[2]) + 1)];

    geodataGroup.points = new Array(groupPoints.length);

    for (i = 0, li = groupPoints.length; i < li; i++) {
        feature = groupPoints[i];
        points = feature.points;

        const finalPoints = new Array(points.length);

        for (j = 0, lj = points.length; j < lj; j++) {
            p = points[j];

            finalPoints[j] = [ Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]),
                               Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]),
                               Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]) ];
        }

        finalFeature = {
            points : finalPoints
        };

        if (feature.id) {
            finalFeature.id = feature.id;
        }

        if (feature.properties) {
            finalFeature.properties = feature.properties;
        }

        geodataGroup.points[i] = finalFeature;
    }

    geodataGroup.lines = new Array(groupLines.length);

    for (i = 0, li = groupLines.length; i < li; i++) {
        feature = groupLines[i];
        lines = feature.lines;

        const finalLines = new Array(lines.length);

        for (j = 0, lj = lines.length; j < lj; j++) {
            line = lines[j];

            let finalPoints = new Array(line.length);

            for (k = 0, lk = line.length; k < lk; k++) {
                p = line[k];

                finalPoints[k] = [ Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]),
                                   Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]),
                                   Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]) ];
            }

            finalLines[j] = finalPoints;
        }

        finalFeature = {
            lines : finalLines
        };

        if (feature.id) {
            finalFeature.id = feature.id;
        }

        if (feature.properties) {
            finalFeature.properties = feature.properties;
        }

        geodataGroup.lines[i] = finalFeature;
    }


    geodataGroup.polygons = new Array(groupPolygons.length);

    for (i = 0, li = groupPolygons.length; i < li; i++) {
        feature = groupPolygons[i];
        points = feature.vertices;

        const finalVertices = new Array(points.length);
        k = 0;

        for (j = 0, lj = points.length; j < lj; j++) {
            p = points[j];
            finalVertices[k++] = Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]);
            finalVertices[k++] = Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]);
            finalVertices[k++] = Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]);
        }

        finalFeature = {
            vertices : finalVertices,
            surface : feature.surface.slice()
        };

        borders = feature.borders;
        const finalBorders = new Array(borders.length);

        for (j = 0, lj = finalBorders.length; j < lj; j++) {
            finalBorders[j] = borders[j].slice();
        }

        finalFeature.borders = finalBorders;

        if (feature.id) {
            finalFeature.id = feature.id;
        }

        if (feature.properties) {
            finalFeature.properties = feature.properties;
        }

        geodataGroup.polygons[i] = finalFeature;
    }

    geodataGroup.bbox = [ bboxMin, bboxMax ];

    if (bboxMax[0] > this.bboxMax[0]) { this.bboxMax[0] = bboxMax[0]; }
    if (bboxMax[1] > this.bboxMax[1]) { this.bboxMax[1] = bboxMax[1]; }
    if (bboxMax[2] > this.bboxMax[2]) { this.bboxMax[2] = bboxMax[2]; }

    if (bboxMin[0] < this.bboxMin[0]) { this.bboxMin[0] = bboxMin[0]; }
    if (bboxMin[1] < this.bboxMin[1]) { this.bboxMin[1] = bboxMin[1]; }
    if (bboxMin[2] < this.bboxMin[2]) { this.bboxMin[2] = bboxMin[2]; }

    return geodataGroup;
};


MapGeodataBuilder.prototype.makeGeodata = function(resolution) {
    this.bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
    this.bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];

    const geodata = {
        "version" : 1,
        "groups" : [],
    }

    if (this.binPath) {
        geodata["binPath"] = this.binPath;
    }

    for (let i = 0, li = this.groups.length; i < li; i++) {
        geodata["groups"].push(this.compileGroup(this.groups[i], resolution));
    }

    if (this.nodes.length > 0) {
        geodata.nodes = [];
        for (let i = 0, li = this.nodes.length; i < li; i++) {
            geodata["nodes"].push(this.nodes[i]);
        }
    }

    return geodata;
};


MapGeodataBuilder.prototype.makeFreeLayer = function(style, resolution, geodata) {
    if (!geodata) {
        geodata = this.makeGeodata(resolution);
    }

    if (!style) {
        style = {
            "layers" : {
                "my-lines" : {
                    "filter" : ["==", "#type", "line"],
                    "line": true,
                    "line-width" : 4,
                    "line-color": [255,0,255,255],
                    "zbuffer-offset" : [-5,0,0]
                },
                "my-points" : {
                    "filter" : ["==", "#type", "point"],
                    "point": true,
                    "point-radius" : 10,
                    "point-color": [0,0,255,255],
                    "zbuffer-offset" : [-5,0,0]
                }
            }
        }
    }

    const freeLayer = {
            'credits' : [],
            'displaySize' : 1024,
            'extents' : {
                'll' : this.bboxMin,
                'ur' : this.bboxMax
            },
            'geodata' : geodata,
            'style' : style,
            'type' : 'geodata'
        };

    return freeLayer;
};

/* harmony default export */ __webpack_exports__["default"] = (MapGeodataBuilder);


/***/ }),

/***/ "./src/core/map/geodata-geometry.js":
/*!******************************************!*\
  !*** ./src/core/map/geodata-geometry.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");


/*import {math as math_} from '../utils/math';*/

//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"];
/*const math = math_;*/


const MapGeodataGeometry = function(map, data) {
    this.map = map;
    this.data = data;
    this.camera = map.camera;
    this.renderer = map.renderer;

    switch (data.type) {
        case 'point-geometry':
            this.type = 1;
            this.vertexBuffer = this.data.geometryBuffer;
            break;
        case 'line-geometry':
            this.type = 2;
            this.vertexBuffer = this.data.geometryBuffer;
            this.indicesBuffer = this.data.indicesBuffer;
            break;
        case 'polygon-geometry':
            this.type = 3;
            this.vertexBuffer = this.data.geometryBuffer;
            this.surface = this.data.surface;
            this.borders = this.data.borders;
            break;
    }
};

MapGeodataGeometry.prototype.getType = function() {
    switch(this.type) {
        case 1: return 'point';
        case 2: return 'line';
        case 3: return 'polygon';
    }
};

MapGeodataGeometry.prototype.getElement = function(index) {
    const v = this.vertexBuffer;
    let i = index * 3;
    switch(this.type) {
        case 1: return [v[i], v[i+1], v[i+2]]; //point
        case 2: return [[v[i], v[i+1], v[i+2]],  [v[i+3], v[i+4], v[i+5]]]; //line
        case 3:
            {
                const s = this.surface;
                const i1 = s[i], i2 = s[i+1], i3 = s[i+2];
                return [[v[i1][0], v[i1][1], v[i1][2]],  [v[i2][0], v[i2][1], v[i2][2]],  [v[i3][0], v[i3][1], v[i3][2]]]; //polygon
            }
    }
};

MapGeodataGeometry.prototype.getElements = function(pathIndex) {
    switch(this.type) {
        case 1: //point
        case 3: return this.surface.length / 3; //polygon
        case 2:  //line
            {
                pathIndex = pathIndex || 0;
                const si = (this.indicesBuffer[pathIndex]) * 3;
                const ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);

                return Math.max(0, ((ei - si) / 3) - 1);
            }
    }
};

MapGeodataGeometry.prototype.getRelationToCanvasPoint = function(index, screenX, screenY) {
    const vb = this.vertexBuffer;
    let i = index * 3;
    let c1, cv, r = [0,0,0];
    let a, b, c, d, e, D, sc, tc, u, v, w;

    c1 = this.camera.position;
    //cv = this.camera.vector;

    cv = this.renderer.getScreenRay(screenX, screenY);

    //console.log(JSON.stringify(c1) + "  " + JSON.stringify(cv));

    switch(this.type) {
        case 1:
            {
                //get point
                const p = [vb[i], vb[i+1], vb[i+2]];
                const cp = [p[0] - c[0], p[0] - c[0],]

                //distance = vec3.coss(ray.direction, point - ray.origin).magnitude;
                vec3.cross(cv, cp, r)
                d = vec3.length(p);

                return {
                    'distance' : d,
                    'point' : p
                }
            }

        case 2:
            {
                //line points
                const p1 = [vb[i], vb[i+1], vb[i+2]];
                const p2 = [vb[i+3], vb[i+4], vb[i+5]];

                //distance = http://geomalgorithms.com/a07-_distance.html

                u = cv;
                v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                w = [c1[0] - p1[0], c1[1] - p1[1], c1[2] - p1[2]];
                a = vec3.dot(u,u);    // always >= 0
                b = vec3.dot(u,v);
                c = vec3.dot(v,v);    // always >= 0
                d = vec3.dot(u,w);
                e = vec3.dot(v,w);
                D = a*c - b*b;        // always >= 0

                // compute the line parameters of the two closest points
                if (D < 0.0000001) {          // the lines are almost parallel
                    sc = 0.0;
                    tc = (b>c ? d/b : e/c);    // use the largest denominator
                }
                else {
                    sc = (b*e - c*d) / D;
                    tc = (a*e - b*d) / D;
                }

                // get the difference of the two closest points
                const dP = [ w[0] + (u[0] * sc) - (v[0] * tc),
                             w[1] + (u[1] * sc) - (v[1] * tc),
                             w[2] + (u[2] * sc) - (v[2] * tc) ];

                return {
                    'closest' : [ p1[0] + (vb[0] * tc), p1[1] + (vb[1] * tc), p1[2] + (vb[2] * tc) ],
                    'line-distance' : vec3.length(dP),
                    'distance' : tc,
                    'line' : [p1, p2]
                }
            }
    }
};

MapGeodataGeometry.prototype.getPathElement = function(index, pathIndex) {
    if (this.type != 2) {
        return null;
    }

    const i = (this.indicesBuffer[pathIndex || 0] + index) * 3, v = this.vertexBuffer;
    return [[v[i], v[i+1], v[i+2]],  [v[i+3], v[i+4], v[i+5]]];
};

MapGeodataGeometry.prototype.getPathPoint = function(distance, pathIndex) {
    pathIndex = pathIndex || 0;

    const si = (this.indicesBuffer[pathIndex]) * 3;
    const ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);

    let totalLength = 0, delta, length, v = this.vertexBuffer;

    for (let i = si; i < (ei-3); i+=3) {
        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];
        length = vec3.length(delta);

        if (totalLength + length > distance) {
            const factor =  (distance - totalLength) / length;
            return [v[i] + delta[0] * factor, v[i+1] + delta[1] * factor, v[i+2] + delta[2] * factor];
        }

        totalLength += length;
    }

    return [v[ei-3], v[ei-2], v[ei-1]];
};

MapGeodataGeometry.prototype.getPathNED = function(distance, withoutSlope, pathIndex) {
    pathIndex = pathIndex || 0;

    const si = (this.indicesBuffer[pathIndex]) * 3;
    const ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);

    let totalLength = 0, p, delta, length, v = this.vertexBuffer;

    for (let i = si; i < (ei-5); i+=3) {
        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];
        length = vec3.length(delta);

        if (totalLength + length > distance) {
            const factor = (totalLength + length) / distance;
            //p = [v[i] + d[0] * factor, v[i+1] + d[1] * factor, v[i+2] + d[2] * factor];
            p = [v[i] + delta[0] * factor, v[i+1] + delta[1] * factor, v[i+2] + delta[2] * factor];
            break;
        }

        totalLength += length;
    }

    if (!p) {
        p = [v[ei-3], v[ei-2], v[ei-1]];
    }

    const vv = [0, 0, 0];
    const nn = [0, 0, 0];
    const pp = [0, 0, 0];

    vec3.nomalize(delta, vv);
    vec3.nomalize(p, pp);
    vec3.cross(pp, vv, nn);

    if (withoutSlope) {
        vec3.cross(pp, nn, vv);
    }

    const east = nn;
    const direction = vv;
    const north = pp;

    return {
        'east'  : east,
        'direction' : direction,
        'north' : north,
        'position' : p,
        'matrix' : [
            east[0], east[1], east[2], 0,
            north[0], north[1], north[2], 0,
            direction[0], direction[1], direction[2], 0,
            0, 0, 0, 1
        ]
    };
};


MapGeodataGeometry.prototype.getPathLengthToElement = function(index, pathIndex) {
    pathIndex = pathIndex || 0;

    const si = (this.indicesBuffer[pathIndex]) * 3;
    const ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);

    let totalLength = 0, delta, length, v = this.vertexBuffer, elementIndex = 0;

    for (let i = si; i < (ei-5); i+=3) {
        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];
        length = vec3.length(delta);

        if (index == elementIndex) {
            return {
                'lengthToElement' : totalLength,
                'elementLengh' : length
            }
        }

        elementIndex++
        totalLength += length;
    }

    return totalLength;
};


MapGeodataGeometry.prototype.getPathLength = function(pathIndex) {
    pathIndex = pathIndex || 0;

    const si = (this.indicesBuffer[pathIndex]) * 3;
    const ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);

    let totalLength = 0, delta, length, v = this.vertexBuffer;

    for (let i = si; i < (ei-5); i+=3) {
        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];
        length = vec3.length(delta);

        totalLength += length;
    }

    return totalLength;
};


MapGeodataGeometry.prototype.getPathsCount = function() {
    if (this.type != 2) {
        return 0;
    }

    return this.indicesBuffer.length;
};


MapGeodataGeometry.prototype.getSurfaceArea = function() {
    if (this.type != 3) {
        return 0;
    }

    if (!this.surfaceArea) {
        let v = this.vertexBuffer, s = this.surface;
        let p1, p2, p3, l1, l2, l3, dx, dy, dz, perimeter, area;

        this.surfaceArea = 0;
        for (let i = 0, li = s.length; i < li; i+= 3) {
            p1 = v[s[i]];
            p2 = v[s[i+1]];
            p3 = v[s[i+2]];

            dx = p2[0] - p1[0];
            dy = p2[1] - p1[1];
            dz = p2[2] - p1[2];
            l1 = Math.sqrt(dx*dx + dy*dy + dz*dz);

            dx = p2[0] - p3[0];
            dy = p2[1] - p3[1];
            dz = p2[2] - p3[2];
            l2 = Math.sqrt(dx*dx + dy*dy + dz*dz);

            dx = p3[0] - p1[0];
            dy = p3[1] - p1[1];
            dz = p3[2] - p1[2];
            l3 = Math.sqrt(dx*dx + dy*dy + dz*dz);

            //Heron's formula
            perimeter = (l1 + l2 + l3)/2;
            area =  Math.sqrt(perimeter*((perimeter-l1)*(perimeter-l2)*(perimeter-l3)));

            this.surfaceArea += area;
        }
    }

    return this.surfaceArea;
};

/* harmony default export */ __webpack_exports__["default"] = (MapGeodataGeometry);


/***/ }),

/***/ "./src/core/map/geodata-import/geojson.js":
/*!************************************************!*\
  !*** ./src/core/map/geodata-import/geojson.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const MapGeodataImportGeoJSON = function(builder, heightMode, srs, options) {
    this.builder = builder;
    this.map = builder.map;
    this.heightMode = heightMode || 'float';
    this.srs = srs;

    options = options || {};

    this.groupIdPrefix = options['groupIdPrefix'] || '';
    this.dontCreateGroups = options['dontCreateGroups'];
    this.tesselation = options['tesselation'];
};

MapGeodataImportGeoJSON.prototype.processGeometry = function(geometry, feature) {
    const coords = geometry['coordinates'];
    if (!coords) {
        return;
    }

    switch(geometry['type']) {
        case 'Point':
            this.builder.addPoint(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);
            break;

        case 'MultiPoint':
            this.builder.addPointArray(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);
            break;

        case 'LineString':
            this.builder.addLineString(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);
            break;

        case 'MultiLineString':
            this.builder.addLineStringArray(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);
            break;

        case 'Polygon':
            if (coords.length > 0) {
                this.builder.addPolygon(coords[0], (coords.length > 1) ? coords.slice(1) : [], null, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs, this.tesselation);
            }
            break;

        case 'MultiPolygon':
            for (let i = 0, li = coords.length; i < li; i++) {
                const coords2 = coords[i];
                if (coords2.length > 0) {
                    this.builder.addPolygon(coords2[0], (coords2.length > 1) ? coords2.slice(1) : [], null, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs, this.tesselation);
                }
            }
            break;

        case 'GeometryCollection':
            {
                const geometries = geometry['gemetries'];

                if (geometries) {
                    for (let i = 0, li = geometries.length; i < li; i++) {
                        this.processGeometry(geometries[i], feature);
                    }
                }
            }
            break;
    }
};

MapGeodataImportGeoJSON.prototype.processFeature = function(json) {
    const geometry = json['geometry'];

    if (geometry) {
        this.processGeometry(geometry, json);
    }
};

MapGeodataImportGeoJSON.prototype.processCollection = function(json) {
    const features = json['features'];

    if (!features) {
        return;
    }

    for (let i = 0, li = features.length; i < li; i++) {
        this.processFeature(features[i]);
    }
};

MapGeodataImportGeoJSON.prototype.processJSON = function(json) {
    if (!json) {
        return;
    }

    if (json['type']) {

        switch (json['type']) {
            case 'FeatureCollection':

                if (!this.dontCreateGroups) {
                    this.builder.addGroup(this.groupIdPrefix != '' ? this.groupIdPrefix : null);
                }

                this.processCollection(json);
                break;
            case 'Feature':

                if (!this.dontCreateGroups) {
                    this.builder.addGroup(this.groupIdPrefix != '' ? this.groupIdPrefix : null);
                }

                this.processFeature(json);
                break;
        }

    } else {

        for (let key in json) {
            const item = json[key];

            if (!this.dontCreateGroups) {
                this.builder.addGroup(this.groupIdPrefix + key);
            }

            switch (json['type']) {
                case 'FeatureCollection':
                    this.processCollection(item);
                    break;
                case 'Feature':
                    this.processFeature(item);
                    break;
            }
        }
    }

};

/* harmony default export */ __webpack_exports__["default"] = (MapGeodataImportGeoJSON);


/***/ }),

/***/ "./src/core/map/geodata-import/vts-geodata.js":
/*!****************************************************!*\
  !*** ./src/core/map/geodata-import/vts-geodata.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const MapGeodataImportVTSGeodata = function(builder, groupIdPrefix, dontCreateGroups) {
    this.builder = builder;
    this.map = builder.map;
    this.groupIdPrefix = groupIdPrefix || '';
    this.dontCreateGroups = dontCreateGroups;
    //this.processJSON(json);
};

MapGeodataImportVTSGeodata.prototype.processJSON = function(json) {
    if (!json) {
        return;
    }

    const groups = json['groups'], builder = this.builder;
    let i, li, j, lj, k, lk, p;
    let newPoints, points;

    if (!groups) {
        return;
    }

    for (i = 0, li = groups.length; i < li; i++) {
        const group = groups[i];

        const bbox = group['bbox'],
              resolution = group['resolution'];

        if (!bbox || !resolution) {
            continue;
        }

        const bboxMin = bbox[0];
        const bboxMax = bbox[1];

        if (!bboxMin || !bboxMax) {
            continue;
        }

        if (!this.dontCreateGroups) {
            builder.addGroup(this.groupIdPrefix + (group['id'] || ''));
        }

        const fx = (bboxMax[0] - bboxMin[0]) / resolution;
        const fy = (bboxMax[1] - bboxMin[1]) / resolution;
        const fz = (bboxMax[2] - bboxMin[2]) / resolution;

        //import group points
        const pointsFeatures = group['points'];
        if (pointsFeatures) {

            points = pointsFeatures['points']

            for (j = 0, lj = pointsFeatures.length; j < lj; j++) {
                const point = pointsFeatures[j];
                const subpoints = point['points'];
                const newSubpoints = new Array(subpoints.length);

                for (k = 0, lk = subpoints.length; k < lk; k++) {
                    p = subpoints[k];
                    newSubpoints[k] = [bboxMin[0] + p[0] * fx, bboxMin[1] + p[1] * fy, bboxMin[2] + p[2] * fz];
                }

                builder.addPointArray(newSubpoints, 'fix', point['properties'], point['id'], null, true);
            }
        }

        //import group lines
        const linesFeatures = group['lines'];
        if (linesFeatures) {
            for (j = 0, lj = linesFeatures.length; j < lj; j++) {
                const line = linesFeatures[j];
                const sublines = line['lines'];
                const newSublines = new Array(sublines.length);

                for (k = 0, lk = sublines.length; k < lk; k++) {

                    points = sublines[k];
                    newPoints = new Array(points.length);

                    for (let l  = 0, ll = points.length; l < ll; l++) {
                        p = points[l];
                        newPoints[l] = [bboxMin[0] + p[0] * fx, bboxMin[1] + p[1] * fy, bboxMin[2] + p[2] * fz];
                    }

                    newSublines[k] = newPoints;
                }

                builder.addLineStringArray(newSublines, 'fix', line['properties'], line['id'], null, true);
            }
        }

        const polygonsFeatures = group['polygons'];
        if (polygonsFeatures) {
            const transform = { sx: fx, sy:fy, sz:fz, px:bboxMin[0], py:bboxMin[1], pz:bboxMin[2] };

            for (j = 0, lj = polygonsFeatures.length; j < lj; j++) {
                const polygon = polygonsFeatures[j];

                builder.addPolygonRAW(polygon['vertices'], polygon['surface'], polygon['borders'], polygon['middle'], 'fix', polygon['properties'], polygon['id'], null, true, transform);
            }
        }

    }

};

/* harmony default export */ __webpack_exports__["default"] = (MapGeodataImportVTSGeodata);


/***/ }),

/***/ "./src/core/map/geodata-import/vts-tree.js":
/*!*************************************************!*\
  !*** ./src/core/map/geodata-import/vts-tree.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ "./src/core/utils/utils.js");

//import {math as math_} from '../../utils/math';


//import {utilsUrl as utilsUrl_} from '../../utils/url';


//get rid of compiler mess
//const math = math_;
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_1__["utils"];
//const utilsUrl = utilsUrl_;

const MapGeodataImportVTSTree = function() {
    this.bintree = null;
    this.pathTable = null;
    this.totalNodes = 0;
    this.pathTableSize = 1;
    this.nodesIndex = 0;
    this.rootSize = 1;
};


// eslint-disable-next-line
MapGeodataImportVTSTree.prototype.processNode = function(nodes, nindex, index, lod, onlyChildren) {

    let index2 = index * 9;

    const flags = nodes[nindex];

    for (let i = 0; i < 8; i++) {

        this.bintree[index2] = nindex;

        if (flags & (1 << i))
        {
            this.totalNodes++;
            const childIndex = this.totalNodes;
            const octant = i;

            this.bintree[index2 + 1 + octant] = childIndex;

            this.processNode(nodes, childIndex, childIndex, lod + 1);
        }
    }

};


MapGeodataImportVTSTree.prototype.processTree = function(data, options) {

    const dataView = new DataView(data);
    let index = 0;
    let magic = '';

    if (data.length < 2) {
        return false;
    }

    magic += String.fromCharCode(dataView.getUint8(index, true)); index += 1;
    magic += String.fromCharCode(dataView.getUint8(index, true)); index += 1;

    if (magic != 'tr') {
        return false;
    }

    this.version = dataView.getUint16(index, true); index += 2;
    const jsonSize = dataView.getUint32(index, true); index += 4;

    let json = utils.unint8ArrayToString(new Uint8Array(data, index, jsonSize));
    index += jsonSize;

    try {
        json = JSON.parse(json);
        // eslint-disable-next-line
    } catch (e) {
    }

    const headerSize = jsonSize + 2 + 2 + 4;
    let bboxIndex;

    if (json['bbox'] && json['bbox']['offset']) {
        bboxIndex = json['bbox']['offset'];
    }

    this.texelSize = json['texelSize'];

    const node = json['node'];

    if (!node) {
        return false;
    }

    if (!node['features'] || !node['features'].legnth < 1) {
        return false;
    }

    const treeSize = dataView.getUint32(index, true); index += 4;
    const treeArray = new Uint8Array(data, index, treeSize); index += treeSize;

    const features = node['features'];
    //let indicesArray;

    this.features = [];

    for (let i = 0, li = features.length; i < li; i++) {

        const feature = {
            type : features[i]['type'],
            uri : features[i]['uri']
        };

        if (features[i]['offset']) {
            feature.indices = new Uint32Array(data.slice(features[i]['offset'] + headerSize, features[i]['offset'] + headerSize + (treeSize+1) * 4));
        }

        this.features.push(feature);
    }

    if (bboxIndex) {
        this.bbox = new Float64Array(data.slice(headerSize + bboxIndex, headerSize + bboxIndex + 8 * 3 * 8));
    }

    this.bintree = new Uint32Array(treeSize*9);
    this.totalNodes = 0;

    //debugger

    if (options.root) {

        const bbox = this.bbox;

        const center = [ (bbox[0]+bbox[3]+bbox[6]+bbox[9]+bbox[12]+bbox[15]+bbox[18]+bbox[21])/8,
                         (bbox[1]+bbox[4]+bbox[7]+bbox[10]+bbox[13]+bbox[16]+bbox[19]+bbox[22])/8,
                         (bbox[2]+bbox[5]+bbox[8]+bbox[11]+bbox[14]+bbox[17]+bbox[20]+bbox[23])/8 ];

        this.rootPoints = [

            [bbox[0],
             bbox[1],
             bbox[2]],

            [bbox[3],
             bbox[4],
             bbox[5]],

             [bbox[9],
              bbox[10],
              bbox[11]],

            [bbox[6],
             bbox[7],
             bbox[8]],


            [bbox[12],
             bbox[13],
             bbox[14]],

            [bbox[15],
             bbox[16],
             bbox[17]],

             [bbox[21],
              bbox[22],
              bbox[23]],

            [bbox[18],
             bbox[19],
             bbox[20]],

        ];

        this.rootCenter = center;
        this.rootRadius = vec3.distance(center, this.rootPoints[0]);
        this.rootTexelSize = this.texelSize ? this.texelSize : vec3.distance(this.rootPoints[0], this.rootPoints[1]) / 256.0;

    } else {
        this.rootPoints = [];
        this.rootCenter = [];
        this.rootRadius = 1;
        this.rootTexelSize = 1;
    }

    this.processNode(treeArray, 0, 0, 0);
    this.totalNodes++;

}


MapGeodataImportVTSTree.prototype.load = function(path, options, onLoaded) {
    utils.loadBinary(path, this.onLoaded.bind(this, options, onLoaded), null);
}


MapGeodataImportVTSTree.prototype.onLoaded = function(options, onLoaded, data) {
    this.processTree(data, options);

    if (onLoaded) {
        onLoaded(options, {
                   'bintree': this.bintree,
                   'pathTable': this.pathTable,
                   'totalNodes': this.totalNodes,
                   'rootSize': this.rootSize,
                   'points': this.rootPoints,
                   'center': this.rootCenter,
                   'radius': this.rootRadius,
                   'texelSize': this.rootTexelSize,
                   'features': this.features,
                   'vtsFormat': true
               });
    }
}

/* harmony default export */ __webpack_exports__["default"] = (MapGeodataImportVTSTree);


/***/ }),

/***/ "./src/core/map/geodata-processor/processor.js":
/*!*****************************************************!*\
  !*** ./src/core/map/geodata-processor/processor.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const MapGeodataProcessor = function(surface, listener) {
    this.layer = surface;
    this.map = surface.map;
    this.renderer = this.map.renderer;
    this.killed = false;
    this.listener = listener;
    this.busy = false;
    this.ready = true;
    this.waitingForStylesheet = false;
    this.stylesheet = null;
    this.fonts = {};
    this.processCounter = 0;


    // eslint-disable-next-line
    const worker = __webpack_require__(/*! worker-loader?inline&fallback=false!./worker-main */ "./node_modules/worker-loader/dist/cjs.js?inline&fallback=false!./src/core/map/geodata-processor/worker-main.js");
    //const worker = require('worker-loader?!./worker-main');

    //debug worker
    this.processWorker = new worker;

    this.processWorker.onerror = function(event){
        throw new Error(event.message + ' (' + event.filename + ':' + event.lineno + ')');
    };

    this.processWorker.onmessage = this.onMessage.bind(this);

    this.processWorker.postMessage({'command':'config', 'data': this.map.config});
};


MapGeodataProcessor.prototype.kill = function() {
    if (this.killed) {
        return;
    }

    this.killed = true;

    if (this.processWorker != null) {
        this.processWorker.terminate();
    }
};


MapGeodataProcessor.prototype.isReady = function() {
    if (this.waitingForStylesheet) {
        this.waitingForStylesheet = !(this.stylesheet.isReady());
    }

    return ((this.ready && !this.busy) || this.killed) && !this.waitingForStylesheet;
};


MapGeodataProcessor.prototype.onMessage = function(message, direct) {
    if (this.killed) {
        return;
    }

    if (!direct) {
        message = message.data;
    }

    const command = message['command'];

    //console.log('onmessage ' + command);

    //if (typeof message === "string" && message == "ready") {
    if (command == 'ready') {
        this.ready = true;
        //console.log("ready");
    } else if (command == 'styleDone') {
        this.busy = false;
    } else if (command == 'loadBitmaps') {
        const bitmaps = message['bitmaps'];

        for (let key in bitmaps) {
            const bitmap = bitmaps[key];
            this.renderer.getBitmap(bitmap['url'], bitmap['filter'] || 'linear', bitmap['tiled'] || false, bitmap['hash'], true);
        }
    }

    if (this.listener != null) {
        if (command == 'packed-events') {
            const messages = message['messages'];

            for (let i = 0, li = messages.length; i < li; i++) {
                this.onMessage(messages[i], true);
            }

            return;
        } else {
            this.listener(command, message);
        }
    }
};


MapGeodataProcessor.prototype.setListener = function(listener) {
    this.listener = listener;
};


MapGeodataProcessor.prototype.sendCommand = function(command, data, tile, dpr) {
    if (this.killed) {
        return;
    }

    this.ready = false;

    const message = {'command': command, 'data':data};

    //console.log('sendCommand ' + command);

    if (tile && tile.id) {
        message['lod'] = tile.id[0];
        message['ix'] = tile.id[1];
        message['iy'] = tile.id[2];

        if (tile.metanode) {
            message['tileSize'] = Math.tan(tile.metanode.diskAngle2A) * tile.metanode.diskDistance;
            message['pixelSize'] =  (message['tileSize'] * 0.70710678118) / tile.metanode.displaySize;
        }
    }

    if (dpr) {
        message['dpr'] = dpr;
    }

    this.processWorker.postMessage(message);
};

// eslint-disable-next-line
MapGeodataProcessor.prototype.setStylesheet = function(stylesheet, fontsOnly) {
    this.stylesheet = stylesheet;

    if (!stylesheet.isReady()) {
        this.waitingForStylesheet = true;
        return;
    }

    this.busy = true;

    const ppi = 96 * (window.devicePixelRatio || 1);
    const config = this.map.config;
    const isDef = (function(val){ return (typeof val !== 'undefined') });
    const rmode = config.mapFeaturesReduceMode;
    let params = config.mapFeaturesReduceParams;


    switch (rmode) {
        case 'scr-count1':
        case 'scr-count2':
            if (!params) {
                params = [1,50,0];
            } else {
                params[0] = isDef(params[0]) ? params[0] : 1;
                params[1] = isDef(params[1]) ? params[1] : 50;
                params[2] = isDef(params[2]) ? params[2] : 0;
            }
            config.mapFeaturesSortByTop = (rmode == 'scr-count2') ? true : false;
            break;

        case 'scr-count4':
            if (!params) {
                params = [0.18,0,0];
            } else {
                params[0] = isDef(params[0]) ? params[0] : 0.18;
                params[1] = isDef(params[1]) ? params[1] : 0;
                params[2] = isDef(params[2]) ? params[2] : 1;
            }
            config.mapFeaturesSortByTop = true;
            break;

        case 'scr-count5':
            if (!params) {
                params = [2,1,0];
            } else {
                params[0] = isDef(params[0]) ? params[0] : 2;
                params[1] = isDef(params[1]) ? params[1] : 1;
                params[2] = isDef(params[2]) ? params[2] : 1;
            }
            config.mapFeaturesSortByTop = true;
            break;

        case 'scr-count6':
        case 'scr-count7':
            if (!params) {
                params = [0.2,0,((rmode == 'scr-count6') ? 1 : 2), 1, 1];
            } else {
                params[0] = (isDef(params[0]) ? params[0] : 0.2);
                params[1] = isDef(params[1]) ? params[1] : 0;
                params[2] = isDef(params[2]) ? params[2] : ((rmode == 'scr-count6') ? 1 : 2);
                params[3] = isDef(params[3]) ? params[3] : 1;
                params[4] = isDef(params[4]) ? params[4] : 1;
                params[5] = ppi;
                config.mapFeaturesSortByTop = true;
            }
            break;

        case 'scr-count8':
            if (!params) {
                params = [0.2, 0.6, 11, 1, 1000, 5];
            } else {
                params[0] = (isDef(params[0]) ? params[0] : 0.2);
                params[1] = isDef(params[1]) ? params[1] : 0.6;
                params[2] = isDef(params[2]) ? params[2] : 11;
                params[3] = isDef(params[3]) ? params[3] : 1;
                params[4] = isDef(params[4]) ? params[4] : 1000;
                params[5] = isDef(params[5]) ? params[5] : 5;
                params[6] = ppi;
                config.mapFeaturesSortByTop = true;
            }
            break;

    }

    config.mapFeaturesReduceParams = params;
    config.mapFeaturesReduceFactor = params[2];
    config.mapFeaturesReduceFactor2 = params[3];
    config.mapFeaturesReduceFactor3 = params[4];

    //this.setFont('#default', this.renderer.font);
    this.sendCommand('setStylesheet', { 'data' : stylesheet.data,
                                        'geocent' : (!this.map.getNavigationSrs().isProjected()),
                                        'metric': config.mapMetricUnits,
                                        'language': config.mapLanguage,
                                        'reduceMode': rmode,
                                        'reduceParams': config.mapFeaturesReduceParams,
                                        'log': config.mapLogGeodataStyles } );

    const fonts = stylesheet.fonts;
    const fontMap = {}; //'#default' : '#default' };

    for (let key in fonts) {
        const fontUrl = fonts[key];
        const font = this.renderer.fonts[fontUrl];
        fontMap[key] = fontUrl;

        if (font) {
            this.setFont(fontUrl, font);
        }
    }

    this.processCounter++;
    this.sendCommand('setFontMap', { 'map' : fontMap });
};


MapGeodataProcessor.prototype.setFont = function(url, font) {
    if (!this.fonts[url]) {
        this.fonts[url] = font;
        this.sendCommand('setFont', {'url' : url, 'data': font.data}, [font.data]);
    }
};


/* harmony default export */ __webpack_exports__["default"] = (MapGeodataProcessor);


/***/ }),

/***/ "./src/core/map/geodata-view.js":
/*!**************************************!*\
  !*** ./src/core/map/geodata-view.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _octree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./octree */ "./src/core/map/octree.js");
/* harmony import */ var _geodata_processor_processor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geodata-processor/processor */ "./src/core/map/geodata-processor/processor.js");





//import RenderGroup_ from '../renderer/group';


//get rid of compiler mess
const mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"], math = _utils_math__WEBPACK_IMPORTED_MODULE_1__["math"], utils = _utils_utils__WEBPACK_IMPORTED_MODULE_2__["utils"];
const MapOctree = _octree__WEBPACK_IMPORTED_MODULE_3__["default"];
//const RenderGroup = RenderGroup_;
const MapGeodataProcessor = _geodata_processor_processor__WEBPACK_IMPORTED_MODULE_4__["default"];

const MapGeodataView = function(map, geodata, extraInfo) {
    this.map = map;
    this.stats = map.stats;
    this.geodata = geodata;
    this.gpu = this.map.renderer.gpu;
    this.renderer = this.map.renderer;
    this.gpuGroups = [];
    this.currentGpuGroup = null;
    this.tile = extraInfo.tile;
    this.surface = extraInfo.surface;

    if (!this.surface.geodataProcessor) {
        const processor = new MapGeodataProcessor(this, this.onGeodataProcessorMessage.bind(this));
        processor.setStylesheet(this.surface.stylesheet);
        this.surface.geodataProcessor = processor;
        this.map.geodataProcessors.push(processor);
    } else {
        if (this.surface.styleChanged) {
            this.surface.geodataProcessor.setStylesheet(this.surface.stylesheet);
            this.surface.styleChanged = false;
        }
    }

    this.geodataProcessor = this.surface.geodataProcessor;
    this.processing = false;
    this.statsCounter = 0;
    this.size = 0;
    this.killed = false;
    this.killedByCache = false;
    this.ready = false;
    this.isReady();
};


MapGeodataView.prototype.kill = function() {
    this.killed = true;
    this.geodata = null;
    this.killGeodataView(false);
};


MapGeodataView.prototype.killGeodataView = function(killedByCache) {
    this.killedByCache = killedByCache;

    for (let i = 0, li = this.gpuGroups.length; i < li; i++) {
        this.gpuGroups[i].kill();
    }

    this.gpuGroups = [];

    if (killedByCache !== true && this.gpuCacheItem != null) {
        this.map.gpuCache.remove(this.gpuCacheItem);
    }

    this.stats.gpuGeodata -= this.size;
    this.stats.graphsFluxGeodata[1][0]++;
    this.stats.graphsFluxGeodata[1][1] += this.size;

    this.ready = false;
    this.size = 0;
    this.gpuCacheItem = null;
};


MapGeodataView.prototype.processPackedCommands = function(buffer, index) {

    const maxIndex = buffer.byteLength;
    const maxTime = this.map.config.mapMaxGeodataProcessingTime;
    const view = new DataView(buffer.buffer);
    let t = performance.now(), length, str, data;

    do {

        const command = buffer[index]; index += 1;

        switch(command) {
            case 9:
                index += 1;
                length = view.getUint32(index); index += 4;
                str = utils.unint8ArrayToString(new Uint8Array(buffer.buffer, index, length)); index+= length;
                data = JSON.parse(str);

                this.currentGpuGroup = this.renderer.gpu.createRenderGroup(data['id'], data['bbox'], data['origin']);
                this.gpuGroups.push(this.currentGpuGroup);

                //console.log('VTS_WORKERCOMMAND_GROUP_BEGIN ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
                break;

            case 10:
                this.size += this.currentGpuGroup.size; index += 1 + 4;
                //console.log('VTS_WORKERCOMMAND_GROUP_END ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
                break;

            case 5:
                index = this.currentGpuGroup.addRenderJob2(buffer, index, this.tile);
                break;

            case 7:
                this.map.markDirty();
                this.gpuCacheItem = this.map.gpuCache.insert(this.killGeodataView.bind(this, true), this.size);

                this.stats.gpuGeodata += this.size;
                this.stats.graphsFluxGeodata[0][0]++;
                this.stats.graphsFluxGeodata[0][1] += this.size;
                this.ready = true;
                this.processing = false;

                //console.log('VTS_WORKERCOMMAND_ALL_PROCESSED ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));

                index += 1 + 4;
                break;
        }

        if ((performance.now() - t) > maxTime) {
            if (index < maxIndex) {
                return index;
            }
        }

    } while(index < maxIndex);


    this.stats.renderBuild += performance.now() - t;

    return -1;
};


MapGeodataView.prototype.onGeodataProcessorMessage = function(command, message, task) {
    if (this.killed || this.killedByCache){
        return;
    }

    switch (command) {

    case 'addPackedCommands':

        //console.log('pack size:' + message['buffer'].byteLength);

        if (task) {
            const index = this.processPackedCommands(message['buffer'], message.index);

            if (index < 0) {
                this.map.markDirty();
                //console.log('addPackedCommandsB ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
            } else {
                //console.log('addPackedCommandsC ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
                message.index = index;
                return -123;
            }

        } else {
            message.index = 0;
            this.map.markDirty();
            this.map.addProcessingTask2(this.onGeodataProcessorMessage.bind(this, command, message, true));

            //console.log('addPackedCommandsA ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
        }

        break;

    case 'ready':

        if (this.geodataProcessor.processCounter > 0) {
            this.geodataProcessor.processCounter--;

            if (this.geodataProcessor.processCounter > 0) {
                this.map.markDirty();
                //console.log('ready2 ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));

                break;
            }
        }

        if (message['geodata']) {
            this.geodata.geodata = message['geodata'];
        }

        this.geodataProcessor.busy = false;
        this.map.markDirty();
        //console.log('ready ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));

            //this.ready = true;
        break;
    }
};


MapGeodataView.prototype.directParseNode = function(node, lod) {

    this.currentGpuGroup.addRenderJob2(null, null, this.tile, { type: 21, data: {'volume': node.volume, 'precision': node.precision, 'tileset': node.tileset }});

    const meshes = node['meshes'] || [];
    let i, li;

    //loop elements
    for (i = 0, li = meshes.length; i < li; i++) {
        this.currentGpuGroup.addRenderJob2(null, null, this.tile, { type: 23, data: { 'path':meshes[i] } });
    }

    const nodes = node['nodes'] || [];

    for (i = 0, li = nodes.length; i < li; i++) {
        this.directParseNode(nodes[i], lod+1);
    }

    const loadNodes = node['loadNodes'] || [];

    for (i = 0, li = loadNodes.length; i < li; i++) {
        this.currentGpuGroup.addRenderJob2(null, null, this.tile, { type: 24, data: { 'path':loadNodes[i] } });
    }

    this.currentGpuGroup.addRenderJob2(null, null, this.tile, { type: 22, data: {} });

};


MapGeodataView.prototype.directParse = function(data) {
    if (!data) {
        return;
    }

    const nodes = data['nodes'] || [];

    for (let i = 0, li = nodes.length; i < li; i++) {

        //VTS_WORKERCOMMAND_GROUP_BEGIN
        this.currentGpuGroup = this.renderer.gpu.createRenderGroup(null /*data['id']*/, null /*data['bbox']*/, null /*data['origin']*/);

        this.gpuGroups.push(this.currentGpuGroup);

        this.directParseNode(nodes[i], 0);

        //VTS_WORKERCOMMAND_GROUP_END:
        this.size += this.currentGpuGroup.size;
    }
};


MapGeodataView.prototype.directBinParse = function(path) {
    this.currentGpuGroup = this.renderer.gpu.createRenderGroup(null /*data['id']*/, null /*data['bbox']*/, null /*data['origin']*/);
    this.gpuGroups.push(this.currentGpuGroup);
    this.currentGpuGroup.binPath = path;
    this.currentGpuGroup.octreeParser = new MapOctree(null /*data['id']*/, null /*data['bbox']*/, null /*data['origin']*/, this.gpu, this.renderer);
    this.currentGpuGroup.octreeParser.binPath = path;
};


MapGeodataView.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {
    if (this.killed) {
        return false;
    }

    const doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);
    doNotLoad = doNotLoad || doNotUseGpu;

    if (!this.ready && !this.processing && !doNotLoad && this.surface.stylesheet.isReady()) {
        if (this.geodata.isReady(doNotLoad, priority, doNotCheckGpu, this.surface.options.fastParse) && this.geodataProcessor.isReady()) {

            if (this.surface.options.fastParse) {

                if (typeof this.geodata.geodata === 'object') { //use geodata directly
                    if (this.geodata.geodata['binPath']) {
                        this.directBinParse(this.geodata.geodata['binPath']);
                    } else {
                        this.directParse(this.geodata.geodata);
                    }
                } else {
                    this.directParse(JSON.parse(this.geodata.geodata));
                }

                this.map.markDirty();
                this.ready = true;
            } else {
                const geodata = this.geodata.geodata;

                this.processing = true;
                this.killedByCache = false;
                this.geodataProcessor.setListener(this.onGeodataProcessorMessage.bind(this));

                if (this.map.config.mapGeodataBinaryLoad && (typeof geodata !== 'string')) {
                    this.geodataProcessor.sendCommand('processGeodataRaw', geodata, this.tile, (window.devicePixelRatio || 1), [geodata]);
                } else {
                    this.geodataProcessor.sendCommand('processGeodata', geodata, this.tile, (window.devicePixelRatio || 1));
                }

                this.geodataProcessor.busy = true;
                //console.log('processGeodata ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
            }
        }
    }

    if (!doNotLoad && this.gpuCacheItem) {
        this.map.gpuCache.updateItem(this.gpuCacheItem);
    }

    return this.ready;
};


MapGeodataView.prototype.getWorldMatrix = function(bbox, geoPos, matrix) {
    let m = matrix;

    if (m != null) {
        m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
        m[12] = bbox.min[0] - geoPos[0]; m[13] = bbox.min[1] - geoPos[1]; m[14] = bbox.min[2] - geoPos[2]; m[15] = 1;
    } else {
        m = mat4.create();

        mat4.multiply( math.translationMatrix(bbox.min[0] - geoPos[0], bbox.min[1] - geoPos[1], bbox.min[2] - geoPos[2]),
                       math.scaleMatrix(1, 1, 1), m);
    }

    return m;
};


MapGeodataView.prototype.draw = function(cameraPos) {
    if (this.ready) {

        const renderer = this.renderer;
        const tiltAngle = this.tile ? Math.abs(this.tile.tiltAngle) : renderer.cameraTiltFator;
        const useSuperElevation = renderer.useSuperElevation;

        for (let i = 0, li = this.gpuGroups.length; i < li; i++) {
            const group = this.gpuGroups[i];
            group.drawChannel = this.map.draw.drawChannel;

            if (group.rootNode || group.binPath) {
                group.draw(null /*mv*/, null /*mvp*/, null, tiltAngle, (this.tile ? this.tile.texelSize : 1));
                continue;
            }

            if (!(group.jobs.length || group.rootNode)) {
                continue; //TODO: remove empty groups
            }

            const mvp = group.mvp;
            const mv = group.mv;
            const mtmp = mvp; //use it as tmp matrix

            if (useSuperElevation) {
                //mat4.set(renderer.camera.getModelviewFMatrix(), mv);
                mat4.multiply(renderer.camera.getModelviewFMatrix(), this.getWorldMatrix(group.bbox, cameraPos, mtmp), mv);
            } else {
                mat4.multiply(renderer.camera.getModelviewFMatrix(), this.getWorldMatrix(group.bbox, cameraPos, mtmp), mv);
            }

            const proj = renderer.camera.getProjectionFMatrix();
            mat4.multiply(proj, mv, mvp);

            group.draw(mv, mvp, null, tiltAngle, (this.tile ? this.tile.texelSize : 1));

            this.stats.drawnFaces += group.polygons;
            this.stats.drawCalls += group.jobs.length;
        }

        if (this.statsCoutner != this.stats.counter) {
            this.statsCoutner = this.stats.counter;
            this.stats.gpuRenderUsed += this.size;
        }
    }
    return this.ready;
};

//MapGeodataView.prototype.getSize = function() {
    //return this.size;
//};

/* harmony default export */ __webpack_exports__["default"] = (MapGeodataView);


/***/ }),

/***/ "./src/core/map/geodata.js":
/*!*********************************!*\
  !*** ./src/core/map/geodata.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderer_bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/bbox */ "./src/core/renderer/bbox.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");



//import MapGeodataBuilder_ from './geodata-builder';

//get rid of compiler mess
const BBox = _renderer_bbox__WEBPACK_IMPORTED_MODULE_0__["default"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_1__["utils"];
//const MapGeodataBuilder = MapGeodataBuilder_;


const MapGeodata = function(map, url, extraInfo) {
    this.map = map;
    this.stats = map.stats;
    this.mapLoaderUrl  = url;
    this.extraInfo = extraInfo;

    this.bbox = new BBox();
    this.size = 0;
    this.fileSize = 0;
    this.geodata = null;
    this.type = 'geodata';

    this.cacheItem = null;

    this.loadState = 0;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;

    this.map.markDirty();
};


MapGeodata.prototype.kill = function() {
    this.bbox = null;
    this.killGeodata();
};


MapGeodata.prototype.killGeodata = function(killedByCache) {
    if (this.geodata) {
        this.geodata = null;
    }

    if (killedByCache !== true && this.cacheItem != null) {
        this.map.resourcesCache.remove(this.cacheItem);
    }

    //if (this.gpuSubmeshes.length == 0) {
    this.loadState = 0;
    //}

    this.size = 0;
    this.fileSize = 0;
    this.cacheItem = null;
};


MapGeodata.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu, fastParse) {
    const doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.maxGpuUsed);
    doNotLoad = doNotLoad || doNotUseGpu;

    if (this.loadState == 2) { //loaded
        this.map.resourcesCache.updateItem(this.cacheItem);
        return true;
    } else {
        if (this.loadState == 0) {
            if (doNotLoad) {
                //remove from queue
                //if (this.mapLoaderUrl) {
                  //  this.map.loader.remove(this.mapLoaderUrl);
                //}
            } else {
                //not loaded
                //add to loading queue or top position in queue

                /*if (typeof this.mapLoaderUrl !== 'object' || this..mapLoaderUrl.indexOf('tileset.json')) {

                    const geodata = new MapGeodataBuilder(this.map);
                    geodata.load3DTiles(this..mapLoaderUrl, {}, (function(){

                        //TODO:
                    }));

                }
                else*/ if (typeof this.mapLoaderUrl === 'object') { //use geodata directly
                    this.geodata = fastParse ? this.mapLoaderUrl : JSON.stringify(this.mapLoaderUrl);
                    this.loadState = 2;
                    this.size = this.geodata.length ? this.geodata.length : 0;
                    this.cacheItem = this.map.resourcesCache.insert(this.killGeodata.bind(this, true), this.size);
                    this.map.resourcesCache.updateItem(this.cacheItem);
                    return true;
                } else {
                    this.scheduleLoad(priority);
                }
            }
        } else if (this.loadState == 3) { //loadError
            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&
                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {

                this.scheduleLoad(priority);
            }
        }  //else load in progress
    }

    return false;
};


MapGeodata.prototype.scheduleLoad = function(priority) {
    //if (this.mapLoaderUrl == null) {
        //this.mapLoaderUrl = this.map.url.makeUrl(this.tile.surface.meshUrl, {lod:this.tile.id[0], ix:this.tile.id[1], iy:this.tile.id[2] });
    //}

    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), priority, this.extraInfo.tile, 'geodata');
};


MapGeodata.prototype.onLoad = function(url, onLoaded, onError) {
    this.mapLoaderCallLoaded = onLoaded;
    this.mapLoaderCallError = onError;

    this.loadState = 1;

    if (this.map.config.mapGeodataBinaryLoad) {
        this.map.loader.processLoadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, 'geodata');
    } else {
        utils.loadJSON(url, this.onLoaded.bind(this), this.onLoadError.bind(this), true, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
    }

    return;
};


MapGeodata.prototype.onLoadError = function() {
    if (this.map.killed){
        return;
    }

    this.loadState = 3;
    this.loadErrorTime = performance.now();
    this.loadErrorCounter ++;

    //make sure we try to load it again
    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) {
        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);
    }

    this.mapLoaderCallError();
};


MapGeodata.prototype.onLoaded = function(data) {
    if (this.map.killed){
        return;
    }

    let size = data.length || data.byteLength;
    if (!size) {
        size = 0;
    }

    this.size = size;
    this.fileSize = size;

    this.geodata = data;

    this.cacheItem = this.map.resourcesCache.insert(this.killGeodata.bind(this, true), size);

    this.map.markDirty();
    this.loadState = 2;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.mapLoaderCallLoaded();
};

// Returns RAM usage in bytes.
//MapGeodata.prototype.getSize = function () {
  //  return this.size;
//};

//MapGeodata.prototype.getFileSize = function () {
  //  return this.fileSize;
//};

/* harmony default export */ __webpack_exports__["default"] = (MapGeodata);


/***/ }),

/***/ "./src/core/map/interface.js":
/*!***********************************!*\
  !*** ./src/core/map/interface.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _trajectory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trajectory */ "./src/core/map/trajectory.js");
/* harmony import */ var _bound_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bound-layer */ "./src/core/map/bound-layer.js");
/* harmony import */ var _surface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./surface */ "./src/core/map/surface.js");
/* harmony import */ var _position__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./position */ "./src/core/map/position.js");
/* harmony import */ var _geodata_builder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geodata-builder */ "./src/core/map/geodata-builder.js");







//get rid of compiler mess
const MapTrajectory = _trajectory__WEBPACK_IMPORTED_MODULE_0__["default"];
const MapBoundLayer = _bound_layer__WEBPACK_IMPORTED_MODULE_1__["default"];
const MapSurface = _surface__WEBPACK_IMPORTED_MODULE_2__["default"];
const MapPosition = _position__WEBPACK_IMPORTED_MODULE_3__["default"];
const MapGeodataBuilder = _geodata_builder__WEBPACK_IMPORTED_MODULE_4__["default"];


const MapInterface = function(map) {
    this.map = map;
    this.config = map.config;
};


MapInterface.prototype.setPosition = function(position) {
    this.map.setPosition(position);
    return this;
};


MapInterface.prototype.getPosition = function() {
    return this.map.getPosition();
};


MapInterface.prototype.setView = function(view, forceRefresh, posToFixed) {
    this.map.setView(view, forceRefresh, posToFixed);
    return this;
};


MapInterface.prototype.getView = function() {
    return this.map.getView();
};


MapInterface.prototype.getCredits = function() {
    return this.map.getCredits();
};


MapInterface.prototype.getCurrentCredits = function() {
    return this.map.getVisibleCredits();
};


MapInterface.prototype.getCreditInfo = function(creditId) {
    const credit = this.map.getCreditById(creditId);
    return credit ? credit.getInfo() : {};
};


MapInterface.prototype.getViews = function() {
    return this.map.getNamedViews();
};


MapInterface.prototype.getViewInfo = function(viewId) {
    const view = this.map.getNamedView(viewId);
    return view ? view.getInfo() : {};
};


MapInterface.prototype.getBoundLayers = function() {
    return this.map.getBoundLayers();
};


MapInterface.prototype.getBoundLayerInfo = function(layerId) {
    return this.map.getBoundLayerInfo(layerId);
};


MapInterface.prototype.getFreeLayers = function() {
    return this.map.getFreeLayers();
};


MapInterface.prototype.getFreeLayerInfo = function(layerId) {
    const layer = this.map.getFreeLayer(layerId);
    return layer ? layer.getInfo() : {};
};


MapInterface.prototype.getSurfaces = function() {
    return this.map.getSurfaces();
};


MapInterface.prototype.getSurfaceInfo = function(surfaceId) {
    const surface = this.map.getFreeLayer(surfaceId);
    return surface ? surface.getInfo() : {};
};


MapInterface.prototype.getSrses = function() {
    return this.map.getSrses();
};


MapInterface.prototype.getPhysicalSrsId = function() {
    return this.map.referenceFrame.model.physicalSrs.id;
};


MapInterface.prototype.getPublicSrsId = function() {
    return this.map.referenceFrame.model.publicSrs.id;
};


MapInterface.prototype.getNavigationSrsId = function() {
    return this.map.referenceFrame.model.navigationSrs.id;
};


MapInterface.prototype.getSrsInfo = function(srsId) {
    const srs = this.map.getSrs(srsId);
    return srs ? srs.getInfo() : {};
};


MapInterface.prototype.getReferenceFrame = function() {
    return this.map.referenceFrame.getInfo();
};


MapInterface.prototype.addFreeLayer = function(id, options) {
    const layer = new MapSurface(this.map, options, 'free');
    this.map.addFreeLayer(id, layer);
};


MapInterface.prototype.removeFreeLayer = function(id) {
    this.map.removeFreeLayer(id);
};


/* MapInterface.prototype.setFreeLayerOptions = function(id, options) {
    this.map.setFreeLayerOptions(id, options);
};


MapInterface.prototype.getFreeLayerOptions = function(id) {
    return this.map.getFreeLayerOptions(id);
}; */


MapInterface.prototype.addBoundLayer = function(id, options) {
    const layer = new MapBoundLayer(this.map, options, id);
    this.map.addBoundLayer(id, layer);
};


MapInterface.prototype.removeBoundLayer = function(id) {
    this.map.removeBoundLayer(id);
};


/* MapInterface.prototype.setBoundLayerOptions = function(id, options) {
    this.map.setBoundLayerOptions(id, options);
};


MapInterface.prototype.getBoundLayerOptions = function(id) {
    return this.map.setBoundLayerOptions(id);
};*/

MapInterface.prototype.convertPositionViewMode = function(position, mode) {
    return this.map.convert.convertPositionViewMode((new MapPosition(position)), mode);
};


MapInterface.prototype.convertPositionHeightMode = function(position, mode, noPrecisionCheck) {
    return this.map.convert.convertPositionHeightMode((new MapPosition(position)), mode, noPrecisionCheck);
};


MapInterface.prototype.convertCoords = function(sourceSrs, destinationSrs, coords) {
    const srs = this.map.getSrs(sourceSrs);
    const srs2 = this.map.getSrs(destinationSrs);
    if (!srs || !srs2) {
        return null;
    }

    return srs2.convertCoordsFrom(coords, srs);
};


MapInterface.prototype.convertCoordsFromNavToPublic = function(pos, mode, lod) {
    const p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionPublicCoords((new MapPosition(p)), lod);
};


MapInterface.prototype.convertCoordsFromPublicToNav = function(pos, mode, lod) {
    const p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionNavCoordsFromPublic((new MapPosition(p)), lod);
};


MapInterface.prototype.convertCoordsFromPhysToPublic = function(pos, containsSE) {
    if (containsSE && this.map.renderer.useSuperElevation) {
        const p = this.map.renderer.transformPointBySE(pos);
        return this.map.convert.convertCoords(p, 'physical', 'public');
    } else {
        return this.map.convert.convertCoords(pos, 'physical', 'public');
    }
};


MapInterface.prototype.convertCoordsFromNavToPhys = function(pos, mode, lod, includeSE) {
    const p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionPhysCoords((new MapPosition(p)), lod, includeSE);
};


MapInterface.prototype.convertCoordsFromPhysToNav = function(pos, mode, lod, containsSE) {
    return this.map.convert.convertCoordsFromPhysToNav(pos, mode, lod, containsSE);
};


MapInterface.prototype.convertCoordsFromNavToCanvas = function(pos, mode, lod) {
    const p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionCanvasCoords((new MapPosition(p)), lod);
};


MapInterface.prototype.convertCoordsFromPhysToCanvas = function(pos, containsSE) {
    const p = ['obj', pos[0], pos[1], 'fix', pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionCanvasCoords((new MapPosition(p)), null, true, containsSE);
};


MapInterface.prototype.convertCoordsFromNavToCameraSpace = function(pos, mode, lod) {
    const p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionCameraSpaceCoords((new MapPosition(p)), lod);
};


MapInterface.prototype.convertCoordsFromPhysToCameraSpace = function(pos) {
    const p = this.map.camera.position;
    return [pos[0] - p[0], pos[1] - p[1], pos[2] - p[2]];
};


MapInterface.prototype.convertCoordsFromCameraSpaceToPhys = function(pos) {
    const p = this.map.camera.position;
    return [p[0]+pos[0], p[1] + pos[1], p[2] + pos[2]];
};


MapInterface.prototype.transformPhysCoordsBySE = function(pos) {
    return this.map.convert.transformPhysCoordsBySE(pos);
};


MapInterface.prototype.getPositionCanvasCoords = function(position, lod) {
    return this.map.convert.getPositionCanvasCoords(new MapPosition(position), lod);
};


MapInterface.prototype.getPositionCameraCoords = function(position, mode) {
    return this.map.convert.getPositionCameraCoords(new MapPosition(position), mode);
};


MapInterface.prototype.movePositionCoordsTo = function(position, azimuth, distance, skipOrientation) {
    return this.map.convert.movePositionCoordsTo(new MapPosition(position), azimuth, distance, skipOrientation);
};


MapInterface.prototype.getGeodesicLinePoints = function(coords, coords2, height, density) {
    return this.map.convert.getGeodesicLinePoints(coords, coords2, height, density);
};


MapInterface.prototype.getSurfaceHeight = function(coords, precision) {
    return this.map.measure.getSurfaceHeight(coords, this.map.measure.getOptimalHeightLodBySampleSize(coords, precision));
};


MapInterface.prototype.getSurfaceAreaGeometry = function(coords, radius, mode, limit, callback, loadTextures) {
    const res = this.map.measure.getSurfaceAreaGeometry(coords, radius, mode, limit, true, loadTextures);
    //console.log('getSurfaceAreaGeometry');

    if (!res[0]) {
        return this.map.core.once('map-update', this.getSurfaceAreaGeometry.bind(this, coords, radius, mode, limit, callback, loadTextures), 1);
    } else {
        const buffer = res[1], map = this.map;
        let ret = [];

        if (map.tree) {
            map.storedTilesRes = [];
            map.tree.storeGeometry(buffer, buffer.length);
            ret = map.storedTilesRes;
            map.storedTilesRes = [];
        }

        callback(ret);
        return (function(){});
    }
};


MapInterface.prototype.getDistance = function(coords, coords2, includingHeights, usePublic) {
    return this.map.measure.getDistance(coords, coords2, includingHeights, usePublic);
};


MapInterface.prototype.getAzimuthCorrection = function(coords, coords2) {
    return this.map.measure.getAzimuthCorrection(coords, coords2);
};


MapInterface.prototype.getNED = function(coords, onlyMatrix) {
    return this.map.measure.getNewNED(coords, (onlyMatrix === false) ? false : true);
};

MapInterface.prototype.getNED2 = function(coords, onlyMatrix) {
    return this.map.measure.getNewNED2(coords, (onlyMatrix === false) ? false : true);
};


MapInterface.prototype.getCameraInfo = function() {
    const camera = this.map.camera;
    return {
        'projectionMatrix' : camera.camera.projection.slice(),
        'viewMatrix' : camera.camera.modelview.slice(),
        'viewProjectionMatrix' : camera.camera.mvp.slice(),
        'rotationMatrix' : camera.camera.rotationview.slice(),
        'position' : this.map.camera.position.slice(),
        'vector' : this.map.camera.vector.slice(),
        'distance' : this.map.camera.distance,
        'height' : this.map.camera.height
    };
};


MapInterface.prototype.isPointInsideCameraFrustum = function(point) {
    return this.map.camera.camera.pointVisible(point, this.map.camera.position);
};


MapInterface.prototype.isBBoxInsideCameraFrustum = function(bbox) {
    return this.map.camera.camera.bboxVisible({min:bbox[0], max:bbox[1]}, this.map.camera.position);
};


MapInterface.prototype.generateTrajectory = function(p1, p2, options) {
    p1 = new MapPosition(p1);
    p2 = new MapPosition(p2);
    return (new MapTrajectory(this.map, p1, p2, options)).generate();
};


MapInterface.prototype.generatePIHTrajectory = function(position, azimuth, distance, options) {
    const p = new MapPosition(position);
    options['distance'] = distance;
    options['azimuth'] = azimuth;
    options['distanceAzimuth'] = true;
    return (new MapTrajectory(this.map, p, p, options)).generate();
};


MapInterface.prototype.setConfigParams = function(params) {
    this.map.setConfigParams(params);
    return this;
};


MapInterface.prototype.setConfigParam = function(key, value) {
    this.map.setConfigParam(key, value);
    return this;
};


MapInterface.prototype.getConfigParam = function(key) {
    return this.map.getConfigParam(key);
};


MapInterface.prototype.redraw = function() {
    this.map.markDirty();
    return this;
};


MapInterface.prototype.addRenderSlot = function(id, callback, enabled) {
    this.map.renderSlots.addRenderSlot(id, callback, enabled);
    return this;
};


MapInterface.prototype.moveRenderSlotBefore = function(whichId, whereId) {
    this.map.renderSlots.moveRenderSlotBefore(whichId, whereId);
    return this;
};


MapInterface.prototype.moveRenderSlotAfter = function(whichId, whereId) {
    this.map.renderSlots.moveRenderSlotAfter(whichId, whereId);
    return this;
};


MapInterface.prototype.removeRenderSlot = function(id) {
    this.map.renderSlots.removeRenderSlot(id);
    return this;
};


MapInterface.prototype.setRenderSlotEnabled = function(id, state) {
    this.map.renderSlots.setRenderSlotEnabled(id, state);
    return this;
};


MapInterface.prototype.getRenderSlotEnabled = function(id) {
    return this.map.renderSlots.getRenderSlotEnabled(id);
};


MapInterface.prototype.setLoaderSuspended = function(state) {
    this.map.loaderSuspended = state;
    return this;
};


MapInterface.prototype.getLoaderSuspended = function() {
    return this.map.loaderSuspended;
};


MapInterface.prototype.getGpuCache = function() {
    return this.map.gpuCache;
};


MapInterface.prototype.getHitCoords = function(screenX, screenY, mode, lod) {
    return this.map.getHitCoords(screenX, screenY, mode, lod);
};


MapInterface.prototype.getScreenRay = function(screenX, screenY) {
    return this.map.getScreenRay(screenX, screenY);
};


MapInterface.prototype.renderToImage = function() {
    return this.map.renderToImage();
};


MapInterface.prototype.getCurrentGeometry = function() {
    return this.map.getCurrentGeometry();
};


MapInterface.prototype.getStats = function(switches) {
    if (switches) {
        return {
            'maxZoom' : this.map.draw.debug.maxZoom
        };
    }

    let busyWorkers = 0;
    for (let i = 0, li = this.map.geodataProcessors; i < li; i++) {
        if (this.map.geodataProcessors[i].busy) {
            busyWorkers++;
        }
    }

    return {
        'bestMeshTexelSize' : this.map.bestMeshTexelSize,
        'bestGeodataTexelSize' : this.map.bestGeodataTexelSize,
        'downloading' : this.map.loader.downloading.length,
        'lastDownload' : this.map.loader.lastDownloadTime,
        'surfaces' : this.map.tree.surfaceSequence.length,
        'freeLayers' : this.map.freeLayerSequence.length,
        'texelSizeFit' : this.map.texelSizeFit,
        'loadMode' : this.map.config.mapLoadMode,
        'processingTasks' : this.map.processingTasks.length,
        'busyWorkers' : busyWorkers,
        'dirty' : this.map.dirty,
        'drawnTiles' : this.map.stats.drawnTiles,
        'drawnGeodataTiles' : this.map.stats.drawnGeodataTiles,
        'renderTime' : this.map.stats.rendererTime,
        'frameTime' : this.map.stats.frameTime
    };
};


MapInterface.prototype.click = function(screenX, screenY, state) {
    this.map.click(screenX, screenY, state);
};


MapInterface.prototype.hover = function(screenX, screenY, persistent, state) {
    this.map.hover(screenX, screenY, persistent, state);
};

MapInterface.prototype.createGeodata = function() {
    return new MapGeodataBuilder(this.map);
};

MapInterface.prototype.getGeodataGeometry = function(id) {
    return this.map.renderer.geometries[id];
};

MapInterface.prototype.setGeodataSelection = function(selection) {
    this.map.renderer.geodataSelection = selection;
    this.map.markDirty();
    return this;
};

MapInterface.prototype.getGeodataSelection = function() {
    return this.map.renderer.geodataSelection;
};


/* harmony default export */ __webpack_exports__["default"] = (MapInterface);


/***/ }),

/***/ "./src/core/map/loader/loader.js":
/*!***************************************!*\
  !*** ./src/core/map/loader/loader.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ "./src/core/utils/utils.js");



//get rid of compiler mess
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["utils"];


const MapLoader = function(map, maxThreads) {
    this.map = map;
    this.core = map.core;
    this.killed = false;
    this.config = map.config;

    this.maxThreads = maxThreads || 1;
    this.usedThreads = 0;
    this.maxPending = this.maxThreads * 2;
    this.fadeout = 19 / 20;

    this.pending = [[],[]];
    this.channel = 0;

    this.downloading = [];
    this.downloadingTime = [];
    this.workerTask = {};

    this.lastDownloadTime = 0;
    this.downloaded = 0;
    this.processWorker = null;
    this.updateThreadCount();

    if (this.config.mapSeparateLoader) {
        // eslint-disable-next-line
        const worker = __webpack_require__(/*! worker-loader?inline&fallback=false!./worker-main */ "./node_modules/worker-loader/dist/cjs.js?inline&fallback=false!./src/core/map/loader/worker-main.js");

        this.processWorker = new worker;

        this.processWorker.onerror = function(event){
            throw new Error(event.message + ' (' + event.filename + ':' + event.lineno + ')');
        };

        this.processWorker.onmessage = this.onWorkerMessage.bind(this);

        this.processWorker.postMessage({'command':'config', 'data': this.config});
    }

};


MapLoader.prototype.updateThreadCount = function() {
    this.maxThreads = this.config.mapDownloadThreads;
    this.maxPending = Math.max(20, this.maxThreads * 2);
    this.fadeout = (this.maxPending-1) / this.maxPending;
};


MapLoader.prototype.setChannel = function(channel) {
    this.channel = channel;
};


MapLoader.prototype.onWorkerMessage = function(message, direct) {
    if (this.killed) {
        return;
    }

    if (!direct) {
        message = message.data;
    }

    const command = message['command'];

    if (command == 'packed-events') {
        const messages = message['messages'];

        for (let i = 0, li = messages.length; i < li; i++) {
            this.onWorkerMessage(messages[i], true);
        }

        return;
    }

    const path = message['path'];

    const task = this.workerTask[path];
    if (task) {

        switch(command) {

            case 'on-loaded':

                if (task.onLoaded) {

                    switch(task.kind) {
                        case 'direct-texture':
                            task.onLoaded(message['data'], true, message['filesize']);
                            break;

                        case 'direct-mesh':
                            task.onLoaded(message['data'], false, true, message['filesize']);
                            break;

                        case 'texture':
                            task.onLoaded(new Blob([message['data']]));
                            break;

                        default:
                            task.onLoaded(message['data']);
                    }

                }

                break;

            case 'on-error':
                if (task.onError) {
                    task.onError();
                }

                break;
        }

        /*
        if (command == 'on-loaded') {

            if (task.onLoaded) {
                if (task.kind == 'texture') {
                    task.onLoaded(new Blob([message['data']]));
                } else {
                    task.onLoaded(message['data']);
                }
            }

        } else if (command == 'on-error') {

            if (task.onError) {
                task.onError();
            }
        }*/

        delete this.workerTask[path];
    }

};


MapLoader.prototype.processLoadBinary = function(path, onLoaded, onError, responseType, kind, options) {
    const withCredentials = utils.forceCredentials ?  true : ((utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false));

    if (this.processWorker) {

        switch(kind) {
            case 'texture':
                if (this.config.mapAsyncImageDecode) {
                    responseType = 'blob';
                    kind = 'direct-texture';
                }
                break;

            case 'mesh':
                if (this.config.mapParseMeshInWorker) {
                    kind = 'direct-mesh';
                }
                break;
        }

        switch(kind) {
            case 'texture':
            case 'direct-texture':
            case 'mesh':
            case 'pointcloud':
            case 'direct-mesh':
            case 'metadata':
            case 'geodata':
            case 'direct-3dtiles':

                //console.log("kind: " + kind + " " + "path: " + path);

                this.workerTask[path] = { onLoaded: onLoaded, onError: onError, kind: kind };
                this.processWorker.postMessage({'command':'load-binary', 'path': path, 'withCredentials':withCredentials, 'xhrParams':this.map.core.xhrParams, 'responseType':responseType, 'kind': kind, 'options': options});
                break;

            default:
                utils.loadBinary(path, onLoaded, onError, withCredentials, this.map.core.xhrParams, responseType);
        }

    } else {
        if (kind == 'texture' && this.config.mapAsyncImageDecode) {
            responseType = 'blob';
        }

        utils.loadBinary(path, onLoaded, onError, withCredentials, this.map.core.xhrParams, responseType);
    }
};


MapLoader.prototype.load = function(path, downloadFunction, priority, id, kind) {
    let index = this.downloading.indexOf(path);

    if (index != -1) {
        return;
    }

    // update the pending list
    const pending = this.pending[this.channel];

   // put the request to the beginning of the pending list
    index = this.map.searchArrayIndexById(pending, path);
    if (index != -1) {
        pending[index].priority = priority;
    } else {
        pending.unshift({id:path, call: downloadFunction, priority : (priority || 0), tile:id, kind:kind });
    }

    //sort pending list by priority
    let sorted;

    do {
        sorted = true;

        for (let i = 0, li = pending.length - 1; i < li; i++) {
            if (pending[i].priority > pending[i+1].priority) {
                const t = pending[i];
                pending[i] = pending[i+1];
                pending[i+1] = t;

                sorted = false;
            }
        }

    } while(!sorted);

    // keep the pending list at reasonable length
    if (pending.length > this.maxPending) {
        pending.pop();
    }
};


MapLoader.prototype.remove = function(path) {
    const index = this.map.searchArrayIndexById(this.pending[this.channel], path);
    if (index != -1) {
        this.pending[this.channel].splice(index, 1);
    }
};


MapLoader.prototype.onLoaded = function(item) {
    const index = this.downloading.indexOf(item.id);
    const timer = performance.now();
    const stats = this.map.stats;
    const recordStats = this.map.draw.replay.storeLoaded;

    if (recordStats) {
        this.map.draw.replay.loaded.push({
            url : item.id,
            kind : item.kind,
            tile: item.tile,
            priority : item.priority,
            time : timer,
            duration : timer - this.downloadingTime[index],
            interval : timer - this.lastDownloadTime,
            threads : this.downloading.length
        });

        //let a = (timer - this.downloadingTime[index]);
        //if (Number.isNaN(a)) {
            //a = a;
        //}

    }

    this.downloading.splice(index, 1);
    this.downloadingTime.splice(index, 1);
    //this.lastDownloadTime = Date.now();
    this.lastDownloadTime = timer;
    this.usedThreads--;
    this.map.markDirty();
    this.update(true);
    stats.loadedCount++;
    stats.loadLast = timer;
};


MapLoader.prototype.onLoadError = function(item) {
    const index = this.downloading.indexOf(item.id);
    const timer = performance.now();
    const stats = this.map.stats;
    const recordStats = this.map.draw.replay.storeLoaded;

    if (recordStats) {
        this.map.draw.replay.loaded.push({
            url : item.id,
            kind : item.kind,
            tile: item.tile,
            priority : item.priority,
            time : timer,
            duration : timer - this.downloadingTime[index],
            interval : timer - this.lastDownloadTime,
            threads : this.downloading.length
        });
    }

    this.downloading.splice(index, 1);
    this.downloadingTime.splice(index, 1);
    //this.lastDownloadTime = Date.now();
    this.lastDownloadTime = timer;
    this.usedThreads--;
    this.map.markDirty();
    this.update(true);
    stats.loadErrorCount++;
    stats.loadLast = timer;
};


MapLoader.prototype.updateChannel = function(channel) {
    const pending = this.pending[channel];
    this.updateThreadCount();

    //reduce priority for pending stuff
    for (let i = 0, li = pending.length; i < li; i++) {
        pending[i].priority *= this.fadeout;
    }

    const timer = performance.now();

    while (pending.length > 0 && this.usedThreads < this.maxThreads) {
        const item = pending.shift();

        if (this.downloading.indexOf(item.id) == -1 && item.call != null) {
            this.downloading.push(item.id);
            this.downloadingTime.push(timer);
            this.usedThreads++;
            this.downloaded++;

            item.call(item.id, this.onLoaded.bind(this, item), this.onLoadError.bind(this, item));
        }
    }
};


MapLoader.prototype.update = function(skipTick) {
    if (this.map.loaderSuspended || this.core.contextLost) {
        return;
    }

    if (!skipTick && this.processWorker && this.config.mapPackLoaderEvents && this.downloading.length) {
        this.processWorker.postMessage({'command':'tick'});
    }

    for (let i = this.pending.length - 1; i >= 0; i--) {
        if (this.pending[i].length > 0) {
            this.updateChannel(i);
            break;
        }
    }
};


/* harmony default export */ __webpack_exports__["default"] = (MapLoader);


/***/ }),

/***/ "./src/core/map/map.js":
/*!*****************************!*\
  !*** ./src/core/map/map.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _utils_platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/platform */ "./src/core/utils/platform.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./view */ "./src/core/map/view.js");
/* harmony import */ var _surface_tree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./surface-tree */ "./src/core/map/surface-tree.js");
/* harmony import */ var _resource_tree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resource-tree */ "./src/core/map/resource-tree.js");
/* harmony import */ var _srs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./srs */ "./src/core/map/srs.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cache */ "./src/core/map/cache.js");
/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./camera */ "./src/core/map/camera.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./config */ "./src/core/map/config.js");
/* harmony import */ var _convert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./convert */ "./src/core/map/convert.js");
/* harmony import */ var _measure__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./measure */ "./src/core/map/measure.js");
/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./draw */ "./src/core/map/draw.js");
/* harmony import */ var _loader_loader__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./loader/loader */ "./src/core/map/loader/loader.js");
/* harmony import */ var _position__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./position */ "./src/core/map/position.js");
/* harmony import */ var _render_slots__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./render-slots */ "./src/core/map/render-slots.js");
/* harmony import */ var _stats__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./stats */ "./src/core/map/stats.js");
/* harmony import */ var _surface_sequence__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./surface-sequence */ "./src/core/map/surface-sequence.js");
/* harmony import */ var _url__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./url */ "./src/core/map/url.js");




















//import GpuTexture_ from '../renderer/gpu/texture';

//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_1__["utils"];
const platform = _utils_platform__WEBPACK_IMPORTED_MODULE_2__["platform"];
const MapView = _view__WEBPACK_IMPORTED_MODULE_3__["default"];
const MapSurfaceTree = _surface_tree__WEBPACK_IMPORTED_MODULE_4__["default"];
const MapResourceTree = _resource_tree__WEBPACK_IMPORTED_MODULE_5__["default"];
const MapSrs = _srs__WEBPACK_IMPORTED_MODULE_6__["default"];
const MapCache = _cache__WEBPACK_IMPORTED_MODULE_7__["default"];
const MapCamera = _camera__WEBPACK_IMPORTED_MODULE_8__["default"];
const MapConfig = _config__WEBPACK_IMPORTED_MODULE_9__["default"];
const MapConvert = _convert__WEBPACK_IMPORTED_MODULE_10__["default"];
const MapMeasure = _measure__WEBPACK_IMPORTED_MODULE_11__["default"];
const MapDraw = _draw__WEBPACK_IMPORTED_MODULE_12__["default"];
const MapLoader = _loader_loader__WEBPACK_IMPORTED_MODULE_13__["default"];
const MapPosition = _position__WEBPACK_IMPORTED_MODULE_14__["default"];
const MapRenderSlots = _render_slots__WEBPACK_IMPORTED_MODULE_15__["default"];
const MapStats = _stats__WEBPACK_IMPORTED_MODULE_16__["default"];
const MapSurfaceSequence = _surface_sequence__WEBPACK_IMPORTED_MODULE_17__["default"];
const MapUrl = _url__WEBPACK_IMPORTED_MODULE_18__["default"];
//const GpuTexture = GpuTexture_;


const Map = function(core, mapConfig, path, config, configStorage) {
    this.config = config || {};
    this.setConfigParams(config);
    this.setLoaderParams(mapConfig, configStorage);
    this.core = core;
    this.proj4 = this.core.getProj4();
    this.coreConfig = core.coreConfig;
    this.killed = false;
    this.config = config || {};
    this.loaderSuspended = false;

    this.url = new MapUrl(this, path);

    this.position = new MapPosition(['obj', 0, 0, 'fix', 0,  0, 0, 0,  0, 0]);
    this.lastPosition = this.position.clone();

    this.srses = {};
    this.bodies = {};
    this.referenceFrame = {};
    this.credits = {};
    this.creditsByNumber = {};
    this.surfaces = {};
    this.virtualSurfaces = {};
    this.glues = {};
    this.freeLayers = {};
    this.boundLayers = {};
    this.stylesheets = {};
    this.processingTasks = [];
    this.processingTasks2 = [];
    this.geodataProcessors = [];

    this.surfaceSequence = new MapSurfaceSequence(this);

    this.initialView = null;
    this.currentView = new MapView(this, {});
    this.currentViewString = '';
    this.namedViews = {};
    this.viewCounter = 0;
    this.srsReady = false;
    this.surfaceCounter = 0;

    this.freeLayerSequence = [];
    this.freeLayersHaveGeodata = false;

    this.visibleCredits = {
        imagery : {},
        glueImagery : {},
        mapdata : {}
    };

    this.mobile = false;
    this.metanodeBuffer = new Uint8Array(1024);

    this.gpuCache = new MapCache(this, this.config.mapGPUCache*1024*1024);
    this.resourcesCache = new MapCache(this, this.config.mapCache*1024*1024);
    this.metatileCache = new MapCache(this, this.config.mapMetatileCache*1024*1024);

    this.setupMobileMode(this.config.mapMobileMode);
    this.setupCache();

    this.loader = new MapLoader(this, this.config.mapDownloadThreads);

    this.renderer = this.core.renderer;
    this.camera = new MapCamera(this);

    this.stats = new MapStats(this);
    this.resourcesTree = new MapResourceTree(this);

    this.mapConfig = new MapConfig(this, mapConfig);
    this.convert = new MapConvert(this);
    this.measure = new MapMeasure(this);
    this.convert.measure = this.measure;

    this.isGeocent = !this.getNavigationSrs().isProjected();

    this.tree = new MapSurfaceTree(this, false);
    this.mapConfig.afterConfigParsed();

    this.updateCoutner = 0;

    this.dirty = true;
    this.dirtyCountdown = 0;
    this.hitMapDirty = true;
    this.geoHitMapDirty = true;

    this.clickEvent = null;
    this.hoverEvent = null;
    this.hoverFeature = null;
    this.hoverFeatureId = null;
    this.lastHoverFeature = null;
    this.lastHoverFeatureId = null;
    this.hoverFeatureCounter = 0;
    this.hoverFeatureList = [];

    this.draw = new MapDraw(this);
    this.draw.setupDetailDegradation();

    let body = this.referenceFrame.body, c;

    if (body && body.atmosphere) {
        c = body.atmosphere.colorHorizon;
        this.draw.atmoColor = [c[0]/255.0, c[1]/255.0, c[2]/255.0, c[3]/255.0];
        c = body.atmosphere.colorZenith;
        this.draw.atmoColor2 = [c[0]/255.0, c[1]/255.0, c[2]/255.0, c[3]/255.0];
        this.draw.atmoHeight = 50000 * (body.atmosphere.thickness / 100000);
        this.draw.atmoDensity = (body.atmosphere.visibility / 100000) * (100000 / body.atmosphere.thickness);
    } else {
        switch(this.referenceFrame.id) {
            case 'melown2015':
            case 'earth-qsc':
                this.draw.atmoColor = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];
                this.draw.atmoColor2 = [72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0];
                //this.draw.atmoColor3 = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];
                this.draw.atmoHeight = 50000;
                break;

            case 'mars-qsc':
                this.draw.atmoColor = [255.0/255.0, 187.0/255.0, 157.0/255.0, 1.0];
                this.draw.atmoColor2 = [255.0/255.0, 155.0/255.0, 113.0/255.0, 1.0];
                //this.draw.atmoColor3 = [255.0/255.0, 187.0/255.0, 157.0/255.0, 0.5];
                this.draw.atmoHeight = 25000;
                this.draw.atmoDensity = 1.0 / 0.25;
                break;
        }
    }

    this.draw.atmoHeightFactor = this.draw.atmoHeight / 50000;

    this.renderSlots = new MapRenderSlots(this);
    this.renderSlots.addRenderSlot('map', this.drawMap.bind(this), true);
};


Map.prototype.kill = function() {
    this.killed = true;

    if (this.tree) {
        this.tree.kill();
    }

    for (let key in this.freeLayers) {
        const layer = this.freeLayers[key];
        if (layer && layer.tree) {
            layer.tree.kill();
        }
    }

    this.gpuCache.clear();
    this.resourcesCache.clear();
    this.metatileCache.clear();

    if (this.renderer != null) {
        this.renderer.kill();
        this.renderer = null;
    }
};


Map.prototype.setupMobileMode = function() {
    this.mobile = this.config.mapMobileMode;

    if (!this.mobile && this.config.mapMobileModeAutodect) {
        this.mobile = platform.isMobile();
    }

    this.setupCache();
};


Map.prototype.setupCache = function() {
    if (!this.resourcesCache) {
        return;
    }

    let factor = 1 / (this.mobile ? Math.pow(2, Math.max(0,this.config.mapMobileDetailDegradation-1)) : 1);
    const factor2 = 1 / (this.mobile ? Math.pow(2, this.config.mapMobileDetailDegradation) : 1);
    factor = (factor + factor2) * 0.5;
    this.resourcesCache.setMaxCost(this.config.mapCache*1024*1024*factor);
    this.gpuCache.setMaxCost(this.config.mapGPUCache*1024*1024*factor);
    this.metatileCache.setMaxCost(this.config.mapMetatileCache*1024*1024*(factor < 0.8 ? 0.5 : 1));
};


Map.prototype.getCoreInterface = function() {
    return this.core.interface;
};


Map.prototype.getRendererInterface = function() {
    return this.core.interface.getRendererInterface();
};


Map.prototype.setOption = function(/*key, value*/) {
};


Map.prototype.getOption = function(/*key*/) {
};


Map.prototype.addSrs = function(id, srs) {
    this.srses[id] = srs;
};


Map.prototype.getSrs = function(srsId) {
    return this.srses[srsId];
};


Map.prototype.getSrses = function() {
    return this.getMapKeys(this.srses);
};


Map.prototype.addBody = function(id, body) {
    this.bodies[id] = body;
};


Map.prototype.getBody = function(id) {
    return this.bodies[id];
};


Map.prototype.getBodies = function() {
    return this.getMapKeys(this.bodies);
};


Map.prototype.setReferenceFrame = function(referenceFrame) {
    this.referenceFrame = referenceFrame;
};


Map.prototype.addCredit = function(id, credit) {
    this.credits[id] = credit;
    this.creditsByNumber[credit.id] = credit;
    credit.key = id;
};


Map.prototype.getCreditByNumber = function(id) {
    return this.creditsByNumber[id];
};


Map.prototype.getCreditById = function(id) {
    return this.credits[id];
};


Map.prototype.getCredits = function() {
    return this.getMapKeys(this.credits);
};


Map.prototype.getVisibleCredits = function() {
    const imagery = this.visibleCredits.imagery;
    const glueImagery = this.visibleCredits.glueImagery;
    const imageryArray = [];
    const imagerySpecificity = [];
    let i, li, t, sorted;

    for (let key in glueImagery) {
        if (!imagery[key]) {
            imagery[key] = glueImagery[key];
        }
    }

    this.visibleCredits.glueImagery = {};

    for (let key in imagery) {
        imageryArray.push(key);
        imagerySpecificity.push(imagery[key]);
    }

    //sort imagery
    do {
        sorted = true;

        for (i = 0, li = imagerySpecificity.length - 1; i < li; i++) {
            if (imagerySpecificity[i] < imagerySpecificity[i+1]) {
                t = imagerySpecificity[i];
                imagerySpecificity[i] = imagerySpecificity[i+1];
                imagerySpecificity[i+1] = t;
                t = imageryArray[i];
                imageryArray[i] = imageryArray[i+1];
                imageryArray[i+1] = t;
                sorted = false;
            }
        }

    } while(!sorted);

    const mapdata = this.visibleCredits.mapdata;
    const mapdataArray = [];
    const mapdataSpecificity = [];

    for (let key in mapdata) {
        mapdataArray.push(key);
        mapdataSpecificity.push(mapdata[key]);
    }

    //sort imagery
    do {
        sorted = true;

        for (i = 0, li = mapdataSpecificity.length - 1; i < li; i++) {
            if (mapdataSpecificity[i] < mapdataSpecificity[i+1]) {
                t = mapdataSpecificity[i];
                mapdataSpecificity[i] = mapdataSpecificity[i+1];
                mapdataSpecificity[i+1] = t;
                t = mapdataArray[i];
                mapdataArray[i] = mapdataArray[i+1];
                mapdataArray[i+1] = t;
                sorted = false;
            }
        }

    } while(!sorted);

    return {
        '3D' : [],
        'imagery' : imageryArray,
        'mapdata' : mapdataArray
    };
};


Map.prototype.addSurface = function(id, surface) {
    this.surfaces.push(surface);
    surface.index = this.surfaces.length - 1;
};


Map.prototype.getSurface = function(id) {
    return this.searchArrayById(this.surfaces, id);
};


Map.prototype.getSurfaces = function() {
    const keys = [];
    for (let i = 0, li = this.surfaces.length; i < li; i++) {
        keys.push(this.surfaces[i].id);
    }
    return keys;
};


Map.prototype.addGlue = function(id, glue) {
    this.glues[id] = glue;
};


Map.prototype.getGlue = function(id) {
    return this.glues[id];
};


Map.prototype.addBoundLayer = function(id, layer) {
    this.boundLayers[id] = layer;
};


Map.prototype.setBoundLayerOptions = function(id, options) {
    if (this.boundLayers[id]) {
        this.boundLayers[id].setOptions(options);
    }
};


Map.prototype.getBoundLayerOptions = function(id) {
    if (this.boundLayers[id]) {
        return this.boundLayers[id].getOptions();
    }

    return null;
};


Map.prototype.removeBoundLayer = function(id) {
    if (this.boundLayers[id]) {
        this.boundLayers[id].kill();
        this.boundLayers[id] = null;
    }
};


Map.prototype.getBoundLayerByNumber = function(number) {
    const layers = this.boundLayers;
    for (let key in layers) {
        if (layers[key].numberId == number) {
            return layers[key];
        }
    }

    return null;
};


Map.prototype.getBoundLayerById = function(id) {
    return this.boundLayers[id];
};


Map.prototype.getBoundLayers = function() {
    return this.getMapKeys(this.boundLayers);
};


Map.prototype.addFreeLayer = function(id, layer) {
    this.freeLayers[id] = layer;
    this.setView(this.getView());
    this.markDirty();
};


Map.prototype.removeFreeLayer = function(id) {
    if (this.freeLayers[id]) {
        this.freeLayers[id].kill();
        this.freeLayers[id] = null;
        this.setView(this.getView());
        this.markDirty();
    }
};


Map.prototype.setFreeLayerOptions = function(id, options) {
    if (this.freeLayers[id]) {
        this.freeLayers[id].setOptions(options);
    }
};


Map.prototype.getFreeLayerOptions = function(id) {
    if (this.freeLayers[id]) {
        return this.freeLayers[id].getOptions();
    }

    return null;
};


Map.prototype.getFreeLayer = function(id) {
    return this.freeLayers[id];
    //return this.searchArrayById(this.freeLayers, id);
};


Map.prototype.getFreeLayers = function() {
    const keys = [];
    for (let key in this.freeLayers) {
        keys.push(key);
    }
    return keys;
};


Map.prototype.getMapsSrs = function(srs) {
    if (srs == null) {
        return null;
    }

    //is it proj4 string?
    if (srs.indexOf('+proj') != -1) {
        return new MapSrs(this, {'srsDef':srs});
    }

    //search existing srs
    return this.srses[srs];
};


Map.prototype.addNamedView = function(id, view) {
    this.namedViews[id] = view;
};


Map.prototype.getNamedView = function(id) {
    return this.namedViews[id];
};


Map.prototype.getNamedViews = function() {
    return this.getMapKeys(this.namedViews);
};


Map.prototype.setView = function(view, forceRefresh, posToFixed) {
    if (view == null) {
        return;
    }

    if (posToFixed && this.convert) {
        let p = this.getPosition();
        p = this.convert.convertPositionHeightMode(p, 'fix', true);
        this.setPosition(p);
    }

    if (typeof view === 'string') {
        view = view.trim();

        if (view.charAt(0) == '{') {
            try {
                view = JSON.parse(view);
            } catch(e){
                return;
            }
        } else {
            view = this.getNamedView(view);

            if (!view) {
                return;
            }

            //view = JSON.parse(JSON.stringify(view));
            view = view.getInfo();
        }
    }

    //construct view string without options
    let string = {};

    if (view.surfaces) {
        string.surfaces = view.surfaces;
    }

    if (view.freeLayers) {
        string.freeLayers = view.freeLayers;
    }

    string = JSON.stringify(string);

    const renderer = this.renderer;

    //process options
    if (view.options) {
        const se = view.options.superelevation;

        if (se && se[0] && se[1] && se[0].length >=2 && se[1].length >=2) {
            renderer.setSuperElevationState(true);
            renderer.setSuperElevation(se[0][0], se[1][0], se[0][1], se[1][1]);
        } else {
            renderer.setSuperElevationState(false);
        }
    } else {
        renderer.setSuperElevationState(false);
    }

    if (string != this.currentViewString || forceRefresh) {
        this.currentView.parse(view);
        this.currentViewString = string;
        this.viewCounter++;  //this also cause rest of geodata

        renderer.gpu.draw.clearJobHBuffer(); //hotfix - reset hysteresis buffer
    }

    this.surfaceSequence.generateSurfaceSequence();
    this.surfaceSequence.generateBoundLayerSequence();

    this.refreshFreelayesInView();

    this.markDirty();
};


Map.prototype.addStylesheet = function(id, style) {
    this.stylesheets[id] = style;
};


Map.prototype.getStylesheet = function(id) {
    return this.stylesheets[id];
    //return this.searchArrayById(this.stylesheets, id);
};


Map.prototype.getStylesheets = function() {
    const keys = [];

    for (let key in this.stylesheets) {
        keys.push(key);
    }
    return keys;
};


Map.prototype.getStylesheetData = function(id) {
    const stylesheet = this.getStylesheet(id);

    if (stylesheet) {
        return {'url':stylesheet.url, 'data': stylesheet.data};
    }

    return {'url':null, 'data':{}};
};


Map.prototype.setStylesheetData = function(id, data) {
    const stylesheet = this.getStylesheet(id);

    //if (stylesheet) {
      //  stylesheet.data = data;
    //}

    this.renderer.gpu.draw.clearJobHBuffer();

    if (stylesheet) {
        if (data) {
            stylesheet.setData(data);
        }

        for (let key in this.freeLayers) {
            const freeLayer = this.getFreeLayer(key);
            if (freeLayer && freeLayer.geodata && freeLayer.stylesheet == stylesheet) {

                if (freeLayer.geodataProcessor) {
                    freeLayer.geodataProcessor.setStylesheet(freeLayer.stylesheet);
                }

                freeLayer.geodataCounter++;
            }
        }
    }

    this.markDirty();

    //TODO: reset geodatview in free layers
};


Map.prototype.getView = function() {
    return this.currentView.getInfo();
};


Map.prototype.refreshFreelayesInView = function() {
    const freeLayers = this.currentView.freeLayers;
    this.freeLayerSequence = [];

    for (let key in freeLayers) {
        const freeLayer = this.getFreeLayer(key);

        if (freeLayer) {

            freeLayer.zFactor = freeLayers[key]['depthOffset'];
            freeLayer.maxLod = freeLayers[key]['maxLod'];

            this.freeLayerSequence.push(freeLayer);

            if (freeLayers[key]['style']) {
                freeLayer.setStyle(freeLayers[key]['style']);
            } else {
                freeLayer.setStyle(freeLayer.originalStyle);
            }

            //TODO: generate bound layer seqence for
        }
    }
};

Map.prototype.refreshView = function() {
    this.viewCounter++;
    this.surfaceSequence.generateSurfaceSequence();
    this.surfaceSequence.generateBoundLayerSequence();
    this.refreshFreelayesInView();
    this.markDirty();
};


Map.prototype.searchArrayIndexById = function(array, id) {
    for (let i = 0, li = array.length; i < li; i++) {
        if (array[i].id == id) {
            return i;
        }
    }

    return -1;
};


Map.prototype.searchArrayById = function(array, id) {
    for (let i = 0, li = array.length; i < li; i++) {
        if (array[i].id == id) {
            return array[i];
        }
    }

    return null;
};


Map.prototype.searchMapByInnerId = function(map, id) {
    for (let key in map) {
        if (map[key].id == id) {
            return map[key];
        }
    }

    return null;
};


Map.prototype.getMapKeys = function(map) {
    const keys = [];
    for (let key in map) {
        keys.push(key);
    }

    return keys;
};


Map.prototype.getMapIds = function(map) {
    const keys = [];
    for (let key in map) {
        keys.push(key.id);
    }

    return keys;
};


Map.prototype.setPosition = function(pos) {
    this.position = new MapPosition(pos);
    this.markDirty();
};


Map.prototype.isReferenceFrameReady = function() {
    return this.referenceFrame.model.physicalSrs.isReady() &&
           this.referenceFrame.model.publicSrs.isReady() &&
           this.referenceFrame.model.navigationSrs.isReady();
};


Map.prototype.getPhysicalSrs = function() {
    return this.referenceFrame.model.physicalSrs;
};


Map.prototype.getPublicSrs = function() {
    return this.referenceFrame.model.publicSrs;
};


Map.prototype.getNavigationSrs = function() {
    return this.referenceFrame.model.navigationSrs;
};


Map.prototype.getPosition = function() {
    return this.position.clone();
};


Map.prototype.setLoaderParams = function(mapConfig, configStorage) {
    const sources = [];

    if (mapConfig && mapConfig['browserOptions']) {
        sources.push(mapConfig['browserOptions']);
    }

    if (configStorage) {
        sources.push(configStorage);
    }

    for (let i = 0, li = sources.length; i < li; i++) {
        const source = sources[i];
        for (let key in source) {
            switch(key) {
                case 'mapSeparateLoader':
                case 'mapGeodataBinaryLoad':
                case 'mapPackLoaderEvents':
                case 'mapParseMeshInWorker':
                case 'mapPackGeodataEvents':
                case 'mapForceCredentials':
                    this.setConfigParam(key, source[key]);
                    break;
            }
        }
    }
};


Map.prototype.setConfigParams = function(params) {
    if (typeof params === 'object' && params !== null) {
        for (let key in params) {
            this.setConfigParam(key, params[key]);
        }
    }
};


Map.prototype.setConfigParam = function(key, value) {
    switch (key) {
    case 'map':                           this.config.map = utils.validateString(value, null); break;
    case 'mapCache':                      this.config.mapCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 900); this.setupCache(); break;
    case 'mapGPUCache':                   this.config.mapGPUCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 360); this.setupCache(); break;
    case 'mapMetatileCache':              this.config.mapMetatileCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 60); this.setupCache(); break;
    case 'mapTexelSizeFit':               this.config.mapTexelSizeFit = utils.validateNumber(value, 0.0001, Number.MAXINTEGER, 1.1); break;
    case 'mapDownloadThreads':            this.config.mapDownloadThreads = utils.validateNumber(value, 1, Number.MAXINTEGER, 6); break;
    case 'mapMaxProcessingTime':          this.config.mapMaxProcessingTime = utils.validateNumber(value, 1, Number.MAXINTEGER, 1000/20); break;
    case 'mapMaxGeodataProcessingTime':   this.config.mapMaxGeodataProcessingTime = utils.validateNumber(value, 1, Number.MAXINTEGER, 10); break;
    case 'mapMobileMode':                 this.config.mapMobileMode = utils.validateBool(value, false); this.setupMobileMode(); break;
    case 'mapMobileModeAutodect':         this.config.mapMobileModeAutodect = utils.validateBool(value, false); break;
    case 'mapMobileDetailDegradation':    this.config.mapMobileDetailDegradation = utils.validateNumber(value, 1, Number.MAXINTEGER, 2); break;
    case 'mapNavSamplesPerViewExtent':    this.config.mapNavSamplesPerViewExtent = utils.validateNumber(value, 0.00000000001, Number.MAXINTEGER, 4); break;
    case 'mapFog':                        this.config.mapFog = utils.validateBool(value, false); if(this.draw){ this.draw.debug.drawFog = this.config.mapFog; this.dirty = true; } break;
    case 'mapFlatshade':                  this.config.mapFlatshade = utils.validateBool(value, false); if(this.draw){ this.draw.debug.drawWireframe = this.config.mapFlatshade ? 3 : 0; this.dirty = true; } break;
    case 'mapIgnoreNavtiles':             this.config.mapIgnoreNavtiles = utils.validateBool(value, false); break;
    case 'mapAllowHires':                 this.config.mapAllowHires = utils.validateBool(value, true); break;
    case 'mapAllowLowres':                this.config.mapAllowLowres = utils.validateBool(value, true); break;
    case 'mapAllowSmartSwitching':        this.config.mapAllowSmartSwitching = utils.validateBool(value, true); break;
    case 'mapDisableCulling':             this.config.mapDisableCulling = utils.validateBool(value, false); break;
    case 'mapPreciseCulling':             this.config.mapPreciseCulling = utils.validateBool(value, false); break;
    case 'mapHeightLodBlend':             this.config.mapHeightLodBlend = utils.validateBool(value, true); break;
    case 'mapHeightNodeBlend':            this.config.mapHeightNodeBlend = utils.validateBool(value, true); break;
    case 'mapBasicTileSequence':          this.config.mapBasicTileSequence = utils.validateBool(value, true); break;
    case 'mapSmartNodeParsing':           this.config.mapSmartNodeParsing = utils.validateBool(value, true); break;
    case 'mapStoreLoadStats':             this.config.mapStoreLoadStats = utils.validateBool(value, true);  if (this.draw && this.draw.replay) this.draw.replay.storeLoaded = this.config.mapStoreLoadStats; break;
    case 'mapXhrImageLoad':               this.config.mapXhrImageLoad = utils.validateBool(value, false); break;
    case 'mapLoadMode':                   this.config.mapLoadMode = utils.validateString(value, 'topdown'); break;
    case 'mapGeodataLoadMode':            this.config.mapGeodataLoadMode = utils.validateString(value, 'fit'); break;
    case 'mapGridMode':                   this.config.mapGridMode = utils.validateString(value, 'linear'); break;
    case 'mapGridSurrogatez':             this.config.mapGridSurrogatez = utils.validateBool(value, false); break;
    case 'mapGridUnderSurface':           this.config.mapGridUnderSurface = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, 0); break;
    case 'mapGridTextureLevel':           this.config.mapGridTextureLevel = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, -1); break;
    case 'mapGridTextureLayer':           this.config.mapGridTextureLayer = utils.validateString(value, ''); break;
    case 'mapPreciseBBoxTest':            this.config.mapPreciseBBoxTest = utils.validateBool(value, true); break;
    case 'mapPreciseDistanceTest':        this.config.mapPreciseDistanceTest = utils.validateBool(value, false); break;
    case 'mapHeightfiledWhenUnloaded':    this.config.mapHeightfiledWhenUnloaded = utils.validateBool(value, false); break;
    case 'mapForceMetatileV3':            this.config.mapForceMetatileV3 = utils.validateBool(value, false); break;
    case 'mapVirtualSurfaces':            this.config.mapVirtualSurfaces = utils.validateBool(value, true); break;
    case 'mapDegradeHorizon':             this.config.mapDegradeHorizon = utils.validateBool(value, true); break;
    case 'mapDegradeHorizonParams':       this.config.mapDegradeHorizonParams = utils.validateNumberArray(value, 4, [0,1,1,1], [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], [1, 3000, 15000, 7000]); break;
    case 'mapRefreshCycles':              this.config.mapRefreshCycles = utils.validateNumber(value, 0, Number.MAXINTEGER, 3); break;
    case 'mapDefaultFont':                this.config.mapDefaultFont = utils.validateString(value, ''); break;
    case 'mapMetricUnits':                this.config.mapMetricUnits = utils.validateBool(value, true); break;
    case 'mapLanguage':                   this.config.mapLanguage = utils.validateString(value, 'en'); break;
    case 'mapNoTextures':                 this.config.mapNoTextures = this.config.mapDisableCulling = utils.validateBool(value, false); break;
    case 'mapForceFrameTime':             this.config.mapForceFrameTime = utils.validateNumber(value, -1, Number.MAXINTEGER, 0); break;
    case 'mapForcePipeline':              this.config.mapForcePipeline = utils.validateNumber(value, 0, Number.MAXINTEGER, 0); break;
    case 'mapFeatureGridCells':           this.config.mapFeatureGridCells = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, 0); break;
    case 'mapFeaturesPerSquareInch':      this.config.mapFeaturesPerSquareInch = utils.validateNumber(value, 0.000001, Number.MAXINTEGER, 0); break;
    case 'mapFeaturesSortByTop':          this.config.mapFeaturesSortByTop = utils.validateBool(value, false); break;
    case 'mapFeaturesReduceParams':       this.config.mapFeaturesReduceParams = value; break;
    case 'mapLogGeodataStyles':           this.config.mapLogGeodataStyles = utils.validateBool(value, true); break;
    case 'map16bitMeshes':                this.config.map16bitMeshes = utils.validateBool(value, false); break;
    case 'mapOnlyOneUVs':                 this.config.mapOnlyOneUVs = utils.validateBool(value, false); break;
    case 'mapIndexBuffers':               this.config.mapIndexBuffers = utils.validateBool(value, false); break;
    case 'mapSoftViewSwitch':             this.config.mapSoftViewSwitch = utils.validateBool(value, true); break;
    case 'mapAsyncImageDecode':           this.config.mapAsyncImageDecode = (utils.validateBool(value, false) && (typeof createImageBitmap !== 'undefined')) ? true : false; break;
    case 'mapFeatureStickMode':           this.config.mapFeatureStickMode = utils.validateNumberArray(value, 2, [0,1], [Number.MAX_VALUE, Number.MAX_VALUE], [0, 1]); break;
    case 'mapSeparateLoader':             this.config.mapSeparateLoader = utils.validateBool(value, true); break;
    case 'mapGeodataBinaryLoad':          this.config.mapGeodataBinaryLoad = utils.validateBool(value, true); break;
    case 'mapPackLoaderEvents':           this.config.mapPackLoaderEvents = utils.validateBool(value, true); break;
    case 'mapParseMeshInWorker':          this.config.mapParseMeshInWorker = utils.validateBool(value, true); break;
    case 'mapPackGeodataEvents':          this.config.mapPackGeodataEvents = utils.validateBool(value, true); break;
    case 'mapSortHysteresis':             this.config.mapSortHysteresis = utils.validateBool(value, false); break;
    case 'mapHysteresisWait':             this.config.mapHysteresisWait = utils.validateNumber(value, 0, Number.MAXINTEGER, 0); break;
    case 'mapBenevolentMargins':          this.config.mapBenevolentMargins = utils.validateBool(value, false); break;
    case 'mapCheckTextureSize':           this.config.mapCheckTextureSize = utils.validateBool(value, false); break;
    case 'mapTraverseToMeshNode':         this.config.mapTraverseToMeshNode = utils.validateBool(value, true); break;
    case 'mapNormalizeOctantTexelSize':   this.config.mapNormalizeOctantTexelSize = utils.validateBool(value, true); break;
    case 'mapDMapSize':                   this.config.mapDMapSize = utils.validateNumber(value, 16, Number.MAXINTEGER, 512); break;
    case 'mapDMapMode':                   this.config.mapDMapMode = utils.validateNumber(value, 1, Number.MAXINTEGER, 1); break;
    case 'mapSplitSpace':                 this.config.mapSplitSpace = value; break;
    case 'mapForceCredentials':           this.config.mapForceCredentials = utils.validateBool(value, false); utils.forceCredentials = this.config.mapForceCredentials; break;
    case 'mapNoTiltConstraint':           this.config.mapNoTiltConstraint = utils.validateBool(value, false); break;
    case 'mario':                         this.config.mario = utils.validateBool(value, true); break;
    case 'mapFeaturesReduceMode':
        value = utils.validateString(value, 'scr-count4');
        if (value == 'auto') value = 'scr-count2';
        if (value == 'legacy') value = 'scr-count2';
        if (value == 'gridcells') value = 'scr-count4';
        if (value == 'singlepass') value = 'scr-count5';
        if (value == 'margin') value = 'scr-count6';
        //if (value == 'margin') value = 'scr-count7';
        this.config.mapFeaturesReduceMode = value;
        break;

    }
};


Map.prototype.getConfigParam = function(key) {
    return this.config[key];

    /*switch (key) {
    case 'map':                           return this.config.map;
    case 'mapCache':                      return this.config.mapCache;
    case 'mapGPUCache':                   return this.config.mapGPUCache;
    case 'mapMetatileCache':              return this.config.mapMetatileCache;
    case 'mapTexelSizeFit':               return this.config.mapTexelSizeFit;
    case 'mapDownloadThreads':            return this.config.mapDownloadThreads;
    case 'mapMaxProcessingTime':          return this.config.mapMaxProcessingTime;
    case 'mapMaxGeodataProcessingTime':   return this.config.mapMaxGeodataProcessingTime;
    case 'mapMobileMode':                 return this.config.mapMobileMode;
    case 'mapMobileModeAutodect':         return this.config.mapMobileModeAutodect;
    case 'mapMobileDetailDegradation':    return this.config.mapMobileDetailDegradation;
    case 'mapNavSamplesPerViewExtent':    return this.config.mapNavSamplesPerViewExtent;
    case 'mapFog':                        return this.config.mapFog;
    case 'mapFlatshade':                  return this.config.mapFlatshade;
    case 'mapIgnoreNavtiles':             return this.config.mapIgnoreNavtiles;
    case 'mapAllowHires':                 return this.config.mapAllowHires;
    case 'mapAllowLowres':                return this.config.mapAllowLowres;
    case 'mapAllowSmartSwitching':        return this.config.mapAllowSmartSwitching;
    case 'mapDisableCulling':             return this.config.mapDisableCulling;
    case 'mapPreciseCulling':             return this.config.mapPreciseCulling;
    case 'mapHeightLodBlend':             return this.config.mapHeightLodBlend;
    case 'mapHeightNodeBlend':            return this.config.mapHeightNodeBlend;
    case 'mapBasicTileSequence':          return this.config.mapBasicTileSequence;
    case 'mapSmartNodeParsing':           return this.config.mapSmartNodeParsing;
    case 'mapStoreLoadStats':             return this.config.mapStoreLoadStats;
    case 'mapXhrImageLoad':               return this.config.mapXhrImageLoad;
    case 'mapLoadMode':                   return this.config.mapLoadMode;
    case 'mapGeodataLoadMode':            return this.config.mapGeodataLoadMode;
    case 'mapGridMode':                   return this.config.mapGridMode;
    case 'mapGridSurrogatez':             return this.config.mapGridSurrogatez;
    case 'mapGridUnderSurface':           return this.config.mapGridUnderSurface;
    case 'mapGridTextureLevel':           return this.config.mapGridTextureLevel;
    case 'mapGridTextureLayer':           return this.config.mapGridTextureLayer;
    case 'mapPreciseBBoxTest':            return this.config.mapPreciseBBoxTest;
    case 'mapPreciseDistanceTest':        return this.config.mapPreciseDistanceTest;
    case 'mapHeightfiledWhenUnloaded':    return this.config.mapHeightfiledWhenUnloaded;
    case 'mapForceMetatileV3':            return this.config.mapForceMetatileV3;
    case 'mapVirtualSurfaces':            return this.config.mapVirtualSurfaces;
    case 'mapDegradeHorizon':             return this.config.mapDegradeHorizon;
    case 'mapDegradeHorizonParams':       return this.config.mapDegradeHorizonParams;
    case 'mapRefreshCycles':              return this.config.mapRefreshCycles;
    case 'mapDefaultFont':                return this.config.mapDefaultFont;
    case 'mapMetricUnits':                return this.config.mapMetricUnits;
    case 'mapLanguage':                   return this.config.mapLanguage;
    case 'mapNoTextures':                 return this.config.mapNoTextures;
    case 'mapForceFrameTime':             return this.config.mapForceFrameTime;
    case 'mapForcePipeline':              return this.config.mapForcePipeline;
    case 'mapFeatureGridCells':           return this.config.mapFeatureGridCells;
    case 'mapFeaturesPerSquareInch':      return this.config.mapFeaturesPerSquareInch;
    case 'mapFeaturesSortByTop':          return this.config.mapFeaturesSortByTop;
    case 'mapFeaturesReduceMode':         return this.config.mapFeaturesReduceMode;
    case 'mapFeaturesReduceParams':       return this.config.mapFeaturesReduceParams;
    case 'mapLogGeodataStyles':           return this.config.mapLogGeodataStyles;
    case 'map16bitMeshes':                return this.config.map16bitMeshes;
    case 'mapOnlyOneUVs':                 return this.config.mapOnlyOneUVs;
    case 'mapIndexBuffers':               return this.config.mapIndexBuffers;
    case 'mapSoftViewSwitch':             return this.config.mapSoftViewSwitch;
    case 'mapAsyncImageDecode':           return this.config.mapAsyncImageDecode;
    case 'mapFeatureStickMode':           return this.config.mapFeatureStickMode;
    case 'mapSeparateLoader':             return this.config.mapSeparateLoader;
    case 'mapGeodataBinaryLoad':          return this.config.mapGeodataBinaryLoad;
    case 'mapPackLoaderEvents':           return this.config.mapPackLoaderEvents;
    case 'mapParseMeshInWorker':          return this.config.mapParseMeshInWorker;
    case 'mapPackGeodataEvents':          return this.config.mapPackGeodataEvents;
    case 'mapSortHysteresis':             return this.config.mapSortHysteresis;
    case 'mapHysteresisWait':             return this.config.mapHysteresisWait;
    case 'mapBenevolentMargins':          return this.config.mapBenevolentMargins;
    case 'mapDMapSize':                   return this.config.mapDMapSize;
    case 'mapDMapMode':                   return this.config.mapDMapMode;
    case 'mario':                         return this.config.mario;
    }*/
};


Map.prototype.click = function(screenX, screenY, state) {
    this.clickEvent = [screenX, screenY, state];
};


Map.prototype.hover = function(screenX, screenY, persistent, state) {
    this.hoverEvent = [screenX, screenY, persistent, state];
};


Map.prototype.markDirty = function() {
    this.dirty = true;
    this.hitMapDirty = true;
    this.geoHitMapDirty = true;
};


Map.prototype.getScreenRay = function(screenX, screenY) {
    return this.renderer.getScreenRay(screenX, screenY);
};


Map.prototype.renderToImage = function() {
    //const renderer = this.renderer;
    const canvas = this.renderer.gpu.canvas;
    const w = canvas.width;
    const h = canvas.height;
    const w2 = utils.fitToPowerOfTwo(w);
    const h2 = utils.fitToPowerOfTwo(h);

    let data = new Uint8Array( w2 * h2 * 4 );

    //const texture = new GpuTexture(this.renderer.gpu);
    //texture.createFromData(w2, h2, data);
    //texture.createFramebuffer(w2, h2);

    const texture = this.renderer.gpu.createTexture({ data: data, width: w2, height: h2, framebuffer: true});

    this.draw.drawToTexture(texture);

    data = texture.readFramebufferPixels(0, 0, w, h);

    texture.kill();

    //flip vertically
    const data2 = new Uint8Array( w * h * 4 );
    for (let y = 0; y < h; y++) {
        let index = y * w * 4;
        let index2 = (h - y - 1) * w * 4;

        for (let x = 0; x < w; x++) {
            data2[index2] = data[index];
            data2[index2+1] = data[index+1];
            data2[index2+2] = data[index+2];
            data2[index2+3] = data[index+3];
            index += 4;
            index2 += 4;
        }
    }

    return { 'width': w, 'height': h, 'data': data2};
};


Map.prototype.getScreenDepth = function(screenX, screenY, useFallback) {

    if (useFallback) {

        const cameraPos = this.camera.position;
        let ray = this.renderer.getScreenRay(screenX, screenY);

        if (this.getNavigationSrs().isProjected()) { //plane fallback
            const planePos = [0,0,Math.min(-1000,this.referenceFrame.getGlobalHeightRange()[0])];
            const planeNormal = [0,0,1];

            const d = vec3.dot(planeNormal, ray); //minification is wrong there
            const a = [planePos[0] - cameraPos[0], planePos[1] - cameraPos[1], planePos[2] - cameraPos[2]];
            let t = vec3.dot(a, planeNormal) / d;

            if (t >= 0) {
                return [true, t];
            } else {
                return [false, 1];
            }

        } else { //elipsoid fallback
            const navigationSrsInfo = this.getNavigationSrs().getSrsInfo();
            const planetRadius = navigationSrsInfo['b'] + this.referenceFrame.getGlobalHeightRange()[0];

            const offset = [cameraPos[0], cameraPos[1], cameraPos[2]];
            const a = vec3.dot(ray, ray); //minification is wrong there
            const b = 2 * vec3.dot(ray, offset);
            const c = vec3.dot(offset, offset) - planetRadius * planetRadius;
            let d = b * b - 4 * a * c;

            if (d > 0) {
                d = Math.sqrt(d);
                const t1 = (-b - d) / (2*a);
                const t2 = (-b + d) / (2*a);
                const t = (t1 < t2) ? t1 : t2;

                return [true, t];
            } else {
                return [false, 1];
            }
        }

    } else {

        if (this.hitMapDirty) {
            const tmp1 = this.draw.ndcToScreenPixel;

            this.draw.drawHitmap();

            this.draw.ndcToScreenPixel = tmp1;

            const width = this.renderer.curSize[0], height = this.renderer.curSize[1];

            const m = new Float32Array(16);
            m[0] = 2.0/width; m[1] = 0; m[2] = 0; m[3] = 0;
            m[4] = 0; m[5] = -2.0/height; m[6] = 0; m[7] = 0;
            m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
            m[12] = -width*0.5*m[0]; m[13] = -height*0.5*m[5]; m[14] = 0; m[15] = 1;

            this.renderer.imageProjectionMatrix = m;
            this.renderer.camera.update();
        }

        const res = this.renderer.getDepth(screenX, screenY);
        return res;
    }
};


Map.prototype.getHitCoords = function(screenX, screenY, mode, lod) {
    if (this.hitMapDirty) {
        this.draw.drawHitmap();
    }

    const cameraSpaceCoords = this.renderer.hitTest(screenX, screenY);
    const cameraPos = this.camera.position;

    let fallbackUsed = false;
    let worldPos;

    const ray = cameraSpaceCoords[4];

    if (this.getNavigationSrs().isProjected()) { //plane fallback
        const planePos = [0,0,Math.min(-1000,this.referenceFrame.getGlobalHeightRange()[0])];
        const planeNormal = [0,0,1];

        const d = vec3.dot(planeNormal, ray); //minification is wrong there
        //if (d > 1e-6) {
        const a = [planePos[0] - cameraPos[0], planePos[1] - cameraPos[1], planePos[2] - cameraPos[2]];
        const t = vec3.dot(a, planeNormal) / d;

            //const t = (vec3.dot(cameraPos, planeNormal) + (-500)) / d;
        if (t >= 0) {
            if (!cameraSpaceCoords[3] || t < cameraSpaceCoords[5]) {
                worldPos = [ (ray[0] * t) + cameraPos[0],
                    (ray[1] * t) + cameraPos[1],
                    (ray[2] * t) + cameraPos[2] ];

                fallbackUsed = true;
            }
        }
        //}

    } else /*if (false)*/ { //elipsoid fallback
        const navigationSrsInfo = this.getNavigationSrs().getSrsInfo();
        const planetRadius = navigationSrsInfo['b'] + this.referenceFrame.getGlobalHeightRange()[0];

        const offset = [cameraPos[0], cameraPos[1], cameraPos[2]];
        const a = vec3.dot(ray, ray); //minification is wrong there
        const b = 2 * vec3.dot(ray, offset);
        const c = vec3.dot(offset, offset) - planetRadius * planetRadius;
        let d = b * b - 4 * a * c;

        if (d > 0) {
            d = Math.sqrt(d);
            const t1 = (-b - d) / (2*a);
            const t2 = (-b + d) / (2*a);
            const t = (t1 < t2) ? t1 : t2;

            //console.log("hit: " + t + ",   " + cameraSpaceCoords[5]);

            if (!cameraSpaceCoords[3] || t < cameraSpaceCoords[5]) {
                worldPos = [ (ray[0] * t) + cameraPos[0],
                    (ray[1] * t) + cameraPos[1],
                    (ray[2] * t) + cameraPos[2] ];

                fallbackUsed = true;
            }
        }
    }

    if (!cameraSpaceCoords[3] && !fallbackUsed) {
        return null;
    }

    if (!fallbackUsed) {
        worldPos = [ cameraSpaceCoords[0] + cameraPos[0],
            cameraSpaceCoords[1] + cameraPos[1],
            cameraSpaceCoords[2] + cameraPos[2] ];
    }

    const navCoords = this.convert.convertCoords(worldPos, 'physical', 'navigation');

    if (this.renderer.useSuperElevation) {
        navCoords[2] = this.renderer.getUnsuperElevatedHeight(navCoords[2]);
    }

    if (mode == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(navCoords, 100, this.config.mapNavSamplesPerViewExtent);
        const surfaceHeight = this.measure.getSurfaceHeight(navCoords, lod);
        navCoords[2] -= surfaceHeight[0];
    }

    return navCoords;
};


Map.prototype.hitTestGeoLayers = function(screenX, screenY, mode) {
    if (this.geoHitMapDirty) {
        if (this.freeLayersHaveGeodata) {
            this.draw.drawGeodataHitmap();
        }
    }

    if (!this.freeLayersHaveGeodata) {
        this.lastHoverFeature = null;
        this.lastHoverFeatureId = null;
        this.hoverFeature = null;
        this.hoverFeatureId = null;

        return [null, false, []];
    }

    let res = this.renderer.hitTestGeoLayers(screenX, screenY);
    let relatedEvents, elementIndex;

    if (res[0]) { //do we hit something?
        //console.log(JSON.stringify([id, JSON.stringify(this.hoverFeatureList[id])]));

        const id = (res[1]) + (res[2]<<8);

        const feature = this.hoverFeatureList[id];

        if (!feature) {
            return [null, false, [], elementIndex];
        }

        if (feature[6]) { //advanced hit feature?
            res = this.renderer.hitTestGeoLayers(screenX, screenY, true);

            if (res[0]) { //do we hit something?
                elementIndex = (res[1]) + (res[2]<<8);
            }
        }

        if (mode == 'hover') {
            this.lastHoverFeature = this.hoverFeature;
            this.lastHoverFeatureId = this.hoverFeatureId;

            if (feature && feature[3]) {
                this.hoverFeature = feature;
                this.hoverFeatureId = (feature != null) ? feature[0]['#id'] : null;
            } else {
                this.hoverFeature = null;
                this.hoverFeatureId = null;
            }

            relatedEvents = [];

            if (this.hoverFeatureId != this.lastHoverFeatureId) {
                if (this.lastHoverFeatureId != null) {
                    relatedEvents.push(['leave', this.lastHoverFeature, this.lastHoverFeatureId]);
                }

                if (this.hoverFeatureId != null) {
                    relatedEvents.push(['enter', this.hoverFeature, this.hoverFeatureId]);
                }

                this.dirty = true;
            }

            if (this.hoverFeature != null && this.hoverFeature[3]) {
                return [this.hoverFeature, true, relatedEvents, elementIndex];
            } else {
                return [null, false, relatedEvents, elementIndex];
            }
        }

        if (mode == 'click') {
            if (feature != null && feature[2]) {
                return [feature, true, [], elementIndex];
            } else {
                return [null, false, [], elementIndex];
            }
        }
    } else {
        relatedEvents = [];

        if (mode == 'hover') {
            this.lastHoverFeature = this.hoverFeature;
            this.lastHoverFeatureId = this.hoverFeatureId;
            this.hoverFeature = null;
            this.hoverFeatureId = null;

            if (this.lastHoverFeatureId != null) {
                if (this.lastHoverFeatureId != null) {
                    relatedEvents.push(['leave', this.lastHoverFeature, this.lastHoverFeatureId]);
                }

                this.dirty = true;
            }
        }

        return [null, false, relatedEvents, elementIndex];
    }
};

Map.prototype.getCurrentGeometry = function() {
    if (this.draw.tree.surfaceSequence.length > 0) {
        this.draw.tree.draw(true);
        const res = this.storedTilesRes;
        this.storedTilesRes = [];
        return res;
    }
};

Map.prototype.applyCredits = function(tile) {
    let value, value2;
    for (let key in tile.imageryCredits) {
        value = tile.imageryCredits[key];
        value2 = this.visibleCredits.imagery[key];

        if (value2) {
            this.visibleCredits.imagery[key] = value > value2 ? value : value2;
        } else {
            this.visibleCredits.imagery[key] = value;
        }
    }
    for (let key in tile.glueImageryCredits) {
        value = tile.glueImageryCredits[key];
        value2 = this.visibleCredits.imagery[key];

        if (value2) {
            this.visibleCredits.glueImagery[key] = value > value2 ? value : value2;
        } else {
            this.visibleCredits.glueImagery[key] = value;
        }
    }
    for (let key in tile.mapdataCredits) {
        value = tile.mapdataCredits[key];
        value2 = this.visibleCredits.mapdata[key];

        if (value2) {
            this.visibleCredits.mapdata[key] = value > value2 ? value : value2;
        } else {
            this.visibleCredits.mapdata[key] = value;
        }
    }

    /*if (this.drawBBoxes) {
        console.log(JSON.stringify(tile.id) + " " + JSON.stringify(this.visibleCredits));
    }*/
};


Map.prototype.drawMap = function() {
    this.draw.drawMap(null);
};


Map.prototype.processProcessingTasks = function() {
    while (this.processingTasks.length > 0) {
        if (this.stats.renderBuild > this.config.mapMaxProcessingTime) {
            this.markDirty();
            return;
        }

        this.processingTasks[0]();
        this.processingTasks.shift();
    }

    while (this.processingTasks2.length > 0) {
        if (this.processingTasks2[0]() != -123) {
            this.processingTasks2.shift();
        } else {
            break;
        }
    }

};


Map.prototype.addProcessingTask = function(task) {
    this.processingTasks.push(task);
};

Map.prototype.addProcessingTask2 = function(task) {
    this.processingTasks2.push(task);
};

/*
Map.prototype.updateGeodataProcessors = function(task) {
    const processors = this.map.geodataProcessors;
    for (let i = 0, li = processors.length; i < li; i++) {
        const processor = processors[i];

        if (!processor.ready && processor.processing) {
            processor.
        }
    }
};*/


Map.prototype.update = function() {
    if (this.killed) {
        return;
    }

    if (this.core.tokenExpiration) {
        if (Date.now() > (this.core.tokenExpiration - (1000*60))) {
            this.core.tokenExpirationCallback();
        }
    }

    if (!this.srsReady) {
        this.loader.update();
        return;
    }

    if (this.div && this.div.style.visibility == 'hidden'){
        //loop heartbeat
        //window.requestAnimFrame(this.update.bind(this));
        return;
    }

    if (!this.position.isSame(this.lastPosition)) {
        this.core.callListener('map-position-changed', {'position':this.position.toArray(), 'last-position':this.lastPosition.toArray()});
    }

    if (this.camera.lastTerrainHeight != this.camera.terrainHeight) {
        this.core.callListener('map-position-fixed-height-changed', {'height':this.camera.terrainHeight, 'last-height':this.camera.lastTerrainHeight});
    }

    this.lastPosition = this.position.clone();
    this.camera.lastTerrainHeight = this.camera.terrainHeight;
    this.drawFog = this.config.mapFog;

    const rect = this.renderer.div.getBoundingClientRect();
    const renderer = this.renderer;
    const camPos = renderer.cameraPosition;

    if (renderer.curSize[0] != rect.width || renderer.curSize[1] != rect.height) {
        renderer.onResize();
        this.dirty = true;
    }

    let dirty = (this.dirty || this.dirtyCountdown > 0), result, p;
    this.stats.begin(dirty);

    this.loader.update();

    //this.updateGeodataProcessors();

    this.processProcessingTasks();

    if (dirty) {
        if (this.dirty) {
            this.dirtyCountdown = this.config.mapRefreshCycles;
        } else {
            this.dirtyCountdown--;
        }

        this.dirty = false;
        this.bestMeshTexelSize = 0;//Number.MAX_VALUE;
        this.bestGeodataTexelSize = 0;//Number.MAX_VALUE;

        this.renderSlots.processRenderSlots();

        this.loader.update();

        this.core.callListener('map-update', {});

        //this.renderer.gpu.setState(this.drawTileState);
        //this.renderer.gpu.gl.disable(this.renderer.gpu.gl.BLEND);
        //this.renderer.drawImage(300, 0, 256, 256, this.renderer.hitmapTexture, null, null, null, null, false);
        //this.renderer.drawImage(558, 0, 256, 256, this.renderer.hitmapTexture, null, null, null, null, false);

        //console.log("" + this.stats.gpuRenderUsed);
    }

    //hover and click events
    if (this.clickEvent != null || this.hoverEvent != null) {
        //this.updateGeoHitmap = this.dirty;

        if (this.hoverEvent != null) {
            result = this.hitTestGeoLayers(this.hoverEvent[0], this.hoverEvent[1], 'hover');

            const relatedEvents = result[2];

            if (relatedEvents != null) {
                for(let i = 0, li = relatedEvents.length; i < li; i++) {
                    const event = relatedEvents[i];

                    switch(event[0]) {
                    case 'enter':
                        p = event[1][1];
                        this.core.callListener('geo-feature-enter', {'feature': event[1][0], 'canvas-coords':renderer.project2(event[1][1], renderer.camera.mvp, camPos),
                            'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3] });
                        break;

                    case 'leave':
                        p = event[1][1];
                        this.core.callListener('geo-feature-leave', {'feature':event[1][0], 'canvas-coords':renderer.project2(event[1][1], renderer.camera.mvp, camPos),
                            'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3] });
                        break;
                    }
                }
            }

            if (result[1] && result[0] != null) {
                p = result[0][1];
                this.core.callListener('geo-feature-hover', {'feature': result[0][0], 'canvas-coords':renderer.project2(result[0][1], renderer.camera.mvp, camPos),
                    'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3]});
            }

            //is it persistent event?
            if (this.hoverEvent[2] !== true) {
                this.hoverEvent = null;
            }
        }

        if (this.clickEvent != null) {
            result = this.hitTestGeoLayers(this.clickEvent[0], this.clickEvent[1], 'click');

            if (result[1] && result[0] != null) {
                p = result[0][1];
                this.core.callListener('geo-feature-click', {'feature': result[0][0], 'canvas-coords':renderer.project2(result[0][1], renderer.camera.mvp, camPos),
                    'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.clickEvent[2], 'element': result[3] });
            }

            this.clickEvent = null;
        }

    }


    this.stats.end(dirty);
};

/* harmony default export */ __webpack_exports__["default"] = (Map);


/***/ }),

/***/ "./src/core/map/measure.js":
/*!*********************************!*\
  !*** ./src/core/map/measure.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var geographiclib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! geographiclib */ "./node_modules/geographiclib/geographiclib.js");
/* harmony import */ var geographiclib__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(geographiclib__WEBPACK_IMPORTED_MODULE_2__);





//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"], mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_1__["math"];
const GeographicLib = geographiclib__WEBPACK_IMPORTED_MODULE_2___default.a;


const MapMeasure = function(map) {
    this.map = map;
    this.config = map.config;
    this.convert = map.convert;
    this.getPhysicalSrs = this.map.getPhysicalSrs();
    this.navigationSrs = this.map.getNavigationSrs();
    this.publicSrs = this.map.getPublicSrs();
    this.navigationSrsInfo = this.navigationSrs.getSrsInfo();
    this.isProjected = this.navigationSrs.isProjected();

    const res = this.getSpatialDivisionNodeDepths();

    this.minDivisionNodeDepth = res[0];
    this.maxDivisionNodeDepth = res[1];
};

MapMeasure.prototype.getSurfaceAreaGeometry = function(coords, radius, mode, limit, loadMeshes, loadTextures) {
    const tree = this.map.tree;

    if (tree.surfaceSequence.length == 0) {
        return [true, []];
    }

    const center = this.convert.convertCoords(coords, 'navigation', 'physical');
    const coneVec = [0,0,0];

    vec3.normalize(center, coneVec);

    const distance = vec3.length(center);
    const coneAngle = Math.atan(Math.tan(radius / distance));

    tree.params = {
        coneVec : coneVec,
        coneAngle : coneAngle,
        mode : mode,
        limit : limit,
        loaded : true,
        areaTiles : [],
        loadMeshes: (loadMeshes === true),
        loadTextures: (loadTextures === true)
    };

    //priority = 0, noReadInly = false
    tree.traceAreaTiles(tree.surfaceTree, 0, false);

    return [tree.params.loaded, tree.params.areaTiles];
};

MapMeasure.prototype.getSurfaceHeight = function(coords, lod, storeStats, node, nodeCoords, coordsArray, useNodeOnly) {
    const tree = this.map.tree;

    if (tree.surfaceSequence.length == 0) {
        return [0, true, true, null, null, null];
    }

    if (!node) {
        const result = this.getSpatialDivisionNode(coords);
        node = result[0];
        nodeCoords = result[1];
    }

    if (!this.config.mapHeightLodBlend) {
        lod = Math.floor(lod);
    }

    if (useNodeOnly || this.config.mapIgnoreNavtiles) {
        return this.getSurfaceHeightNodeOnly(null, lod + 8, storeStats, lod, null, node, nodeCoords, coordsArray);
    }

    if (node != null && lod !== null) {
        const root = tree.findSurfaceTile(node.id);

        const extents = {
            ll : node.extents.ll.slice(),
            ur : node.extents.ur.slice()
        };
        const params = {
            coords : nodeCoords,
            desiredLod : Math.ceil(lod),
            extents : extents,
            metanode : null,
            heightMap : null,
            heightMapExtents : null,
            traceHeight : true,
            waitingForNode : false,
            finalNode : false,
            bestHeightMap : 999
        };

        tree.traceHeight(root, params, false);

        const metanode = params.metanode;
        let i, li, height;

        if (params.heightMap) {
            if (storeStats) {
                const stats = this.map.stats;
                stats.heightClass = 2;
                stats.heightLod = lod;
                stats.heightNode = metanode.id[0];
            }

            let res = metanode.id[0] >= Math.ceil(lod);
            let arrayRes, height1, height2;

            if (this.config.mapHeightLodBlend && metanode.id[0] > 0 &&
                params.parent && params.parent.heightMap && lod <= metanode.id[0]) {
                height1 = this.getHeightmapValue(nodeCoords, params.parent.metanode, params.parent);
                height2 = this.getHeightmapValue(nodeCoords, metanode, params);
                const factor = lod - Math.floor(lod);
                height = height1 + (height2 - height1) * factor;

                if (coordsArray) {
                    arrayRes = new Array(coordsArray.length);

                    for (i = 0, li = coordsArray.length; i < li; i++) {
                        const nodeCoords2 = coordsArray[i];//node.getInnerCoords(coordsArray[i]);
                        height1 = this.getHeightmapValue(nodeCoords2, params.parent.metanode, params.parent);
                        height2 = this.getHeightmapValue(nodeCoords2, metanode, params);

                        arrayRes[i] = [height1 + (height2 - height1) * factor, res, true];
                    }
                }

                //console.log("lod: " + lod + " h1: " + height1 + " h2: " + height2 + " h: " + height);
            } else {
                height = this.getHeightmapValue(nodeCoords, metanode, params);

                if (coordsArray) {
                    arrayRes = new Array(coordsArray.length);

                    for (i = 0, li = coordsArray.length; i < li; i++) {
                        height2 = this.getHeightmapValue(coordsArray[i], metanode, params);

                        arrayRes[i] = [height2, res, true];
                    }
                }
            }

            return [height, res, true, null, null, arrayRes];

        } else if (metanode /*&& metanode.id[0] == lod && !metanode.hasNavtile()*/){
            let res = this.getSurfaceHeightNodeOnly(coords, lod + 8, storeStats, lod, null, node, nodeCoords, coordsArray);

            //console.log("lod2: " + lod + " h: " + height[0]);
            //return [res[0], res[1], true, null, null, res[5]];

            return [res[0], res[1], res[2], null, null, res[5]];
        }

    }

    return [0, false, false, null, null, null];
};


MapMeasure.prototype.getSurfaceHeightNodeOnly = function(coords, lod, storeStats, statsLod, deltaSample, node, nodeCoords, coordsArray) {
    let arrayRes, height;

    const tree = this.map.tree, stats = this.map.stats;

    if (tree.surfaceSequence.length == 0) {
        return [0, true, true, null, null, null];
    }

    if (!deltaSample) {
        if (!node) {
            const result = this.getSpatialDivisionNode(coords);
            node = result[0];
            nodeCoords = result[1];
        }

        if (coordsArray) {
            arrayRes = new Array(coordsArray.length);

            for (let i = 0, li = coordsArray.length; i < li; i++) {
                arrayRes[i] = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, deltaSample, node, coordsArray[i]);
            }
        }

    } else {
        node = deltaSample[0];
        nodeCoords = deltaSample[1];
    }

    if (!this.config.mapHeightLodBlend) {
        lod = Math.floor(lod);
    }

    if (!deltaSample && this.config.mapHeightNodeBlend) {
        const res1 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0], nodeCoords[1], nodeCoords[2]]]);

        if (res1[2]) {
            const sx = res1[3].ur[0] - res1[3].ll[0];
            const sy = res1[3].ur[1] - res1[3].ll[1];

            const fx = (nodeCoords[0] - res1[3].ll[0]) / sx;
            const fy = (nodeCoords[1] - res1[3].ll[1]) / sy;

            /*
            const c2 = node.getOuterCoords([nodeCoords[0] + sx, nodeCoords[1], nodeCoords[2]]);
            const c3 = node.getOuterCoords([nodeCoords[0], nodeCoords[1] + sy, nodeCoords[2]]);
            const c4 = node.getOuterCoords([nodeCoords[0] + sx, nodeCoords[1] + sy, nodeCoords[2]]);

            const res2 = this.getSurfaceHeightNodeOnly(c2, lod, storeStats, statsLod, true);
            const res3 = this.getSurfaceHeightNodeOnly(c3, lod, storeStats, statsLod, true);
            const res4 = this.getSurfaceHeightNodeOnly(c4, lod, storeStats, statsLod, true);
            */

            const res2 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0] + sx, nodeCoords[1], nodeCoords[2]]]);
            const res3 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0], nodeCoords[1] + sy, nodeCoords[2]]]);
            const res4 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0] + sx, nodeCoords[1] + sy, nodeCoords[2]]]);

            const w0 = (res1[0] + (res2[0] - res1[0])*fx);
            const w1 = (res3[0] + (res4[0] - res3[0])*fx);
            height = (w0 + (w1 - w0)*fy);

            //console.log("h: " + height + "fx: " + fx + "fy: " + fy + "s1234: " + res1[0] + " "  + res2[0] + " "  + res3[0] + " "  + res4[0]);
            /*
            if (res1[4] && res2[4] && res3[4] && res4[4]){
                console.log("h: " + height + "fx: " + fx + "fy: " + fy + "s1234: " + JSON.stringify(res1[4].id) + " "  + JSON.stringify(res2[4].id) + " "  + JSON.stringify(res3[4].id) + " "  + JSON.stringify(res4[4].id));
            }*/

            return [height, res1[1], res1[2], res1[3], null, arrayRes];
        } else {
            return [res1[0], res1[1], res1[2], res1[3], null, arrayRes];
        }
        //convert new coords to nav coords
        //blend values
    }

    if (node != null && lod !== null) {
        const root = tree.findSurfaceTile(node.id);

        const extents = {
            ll : node.extents.ll.slice(),
            ur : node.extents.ur.slice()
        };
        const params = {
            coords : nodeCoords,
            desiredLod : Math.ceil(lod),
            extents : extents,
            metanode : null,
            heightMap : null,
            heightMapExtents : null,
            traceHeight : true,
            waitingForNode : false,
            finalNode : false,
            bestHeightMap : 999
        };

        tree.traceHeight(root, params, true);

        const metanode = params.metanode;
        let center, center2;

        if (metanode != null) { // && metanode.id[0] == lod){

            if (metanode.metatile.version >= 5) {
                center = this.convert.convertCoords(metanode.diskPos, 'physical', 'navigation');
            } else {
                if (metanode.bbox.maxSize < 8000) { // use bbox only when bbox is reasonable small
                    center = metanode.bbox.center();
                    center = this.convert.convertCoords(center, 'physical', 'navigation');
                } else {
                    center = [0,0,nodeCoords[2]];
                }
            }

            //console.log("lod2: " + lod + " nodelod: " + metanode.id[0] + " h: " + center[2]/1.55);

            if (storeStats) {
                stats.heightClass = 1;
                stats.heightLod = statsLod;
                stats.heightNode = metanode.id[0];
            }

            if (this.config.mapHeightLodBlend && metanode.id[0] > 0 &&
                params.parent && params.parent.metanode) {

                if (params.parent.metanode.metatile.version >= 5) {
                    center2 = this.convert.convertCoords(params.parent.metanode.diskPos, 'physical', 'navigation');
                } else {
                    if (params.parent.metanode.bbox.maxSize < 8000) { // use bbox only when bbox is reasonable small
                        center2 = this.convert.convertCoords(params.parent.metanode.bbox.center(), 'physical', 'navigation');
                    } else {
                        center2 = [0,0,nodeCoords[2]];
                    }
                }

                const factor = lod - Math.floor(lod);
                height = center[2] + (center2[2] - center[2]) * factor;

                //extetnts = params.extents;
                //return [height, true, true, params.extents, metanode, arrayRes];

                return [height, (metanode.id[0] >= Math.floor(lod) || params.finalNode),
                        (!params.waitingForNode || metanode.id[0] >= Math.floor(lod) || params.finalNode),
                        params.extents, metanode, arrayRes];


                //console.log("lod: " + lod + " h1: " + center[2] + " h2: " + center2[2] + " h: " + height);
            } else {
                return [center[2], (metanode.id[0] >= Math.floor(lod) || params.finalNode),
                        (!params.waitingForNode || metanode.id[0] >= Math.floor(lod) || params.finalNode),
                        params.extents, metanode, arrayRes];

                //return [center[2], true, true, params.extents, metanode, arrayRes];
            }
        }

        /*
        if (metanode != null) {
            const height = metanode.minHeight + (metanode.maxHeight - metanode.minHeight) * 0.5;
            return [height, metanode.id[0] >= lod, true];
        }*/
    }

    //coords
    //console.log("lod3: " + lod + " h: 0");

    if (storeStats) {
        stats.heightClass = 0;
        stats.heightLod = statsLod;
        stats.heightNode = 0;
    }


    return [0, false, false, null, null, arrayRes];
};


MapMeasure.prototype.getHeightmapValue = function(coords, node, params) {
    const heightMap = params.heightMap;
    const data = heightMap.getImageData();
    const dataExtents = heightMap.getImageExtents();
    const mapExtents = params.heightMapExtents;

    //relative tile coords
    let x = coords[0] - mapExtents.ll[0];
    //const y = nodeCoords[1] - mapExtents.ll[1];
    let y = mapExtents.ur[1] - coords[1];

    const maxX = (dataExtents[0]-1);
    const maxY = (dataExtents[1]-1);

    //data coords
    x = (maxX) * (x / (mapExtents.ur[0] - mapExtents.ll[0]));
    y = (maxY) * (y / (mapExtents.ur[1] - mapExtents.ll[1]));

    if (x < 0) { x = 0; }
    if (y < 0) { y = 0; }
    if (x > maxX) { x = maxX; }
    if (y > maxY) { y = maxY; }

    const ix = Math.floor(x);
    const iy = Math.floor(y);
    const fx = x - ix;
    const fy = y - iy;

    const index = iy * dataExtents[0];
    const index2 = (iy == maxY) ? index : index + dataExtents[0];
    const ix2 = (ix == maxX) ? ix : ix + 1;
    const h00 = data[(index + ix)*4];
    const h01 = data[(index + ix2)*4];
    const h10 = data[(index2 + ix)*4];
    const h11 = data[(index2 + ix2)*4];
    const w0 = (h00 + (h01 - h00)*fx);
    const w1 = (h10 + (h11 - h10)*fx);
    let height = (w0 + (w1 - w0)*fy);

    height = node.minHeight + (node.maxHeight - node.minHeight) * (height/255);

    return height;
};


MapMeasure.prototype.getSpatialDivisionNode = function(coords) {
    const nodes = this.map.referenceFrame.getSpatialDivisionNodes();

    let bestNode = null;
    let bestLod = -1;
    let bestCoords = [0,0];

    for (let i = 0, li = nodes.length; i < li; i++) {
        const node = nodes[i];
        const nodeCoords = node.getInnerCoords(coords);
        const extents = node.extents;

        if (nodeCoords[0] >= extents.ll[0] && nodeCoords[0] <= extents.ur[0] &&
            nodeCoords[1] >= extents.ll[1] && nodeCoords[1] <= extents.ur[1]) {

            if (node.id[0] > bestLod) {
                bestNode = node;
                bestLod = node.id[0];
                bestCoords = nodeCoords;
            }
        }
    }

    return [bestNode, bestCoords];
};


MapMeasure.prototype.getSpatialDivisionNodeAndExtents = function(id) {
    const nodes = this.map.referenceFrame.getSpatialDivisionNodes();

    let bestNode = null;
    let bestNodeCoords = [0,0], shift;

    for (let i = 0, li = nodes.length; i < li; i++) {
        const node = nodes[i];

        //has division node this tile node
        shift = id[0] - node.id[0];

        if (shift >= 0) {
            const x = id[1] >> shift;
            const y = id[2] >> shift;

            if (node.id[1] == x && node.id[2] == y) {
                bestNode = node;
                bestNodeCoords = [node.id[1] << shift, node.id[2] << shift];
            }
        }
    }

    if (!bestNode) {
        return null;
    }

    shift = id[0] - bestNode.id[0];

    const factor = 1.0 / Math.pow(2, shift);
    const ur = bestNode.extents.ur;
    const ll = bestNode.extents.ll;

    //extents ll ur but tiles are ul lr!!!!

    const dx = (ur[0] - ll[0]) * factor;
    const dy = (ll[1] - ur[1]) * factor;

    const nx = id[1] - bestNodeCoords[0];
    const ny = id[2] - bestNodeCoords[1];

    return [bestNode, [[ll[0] + dx * nx, ur[1] + dy * ny], [ll[0] + dx * (nx+1), ur[1] + dy * (ny+1)] ]];
};


MapMeasure.prototype.getSpatialDivisionNodeFromId = function(id) {
    const shift = id[0] - this.maxDivisionNodeDepth;
    const nx = id[1] >> shift;
    const ny = id[2] >> shift;

    return this.map.referenceFrame.nodesMap['' + this.maxDivisionNodeDepth + '.'  + nx + '.' + ny];
};


MapMeasure.prototype.getSpatialDivisionNodeAndExtents2 = function(id, res, divisionNode) {
    if (!divisionNode) {
        return [null, 0,0,0,0];
    }

    const shift = id[0] - divisionNode.id[0];
    const factor = 1.0 / Math.pow(2, shift);
    const ur = divisionNode.extents.ur;
    const ll = divisionNode.extents.ll;

    //extents ll ur but tiles are ul lr!!!!

    const dx = (ur[0] - ll[0]) * factor;
    const dy = (ll[1] - ur[1]) * factor;

    const nx = id[1] - (divisionNode.id[1] << shift);
    const ny = id[2] - (divisionNode.id[2] << shift);

    res[0] = divisionNode;
    res[1] = ll[0] + dx * nx;
    res[2] = ur[1] + dy * ny;
    res[3] = ll[0] + dx * (nx+1);
    res[4] = ur[1] + dy * (ny+1);
};


MapMeasure.prototype.getSpatialDivisionNodeDepths = function() {
    const nodes = this.map.referenceFrame.getSpatialDivisionNodes();
    let maxLod = -1;
    let minLod = Number.MAX_VALUE;

    for (let i = 0, li = nodes.length; i < li; i++) {
        const node = nodes[i];

        if (node.id[0] < minLod) {
            minLod = node.id[0];
        }

        if (node.id[0] > maxLod) {
            maxLod = node.id[0];
        }
    }

    return [minLod, maxLod];
};


MapMeasure.prototype.getOptimalHeightLodBySampleSize = function(coords, desiredSamplesSize) {
    const result = this.getSpatialDivisionNode(coords);
    const node = result[0];

    if (node != null) {
        const nodeLod = node.id[0];
        const nodeExtent = node.extents.ur[1] - node.extents.ll[1];

        let lod = Math.log(nodeExtent / desiredSamplesSize) / Math.log(2);
        //lod = Math.round(lod) - 8 + nodeLod;
        lod = lod - 8 + nodeLod;

        return Math.max(0, lod);
    }

    return null;
};


MapMeasure.prototype.getOptimalHeightLod = function(coords, viewExtent, desiredSamplesPerViewExtent) {
    const result = this.getSpatialDivisionNode(coords);
    const node = result[0];

    if (node != null) {
        const nodeLod = node.id[0];
        const nodeExtent = node.extents.ur[1] - node.extents.ll[1];

        let lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / Math.log(2);
        //lod = Math.round(lod) - 8 + nodeLod;
        lod = lod - 8 + nodeLod;

        return Math.max(0, lod);
    }

    return null;
};


MapMeasure.prototype.getDistance = function(coords, coords2, includingHeight, usePublic) {
    const sourceSrs = usePublic ? this.publicSrs : this.navigationSrs;
    const p1 = this.getPhysicalSrs.convertCoordsFrom(coords,  sourceSrs);
    const p2 = this.getPhysicalSrs.convertCoordsFrom(coords2, sourceSrs);
    const dx = p2[0] - p1[0];
    const dy = p2[1] - p1[1];
    const dz = p2[2] - p1[2];

    const dd = Math.sqrt(dx*dx + dy*dy + dz*dz);
    const navigationSrsInfo = this.navigationSrsInfo;

    if (!this.isProjected) {
        const geod = this.getGeodesic(); //new GeographicLib["Geodesic"]["Geodesic"](navigationSrsInfo["a"],
                                       //                   (navigationSrsInfo["a"] / navigationSrsInfo["b"]) - 1.0);

        const r = geod.Inverse(coords[1], coords[0], coords2[1], coords2[0]);

        if (r.s12 > (navigationSrsInfo['a'] * 2 * Math.PI) / 4007.5) { //aprox 10km for earth
            if (includingHeight) {
                return [Math.sqrt(r.s12*r.s12 + dz*dz), -r.azi1, dd];
            } else {
                return [r.s12, -r.azi1, dd];
            }
        } else {
            if (includingHeight) {
                return [Math.sqrt(dx*dx + dy*dy + dz*dz), -r.azi1, dd];
            } else {
                return [r.s12, -r.azi1, dd];
            }
        }

    } else {
        return [Math.sqrt(dx*dx + dy*dy), math.degrees(Math.atan2(dx, dy)), dd];
    }
};


MapMeasure.prototype.getGeodesic = function() {
    const navigationSrsInfo = this.navigationSrsInfo;

    const geodesic = new GeographicLib.Geodesic.Geodesic(navigationSrsInfo['a'],
                                                      (navigationSrsInfo['a'] / navigationSrsInfo['b']) - 1.0);

    return geodesic;
};


MapMeasure.prototype.getAzimuthCorrection = function(coords, coords2) {
    if (!this.getNavigationSrs().isProjected()) {
        const geodesic = this.getGeodesic();
        const r = geodesic.Inverse(coords[0], coords[1], coords2[0], coords2[1]);
        let ret = (r.azi1 - r.azi2);
        if (isNaN(ret)) {
            ret = 0;
        }
        return ret;
    }
    return 0;
};


MapMeasure.prototype.getNED = function(coords) {
    const centerCoords = this.convert.convertCoords([coords[0], coords[1], 0], 'navigation', 'physical');
    let upCoords, rightCoords;

    if (this.isProjected) {
        upCoords = this.convert.convertCoords([coords[0], coords[1] + 100, 0], 'navigation', 'physical');
        rightCoords = this.convert.convertCoords([coords[0] + 100, coords[1], 0], 'navigation', 'physical');
    } else {
        const cy = (coords[1] + 90) - 0.0001;
        const cx = (coords[0] + 180) + 0.0001;

        if (cy < 0 || cx > 180) { //if we are out of bounds things start to be complicated
            const geodesic = this.getGeodesic();

            //up coords
            let r = geodesic.Direct(coords[1], coords[0], 0, -100);
            upCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');

            //right coords
            r = geodesic.Direct(coords[1], coords[0], 90, 100);
            rightCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');
        } else {
            // substraction instead of addition is probably case of complicated view matrix calculation
            upCoords = this.convert.convertCoords([coords[0], coords[1] - 0.0001, 0], 'navigation', 'physical');
            rightCoords = this.convert.convertCoords([coords[0] + 0.0001, coords[1], 0], 'navigation', 'physical');
        }
    }

    const up = [upCoords[0] - centerCoords[0],
        upCoords[1] - centerCoords[1],
        upCoords[2] - centerCoords[2]];

    const right = [rightCoords[0] - centerCoords[0],
        rightCoords[1] - centerCoords[1],
        rightCoords[2] - centerCoords[2]];

    const dir = [0,0,0];
    vec3.normalize(up);
    vec3.normalize(right);
    vec3.cross(up, right, dir);
    vec3.normalize(dir);

    return {
        east  : right,
        direction : up,
        north : dir
    };
};

MapMeasure.prototype.getNewNED = function(coords, returnMatrix) {
    const centerCoords = this.convert.convertCoords([coords[0], coords[1], 0], 'navigation', 'physical');
    let upCoords, rightCoords;

    if (this.isProjected) {
        upCoords = this.convert.convertCoords([coords[0], coords[1] + 100, 0], 'navigation', 'physical');
        rightCoords = this.convert.convertCoords([coords[0] + 100, coords[1], 0], 'navigation', 'physical');
    } else {
        //get NED for latlon coordinates
        //http://www.mathworks.com/help/aeroblks/directioncosinematrixeceftoned.html
        /*
        const coords = this.position.getCoords();
        const lon = math.radians(coords[0]);
        const lat = math.radians(coords[1]);

        //NED vectors for sphere
        const east = [-Math.sin(lat)*Math.cos(lon), -Math.sin(lat)*Math.sin(lon), Math.cos(lat)];
        const direction = [-Math.sin(lon), Math.cos(lon), 0];
        const north = [-Math.cos(lat)*Math.cos(lon), -Math.cos(lat)*Math.sin(lon), -Math.sin(lat)];

        north = vec3.negate(north);
        east  = vec3.negate(east);

        //get elipsoid factor
        const navigationSrsInfo = this.getNavigationSrs().getSrsInfo();
        const factor = navigationSrsInfo["b"] / navigationSrsInfo["a"];

        //flaten vectors
        north[2] *= factor;
        east[2] *= factor;
        direction[2] *= factor;

        //normalize vectors
        north = vec3.normalize(north);
        east  = vec3.normalize(east);
        direction = vec3.normalize(direction);
        */

        const cy = (coords[1] + 90) + 0.0001;
        const cx = (coords[0] + 180) + 0.0001;

        if (cy < 0 || cx > 180) { //if we are out of bounds things start to be complicated
            const geodesic = this.getGeodesic();

            //up coords
            let r = geodesic.Direct(coords[1], coords[0], 0, -100);
            upCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');

            //right coords
            r = geodesic.Direct(coords[1], coords[0], 90, -100);
            rightCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');
        } else {
            // substraction instead of addition is probably case of complicated view matrix calculation
            upCoords = this.convert.convertCoords([coords[0], coords[1] + 0.0001, 0], 'navigation', 'physical');
            rightCoords = this.convert.convertCoords([coords[0] + 0.0001, coords[1], 0], 'navigation', 'physical');
        }
    }

    const up = [upCoords[0] - centerCoords[0],
        upCoords[1] - centerCoords[1],
        upCoords[2] - centerCoords[2]];

    const right = [rightCoords[0] - centerCoords[0],
        rightCoords[1] - centerCoords[1],
        rightCoords[2] - centerCoords[2]];

    const dir = [0,0,0];
    vec3.normalize(up);
    vec3.normalize(right);
    vec3.cross(up, right, dir);
    vec3.normalize(dir);

    if (returnMatrix) {
        const east = right;
        const direction = up;
        const north = dir;

        return [
            east[0], east[1], east[2], 0,
            north[0], north[1], north[2], 0,
            direction[0], direction[1], direction[2], 0,
            0, 0, 0, 1
        ];
    }

    return {
        east  : right,
        direction : up,
        north : dir
    };
};


MapMeasure.prototype.getNewNED2 = function(coords, returnMatrix) {
    const centerCoords = this.convert.convertCoords([coords[0], coords[1], 0], 'navigation', 'physical');
    let upCoords, rightCoords;

    if (this.isProjected) {
        upCoords = this.convert.convertCoords([coords[0], coords[1] + 100, 0], 'navigation', 'physical');
        rightCoords = this.convert.convertCoords([coords[0] + 100, coords[1], 0], 'navigation', 'physical');
    } else {

        const cy = (coords[1] + 90) + 0.0001;
        const cx = (coords[0] + 180) + 0.0001;

        if (cy < 0 || cx > 180) { //if we are out of bounds things start to be complicated
            const geodesic = this.getGeodesic();

            //up coords
            let r = geodesic.Direct(coords[1], coords[0], 0, -100);
            upCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');

            //right coords
            r = geodesic.Direct(coords[1], coords[0], 90, -100);
            rightCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');
        } else {
            // substraction instead of addition is probably case of complicated view matrix calculation
            upCoords = this.convert.convertCoords([coords[0], coords[1] + 0.0001, 0], 'navigation', 'physical');
            rightCoords = this.convert.convertCoords([coords[0] + 0.0001, coords[1], 0], 'navigation', 'physical');
        }
    }

    const up = [upCoords[0] - centerCoords[0],
        upCoords[1] - centerCoords[1],
        upCoords[2] - centerCoords[2]];

    const right = [rightCoords[0] - centerCoords[0],
        rightCoords[1] - centerCoords[1],
        rightCoords[2] - centerCoords[2]];

    const dir = [0,0,0];
    vec3.normalize(up);
    vec3.normalize(right);
    vec3.cross(up, right, dir);
    vec3.normalize(dir);

    if (returnMatrix) {
        const east = right;
        const direction = up;
        const north = dir;

        return [
            east[0], east[1], east[2], 0,
            north[0], north[1], north[2], 0,
            direction[0], direction[1], direction[2], 0,
            0, 0, 0, 1
        ];
    }

    return {
        east  : right,
        direction : up,
        north : dir
    };
};


//TODO: use getNewNED
MapMeasure.prototype.getPositionCameraInfo = function(position, projected, clampTilt) {
    //const position = [0,0,0];
    const orientation = position.getOrientation();
    const distance = position.getViewDistance();

    let roty = orientation[1]
    if (!this.config.mapNoTiltConstraint)
    {
        if (clampTilt) { //used for street labels
            orientation[1] = math.clamp(orientation[1], -89.0, 90.0);
        }

        roty = math.clamp(orientation[1], -89.5, 89.5);
    }

    let tmpMatrix = mat4.create();
    mat4.multiply(math.rotationMatrix(2, math.radians(-orientation[0])), math.rotationMatrix(0, math.radians(roty)), tmpMatrix);
    let orbitPos, ned, north, east, direction, spaceMatrix, rotationMatrix;
    let east2, north2, direction2, dir, up, right;

    if (position.getViewMode() == 'obj') {
        orbitPos = [0, -distance, 0];
        mat4.multiplyVec3(tmpMatrix, orbitPos);
    } else {
        orbitPos = [0, 0, 0];
    }

    //this.cameraVector = [0, 0, 1];
    //mat4.multiplyVec3(this.updateCameraMatrix, this.cameraVector);

    const ret = {
        orbitCoords : null,
        distance : distance,
        rotMatrix : null,
        vector : null,
        orbitHeight : orbitPos[2]
    };

    let coords = position.getCoords();

    if (projected) {

        tmpMatrix = mat4.create();
        mat4.multiply(math.rotationMatrix(0, math.radians(-roty - 90.0)), math.rotationMatrix(2, math.radians(orientation[0])), tmpMatrix);

        ned = this.getNED(coords);
        north = ned.north;
        east  = ned.east;
        direction = ned.direction;

        spaceMatrix = [
            east[0], east[1], east[2], 0,
            direction[0], direction[1], direction[2], 0,
            north[0], north[1], north[2], 0,
            0, 0, 0, 1
        ];

        east2  = [1,0,0];
        direction2 = [0,1,0];
        north2 = [0,0,1];

        dir = [1,0,0];
        up = [0,0,-1];
        right = [0,0,0];
        vec3.cross(dir, up, right);

        //rotate vectors according to eulers
        mat4.multiplyVec3(tmpMatrix, north2);
        mat4.multiplyVec3(tmpMatrix, east2);
        mat4.multiplyVec3(tmpMatrix, direction2);

        mat4.multiplyVec3(tmpMatrix, dir);
        mat4.multiplyVec3(tmpMatrix, up);
        mat4.multiplyVec3(tmpMatrix, right);

        let t = 0;
        t = dir[0]; dir[0] = dir[1]; dir[1] = t;
        t = up[0]; up[0] = up[1]; up[1] = t;
        t = right[0]; right[0] = right[1]; right[1] = t;

        dir[2] = -dir[2];
        up[2] = -up[2];
        right[2] = -right[2];

        //get rotation matrix
        rotationMatrix = [
            east2[0], east2[1], east2[2], 0,
            direction2[0], direction2[1], direction2[2], 0,
            north2[0], north2[1], north2[2], 0,
            0, 0, 0, 1
        ];

        ret.vector = vec3.normalize([-orbitPos[0], -orbitPos[1], -orbitPos[2]]);
        ret.vector2 = ret.vector; //vector2 is probably hack for tree.js bboxVisible

        ret.orbitCoords = orbitPos;
        ret.rotMatrix = rotationMatrix;

    } else { //geographics


        ned = this.getNED(coords);
        north = ned.north;
        east  = ned.east;
        direction = ned.direction;


        spaceMatrix = [
            east[0], east[1], east[2], 0,
            direction[0], direction[1], direction[2], 0,
            north[0], north[1], north[2], 0,
            0, 0, 0, 1
        ];

        const localRotMatrix = mat4.create();
        mat4.multiply(math.rotationMatrix(0, math.radians(-roty - 90.0)), math.rotationMatrix(2, math.radians(orientation[0])), localRotMatrix);

        east2  = [1,0,0];
        direction2 = [0,1,0];
        north2 = [0,0,1];

        coords = position.getCoords();
        const latlonMatrix = mat4.create();
        mat4.multiply(math.rotationMatrix(0, math.radians((coords[1] - 90.0))), math.rotationMatrix(2, math.radians((-coords[0]-90))), latlonMatrix);

        //rotate vectors according to latlon
        mat4.multiplyVec3(latlonMatrix, north2);
        mat4.multiplyVec3(latlonMatrix, east2);
        mat4.multiplyVec3(latlonMatrix, direction2);


        spaceMatrix = [
            east2[0], east2[1], east2[2], 0,
            direction2[0], direction2[1], direction2[2], 0,
            north2[0], north2[1], north2[2], 0,
            0, 0, 0, 1
        ];

        right = [1,0,0];
        dir = [0,1,0];
        up = [0,0,1];

        mat4.multiplyVec3(spaceMatrix, dir);
        mat4.multiplyVec3(spaceMatrix, up);
        mat4.multiplyVec3(spaceMatrix, right);

        mat4.multiplyVec3(localRotMatrix, right);
        mat4.multiplyVec3(localRotMatrix, dir);
        mat4.multiplyVec3(localRotMatrix, up);

        rotationMatrix = [
            right[0], right[1], right[2], 0,
            dir[0], dir[1], dir[2], 0,
            up[0], up[1], up[2], 0,
            0, 0, 0, 1
        ];

        //get orbit pos
        spaceMatrix = mat4.inverse(spaceMatrix);
        mat4.multiplyVec3(spaceMatrix, orbitPos);

        ret.vector = [-rotationMatrix[2], -rotationMatrix[6], -rotationMatrix[10]];

    }

    ret.orbitCoords = orbitPos;
    ret.rotMatrix = rotationMatrix;
    return ret;
};


/* harmony default export */ __webpack_exports__["default"] = (MapMeasure);


/***/ }),

/***/ "./src/core/map/mesh.js":
/*!******************************!*\
  !*** ./src/core/map/mesh.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _submesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./submesh */ "./src/core/map/submesh.js");
/* harmony import */ var _renderer_bbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/bbox */ "./src/core/renderer/bbox.js");

//import {mat4 as mat4_} from '../utils/matrix';
//import {utils as utils_} from '../utils/utils';



//get rid of compiler mess
//const mat4 = mat4_;
const BBox = _renderer_bbox__WEBPACK_IMPORTED_MODULE_1__["default"];
const MapSubmesh = _submesh__WEBPACK_IMPORTED_MODULE_0__["default"];
//const utils = utils_;


const MapMesh = function(map, url, tile) {
    this.generateLines = true;
    this.map = map;
    this.stats = map.stats;
    this.mapLoaderUrl  = url;
    this.tile = tile; // used only for stats
    this.use16bit = map.config.map16bitMeshes;

    this.bbox = new BBox();
    this.size = 0;
    this.gpuSize = 0;
    this.fileSize = 0;
    this.faces = 0;

    this.cacheItem = null;  //store killSubmeshes
    this.gpuCacheItem = null; //store killGpuSubmeshes

    this.loadState = 0;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;

    this.mBuffer = new Float32Array(16);
    this.mBuffer2 = new Float32Array(16);
    this.vBuffer = new Float32Array(4);

    this.submeshes = [];
    this.gpuSubmeshes = [];
    this.submeshesKilled = false;

};


MapMesh.prototype.kill = function() {
    this.bbox = null;
    this.killSubmeshes();
    this.killGpuSubmeshes();
};


MapMesh.prototype.killSubmeshes = function(killedByCache) {
    for (let i = 0, li = this.submeshes.length; i < li; i++) {
        this.submeshes[i].kill();
    }
    //this.submeshes = [];
    this.submeshesKilled = true;

    if (killedByCache !== true && this.cacheItem) {
        this.map.resourcesCache.remove(this.cacheItem);
        //this.tile.validate();
    }

    if (this.gpuSubmeshes.length == 0) {
        this.loadState = 0;
    }

    this.cacheItem = null;
};


MapMesh.prototype.killGpuSubmeshes = function(killedByCache) {
    let size = 0, i, li;
    for (i = 0, li = this.gpuSubmeshes.length; i < li; i++) {

        if (this.map.renderer.device === 2) {
            this.gpuSubmeshes[i].geometry.dispose();
        } else {
            this.gpuSubmeshes[i].kill();
        }

        size += this.gpuSubmeshes[i].gpuSize;
    }

    if (li > 0) {
        this.stats.gpuMeshes -= size;
        this.stats.graphsFluxMesh[1][0]++;
        this.stats.graphsFluxMesh[1][1] += size;
    }

    this.gpuSubmeshes = [];

    if (killedByCache !== true && this.gpuCacheItem) {
        this.map.gpuCache.remove(this.gpuCacheItem);
        //this.tile.validate();
    }

    //console.log("kill: " + this.stats.counter + "   " + this.mapLoaderUrl);

//    if (this.submeshes.length == 0) {
    if (this.submeshesKilled) {
        this.loadState = 0;
    }

    this.gpuCacheItem = null;
};


MapMesh.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {
    let doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);
    doNotLoad = doNotLoad || doNotUseGpu;

    //if (doNotUseGpu) {
      //  doNotUseGpu = doNotUseGpu;
    //}

    //if (this.mapLoaderUrl == "https://cdn.vts.com/mario/proxy/melown2015/surface/vts/cz10/12-1107-688.bin?0") {
      //  this.mapLoaderUrl = this.mapLoaderUrl;
    //}

    if (this.loadState == 2) { //loaded
        if (this.cacheItem) {
            this.map.resourcesCache.updateItem(this.cacheItem);
        }

        if (doNotCheckGpu) {
            return true;
        }

        if (this.gpuSubmeshes.length == 0) {
            if (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed) {
                return false;
            }

            /*if (this.stats.renderBuild > this.map.config.mapMaxProcessingTime) {
                this.map.markDirty();
                return false;
            }*/

            if (doNotUseGpu) {
                return false;
            }

            let t = performance.now();
            this.buildGpuSubmeshes();
            this.stats.renderBuild += performance.now() - t;
        }

        if (!doNotLoad && this.gpuCacheItem) {
            this.map.gpuCache.updateItem(this.gpuCacheItem);
        }
        return true;
    } else {
        if (this.loadState == 0) {
            if (doNotLoad) {
                //remove from queue
                //if (this.mapLoaderUrl) {
                  //  this.map.loader.remove(this.mapLoaderUrl);
                //}
            } else {
                //not loaded
                //add to loading queue or top position in queue
                this.scheduleLoad(priority);
            }
        } else if (this.loadState == 3) { //loadError
            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&
                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {

                this.scheduleLoad(priority);
            }
        } //else load in progress
    }

    return false;
};


MapMesh.prototype.scheduleLoad = function(priority) {
    if (!this.mapLoaderUrl) {
        this.mapLoaderUrl = this.map.url.makeUrl(this.tile.resourceSurface.meshUrl, {lod:this.tile.id[0], ix:this.tile.id[1], iy:this.tile.id[2] });
    }

    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), priority, this.tile, 'mesh');
};


MapMesh.prototype.onLoad = function(url, onLoaded, onError) {
    this.mapLoaderCallLoaded = onLoaded;
    this.mapLoaderCallError = onError;

    this.map.loader.processLoadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, 'mesh');
    this.loadState = 1;
};


MapMesh.prototype.onLoadError = function() {
    if (this.map.killed){
        return;
    }

    this.loadState = 3;
    this.loadErrorTime = performance.now();
    this.loadErrorCounter ++;

    //make sure we try to load it again
    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) {
        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);
    }

    this.mapLoaderCallError();
};


MapMesh.prototype.onLoaded = function(data, task, direct) {
    if (this.map.killed){
        return;
    }

    if (!task) {
        //this.map.stats.renderBuild > this.map.config.mapMaxProcessingTime) {
        this.map.markDirty();
        this.map.addProcessingTask(this.onLoaded.bind(this, data, true, direct));
        return;
    }

    const t = performance.now();

    if (direct) {
        this.parseWorkerData(data);
    } else {
        this.fileSize = data.byteLength;
        const stream = {data: new DataView(data), buffer:data, index:0};
        this.parseMapMesh(stream);
    }

    this.map.stats.renderBuild += performance.now() - t;

    this.submeshesKilled = false;

    this.cacheItem = this.map.resourcesCache.insert(this.killSubmeshes.bind(this, true), this.size);

    this.map.markDirty();
    this.loadState = 2;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.mapLoaderCallLoaded();
};


// Returns RAM usage in bytes.
//MapMesh.prototype.getSize = function () {
  //  return this.size;
//};

//MapMesh.prototype.fileSize = function () {
    //return this.fileSize;
//};


MapMesh.prototype.parseWorkerData = function (data) {
    this.faces = data['faces'];
    this.gpuSize = data['gpuSize'];
    this.meanUndulation = data['meanUndulation'];
    this.numSubmeshes = data['numSubmeshes'];
    this.size = data['size'];
    this.version = data['version'];
    this.submeshes = [];

    const submeshes = data['submeshes'];

    for (let i = 0, li = submeshes.length; i < li; i++) {
        const submesh = new MapSubmesh(this);
        const submeshData = submeshes[i];

        submesh.bbox.min = submeshData['bboxMin'];
        submesh.bbox.max = submeshData['bboxMax'];
        submesh.externalUVs = submeshData['externalUVs'];
        submesh.faces = submeshData['faces'];
        submesh.flags = submeshData['flags'];
        submesh.gpuSize = submeshData['gpuSize'];
        submesh.indices = submeshData['indices'];
        submesh.internalUVs = submeshData['internalUVs'];
        submesh.size = submeshData['size'];
        submesh.surfaceReference = submeshData['surfaceReference'];
        submesh.textureLayer = submeshData['textureLayer'];
        submesh.textureLayer2 = submeshData['textureLayer2'];
        submesh.vertices = submeshData['vertices'];

        this.submeshes.push(submesh);
    }

    this.bbox.updateMaxSize();
};

MapMesh.prototype.parseMapMesh = function (stream) {
/*
    struct MapMesh {
        struct MapMeshHeader {
            char magic[2];                // letters "ME"
            ushort version;               // currently 1
            double meanUndulation;        // read more about undulation below
            ushort numSubmeshes;          // number of submeshes
        } header;
        struct Submesh submeshes [];      // array of submeshes, size of array is defined by numSubmeshes property
    };
*/
    this.killSubmeshes(); //just in case

    //parase header
    const streamData = stream.data;
    let magic = '';

    if (streamData.length < 2) {
        return false;
    }

    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;
    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;

    if (magic != 'ME') {
        return false;
    }

    this.version = streamData.getUint16(stream.index, true); stream.index += 2;

    if (this.version > 3) {
        return false;
    }

    //if (this.version >= 3) {
    stream.uint8Data = new Uint8Array(stream.buffer);
    //}

    this.meanUndulation = streamData.getFloat64(stream.index, true); stream.index += 8;
    this.numSubmeshes = streamData.getUint16(stream.index, true); stream.index += 2;

    this.submeshes = [];
    this.gpuSize = 0;
    this.faces = 0;

    for (let i = 0, li = this.numSubmeshes; i < li; i++) {
        const submesh = new MapSubmesh(this, stream);
        if (submesh.valid) {
            this.submeshes.push(submesh);
            this.size += submesh.getSize();
            this.faces += submesh.faces;

            //aproximate size
            this.gpuSize += submesh.getSize();
        }
    }

    this.numSubmeshes = this.submeshes.length;
};


MapMesh.prototype.addSubmesh = function(submesh) {
    this.submeshes.push(submesh);
    this.size += submesh.size;
    this.faces += submesh.faces;
};


MapMesh.prototype.buildGpuSubmeshes = function() {
    let size = 0;
    this.gpuSubmeshes = new Array(this.submeshes.length);

    for (let i = 0, li = this.submeshes.length; i < li; i++) {
        this.gpuSubmeshes[i] = this.submeshes[i].buildGpuMesh();
        this.gpuSubmeshes[i].gpuSize = this.submeshes[i].size;
        size += this.gpuSubmeshes[i].gpuSize;
    }

    this.stats.gpuMeshes += size;
    this.stats.graphsFluxMesh[0][0]++;
    this.stats.graphsFluxMesh[0][1] += size;

    this.gpuCacheItem = this.map.gpuCache.insert(this.killGpuSubmeshes.bind(this, true), size);
    this.gpuSize = size;

    //console.log("build: " + this.stats.counter + "   " + this.mapLoaderUrl);
};


MapMesh.prototype.drawSubmesh = function (cameraPos, index, texture, type, alpha, layer, surface, splitMask, splitSpace) {
    if (this.gpuSubmeshes[index] == null && this.submeshes[index] != null && !this.submeshes[index].killed) {
        this.gpuSubmeshes[index] = this.submeshes[index].buildGpuMesh();
    }

    const submesh = this.submeshes[index];
    const gpuSubmesh = this.gpuSubmeshes[index];

    if (!gpuSubmesh) { // || !texture) {
        return;
    }

    this.map.renderer.gpu.drawTileSubmesh(cameraPos, index, texture, type, alpha, layer, surface, splitMask, splitSpace, submesh, gpuSubmesh);
};


/* harmony default export */ __webpack_exports__["default"] = (MapMesh);


/***/ }),

/***/ "./src/core/map/metanode.js":
/*!**********************************!*\
  !*** ./src/core/map/metanode.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var _renderer_bbox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/bbox */ "./src/core/renderer/bbox.js");






//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"], mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
const BBox = _renderer_bbox__WEBPACK_IMPORTED_MODULE_3__["default"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_2__["math"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_1__["utils"];


const MapMetanode = function(metatile, id, stream, divisionNode) {
    this.metatile = metatile;
    this.map = metatile.map;
    this.id = id;
    this.credits = [];
    this.alien = false;
    this.ready = false;
    this.heightReady = false;
    this.divisionNode = divisionNode;

    this.diskPos = new Array(3);
    this.diskDistance = 1;
    this.diskNormal = new Array(3);
    this.diskAngle = 1;
    this.diskAngle2 = 1;
    this.diskAngle2A = 1;
    //this.bboxHeight = 1;
    this.bbox2 = new Array(24);

    //this.flagsGeometryPresent =  1;
    //this.flagsNavtilePresent =  3;
    //this.flagsInternalTexturePresent =  7;
    //this.flagsCoarsenessControl =  15;
    //this.flagsChildShift =  3;

    if (stream) {
        this.parseMetanode(stream);
    }
};


MapMetanode.prototype.kill = function() {
};


MapMetanode.prototype.hasChild = function(index) {
    return ((this.flags & (1<<(index+4))) != 0);
};


MapMetanode.prototype.hasChildById = function(id) {
    const ix = id[1] - (this.id[1]<<1);
    const iy = id[2] - (this.id[2]<<1);

    //ul,ur,ll,lr
    return this.hasChild((iy<<1) + ix);
};


MapMetanode.prototype.hasChildren = function() {
    return ((this.flags & ((15)<<4)) != 0);
};


MapMetanode.prototype.parseExtentBits = function(extentBytes, extentBits, index) {
    let value = 0, i, li;

    for (i = 0, li = extentBits; i < li; i++) {
        const byteIndex = index >> 3;
        const bitIndex = index & 0x7;

        if (extentBytes[byteIndex] & (1 << (7-bitIndex))) {
            value = value | (1 << (li - i - 1));
        }

        index ++;
    }

    value /= (1 << li) - 1;
//    value *= maxExtent;

    return value;
};


MapMetanode.prototype.hasGeometry = function() {
    return ((this.flags & 1) != 0);
};


MapMetanode.prototype.hasNavtile = function() {
    return ((this.flags & (1 << 1)) != 0);
};


MapMetanode.prototype.usedTexelSize = function() {
    return ((this.flags & (1 << 2)) != 0);
};


MapMetanode.prototype.usedDisplaySize = function() {
    return ((this.flags & (1 << 3)) != 0);
};

MapMetanode.prototype.parseMetanode = function(stream) {

/*
struct Metanode {
    char flags;                   // #0 - geometry present, #1 - navtile present #2 - applyTexelSize,
                                  // #3 - applyPixelSize, #4,5,6,7 - ul,ur,ll,lr child exists
    char geomExtents[];           // a packed array of 6 bit sequences, each lod+2 long, in the following order:
                                  // minx,maxx,miny,maxy,minz,maxz, undefined if no geometry present
    uchar internalTextureCount;   // number of internal textures in geometry
    hfloat texelSize;             // internal texel size in physical srs units, undef unless applyTexelSize is set
    ushort displaySize;           // desired display size, undef unless applyDisplay size is set
    short minHeight, maxHeight;   // navigation tile value range, undef if no navtile present
}
*/

    const streamData = stream.data;
    //const lastIndex = stream.index;
    const version = this.metatile.version;

    this.flags = streamData.getUint8(stream.index, true); stream.index += 1;

    if (version < 5) {
        const extentsSize = (((this.id[0] + 2) * 6 + 7) >> 3);
        const extentsBytes = this.map.metanodeBuffer;//new Uint8Array(extentsSize);

        for (let i = 0, li = extentsSize; i < li; i++) {
            extentsBytes[i] = streamData.getUint8(stream.index, true); stream.index += 1;
        }

        const extentBits = this.id[0] + 2;

        const minExtents = [0,0,0];
        const maxExtents = [0,0,0];

        let index = 0;
        const spaceExtentSize = this.map.spaceExtentSize;
        const spaceExtentOffset = this.map.spaceExtentOffset;

        for (let i = 0; i < 3; i++) {
            minExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index) * spaceExtentSize[i] + spaceExtentOffset[i];
            //minExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index, 1.0);
            index += extentBits;
            maxExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index) * spaceExtentSize[i] + spaceExtentOffset[i];
            //maxExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index, 1.0);
            index += extentBits;
        }

        //check zero bbox
        let extentsBytesSum = 0;
        for (let i = 0, li = extentsBytes.length; i < li; i++) {
            extentsBytesSum += extentsBytes[i];
        }

        //extent bytes are empty and therefore bbox is empty also
        if (extentsBytesSum == 0 ) {
            //console.log("empty-node: id: " + JSON.stringify(this.id));
            //console.log("empty-node: surafce: " + this.metatile.surface.id);

            minExtents[0] = Number.POSITIVE_INFINITY;
            minExtents[1] = Number.POSITIVE_INFINITY;
            minExtents[2] = Number.POSITIVE_INFINITY;
            maxExtents[0] = Number.NEGATIVE_INFINITY;
            maxExtents[1] = Number.NEGATIVE_INFINITY;
            maxExtents[2] = Number.NEGATIVE_INFINITY;
        }

        this.bbox = new BBox(minExtents[0], minExtents[1], minExtents[2], maxExtents[0], maxExtents[1], maxExtents[2]);
    }

    //this.surrogatezHeight = 0;

    if (version >= 4) {
        this.minZ = streamData.getFloat32(stream.index, true); stream.index += 4;
        this.maxZ = streamData.getFloat32(stream.index, true); stream.index += 4;
        this.surrogatez = streamData.getFloat32(stream.index, true); stream.index += 4;

        //if (!(this.minZ > this.maxZ || this.surrogatez == Number.NEGATIVE_INFINITY)) {
          //  this.surrogatezHeight = this.surrogatez; //have to converted to nav srs height
        //}
    }

    if (version >= 5) {
        // values are probably not needed for frontend
        /*this.llx = */streamData.getFloat32(stream.index, true); stream.index += 4;
        /*this.lly = */streamData.getFloat32(stream.index, true); stream.index += 4;
        /*this.urx = */streamData.getFloat32(stream.index, true); stream.index += 4;
        /*this.ury = */streamData.getFloat32(stream.index, true); stream.index += 4;
    }

    this.internalTextureCount = streamData.getUint8(stream.index, true); stream.index += 1;

    this.pixelSize = utils.decodeFloat16( streamData.getUint16(stream.index, true) ); stream.index += 2;
    this.displaySize = streamData.getUint16(stream.index, true); stream.index += 2;
    this.displaySize = this.metatile.surface.displaySize; //1024;
    if ((this.flags & (1 << 2)) == 0) {
        this.pixelSize = Number.POSITIVE_INFINITY;
    }

    if ((this.flags & (1 << 3)) == 0) {
        this.displaySize = 256;
    }

    this.minHeight = streamData.getInt16(stream.index, true); stream.index += 2;
    this.maxHeight = streamData.getInt16(stream.index, true); stream.index += 2;

    if (version < 4) {
        this.minZ = this.minHeight;
        this.maxZ = this.maxHeight;
        this.surrogatez =this.minHeight;
    }

    this.minZ2 = this.minZ;
    this.maxZ2 = this.maxZ;


    if (this.metatile.version >= 3) {
        if (this.metatile.flags & (1<<7)) {
            this.sourceReference = streamData.getUint16(stream.index, true); stream.index += 2;
        } else if (this.metatile.flags & (1<<6)) {
            this.sourceReference = streamData.getUint8(stream.index, true); stream.index += 1;
        }
    }

    this.heightReady = this.hasNavtile();

    this.alien = false;

    this.generateCullingHelpers();
};


MapMetanode.prototype.clone = function() {
    const node = new  MapMetanode(this.metatile, this.id);
    node.flags = this.flags;
    node.minHeight = this.minHeight;
    node.maxHeight = this.maxHeight;
    node.minZ = this.minZ;
    node.maxZ = this.maxZ;
    node.minZ2 = this.minZ2;
    node.maxZ2 = this.maxZ2;
    node.llx = this.llx;
    node.lly = this.lly;
    node.urx = this.urx;
    node.ury = this.ury;
    node.surrogatez = this.surrogatez;
    node.internalTextureCount = this.internalTextureCount;
    node.pixelSize = this.pixelSize;
    node.displaySize = this.displaySize;
    node.ready = this.ready;
    node.stream = this.stream;
    node.heightReady = this.heightReady;

    //copy credits
    node.credits = new Array(this.credits.length);

    for (let i = 0, li = this.credits.length; i < li; i++) {
        node.credits[i] = this.credits[i];
    }

    if (this.bbox) {
        node.bbox = this.bbox.clone();
    }


//    if (this.map.config.mapGeocentCulling) {
    node.diskPos = this.diskPos;
    node.diskNormal = this.diskNormal;
    node.diskAngle = this.diskAngle;
    node.diskAngle2 = this.diskAngle2;
    node.diskAngle2A = this.diskAngle2A;
    node.diskDistance = this.diskDistance;
    node.bbox2 = this.bbox2;

    node.divisionNode = this.divisionNode;

 //   }

    if (this.plane) {
        node.plane = this.plane.slice();
    }

    return node;
};


MapMetanode.prototype.generateCullingHelpers = function(virtual) {
    this.ready = true;

    const map = this.map;
    const draw = map.draw;
    const geocent = map.isGeocent;
    const version = this.metatile.useVersion;

    if (this.id[0] < map.measure.minDivisionNodeDepth || (!geocent && version < 4)) {
        return;
    }

    if (map.config.mapPreciseCulling || version >= 4) { //use division node srs
        if (virtual) {
            return; //result is same for each tile id
        }

        let divisionNode;
        let llx, lly, urx, ury;
        let pos = draw.tmpVec3;

        if (this.id[0] > map.measure.maxDivisionNodeDepth) {
            const pos2 = draw.tmpVec5;

            divisionNode = map.measure.getSpatialDivisionNodeFromId(this.id);

            if (!divisionNode) {
                return;
            }

            map.measure.getSpatialDivisionNodeAndExtents2(this.id, pos2, divisionNode);

            llx = pos2[1];
            lly = pos2[2];
            urx = pos2[3];
            ury = pos2[4];

            this.divisionNode = divisionNode;

        } else {
            const res = map.measure.getSpatialDivisionNodeAndExtents(this.id);
            divisionNode = res ? res[0] : null;

            if (!divisionNode) {
                return;
            }

            llx = res[1][0][0];
            lly = res[1][0][1];
            urx = res[1][1][0];
            ury = res[1][1][1];
            this.divisionNode = divisionNode;
        }

        this.llx = llx;
        this.lly = lly;
        this.urx = urx;
        this.ury = ury;

        const h = this.minZ;

        pos[0] = (urx + llx)* 0.5;
        pos[1] = (ury + lly)* 0.5;
        pos[2] = h;

        divisionNode.getPhysicalCoordsFast(pos, true, this.diskPos, 0, 0);

        if (geocent) {
            this.diskDistance = vec3.length(this.diskPos);
            vec3.normalize(this.diskPos, this.diskNormal);
        } else {
            this.diskNormal[0] = 0;
            this.diskNormal[1] = 0;
            this.diskNormal[2] = 1;
        }

        const normal = this.diskNormal;

        pos[0] = urx;
        pos[1] = ury;
        pos[2] = h;

        const bbox = this.bbox2;

        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 0);

        pos[1] = lly;
        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 3);

        pos[0] = llx;
        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 6);

        pos[1] = ury;
        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 9);

        let height;

        if (!geocent) {
            height = this.maxZ - h;

            bbox[12] = bbox[0];
            bbox[13] = bbox[1];
            bbox[14] = bbox[2] + height;

            bbox[15] = bbox[3];
            bbox[16] = bbox[4];
            bbox[17] = bbox[5] + height;

            bbox[18] = bbox[6];
            bbox[19] = bbox[7];
            bbox[20] = bbox[8] + height;

            bbox[21] = bbox[9];
            bbox[22] = bbox[10];
            bbox[23] = bbox[11] + height;
            return;
        }

        let normalize;
        let d1, d2, d3, d4, maxDelta;
        let dot = vec3.dot;

        if (map.config.mapPreciseBBoxTest || version >= 4) {
        //if (true) {
            height = this.maxZ - h;

            if (this.id[0] <= 3) { //get aabbox for low lods
                normalize = vec3.normalize2;

                normalize(bbox, 0, pos);
                d1 = dot(normal, pos);

                normalize(bbox, 3, pos);
                d2 = dot(normal, pos);

                normalize(bbox, 6, pos);
                d3 = dot(normal, pos);

                normalize(bbox, 9, pos);
                d4 = dot(normal, pos);

                maxDelta = Math.min(d1, d2, d3, d4);

                pos[0] = (urx + llx)* 0.5;
                pos[1] = ury;
                pos[2] = h;

                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 12);

                pos[1] = lly;
                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 15);

                pos[0] = urx;
                pos[1] = (ury + lly)* 0.5;
                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 18);

                pos[0] = llx;
                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 21);

                const mpos = this.diskPos;
                let maxX = Math.max(bbox[0], bbox[3], bbox[6], bbox[9], bbox[12], bbox[15], bbox[18], bbox[21], mpos[0]);
                let minX = Math.min(bbox[0], bbox[3], bbox[6], bbox[9], bbox[12], bbox[15], bbox[18], bbox[21], mpos[0]);

                let maxY = Math.max(bbox[1], bbox[4], bbox[7], bbox[10], bbox[13], bbox[16], bbox[19], bbox[22], mpos[1]);
                let minY = Math.min(bbox[1], bbox[4], bbox[7], bbox[10], bbox[13], bbox[16], bbox[19], bbox[22], mpos[1]);

                let maxZ = Math.max(bbox[2], bbox[5], bbox[8], bbox[11], bbox[14], bbox[17], bbox[20], bbox[23], mpos[2]);
                let minZ = Math.min(bbox[2], bbox[5], bbox[8], bbox[11], bbox[14], bbox[17], bbox[20], bbox[23], mpos[2]);

                if (this.id[0] <= 1) {
                    pos[0] = urx + (llx-urx )* 0.25;
                    pos[1] = (ury + lly)* 0.5;

                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 12);

                    pos[0] = urx + (llx-urx )* 0.75;
                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 15);

                    pos[0] = (urx + llx)* 0.5;
                    pos[1] = ury + (lly-ury )* 0.25;
                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 18);

                    pos[1] = ury + (lly-ury )* 0.75;
                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 21);

                    maxX =  Math.max(maxX, bbox[12], bbox[15], bbox[18], bbox[21]);
                    minX =  Math.min(minX, bbox[12], bbox[15], bbox[18], bbox[21]);

                    maxY =  Math.max(maxY, bbox[13], bbox[16], bbox[19], bbox[22]);
                    minY =  Math.min(minY, bbox[13], bbox[16], bbox[19], bbox[22]);

                    maxZ =  Math.max(maxZ, bbox[14], bbox[17], bbox[20], bbox[23]);
                    minZ =  Math.min(minZ, bbox[14], bbox[17], bbox[20], bbox[23]);

                    maxDelta = -1;//full circle;
                }

                bbox[0] = minX; bbox[1] = minY; bbox[2] = minZ;
                bbox[3] = maxX; bbox[4] = minY; bbox[5] = minZ;
                bbox[6] = maxX; bbox[7] = maxY; bbox[8] = minZ;
                bbox[9] = minX; bbox[10] = maxY; bbox[11] = minZ;

                bbox[12] = minX; bbox[13] = minY; bbox[14] = maxZ;
                bbox[15] = maxX; bbox[16] = minY; bbox[17] = maxZ;
                bbox[18] = maxX; bbox[19] = maxY; bbox[20] = maxZ;
                bbox[21] = minX; bbox[22] = maxY; bbox[23] = maxZ;
            } else {

                normalize = vec3.normalize3;
                dot = vec3.dot2;

                normalize(bbox, 0, bbox, 12);
                d1 = dot(normal, bbox, 12);

                normalize(bbox, 3, bbox, 15);
                d2 = dot(normal, bbox, 15);

                normalize(bbox, 6, bbox, 18);
                d3 = dot(normal, bbox, 18);

                normalize(bbox, 9, bbox, 21);
                d4 = dot(normal, bbox, 21);

                maxDelta = Math.min(d1, d2, d3, d4);

                if (this.id[0] <= 8) { //extend bbox because of lon curvature
                    pos = this.diskPos;

                    const expand = 0.12 / (9-4) * (5-(this.id[0]-4));

                    bbox[0] += (bbox[0] - pos[0]) * expand;
                    bbox[1] += (bbox[1] - pos[1]) * expand;
                    bbox[2] += (bbox[2] - pos[2]) * expand;

                    bbox[3] += (bbox[3] - pos[0]) * expand;
                    bbox[4] += (bbox[4] - pos[1]) * expand;
                    bbox[5] += (bbox[5] - pos[2]) * expand;

                    bbox[6] += (bbox[6] - pos[0]) * expand;
                    bbox[7] += (bbox[7] - pos[1]) * expand;
                    bbox[8] += (bbox[8] - pos[2]) * expand;

                    bbox[9] += (bbox[9] - pos[0]) * expand;
                    bbox[10] += (bbox[10] - pos[1]) * expand;
                    bbox[11] += (bbox[11] - pos[2]) * expand;
                }

                //extend bbox height by tile curvature
                height += draw.planetRadius - (draw.planetRadius * maxDelta);

                bbox[12] = bbox[0] + bbox[12] * height;
                bbox[13] = bbox[1] + bbox[13] * height;
                bbox[14] = bbox[2] + bbox[14] * height;

                bbox[15] = bbox[3] + bbox[15] * height;
                bbox[16] = bbox[4] + bbox[16] * height;
                bbox[17] = bbox[5] + bbox[17] * height;

                bbox[18] = bbox[6] + bbox[18] * height;
                bbox[19] = bbox[7] + bbox[19] * height;
                bbox[20] = bbox[8] + bbox[20] * height;

                bbox[21] = bbox[9] + bbox[21] * height;
                bbox[22] = bbox[10] + bbox[22] * height;
                bbox[23] = bbox[11] + bbox[23] * height;
            }

        } else {
            normalize = vec3.normalize2;

            normalize(bbox, 0, pos);
            d1 = dot(normal, pos);

            normalize(bbox, 3, pos);
            d2 = dot(normal, pos);

            normalize(bbox, 6, pos);
            d3 = dot(normal, pos);

            normalize(bbox, 9, pos);
            d4 = dot(normal, pos);

            maxDelta = Math.min(d1, d2, d3, d4);
        }

        if (version >= 5 && this.usedDisplaySize()) {
            this.bboxMaxSize = Math.max(
                vec3.distance2(bbox, 0, bbox, 3),
                vec3.distance2(bbox, 3, bbox, 6),
                vec3.distance2(bbox, 0, bbox, 12)
            );
        }

        //get cos angle based at 90deg
        this.diskAngle = Math.cos(Math.max(0,(Math.PI * 0.5) - Math.acos(maxDelta)));
        this.diskAngle2 = maxDelta;
        this.diskAngle2A = Math.acos(maxDelta); //optimalization
    }
};


MapMetanode.prototype.getWorldMatrix = function(geoPos, matrix) {
    // Note: the current camera geographic position (geoPos) is not necessary
    // here, in theory, but for numerical stability (OpenGL ES is float only)
    // we get rid of the large UTM numbers in the following subtractions. The
    // camera effectively stays in the position [0,0] and the tiles travel
    // around it. (The Z coordinate is fine and is not handled in this way.)

    let m = matrix;

    if (m != null) {
        m[0] = this.bbox.side(0); m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = this.bbox.side(1); m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = this.bbox.side(2); m[11] = 0;
        m[12] = this.bbox.min[0] - geoPos[0]; m[13] = this.bbox.min[1] - geoPos[1]; m[14] = this.bbox.min[2] - geoPos[2]; m[15] = 1;
    } else {
        m = mat4.create();

        mat4.multiply( math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]),
                       math.scaleMatrix(this.bbox.side(0), this.bbox.side(1), this.bbox.side(2)), m);
    }

    return m;
};


MapMetanode.prototype.drawBBox = function(cameraPos) {

    if (this.metatile.useVersion >= 4) {
        return this.drawBBox2(cameraPos);
    }

    const renderer = this.map.renderer;

    if (this.map.renderer.device === 2) {

        if (!this.helper) {
            this.helper = renderer.createBBox(this.bbox)
        }


        this.helper.box.setFromCenterAndSize( this.helper.box.min.clone().set((this.bbox.min[0] + this.bbox.max[0])*0.5 - cameraPos[0],
                                                                              (this.bbox.min[1] + this.bbox.max[1])*0.5 - cameraPos[1],
                                                                              (this.bbox.min[2] + this.bbox.max[2])*0.5 - cameraPos[2]),
                                              this.helper.box.min.clone().set(this.bbox.side(0), this.bbox.side(1), this.bbox.side(2) ) );

        renderer.gpu.addSceneObject(this.helper);

    } else {

        renderer.gpu.useProgram(renderer.gpu.progBBox, ['aPosition']);

        const mvp = mat4.create();
        const mv = mat4.create();

        mat4.multiply(renderer.camera.getModelviewMatrix(), this.getWorldMatrix(cameraPos), mv);

        const proj = renderer.camera.getProjectionMatrix();
        mat4.multiply(proj, mv, mvp);

        renderer.gpu.progBBox.setMat4('uMVP', mvp);

        //draw bbox
        renderer.bboxMesh.draw(renderer.gpu.progBBox, 'aPosition');

    }

};


MapMetanode.prototype.drawBBox2 = function() {

    const bbox = this.bbox2;
    const buffer = this.map.draw.bboxBuffer;
    const camPos = this.map.camera.position;

    for (let i = 0, li = 8*3; i < li; i+=3) {
        buffer[i] = bbox[i] - camPos[0];
        buffer[i+1] = bbox[i+1] - camPos[1];
        buffer[i+2] = bbox[i+2] - camPos[2];
    }

    const renderer = this.map.renderer;

    if (renderer.device === 2) {

        if (!this.helper) {
            this.helper = renderer.gpu.bboxMesh2.clone();
        }

        this.helper.onBeforeRender = renderer.gpu.bboxMaterial.userData.onRender.bind(this.helper, buffer.slice());

        renderer.gpu.addSceneObject(this.helper);

        //this.helper.onBeforeRender = this.helper.material.userData.onRender.bind(this.helper, gpuTexture, t, flags, splitMask);
    } else {
        const prog = renderer.gpu.progBBox2;

        renderer.gpu.useProgram(prog, ['aPosition']);

        prog.setFloatArray('uPoints', buffer);

        const mvp = renderer.camera.getMvpMatrix();

        prog.setMat4('uMVP', mvp);

        //draw bbox
        renderer.gpu.bboxMesh2.draw(prog, 'aPosition');

    }

};

MapMetanode.prototype.drawPlane = function(cameraPos, tile) {
    const renderer = this.map.renderer;
    const buffer = this.map.draw.planeBuffer;
    const points = this.plane;

    if (!points) {
        return;
    }

    renderer.gpu.useProgram(renderer.gpu.progPlane, ['aPosition', 'aTexCoord']);

    const mvp = mat4.create();
    const mv = renderer.camera.getModelviewMatrix();
    const proj = renderer.camera.getProjectionMatrix();
    mat4.multiply(proj, mv, mvp);

    const sx = cameraPos[0];
    const sy = cameraPos[1];
    const sz = cameraPos[2];

    for (let i = 0; i < 9; i++) {
        const index = i*3;
        buffer[index] = points[index] - sx;
        buffer[index+1] = points[index+1] - sy;
        buffer[index+2] = points[index+2] - sz;
    }

    const prog = renderer.gpu.progPlane;

    prog.setMat4('uMV', mv);
    prog.setMat4('uProj', proj);
    prog.setFloatArray('uPoints', buffer);

    const embed = 8;
    const altitude = Math.max(10, tile.distance + 20);
    const gridSelect = (Math.log(altitude) / Math.log(embed));
    const step1 = 4;//(Math.pow(embed, Math.floor(gridSelect)));
    const step2 = 8;//(Math.pow(embed, Math.ceil(gridSelect)));
    const blend = (gridSelect - Math.floor(gridSelect));

    prog.setVec4('uParams', [step1, 0, 1/15, step2]);

    prog.setVec4('uParams2', [0, 0, blend, 0]);

    renderer.gpu.bindTexture(renderer.gpu.heightmapTexture);

    //draw bbox
    renderer.gpu.planeMesh.draw(renderer.gpu.progPlane, 'aPosition', 'aTexCoord');
};


MapMetanode.prototype.getGridHeight = function(coords, data, dataWidth) {
    let x = coords[0] - this.llx;
    let y = coords[1]  - this.lly;
    const maxX = (dataWidth-1);
    const maxY = (dataWidth-1);

    //data coords
    x = (maxX) * (x / (this.urx - this.llx));
    y = (maxY) * (y / (this.ury - this.lly));

    if (x < 0) { x = 0; }
    if (y < 0) { y = 0; }
    if (x > maxX) { x = maxX; }
    if (y > maxY) { y = maxY; }

    const ix = Math.floor(x);
    const iy = Math.floor(y);
    const fx = x - ix;
    const fy = y - iy;

    const index = iy * dataWidth;
    const index2 = (iy == maxY) ? index : index + dataWidth;
    const ix2 = (ix == maxX) ? ix : ix + 1;
    const h00 = data[index + ix];
    const h01 = data[index + ix2];
    const h10 = data[index2 + ix];
    const h11 = data[index2 + ix2];
    const w0 = (h00 + (h01 - h00)*fx);
    const w1 = (h10 + (h11 - h10)*fx);
    const height = (w0 + (w1 - w0)*fy);

    return height;
};

/* harmony default export */ __webpack_exports__["default"] = (MapMetanode);


/***/ }),

/***/ "./src/core/map/metatile.js":
/*!**********************************!*\
  !*** ./src/core/map/metatile.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _metanode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metanode */ "./src/core/map/metanode.js");

//import {utils as utils_} from '../utils/utils';


//get rid of compiler mess
//const utils = utils_;
const MapMetanode = _metanode__WEBPACK_IMPORTED_MODULE_0__["default"];


const MapMetatile = function(metaresources, surface, tile) {
    this.metaresources= metaresources; //this is metastorage tile
    this.map = metaresources.map;
    this.surface = surface;
    this.id = metaresources.id;
    this.tile = tile; // used only for stats
    this.nodes = [];
    this.drawCounter = 0;
    this.loadState = 0;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.size = 0;
    this.cacheItem = null;
};


MapMetatile.prototype.kill = function(killedByCache) {
    if (killedByCache !== true && this.cacheItem != null) {
        this.map.metatileCache.remove(this.cacheItem);
    }

    if (this.metaresources) {
        this.metaresources.removeMetatile(this);
        //this.metaresources.validate();
        //this.metaresources = null;
    }

    this.loadState = 0;
    this.surface = 0;
    this.cacheItem = null;

    this.nodes = [];
};


MapMetatile.prototype.clone = function(surface) {
    const metatile = new MapMetatile(this.metaresources, surface);
    metatile.nodes = this.nodes;
    metatile.loadState = this.loadState;
    metatile.nodes = this.nodes;
    metatile.size = this.size;

    metatile.lod = this.lod;
    metatile.metatileIdx = this.metatileIdx;
    metatile.metatileIdy = this.metatileIdy;
    metatile.offsetx = this.offsetx;
    metatile.offsety = this.offsety;
    metatile.sizex = this.sizex;
    metatile.sizey = this.sizey;
    metatile.version = this.version;
    metatile.credits = this.credits;

    if (this.version < 2) {
        metatile.nodeSize = this.nodeSize;
    } else {
        metatile.flags = this.flags;
        metatile.creditCount = this.creditCount;
        metatile.flagPlanes = this.flagPlanes;
    }

    metatile.cacheItem= this.map.metatileCache.insert(metatile.kill.bind(metatile, true), metatile.size);
    return metatile;
};


MapMetatile.prototype.isReady = function (/*doNotLoad,*/ priority) {
    //if (this.id[0] == 18 &&
    //    this.id[1] == 130400 &&
    //    this.id[2] == 129088) {
    //    debugger;
    //}

    if (this.loadState == 2) { //loaded
        return true;
    } else {

        if (this.loadState == 0) {
            //if (doNotLoad) {
                //remove from queue
                //if (this.mapLoaderUrl) {
                  //  this.map.loader.remove(this.mapLoaderUrl);
                //}
            //} else {
                //not loaded
                //add to loading queue or top position in queue
            if (this.loadState == 3) { //loadError
                if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&
                        performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {

                    this.scheduleLoad(priority);
                }
            } else {
                this.scheduleLoad(priority);
            }
            //}
        } //else load in progress

        return false;
    }
};


MapMetatile.prototype.used = function() {
    if (this.cacheItem != null) {
        this.map.metatileCache.updateItem(this.cacheItem);
    }
};


MapMetatile.prototype.getNode = function(id) {
    const x = id[1] - this.id[1] - this.offsetx;
    const y = id[2] - this.id[2] - this.offsety;

    if (x < 0 || y < 0 || x >= this.sizex || y >= this.sizey) {
        return null;
    }

    let node = this.nodes[this.sizex * y + x];

    if (!node) {
        const index = this.sizex * y + x;
        const stream = {data:this.data, index:this.metanodesIndex + (index * this.metanodeSize)};
        node = (new MapMetanode(this, [this.lod, this.metatileIdx + this.offsetx + x, this.metatileIdy + this.offsety + y], stream, this.divisionNode));
        this.nodes[index] = node;
        this.applyMetanodeCredits(x, y);
        this.applyMetatanodeBitplanes(x, y);
    }

/*
    if (!node.ready) {
        node.generateCullingHelpers();
        node.ready = true;
    }
*/

    return node;
};


MapMetatile.prototype.scheduleLoad = function() {
    if (this.mapLoaderUrl == null) {
        this.mapLoaderUrl = this.surface.getMetaUrl(this.id);
    }

    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), null, this.tile, 'metatile');
};


MapMetatile.prototype.onLoad = function(url, onLoaded, onError) {
    this.mapLoaderCallLoaded = onLoaded;
    this.mapLoaderCallError = onError;

    this.map.loader.processLoadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, 'metadata');
    //utils.loadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
    this.loadState = 1;
};


MapMetatile.prototype.onLoadError = function() {
    if (this.map.killed){
        return;
    }

    this.loadState = 3;
    this.loadErrorTime = performance.now();
    this.loadErrorCounter ++;

    //make sure we try to load it again
    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) {
        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);
    }

    this.mapLoaderCallError();
};


MapMetatile.prototype.onLoaded = function(data, task) {
    if (this.map.killed){
        return;
    }

    if (!task) {
    //if (this.map.stats.renderBuild > this.map.config.mapMaxProcessingTime) {
        this.map.markDirty();
        this.map.addProcessingTask(this.onLoaded.bind(this, data, true));
        return;
    }

    data = new DataView(data);

    this.size += data.byteLength * 4;

    this.data = data;

    const t = performance.now();
    this.parseMetatatile({data:data, index: 0});
    this.map.stats.renderBuild += performance.now() - t;

    this.cacheItem= this.map.metatileCache.insert(this.kill.bind(this, true), this.size);

    this.map.markDirty();
    this.loadState = 2;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.mapLoaderCallLoaded();
};


MapMetatile.prototype.parseMetatatile = function(stream) {

/*
    struct Header {

        char magic[2];                         // letters "MT"
        ushort version;                        // version
        uchar lod;                             // common lod
        uint metatileIdx, metatileIdy;         // id of upper left tile corner (reflected in tile name)
        ushort offsetx, offsety;               // offset of valid data block
        ushort sizex, sizey;                   // dimensions of metanode grid
        uchar nodeSize;                        // size of a metanode in bytes
        uchar creditCount;                     // total number of credit blocks (= number of attributions used by nodes)
        ushort creditSize;                     // size of credit block in bytes
    };
*/

    const streamData = stream.data;
    let magic = '';

    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;
    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;

    if (magic != 'MT') {
        return;
    }

    this.version = streamData.getUint16(stream.index, true); stream.index += 2;

    if (this.version > 5) {
        return;
    }

    this.lod = streamData.getUint8(stream.index, true); stream.index += 1;

    this.metatileIdx = streamData.getUint32(stream.index, true); stream.index += 4;
    this.metatileIdy = streamData.getUint32(stream.index, true); stream.index += 4;

    this.offsetx = streamData.getUint16(stream.index, true); stream.index += 2;
    this.offsety = streamData.getUint16(stream.index, true); stream.index += 2;

    this.sizex = streamData.getUint16(stream.index, true); stream.index += 2;
    this.sizey = streamData.getUint16(stream.index, true); stream.index += 2;

    this.flagPlanes = new Array(8);

    if (this.version < 2) {
        this.nodeSize = streamData.getUint8(stream.index, true); stream.index += 1;
    } else {
        this.flags = streamData.getUint8(stream.index, true); stream.index += 1;
        this.creditCount = streamData.getUint8(stream.index, true); stream.index += 1;
        this.parseFlagPlanes(stream);
    }

    this.parseMetatatileCredits(stream);
    this.parseMetatatileNodes(stream);

    this.useVersion = (this.map.config.mapForceMetatileV3 && this.version < 5) ? 3 : this.version;
};


MapMetatile.prototype.parseFlagPlanes = function(stream) {
    const streamData = stream.data;

    //rounded to bytes
    const bitplaneSize = ((this.sizex * this.sizey + 7) >> 3);

    for (let i = 0; i < 6; i++) {
        if ((this.flags & (1 << i)) != 0) {

            const bitplane = new Uint8Array(bitplaneSize);

            for (let j = 0; j < bitplaneSize; j++) {
                bitplane[j] = streamData.getUint8(stream.index, true); stream.index += 1;
            }

            this.flagPlanes[i] = bitplane;
        }
    }
};


MapMetatile.prototype.parseMetatatileCredits = function(stream) {

/*
    struct CreditBlock {
       ushort creditId;       // numerical creditId
       char creditMask[];     // bitfield of size header.sizex * header.sizey, row major, row padded
    };
*/

    const streamData = stream.data;

    if (this.version < 2) {
        this.creditCount = streamData.getUint8(stream.index, true); stream.index += 1;
        this.creditSize = streamData.getUint16(stream.index, true); stream.index += 2;
    }

    if (this.creditCount == 0) {
        this.credits = [];
        return;
    }

    //rounded to bytes
    const bitfieldSize = ((this.sizex * this.sizey + 7) >> 3);

    this.credits = new Array(this.creditCount);

    for (let i = 0, li = this.credits.length; i < li; i++) {
        const creditId = streamData.getUint16(stream.index, true); stream.index += 2;
        const bitfield = new Uint8Array(bitfieldSize);

        for (let j = 0; j < bitfieldSize; j++) {
            bitfield[j] = streamData.getUint8(stream.index, true); stream.index += 1;
        }

        const credit = this.map.getCreditByNumber(creditId);
        const stringId = credit ? credit.key : null;

        this.credits[i] = { creditId : stringId, creditMask: bitfield};
    }
};


MapMetatile.prototype.applyMetatatileBitplanes = function() {
    for (let i = 0; i < 1; i++) {
        if (this.flagPlanes[i]) {

            const bitplane = this.flagPlanes[i];

            for (let y = 0; y < this.sizey; y++) {
                for (let x = 0; x < this.sizex; x++) {
                    let byteIndex = this.sizex * y + x;
                    const bitIndex = byteIndex & 7;
                    const bitMask = 1 << bitIndex;
                    byteIndex >>= 3;

                    if (bitplane[byteIndex] & bitMask) {
                        switch(i) {
                        case 0:
                            this.nodes[y*this.sizex+x].alien = true;
                            break;
                        }
                    }
                }
            }
        }
    }
};


MapMetatile.prototype.applyMetatanodeBitplanes = function(x, y) {
    for (let i = 0; i < 1; i++) {
        if (this.flagPlanes[i]) {
            let byteIndex = this.sizex * y + x;
            let bitIndex = byteIndex & 7;
            const bitplane = this.flagPlanes[i];
            const bitMask = 1 << bitIndex;
            byteIndex >>= 3;

            if (bitplane[byteIndex] & bitMask) {
                switch(i) {
                case 0:
                    this.nodes[y*this.sizex+x].alien = true;
                    break;
                }
            }
        }
    }
};


MapMetatile.prototype.applyMetatatileCredits = function() {
    for (let y = 0; y < this.sizey; y++) {
        for (let x = 0; x < this.sizex; x++) {
            let byteIndex = this.sizex * y + x;
            const bitIndex = byteIndex & 7;
            const bitMask = 1 << bitIndex;
            byteIndex >>= 3;

            for (let i = 0, li = this.credits.length; i < li; i++) {
                if (this.credits[i].creditMask[byteIndex] & bitMask) {
                    const id = this.credits[i].creditId;
                    if (id) {
                        this.nodes[y*this.sizex+x].credits.push(id);
                    }
                }
            }
        }
    }
};


MapMetatile.prototype.applyMetanodeCredits = function(x, y) {
    let byteIndex = this.sizex * y + x;
    const bitIndex = byteIndex & 7;
    const bitMask = 1 << bitIndex;
    byteIndex >>= 3;

    for (let i = 0, li = this.credits.length; i < li; i++) {
        if (this.credits[i].creditMask[byteIndex] & bitMask) {
            const id = this.credits[i].creditId;
            if (id) {
                this.nodes[y*this.sizex+x].credits.push(id);
            }
        }
    }
};


MapMetatile.prototype.parseMetatatileNodes = function(stream) {
    this.metanodesIndex = stream.index;
    this.metanodeSize = 1 + 1 + 2 + 2 + 2 + 2;

    if (this.version >= 5) {
        this.metanodeSize += (3 + 4) * 4;
    } else {
        this.metanodeSize += Math.floor((6 * (this.id[0] + 2) + 7) / 8);

        if (this.version == 4) {
            this.metanodeSize += 3 * 4;
        }
    }

    if (this.version >= 3) {
        if (this.flags & (1<<7)) {
            this.metanodeSize += 2;
        } else if (this.flags & (1<<6)) {
            this.metanodeSize += 1;
        }
    }

    if (this.lod >= this.map.measure.minDivisionNodeDepth) {
        this.divisionNode = this.map.measure.getSpatialDivisionNodeAndExtents([this.lod, this.metatileIdx + this.offsetx, this.metatileIdy + this.offsety]);
        if (this.divisionNode) {
            this.divisionNode = this.divisionNode[0];
        }
    } else {
        this.divisionNode = null;
    }

    this.nodes = new Array(this.sizex*this.sizey);

    /*
    const index = 0;

    for (let y = 0; y < this.sizey; y++) {
        for (let x = 0; x < this.sizex; x++) {
            this.nodes[index] = (new MapMetanode(this, [this.lod, this.metatileIdx + this.offsetx + x, this.metatileIdy + this.offsety + y], stream, divisionNode));
            index++;
        }
    }

    this.applyMetatatileCredits();
    this.applyMetatatileBitplanes();
    */
};


/* harmony default export */ __webpack_exports__["default"] = (MapMetatile);


/***/ }),

/***/ "./src/core/map/octree.js":
/*!********************************!*\
  !*** ./src/core/map/octree.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _renderer_bbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/bbox */ "./src/core/renderer/bbox.js");
/* harmony import */ var _utils_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/url */ "./src/core/utils/url.js");
/* harmony import */ var _resource_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resource-node */ "./src/core/map/resource-node.js");
/* harmony import */ var _geodata_import_vts_tree_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geodata-import/vts-tree.js */ "./src/core/map/geodata-import/vts-tree.js");



//import {math as math_} from '../utils/math';
//import {utils as utils_} from '../utils/utils';




//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"]; // mat4 = mat4_;
const BBox = _renderer_bbox__WEBPACK_IMPORTED_MODULE_1__["default"];
//const math = math_;
//const utils = utils_;
const MapResourceNode = _resource_node__WEBPACK_IMPORTED_MODULE_3__["default"];
const MapGeodataImportVTSTree = _geodata_import_vts_tree_js__WEBPACK_IMPORTED_MODULE_4__["default"];

const utilsUrl = _utils_url__WEBPACK_IMPORTED_MODULE_2__["utilsUrl"];

const localTest = false;

const MapOctree = function(id, bbox, origin, gpu, renderer) {
    this.id = id;
    this.bbox = null;
    this.origin = origin || [0,0,0];
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.renderer = renderer;
    this.mv = new Float32Array(16);
    this.mvp = new Float32Array(16);
    this.loadMode = 0;
    //this.geFactor = 1/38;
    this.geFactor = 1/16;
    this.geFactor2 = 0.5;
    this.geNormalized = false;

    if (bbox != null && bbox[0] != null && bbox[1] != null) {
        this.bbox = new BBox(bbox[0][0], bbox[0][1], bbox[0][2], bbox[1][0], bbox[1][1], bbox[1][2]);
    }

    this.binFiles = [];

    this.size = 0;
};

//destructor

MapOctree.prototype.kill = function() {

    //TODO: remove resources

    this.binFiles = null;

};


MapOctree.prototype.getSize = function() {
    return this.size;
};


MapOctree.prototype.getZbufferOffset = function() {
    return this.size;
};

MapOctree.prototype.getNodeLOD = function(node) {
    let lod = 0;

    while(node.parent) {
        lod++;
        node = node.parent;
    }

    return lod;
};


MapOctree.prototype.getNodeTexelSize = function(node, screenPixelSize) {
    const pos = node.volume.center;
    const cameraPos = this.renderer.cameraPosition;
    let d = vec3.length(
        [pos[0] - cameraPos[0],
         pos[1] - cameraPos[1],
         pos[2] - cameraPos[2]]);

    d -= node.volume.radius;

    if (d <= 0) {
        return [Number.POSITIVE_INFINITY, 0.1];
    }

    return [this.renderer.camera.scaleFactor2(d) * screenPixelSize, d];
};


MapOctree.prototype.drawNodeVolume = function(points, color, node) {
    const renderer = this.renderer;

    if (this.map.renderer.device === 2) {

        if (!node.helper) {
            node.helper = renderer.bboxMesh2.clone();
        }

        const buffer = this.map.draw.bboxBuffer;
        const camPos = this.map.camera.position;

        for (let i = 0, li = 8*3, j = 0; i < li; i+=3, j++) {
            buffer[i] = points[j][0] - camPos[0];
            buffer[i+1] = points[j][1] - camPos[1];
            buffer[i+2] = points[j][2] - camPos[2];
        }

        node.helper.onBeforeRender = renderer.bboxMaterial.userData.onRender.bind(node.helper, buffer.slice());

        renderer.addSceneObject(node.helper);

    } else {

        drawLineString({
            points : [points[0], points[1], points[2], points[3], points[0],
                      points[4], points[5], points[6], points[7], points[4]
            ],
            size : 1.0,
            color : color,
            depthTest : false,
            screenSpace : false, //switch to physical space
            blend : false
            }, renderer);

        drawLineString({
            points : [points[1], points[5]],
            size : 1.0,
            color : color,
            depthTest : false,
            screenSpace : false, //switch to physical space
            blend : false
            }, renderer);

        drawLineString({
            points : [points[2], points[6]],
            size : 1.0,
            color : color,
            depthTest : false,
            screenSpace : false, //switch to physical space
            blend : false
            }, renderer);

        drawLineString({
            points : [points[3], points[7]],
            size : 1.0,
            color : color,
            depthTest : false,
            screenSpace : false, //switch to physical space
            blend : false
            }, renderer);

    }

}

MapOctree.prototype.drawNode = function(node, noSkip, splitMask, splitSpace) {
    const renderer = this.renderer;
    const debug = this.map.draw.debug;
    const jobs = node.jobs;

    renderer.drawnNodes++;

    if (debug.drawNBBoxes) {
        const points = node.volume.points;
        let color = [255,0,255,255];

        if (node.tileset) {
            color = [0,255,0,255];
        }

        if (noSkip) {
            color = [255,255,0,255];
        }

        if (debug.drawSpaceBBox && node.volume2) {
            this.drawNodeVolume(node.volume2.points, [255,0,0,255], node);
        } else {
            this.drawNodeVolume(points, color, node);
        }

        const cameraPos = this.renderer.cameraPosition;
        let pos = node.volume.center;

        const shift = [cameraPos[0] - pos[0],
               cameraPos[1] - pos[1],
               cameraPos[2] - pos[2]];

        vec3.normalize(shift);
        vec3.scale(shift, node.volume.radius);

        pos = [pos[0]+shift[0]-cameraPos[0],
               pos[1]+shift[1]-cameraPos[1],
               pos[2]+shift[2]-cameraPos[2]];

        pos = this.renderer.core.getRendererInterface().getCanvasCoords(
            pos,
             this.renderer.camera.getMvpMatrix());

        let factor = 2, text;

        if (debug.drawLods) {
            text = '' + node.lod;//this.getNodeLOD(node);
            renderer.gpu.draw.drawText(Math.round(pos[0]-renderer.gpu.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-4*factor), 4*factor, text, [1,0,0,1], pos[2]);
        }

        if (debug.drawOctants) {
            text = '' + node.index;//this.getNodeLOD(node);
            renderer.gpu.draw.drawText(Math.round(pos[0]-renderer.gpu.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [1,1,0,1], pos[2]);
        }

        if (debug.drawDistance) {
            const res = this.getNodeTexelSize(node, node.precision * renderer.curSize[0]);
            text = '' + res[1].toFixed(2) + ' ' + res[0].toFixed(2) + ' ' + node.precision.toFixed(3);
            renderer.gpu.draw.drawText(Math.round(pos[0]-renderer.gpu.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+17*factor), 4*factor, text, [0.5,0.5,1,1], pos[2]);
        }

        if (debug.drawFaceCount) {
            const mesh = (jobs[0] && jobs[0].type == 12) ? jobs[0].mesh : null;
            if (mesh) {
                text = '' + mesh.faces + ' - ' + mesh.submeshes.length;
                renderer.gpu.draw.drawText(Math.round(pos[0]-renderer.gpu.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);
            }
        }

        if (debug.drawResources && jobs[0]) {
            text = '' + (this.getGpuSize(jobs[0])/(1024*1024)).toFixed(2) + 'MB';
            renderer.gpu.draw.drawText(Math.round(pos[0]-renderer.gpu.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [0,1,0,1], pos[2]);
        }

        if (debug.drawSurfaces && jobs[0]) {
            text = '';

            const mesh = (jobs[0] && jobs[0].type == 12) ? jobs[0].mesh : null;
            if (mesh) {
                let path = mesh.mapLoaderUrl;
                path = path.replace('.mesh', '');
                const parts = path.split('/');

                if (parts.length > 1) {
                    text = parts[parts.length-2] + '/' + parts[parts.length-1];
                } else {
                    text = parts[0];
                }
            }

            renderer.gpu.draw.drawText(Math.round(pos[0]-renderer.gpu.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);
        }

        if (debug.drawTextureSize) {
            const mesh = (jobs[0] && jobs[0].type == 12) ? jobs[0].mesh : null;
            if (mesh) {
                const submeshes = mesh.submeshes;
                for (let i = 0, li = submeshes.length; i < li; i++) {

                    if (submeshes[i].internalUVs) {
                        let texture;
                        if (jobs[0].direct) {
                            texture = submeshes[i].texture;
                        } else {
                            texture = jobs[0].textures[i];
                        }

                        if (texture) {
                            const gpuTexture = texture.getGpuTexture();
                            if (gpuTexture) {
                                text = '[' + i + ']: ' + gpuTexture.width + ' x ' + gpuTexture.height;
                                renderer.gpu.draw.drawText(Math.round(pos[0]-renderer.gpu.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);
                            }
                        }
                    } else {
                        text = '[' + i + ']: 256 x 256';
                        renderer.gpu.draw.drawText(Math.round(pos[0]-renderer.gpu.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);
                    }
                }
            }
        }
    }

    //debug.drawNBBoxes = true;

    if (!noSkip) {
        //return true;
    }

    for (let i = 0, li = jobs.length; i < li; i++) {
        const job = jobs[i];

        switch(job.type) {

            case 12:
                if (this.isMeshReady(job, null, null, null, true, node)) {
                    this.drawMesh(job, node, splitMask, splitSpace);
                }
                break;

            case 13:
                if (job.pointcloud.isReady()) {
                    job.pointcloud.draw(this.renderer.cameraPosition);
                }
                break;
        }

    }

};

// eslint-disable-next-line
MapOctree.prototype.isMeshReady = function(job, doNotLoad, priority, skipGpu, skipStats, node) {
    const mesh = job.mesh;
    const submeshes = mesh.submeshes;
    const stats = this.map.stats;
    let ready = true;

    //console.log('' + stats.gpuNeeded + '  ' + job.texturePath);

    if (mesh.isReady(doNotLoad, priority, skipGpu)) {
        if (!skipStats) {
            stats.gpuNeeded += mesh.gpuSize;

            //if (job.texturePath) {
                //console.log('--' + node.lod + '--' + job.texturePath + '    ' + stats.gpuNeeded);
            //}
        }

        for (let i = 0, li = submeshes.length; i < li; i++) {
            const submesh = submeshes[i];

            if (submesh.internalUVs) {

                let texture;

                if (job.direct) {
                    if (!submesh.texture) {
                        let path = mesh.mapLoaderUrl;
                        path = path.replace('.mesh', '-' + i + '.jpg');
                        const resource = new MapResourceNode(this.renderer.core.map, null, null);
                        submesh.texture = resource.getTexture(path, 0, null, null, null /*tile*/, true);
                    }

                    texture = submesh.texture;
                } else {
                    if (!job.texturePath) {
                        continue;
                    }

                    if (!job.textures[i]) {
                        const path = job.texturePath + '-' + i + '.jpg';
                        job.textures[i] = job.resources.getTexture(path, 0, null, null, null /*tile*/, true);
                    }

                    texture = job.textures[i];
                }


                if (!texture.isReady(doNotLoad, priority, skipGpu)) {
                    ready = false;
                }

                if (!skipStats) {
                    stats.gpuNeeded += texture.getGpuSize();
                }
            }
        }

    } else {
        ready = false;
    }

    //console.log('' + stats.gpuNeeded + '  finish');

    return ready;
}


MapOctree.prototype.getGpuSize = function(job) {
    const mesh = job.mesh;

    if (!mesh) return 0;

    const submeshes = mesh.submeshes;
    let size = 0;
    let doNotLoad = true;

    if (mesh.isReady(doNotLoad)) {
        size += mesh.gpuSize;

        for (let i = 0, li = submeshes.length; i < li; i++) {
            const submesh = submeshes[i];

            if (submesh.internalUVs && job.texturePath) {
                if (job.textures[i]) {
                    size += job.textures[i].getGpuSize();
                }
            }
        }
    }

    return size;
}


MapOctree.prototype.drawMesh = function(job ,node, splitMask, splitSpace) {
    const mesh = job.mesh;
    const submeshes = mesh.submeshes;
    const cameraPos = this.renderer.cameraPosition;

    for (let i = 0, li = submeshes.length; i < li; i++) {
        const submesh = submeshes[i];

        if (job.direct) {
            if (submesh.texture) {
                mesh.drawSubmesh(cameraPos, i, submesh.texture, this.map.draw.drawChannel == 1 ? 1 : 4 /*type*/, null /*alpha*/, null /*layer*/, null /*surface*/,  splitMask, splitSpace);
            }
        } else {
            if (job.textures[i]) {
                mesh.drawSubmesh(cameraPos, i, job.textures[i], this.map.draw.drawChannel == 1 ? 1 : 4 /*type*/, null /*alpha*/, null /*layer*/, null /*surface*/,  splitMask, splitSpace);
            }
        }
    }
}

MapOctree.prototype.generateNode = function(index, file, lod, cindex, texelSize, points, center, radius, hasMesh) {

    let jobs = [];

    if (hasMesh) {

        if (file.vtsFormat) {
            for (let i = 0, li = file.features.length; i < li; i++) {
                const feature = file.features[i];

                switch(feature.type) {
                    case 1: //mesh
                        jobs.push({
                            type: 12,
                            mesh: feature.resources[index],
                            direct: true
                        });
                        break;

                    case 2: //point cloud
                        jobs.push({
                            type: 13,
                            pointcloud: feature.resources[index],
                            direct: true
                        });
                        break;
                }
            }
        } else {
            jobs = [
                {
                    type: 12,
                    mesh: file.meshes[index],
                    direct: true
                }
            ];
        }
    }

    const node = {
        lod : lod,
        index: cindex,
        precision: texelSize,
        volume: {
            points: points,
            center: center,
            radius: radius,
        },
        jobs: jobs
    };

    return node;
}



MapOctree.prototype.traverseBinNode = function(cindex, points, center, radius, texelSize, lod, index, file, visible, isready, skipRender) {

    const renderer = this.renderer;
    const cameraPos = this.renderer.cameraPosition;

    if (!visible && !renderer.camera.pointsVisible2(points, cameraPos)) {
        return;
    }

    let tree = file.tree;
    //const vtsFormat = file.vtsFormat;
    const res = this.getBinNodeTexelSize(center, radius, texelSize * renderer.curSize[0]);

    let index2 = index * 9;

    let pathFlags = tree[index2];
    let pathIndex = (pathFlags & 0xfffffff);

    if (pathFlags & (1 << 31)) {  // has json, jump to another tree (bin file)
        const tab = file.pathTable;

        if (tab[pathIndex] == 2) { //loaded
            const fileIndex = tab[pathIndex+1] | tab[pathIndex+2] << 8 | tab[pathIndex+3] << 16; // | | tab[pathIndex+3] << 24;
            file = this.binFiles[fileIndex];
            tree = file.tree;
            index = 0;
            index2 = 0;
            pathFlags = tree[index2];
            pathIndex = (pathFlags & 0xfffffff);
        } else {
            return;
        }
    }

    let hasMesh = (pathIndex != 0);

    if (file.vtsFormat) {
        hasMesh = true;
    }

    this.map.config.mapTraverseToMeshNode = false; //!!!!!!!!!!!!!!!! DEBUG

    if (this.loadMode == 1) { // topdown with splitting

        const priority = lod * res[1];

        const noChildren = (!tree[index2+1] && !tree[index2+2] && !tree[index2+3] && !tree[index2+4] &&
                          !tree[index2+5] && !tree[index2+6] && !tree[index2+7] && !tree[index2+8]);

        if (noChildren || (res[0] <= this.map.draw.texelSizeFit && (hasMesh || !this.map.config.mapTraverseToMeshNode))) {

            if (!skipRender && (/*node.parent ||*/ this.isBinNodeReady(points, center, index, file, null, priority, null, true))) {

                const node = this.generateNode(index, file, lod, cindex, texelSize, points, center, radius, hasMesh);
                this.drawNode(node);
                //const mask = [0,1,1,1,1,1,1,1];
                //this.drawNode(node, null, mask, points);
            }

        } else {

            //are nodes ready
            //let ready = true;
            let useMask = false;
            let readyCount = 0;
            const mask = [0,0,0,0,0,0,0,0];
            const childPointsCache = [];
            const childCenterCache = [];
            const splitLods = this.map.config.mapSplitLods;

            const childPriority = (lod+1) * res[1];

            let yv = //vtsFormat ? [(points[2][0] - points[0][0])*0.5, (points[2][1] - points[0][1])*0.5, (points[2][2] - points[0][2])*0.5] :
                                 [(points[2][0] - points[1][0])*0.5, (points[2][1] - points[1][1])*0.5, (points[2][2] - points[1][2])*0.5];

            let xv = [(points[1][0] - points[0][0])*0.5, (points[1][1] - points[0][1])*0.5, (points[1][2] - points[0][2])*0.5];
            let zv = [(points[0][0] - points[4][0])*0.5, (points[0][1] - points[4][1])*0.5, (points[0][2] - points[4][2])*0.5];
            let xf, yf, zf;

            zv[0] = -zv[0];
            zv[1] = -zv[1];
            zv[2] = -zv[2];

            for (let i = 0, li = 8; i < li; i++) {

                const childIndex = tree[index2 + 1 + i];

                if (childIndex) {
                    const childIndex2 = childIndex * 9;

                    switch(i) {
                        case 0: xf = -1, yf = -1, zf = -1; break;
                        case 1: xf = 0, yf = -1, zf = -1; break;
                        case 2: xf = -1, yf = 0, zf = -1; break;
                        case 3: xf = 0, yf = 0, zf = -1; break;
                        case 4: xf = -1, yf = -1, zf = 0; break;
                        case 5: xf = 0, yf = -1, zf = 0; break;
                        case 6: xf = -1, yf = 0, zf = 0; break;
                        case 7: xf = 0, yf = 0, zf = 0; break;
                    }

                    const p = [center[0] + xv[0] * xf + yv[0] * yf + zv[0] * zf,
                             center[1] + xv[1] * xf + yv[1] * yf + zv[1] * zf,
                             center[2] + xv[2] * xf + yv[2] * yf + zv[2] * zf];

                    const childPoints = [

                        [p[0],
                         p[1],
                         p[2]],

                        [p[0] + xv[0],
                         p[1] + xv[1],
                         p[2] + xv[2]],

                        [p[0] + xv[0] + yv[0],
                         p[1] + xv[1] + yv[1],
                         p[2] + xv[2] + yv[2]],

                        [p[0] + yv[0],
                         p[1] + yv[1],
                         p[2] + yv[2]],

                        [p[0] + zv[0],
                         p[1] + zv[1],
                         p[2] + zv[2]],

                        [p[0] + xv[0] + zv[0],
                         p[1] + xv[1] + zv[1],
                         p[2] + xv[2] + zv[2]],

                        [p[0] + xv[0] + yv[0] + zv[0],
                         p[1] + xv[1] + yv[1] + zv[1],
                         p[2] + xv[2] + yv[2] + zv[2]],

                        [p[0] + yv[0] + zv[0],
                         p[1] + yv[1] + zv[1],
                         p[2] + yv[2] + zv[2]]

                    ];

                    const childCenter = [ (childPoints[0][0]+childPoints[1][0]+childPoints[2][0]+childPoints[3][0]+childPoints[4][0]+childPoints[5][0]+childPoints[6][0]+childPoints[7][0])/8,
                                   (childPoints[0][1]+childPoints[1][1]+childPoints[2][1]+childPoints[3][1]+childPoints[4][1]+childPoints[5][1]+childPoints[6][1]+childPoints[7][1])/8,
                                   (childPoints[0][2]+childPoints[1][2]+childPoints[2][2]+childPoints[3][2]+childPoints[4][2]+childPoints[5][2]+childPoints[6][2]+childPoints[7][2])/8 ];

/*
                    const childCenter = [p[0] + xv[0]*0.5 + yv[0]*0.5 + zv[0]*0.5,
                                       p[1] + xv[1]*0.5 + yv[1]*0.5 + zv[1]*0.5,
                                       p[2] + xv[2]*0.5 + yv[2]*0.5 + zv[2]*0.5];
*/
                    childPointsCache[i] = childPoints;
                    childCenterCache[i] = childCenter;

                    if (splitLods) {
                        const res2 = this.getBinNodeTexelSize(childCenter, radius*0.5, texelSize*0.5 * renderer.curSize[0]);
                        if (res2[0] <= this.map.draw.texelSizeFit) {
                            tree[childIndex2] |= (1 << 29);  // set good lod flag true
                        } else {
                            tree[childIndex2] &= ~(1 << 29);  // set good lod flag false
                        }
                    }

                    if (renderer.camera.pointsVisible2(childPoints, cameraPos)) {
                        tree[childIndex2] |= (1 << 30);  // set visible flag true
                    } else {
                        tree[childIndex2] &= ~(1 << 30);  // set visible flag false
                        continue;
                    }

                    if (!this.isBinNodeReady(childPoints, childCenter, childIndex, file, null, childPriority, true, skipRender) || (splitLods && (tree[index2] & (1 << 29) /* good lod flag*/ ))) {
                        //ready = false;
                        useMask = true;
                        mask[i] = 1;
                    } else {
                        readyCount++;
                    }
                }
            }

            for (let i = 0, li = 8; i < li; i++) {
                const childIndex = tree[index2 + 1 + i];

                if (childIndex) {
                    const childIndex2 = childIndex * 9;

                    if ((tree[childIndex2] & (1 << 30) /* visibility flag*/ ) && !(splitLods && (tree[childIndex2] & (1 << 29) /* good lod flag*/ ))) {
                        const skipChildRender = (skipRender || (mask[i] == 1));

                        this.traverseBinNode(i, childPointsCache[i], childCenterCache[i], radius * 0.5, texelSize * 0.5, lod+1, childIndex, file, true, null, skipChildRender);
                    }
                }
            }

            if (useMask) { // some children are not ready, draw parent as fallback
                if (!skipRender && this.isBinNodeReady(points, center, index, file, null, priority, null, true)) {

                    const node = this.generateNode(index, file, lod, cindex, texelSize, points, center, radius, hasMesh);

                    if (readyCount > 0) {
                        this.drawNode(node, null, mask, points);
                    } else {
                        this.drawNode(node);
                    }
                }
            }

        }
    }

};


MapOctree.prototype.getPath = function(tab, index) {
    let stmp = '';
    while(tab[index] != 0) {
        stmp += String.fromCharCode(tab[index++]);
        if (stmp.length > 700) {
            //debugger
            break;
        }
    }

    return stmp;
};


MapOctree.prototype.isBinNodeReady = function(points, center, index, file, doNotLoad, priority, skipGpu, skipStats) {
    let ready = true;

    let tree = file.tree;
    let index2 = index * 9;
    let pathFlags = tree[index2];
    let pathIndex = (pathFlags & 0xfffffff);

    if (pathFlags & (1 << 31)) {  // has json, jump to another tree (bin file)
        const tab = file.pathTable;

        if (tab[pathIndex] == 2) { //loaded
            const fileIndex = tab[pathIndex+1] | tab[pathIndex+2] << 8 | tab[pathIndex+3] << 16;// | tab[pathIndex+4] << 24;
            file = this.binFiles[fileIndex];
            tree = file.tree;
            index = 0;
            index2 = 0;
            pathFlags = tree[index2];
            pathIndex = (pathFlags & 0xfffffff);
        } else {

            if (tab[pathIndex] == 0) {
                tab[pathIndex] = 1;

                this.binFiles.push({});

                let path = this.getPath(tab, pathIndex+4);
                path = utilsUrl.getProcessUrl(path, this.rootPath);

                if (localTest) {
                    const importer = new MapGeodataImport3DTiles2();
                    importer.navSrs = this.map.getNavigationSrs();
                    importer.physSrs = this.map.getPhysicalSrs();
                    importer.srs = importer.navSrs;

                    importer.loadJSON(path + '.json', {index: this.binFiles.length-1, nodeFile:file.index, nodeOffset:pathIndex, root: false}, this.onBinFileLoaded.bind(this));
                } else {
                    this.map.loader.processLoadBinary(path + '.json', this.onBinFileLoaded.bind(this,{index: this.binFiles.length-1, nodeFile:file.index, nodeOffset:pathIndex, root: false }), null, "text", 'direct-3dtiles', {root: false});
                }
            }

            return false;
        }
    }

    let hasMesh = (pathIndex != 0);

    if (file.vtsFormat) {
        hasMesh = true;
    }

    if (hasMesh) {

        if (file.vtsFormat) {

            for (let i = 0, li = file.features.length; i < li; i++) {
                const feature = file.features[i];

                switch (feature.type) {

                    case 1: //mesh
                        break;

                    case 2: //pointcloud
                        {
                            let pointcloud = feature.resources[index];

                            if (!pointcloud) {
                                if (feature.indices) {
                                    const path = utilsUrl.getProcessUrl(feature.uri, this.rootPath);
                                    const resource = new MapResourceNode(this.renderer.core.map, null, null);
                                    pointcloud = resource.getPointCloud(path, null, feature.indices[index] - 1, feature.indices[index+1] - feature.indices[index]);
                                    feature.resources[index] = pointcloud;
                                    pointcloud.transform = [points[0][0], points[0][1], points[0][2], Math.abs(points[1][0] - points[0][0])];
                                }
                            }

                            if (!pointcloud.isReady(doNotLoad, priority, skipGpu)) {
                                ready = false;
                            }
                        }
                        break;
                }
            }

        } else {
            if (!file.meshes[index]) {
                let path = this.getPath(file.pathTable, pathIndex);
                path = utilsUrl.getProcessUrl(path, this.rootPath);
                const resource = new MapResourceNode(this.renderer.core.map, null, null);
                file.meshes[index] = resource.getMesh(path + '.mesh', null);
            }

            const job = {
                mesh: file.meshes[index],
                //textures: [file.textures[index]],
                direct: true
            };

            if (!this.isMeshReady(job, doNotLoad, priority, skipGpu, skipStats /*, node*/)) {
                ready = false;
            }

        }
    }

    return ready;
};


MapOctree.prototype.getBinNodeTexelSize = function(pos, radius, screenPixelSize) {
    const cameraPos = this.renderer.cameraPosition;
    let d = vec3.length(
        [pos[0] - cameraPos[0],
         pos[1] - cameraPos[1],
         pos[2] - cameraPos[2]]);

    d -= radius;

    if (d <= 0) {
        return [Number.POSITIVE_INFINITY, 0.1];
    }

    return [this.renderer.camera.scaleFactor2(d) * screenPixelSize * 0.5, d];
};


MapOctree.prototype.onBinFileLoaded = function(info, data) {
    const binFile = this.binFiles[info.index];
    binFile.loadState = 2;
    binFile.tree = data.bintree;
    binFile.pathTable = data.pathTable;
    binFile.rootSize = data.rootSize;
    binFile.index = info.index;

    this.map.stats.octoNodes += data.totalNodes;
    this.map.stats.octoNodesMemSize += binFile.tree.byteLength + 8*2 + 16*2 + 24;


    if (data.vtsFormat) {

        //shift is DEBUG ONLY !!!!!!!!!!!!!!!!!!!!
        const cpos = this.renderer.cameraPosition;
        const cdist = this.renderer.cameraDistance;
        const cvec = this.renderer.cameraVector;

        //const shift = [0,0,0];
        const shift = [
            cpos[0] + cvec[0] * cdist,
            cpos[1] + cvec[1] * cdist,
            cpos[2] + cvec[2] * cdist
        ];

        vec3.add(data.center, shift);
        vec3.add(data.points[0], shift);
        vec3.add(data.points[1], shift);
        vec3.add(data.points[2], shift);
        vec3.add(data.points[3], shift);
        vec3.add(data.points[4], shift);
        vec3.add(data.points[5], shift);
        vec3.add(data.points[6], shift);
        vec3.add(data.points[7], shift);

        binFile.vtsFormat = data.vtsFormat;
        binFile.features = data.features;

        for (let i = 0, li = binFile.features.length; i < li; i++) {
            const feature = binFile.features[i];
            feature.resources = new Array(data.totalNodes);

            this.map.stats.octoNodesMemSize += feature.resources.length*4 +
                                               feature.indices ? feature.indices.byteLength : 0;
        }

    } else {
        binFile.meshes = new Array(data.totalNodes);
        this.map.stats.octoNodesMemSize += binFile.pathTable.byteLength +
                                           binFile.meshes.length*4;
    }

    if (info.nodeOffset) {
        const tab = this.binFiles[info.nodeFile].pathTable;
        tab[info.nodeOffset] = 2; //load state
        tab[info.nodeOffset+1] = (info.index & 0xff);
        tab[info.nodeOffset+2] = (info.index >> 8) & 0xff;
        tab[info.nodeOffset+3] = (info.index >> 16) & 0xff;
        //table[info.nodeOffset+3] = (info.index >> 24) & 0xff;
    }

    if (info.root) {
        this.rootPoints = data.points;
        this.rootCenter = data.center;
        this.rootRadius = data.radius;
        this.rootTexelSize = data.texelSize;

        if (this.map.config.autocenter) {
            const coords = this.map.convert.convertCoordsFromPhysToNav(data.center, 'fix');
            const pos = this.map.getPosition();
            pos.setCoords(coords);
            pos.pos[3] = 'fix';
            pos.setViewExtent(500);
            this.map.setPosition(pos);
        }
    }

    this.renderer.core.map.dirty = true;
};


// eslint-disable-next-line
MapOctree.prototype.draw = function(mv, mvp, applyOrigin, tiltAngle, texelSize) {
    if (this.id != null) {
        if (this.renderer.layerGroupVisible[this.id] === false) {
            return;
        }
    }

    const renderer = this.renderer;
    //const renderCounter = [[renderer.geoRenderCounter, mv, mvp, this]];
    const map = renderer.core.map;
    this.map = map;

    if (this.binPath) {

        if (this.binFiles.length == 0) {
            this.binFiles.push(
                {
                    loadState : 1
                }
            );

            this.rootPath = utilsUrl.makeAbsolute(this.binPath);
            this.rootPath = utilsUrl.getBase(this.rootPath);

            //localTest = true; ///!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

            if (localTest) {

                if (this.binPath.indexOf('.json') != -1)
                {
                    const importer = new MapGeodataImport3DTiles2();
                    importer.navSrs = this.map.getNavigationSrs();
                    importer.physSrs = this.map.getPhysicalSrs();
                    importer.srs = importer.navSrs;

                    importer.loadJSON(utilsUrl.makeAbsolute(this.binPath), {index: 0, root: true}, this.onBinFileLoaded.bind(this));
                } else {
                    const importer = new MapGeodataImportVTSTree();

                    importer.load(utilsUrl.makeAbsolute(this.binPath), {index: 0, root: true}, this.onBinFileLoaded.bind(this));
                }

            } else {
                map.loader.processLoadBinary(utilsUrl.makeAbsolute(this.binPath), this.onBinFileLoaded.bind(this,{index:0, root: true}), null, "text", 'direct-3dtiles', {root: true});
            }

            return;
        } else if (this.binFiles[0].loadState == 1) {
            return;
        }

        renderer.drawnNodes = 0;

        const mode = this.map.config.mapLoadMode;

        switch(mode) {
        case 'topdown': this.loadMode = 1; /*((this.map.config.mapSplitMeshes) ? 1 : 0);*/ break;
        case 'fit':     this.loadMode = 2; break;
        case 'fitonly': this.loadMode = 3; break;
        }

        const file = this.binFiles[0];

        this.traverseBinNode(0, this.rootPoints, this.rootCenter, this.rootRadius, this.rootTexelSize, 0, 0, file, null, null, null);
    }

};


/* harmony default export */ __webpack_exports__["default"] = (MapOctree);


/***/ }),

/***/ "./src/core/map/pointcloud.js":
/*!************************************!*\
  !*** ./src/core/map/pointcloud.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _renderer_bbox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/bbox */ "./src/core/renderer/bbox.js");





//import GpuProgram_ from '../renderer/gpu/program';
//import GpuShaders_ from '../renderer/gpu/shaders';
//import GpuPointcloud_ from '../renderer/gpu/pointcloud';

//get rid of compiler mess
const mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_1__["mat4"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_0__["math"];
const BBox = _renderer_bbox__WEBPACK_IMPORTED_MODULE_3__["default"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_2__["utils"];
//const GpuProgram = GpuProgram_;
//const GpuShaders = GpuShaders_;
//const GpuPointcloud = GpuPointcloud_;

const MapPointCloud = function(map, url, tile, offset, size) {
    this.generateLines = true;
    this.map = map;
    this.stats = map.stats;
    this.mapLoaderUrl  = url;
    this.rangeOffset = offset;
    this.rangeSize = size;
    this.tile = tile; // used only for stats

    this.bbox = new BBox();
    this.size = 0;
    this.gpuSize = 0;
    this.fileSize = 0;
    this.faces = 0;

    this.cacheItem = null;  //store killSubcloudes
    this.gpuCacheItem = null; //store killGpuSubclouds

    this.loadState = 0;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;

    this.mBuffer = new Float32Array(16);
    this.mBuffer2 = new Float32Array(16);
    this.vBuffer = new Float32Array(4);

    this.subclouds = [];
    this.gpuSubclouds = [];
    this.subcloudsKilled = false;
};


MapPointCloud.prototype.kill = function() {
    this.bbox = null;
    this.killSubclouds();
    this.killGpuSubcloud();
};


MapPointCloud.prototype.killSubclouds = function(killedByCache) {
    for (let i = 0, li = this.subclouds.length; i < li; i++) {
        this.subclouds[i].kill();
    }
    //this.subclouds = [];
    this.subcloudsKilled = true;

    if (killedByCache !== true && this.cacheItem) {
        this.map.resourcesCache.remove(this.cacheItem);
        //this.tile.validate();
    }

    if (this.gpuSubclouds.length == 0) {
        this.loadState = 0;
    }

    this.cacheItem = null;
};


MapPointCloud.prototype.killGpuSubclouds = function(killedByCache) {
    let size = 0, i, li;
    for (i = 0, li = this.gpuSubclouds.length; i < li; i++) {
        this.gpuSubclouds[i].kill();
        size += this.gpuSubclouds[i].getSize();
    }

    if (li > 0) {
        this.stats.gpuMeshes -= size;
        this.stats.graphsFluxMesh[1][0]++;
        this.stats.graphsFluxMesh[1][1] += size;
    }

    this.gpuSubclouds = [];

    if (killedByCache !== true && this.gpuCacheItem) {
        this.map.gpuCache.remove(this.gpuCacheItem);
    }

    if (this.subcloudsKilled) {
        this.loadState = 0;
    }

    this.gpuCacheItem = null;
};


MapPointCloud.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {
    const doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);
    doNotLoad = doNotLoad || doNotUseGpu;

    if (this.loadState == 2) { //loaded
        if (this.cacheItem) {
            this.map.resourcesCache.updateItem(this.cacheItem);
        }

        if (doNotCheckGpu) {
            return true;
        }

        if (this.gpuSubclouds.length == 0) {
            if (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed) {
                return false;
            }

            if (doNotUseGpu) {
                return false;
            }

            const t = performance.now();
            this.buildGpuSubclouds();
            this.stats.renderBuild += performance.now() - t;
        }

        if (!doNotLoad && this.gpuCacheItem) {
            this.map.gpuCache.updateItem(this.gpuCacheItem);
        }
        return true;
    } else {
        if (this.loadState == 0) {
            if (doNotLoad) {
                //remove from queue
                //if (this.mapLoaderUrl) {
                  //  this.map.loader.remove(this.mapLoaderUrl);
                //}
            } else {
                //not loaded
                //add to loading queue or top position in queue
                this.scheduleLoad(priority);
            }
        } else if (this.loadState == 3) { //loadError
            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&
                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {

                this.scheduleLoad(priority);
            }
        } //else load in progress
    }

    return false;
};


MapPointCloud.prototype.scheduleLoad = function(priority) {
    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), priority, this.tile, 'pointcloud');
};


MapPointCloud.prototype.onLoad = function(url, onLoaded, onError) {
    this.mapLoaderCallLoaded = onLoaded;
    this.mapLoaderCallError = onError;

    this.map.loader.processLoadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, 'pointcloud', { offset: this.rangeOffset, size: this.rangeSize });
    this.loadState = 1;
};


MapPointCloud.prototype.onLoadError = function() {
    if (this.map.killed){
        return;
    }

    this.loadState = 3;
    this.loadErrorTime = performance.now();
    this.loadErrorCounter ++;

    //make sure we try to load it again
    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) {
        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);
    }

    this.mapLoaderCallError();
};


MapPointCloud.prototype.onLoaded = function(data, task, direct) {
    if (this.map.killed){
        return;
    }

    if (!task) {
        //this.map.stats.renderBuild > this.map.config.mapMaxProcessingTime) {
        this.map.markDirty();
        this.map.addProcessingTask(this.onLoaded.bind(this, data, true, direct));
        return;
    }

    const t = performance.now();

    if (direct) {
        this.parseWorkerData(data);
    } else {
        this.fileSize = data.byteLength;
        const stream = {data: new DataView(data), buffer:data, index:0};
        this.parseMapPointCloud(stream);
    }

    this.map.stats.renderBuild += performance.now() - t;

    this.subcloudsKilled = false;

    this.cacheItem = this.map.resourcesCache.insert(this.killSubclouds.bind(this, true), this.size);

    this.map.markDirty();
    this.loadState = 2;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.mapLoaderCallLoaded();
};


// Returns RAM usage in bytes.
//MapPointCloud.prototype.getSize = function () {
  //  return this.size;
//};

//MapPointCloud.prototype.fileSize = function () {
    //return this.fileSize;
//};

MapPointCloud.prototype.parseMapPointCloud = function (stream) {

    //this.killSubclouds(); //just in case

    //parase header
    const streamData = stream.data;
    let magic = '';

    if (streamData.length < 2) {
        return false;
    }

    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;
    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;

    if (magic != 'pc') {
        return false;
    }

    this.version = streamData.getUint16(stream.index, true); stream.index += 2;

    const jsonSize = streamData.getUint32(stream.index, true); stream.index += 4;

    let json = utils.unint8ArrayToString(new Uint8Array(streamData.buffer, stream.index, jsonSize));
    stream.index += jsonSize;

    try {
        json = JSON.parse(json);
        // eslint-disable-next-line
    } catch (e) {
    }

    const headerSize = jsonSize + 2 + 2 + 4;

    const features = json['features'];
    const attributes = json['attributes'];

    if (!features || features.length < 1) {
        return false;
    }

    if (!attributes || attributes.length < 1) {
        return false;
    }

    for (let i = 0, li = features.length; i < li; i++) {
        const feature = features[i];

        const attribute = attributes[feature['attributes']];

        if (!attribute) {
            continue;
        }

        const subcloud = {};

        let offset = feature['offset'] + headerSize;
        const size = feature['size'];

        subcloud.size = size;

        if('color' in attribute) {
            switch(attribute['color']){
                case 0: //rgb888
                    subcloud.colors = new Uint8Array(streamData.buffer, offset, size * 3);
                    offset += size*3;
                    break;
            }
        }

        if('position' in attribute) {
            switch(attribute['position']){
                case 0: // xyz uint8
                    subcloud.vertices = new Uint8Array(streamData.buffer, offset, size * 3);
                    offset += size*3;
                    break;
            }
        }

        this.addSubcloud(subcloud);
    }
};


MapPointCloud.prototype.addSubcloud = function(subcloud) {
    this.subclouds.push(subcloud);
    this.size += subcloud.size * 3 * 2;
    this.points += subcloud.size;
};


MapPointCloud.prototype.buildGpuSubclouds = function() {
    let size = 0;
    this.gpuSubclouds = new Array(this.subclouds.length);

    const renderer = this.map.renderer;

    for (let i = 0, li = this.subclouds.length; i < li; i++) {
        const subcloud = this.subclouds[i];

        this.gpuSubclouds[i] = new GpuPointcloud(renderer.gpu, { vertices: subcloud.vertices, colors: subcloud.colors }, subcloud.size, this.map.core, true);
    }

    this.stats.gpuMeshes += size;
    this.stats.graphsFluxMesh[0][0]++;
    this.stats.graphsFluxMesh[0][1] += size;

    this.gpuCacheItem = this.map.gpuCache.insert(this.killGpuSubclouds.bind(this, true), size);
    this.gpuSize = size;

    //console.log("build: " + this.stats.counter + "   " + this.mapLoaderUrl);
};

MapPointCloud.prototype.getWorldMatrix = function(geoPos, matrix) {
    // Note: the current camera geographic position (geoPos) is not necessary
    // here, in theory, but for numerical stability (OpenGL ES is float only)
    // we get rid of the large UTM numbers in the following subtractions. The
    // camera effectively stays in the position [0,0] and the tiles travel
    // around it. (The Z coordinate is fine and is not handled in this way.)

    let m = matrix;

    if (m) {
        m[0] = this.transform[3]; m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = this.transform[3]; m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = this.transform[3]; m[11] = 0;
        m[12] = this.transform[0] - geoPos[0]; m[13] = this.transform[1] - geoPos[1]; m[14] = this.transform[2] - geoPos[2]; m[15] = 1;
    } else {
        m = mat4.create();

        mat4.multiply( math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]),
                       math.scaleMatrix(this.bbox.side(0), this.bbox.side(1), this.bbox.side(2)), m);
    }

    return m;
};

// eslint-disable-next-line
MapPointCloud.prototype.drawSubcloud = function (cameraPos, index, texture, type, alpha, layer, surface, splitMask, splitSpace) {
    const renderer = this.map.renderer;

    if (!this.gpuSubclouds[index] && this.subclouds[index] && !this.subclouds[index].killed) {
        this.gpuSubclouds[index] = new GpuPointcloud(renderer.gpu, { vertices: this.subclouds[index].vertices, colors: this.subclouds[index].colors }, this.subclouds[index].size, this.map.core, true);
    }

    const subcloud = this.subclouds[index];
    const gpuSubcloud = this.gpuSubclouds[index];

    if (!gpuSubcloud) {
        return;
    }

    const program = renderer.gpu.progPCloud;

    const mv = this.mBuffer, m = this.mBuffer2; //, mvp = this.vBuffer;

    mat4.multiply(renderer.camera.getModelviewFMatrix(), this.getWorldMatrix(cameraPos, m), mv);

    renderer.gpu.useProgram(program, ['aPosition', 'aColor'], null /*gpuMask*/);

    const proj = renderer.camera.getProjectionMatrix();
    mat4.multiply(proj, mv, m);

    program.setMat4('uMVP', m);


    gpuSubcloud.draw(program, 'aPosition', 'aColor');

    this.stats.drawnFaces += subcloud.size;
    this.stats.drawCalls ++;
};

MapPointCloud.prototype.draw = function (cameraPos, splitMask, splitSpace) {

    for (let i = 0, li = this.subclouds.length; i < li; i++) {
        this.drawSubcloud(cameraPos, i, splitMask, splitSpace);
    }

};

/* harmony default export */ __webpack_exports__["default"] = (MapPointCloud);


/***/ }),

/***/ "./src/core/map/position.js":
/*!**********************************!*\
  !*** ./src/core/map/position.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");



//get rid of compiler mess
const math = _utils_math__WEBPACK_IMPORTED_MODULE_0__["math"];

const MapPosition = function(pos) {
    if (pos instanceof MapPosition) {
        this.pos = pos.pos.slice();
    } else {
        if (!(pos != null && (pos instanceof Array))) {
            this.pos = [];
        } else {
            this.pos = pos.slice();
        }

        this.validate();
    }
};


MapPosition.prototype.clone = function() {
    return new MapPosition(this.pos);
};


MapPosition.prototype.getCoords = function() {
    return [this.pos[1], this.pos[2], this.pos[4]];
};


MapPosition.prototype.getCoords2 = function() {
    return [this.pos[1], this.pos[2]];
};


MapPosition.prototype.setCoords = function(coords) {
    this.pos[1] = coords[0];
    this.pos[2] = coords[1];
    this.pos[4] = coords[2];
    return this;
};


MapPosition.prototype.setCoords2 = function(coords) {
    this.pos[1] = coords[0];
    this.pos[2] = coords[1];
    return this;
};


MapPosition.prototype.getHeight = function() {
    return this.pos[4];
};


MapPosition.prototype.setHeight = function(height) {
    this.pos[4] = height;
    return this;
};


MapPosition.prototype.getOrientation = function() {
    return [this.pos[5], this.pos[6], this.pos[7]];
};


MapPosition.prototype.setOrientation = function(orientation) {
    this.pos[5] = orientation[0];
    this.pos[6] = orientation[1];
    this.pos[7] = orientation[2];
    return this;
};


MapPosition.prototype.getFov = function() {
    return this.pos[9];
};


MapPosition.prototype.setFov = function(fov) {
    this.pos[9] = fov;
    return this;
};


MapPosition.prototype.getViewExtent = function() {
    return this.pos[8];
};


MapPosition.prototype.setViewExtent = function(extent) {
    this.pos[8] = extent;
    return this;
};


MapPosition.prototype.getViewDistance = function() {
    return (this.getViewExtent()*0.5) / Math.tan(math.radians(this.getFov()*0.5));
};


MapPosition.prototype.getViewMode = function() {
    return this.pos[0];
};


MapPosition.prototype.getHeightMode = function() {
    return this.pos[3];
};


MapPosition.prototype.check = function() {
    //check pich
    if (this.getViewMode() == 'obj') {
        this.pos[6] = math.clamp(this.pos[6], -90.0, 90.0);
    } else {
        this.pos[6] = math.clamp(this.pos[6], -90.0, 90.0);
    }

    this.pos[5] = this.pos[5] % 360;
    this.pos[7] = this.pos[7] % 360;
};


MapPosition.prototype.isSame = function(pos) {
    pos = pos.pos;
    return (this.pos[0] == pos[0] &&
             math.isEqual(this.pos[1], pos[1], 0.0000001) &&
             math.isEqual(this.pos[2], pos[2], 0.0000001) &&
             this.pos[3] == pos[3] &&
             math.isEqual(this.pos[4], pos[4], 0.001) &&
             math.isEqual(this.pos[5], pos[5], 0.001) &&
             math.isEqual(this.pos[6], pos[6], 0.001) &&
             math.isEqual(this.pos[7], pos[7], 0.001) &&
             math.isEqual(this.pos[8], pos[8], 0.001) &&
             math.isEqual(this.pos[9], pos[9], 0.001));
};


MapPosition.prototype.validate = function() {
    const pos = this.pos;
    if (pos[0] == 'fixed') { //old format
        pos[0] = 'obj';
        pos[9] = pos[8];
        pos[8] = pos[7];
        pos[7] = pos[6];
        pos[6] = pos[5];
        pos[5] = pos[4];
        pos[4] = pos[3];
        pos[3] = 'fix';
    }

    pos[0] = (pos[0] == 'obj' || pos[0] == 'subj') ? pos[0] : 'obj';
    pos[1] = (pos[1] != null) ? pos[1] : 0;
    pos[2] = (pos[2] != null) ? pos[2] : 0;
    pos[3] = (pos[3] == 'fix' || pos[3] == 'fixed' || pos[3] == 'float') ? pos[3] : 'float';
    pos[4] = (pos[4] != null) ? pos[4] : 0;
    pos[5] = (pos[5] != null) ? pos[5] : 0;
    pos[6] = (pos[6] != null) ? pos[6] : -90;
    pos[7] = (pos[7] != null) ? pos[7] : 0;
    pos[8] = (pos[8] != null) ? pos[8] : 900;
    pos[9] = (pos[9] != null) ? pos[9] : 45;

    pos[3] = (pos[3] == 'fixed') ? 'fix' : pos[3];
};


MapPosition.prototype.toString = function() {
    const p = this.pos;
    return p[0] + ', ' + p[1].toFixed(0) + ', ' + p[2].toFixed(0) + ', ' + p[3] + ', ' + p[4].toFixed(0)
           + ', ' + p[5].toFixed(0) + ', ' + p[6].toFixed(0) + ', ' + p[7].toFixed(0) + ', '
           + ', ' + p[8].toFixed(0) + ', ' + p[9].toFixed(0);
};


MapPosition.prototype.toArray = function() {
    return this.pos.slice();
};


/* harmony default export */ __webpack_exports__["default"] = (MapPosition);


/***/ }),

/***/ "./src/core/map/refframe.js":
/*!**********************************!*\
  !*** ./src/core/map/refframe.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _division_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./division-node */ "./src/core/map/division-node.js");



//get rid of compiler mess
const MapDivisionNode = _division_node__WEBPACK_IMPORTED_MODULE_0__["default"];


const MapRefFrame = function(map, json) {
    this.map = map;
    this.proj4 = map.proj4;
    this.valid = false;
    this.id = json['id'] || null;
    this.description = json['description'] || '';
    this.nodesMap = [];

    const model = json['model'];

    if (model == null) {
        return;
    }

    this.model = {
        physicalSrs : map.getMapsSrs(model['physicalSrs']),
        navigationSrs : map.getMapsSrs(model['navigationSrs']),
        publicSrs : map.getMapsSrs(model['publicSrs'])
    };

    this.body = json['body'] ? map.getBody(json['body']) : null;

    this.params = {};

    if (json['parameters'] != null) {
        const params = json['parameters'];
        this.params.metaBinaryOrder = params['metaBinaryOrder'] || 1;
        this.params.navDelta = params['navDelta'] || 8;
    }

    const division = json['division'];

    if (division == null) {
        return;
    }

    this.division = {
        rootLod : division['rootLod'] || 0,
        arity : division['arity'] || null,
        heightRange : division['heightRange'] || [0,1]
    };

    const extents = this.parseSpaceExtents(division['extents']);
    this.division.extents = extents;

    map.spaceExtentSize = [extents.ur[0] - extents.ll[0], extents.ur[1] - extents.ll[1], extents.ur[2] - extents.ll[2]];
    map.spaceExtentOffset = extents.ll;

    const divisionNodes = division['nodes'];
    this.division.nodes = [];

    if (divisionNodes == null) {
        return;
    }

    this.hasPoles = (divisionNodes.length == 4);

    for (let i = 0, li = divisionNodes.length; i < li; i++) {
        const node = this.parseNode(divisionNodes[i]);
        this.nodesMap['' + node.id[0] + '.'  + node.id[1] + '.' + node.id[2]] = node;
        this.division.nodes.push(node);
    }

    this.valid = true;
};


MapRefFrame.prototype.getInfo = function() {
    return {
        'id' : this.id,
        'physicalSrs' : this.model.physicalSrs.id,
        'navigationSrs' : this.model.navigationSrs.id,
        'publicSrs' : this.model.publicSrs.id
    };
};


MapRefFrame.prototype.getGlobalHeightRange = function() {
    return this.division.heightRange;
};


MapRefFrame.prototype.parseNode = function(nodeData) {
    const node = {
        srs : nodeData['srs'],
        partitioning : nodeData['partitioning']
    };

    node.extents = this.parseExtents(nodeData['extents']);

    const nodeId = nodeData['id'];

    if (nodeId == null) {
        return;
    }

    node.id = {
        lod : nodeId['lod'] || 0,
        position : nodeId['position'] || [0,0]
    };

    return new MapDivisionNode(this.map, [node.id.lod, node.id.position[0], node.id.position[1]],
                                           node.srs, node.extents, this.heightRange, node.partitioning);
};


MapRefFrame.prototype.parseExtents = function(extentsData) {
    if (extentsData == null) {
        return { ll : [0,0], ur : [1,1] };
    }

    return {
        ll : extentsData['ll'] || [0,0],
        ur : extentsData['ur'] || [1,1]
    };
};


MapRefFrame.prototype.parseSpaceExtents = function(extentsData) {
    if (extentsData == null) {
        return { ll : [0,0,0], ur : [1,1,1] };
    }

    return {
        ll : extentsData['ll'] || [0,0,0],
        ur : extentsData['ur'] || [1,1,1]
    };
};


MapRefFrame.prototype.getSpatialDivisionNodes = function() {
    return this.division.nodes;
};


MapRefFrame.prototype.convertCoords = function(coords, source, destination) {
    let sourceSrs, destinationSrs;

    switch(source) {
    case 'public':     sourceSrs = this.model.publicSrs;     break;
    case 'physical':   sourceSrs = this.model.physicalSrs;   break;
    case 'navigation': sourceSrs = this.model.navigationSrs; break;
    }

    switch(destination) {
    case 'public':     destinationSrs = this.model.publicSrs;     break;
    case 'physical':   destinationSrs = this.model.physicalSrs;   break;
    case 'navigation': destinationSrs = this.model.navigationSrs; break;
    }

    return sourceSrs.convertCoordsTo(coords, destinationSrs);
};


/* harmony default export */ __webpack_exports__["default"] = (MapRefFrame);


/***/ }),

/***/ "./src/core/map/render-slots.js":
/*!**************************************!*\
  !*** ./src/core/map/render-slots.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


const MapRenderSlots = function(map) {
    this.map = map;
    this.draw = map.draw;
    this.renderer = map.renderer;
    this.config = map.config;
    this.renderSlots = [];
};


MapRenderSlots.prototype.createRenderSlot = function(id, callback, enabled) {
    return { id:id,
        callback:callback,
        enabled : enabled
    };
};


MapRenderSlots.prototype.addRenderSlot = function(id, callback, enabled) {
    this.renderSlots.push(this.createRenderSlot(id, callback, enabled));
};


MapRenderSlots.prototype.getRenderSlotIndex = function(id) {
    return this.map.searchArrayIndexById(this.renderSlots, id);
};


MapRenderSlots.prototype.checkRenderSlotId = function(id) {
    if (id == 'after-map-render') {
        return 'map';
    } else {
        return id;
    }
};


MapRenderSlots.prototype.moveRenderSlotBefore = function(whichId, whereId) {
    const from = this.getRenderSlotIndex(this.checkRenderSlotId(whichId));
    const to = this.getRenderSlotIndex(whereId);
    if (from != -1 && to != -1 && to != from-1) {
        this.renderSlots.splice(to, 0, this.renderSlots.splice(from, 1)[0]);
    }
};


MapRenderSlots.prototype.moveRenderSlotAfter = function(whichId, whereId) {
    const from = this.getRenderSlotIndex(this.checkRenderSlotId(whichId));
    let to = this.getRenderSlotIndex(whereId);
    if (from != -1 && to != -1 && to != from+1) {
        to++;
        this.renderSlots.splice(to, 0, this.renderSlots.splice(from, 1)[0]);
    }
};


MapRenderSlots.prototype.removeRenderSlot = function(id) {
    const index = this.getRenderSlotIndex(id);
    if (index != -1) {
        this.renderSlots.splice(index, 1);
    }
};


MapRenderSlots.prototype.setRenderSlotEnabled = function(id, state) {
    const index = this.getRenderSlotIndex(id);
    if (index != -1) {
        this.renderSlots[index].enabled = state;
    }
};


MapRenderSlots.prototype.getRenderSlotEnabled = function(id) {
    const index = this.getRenderSlotIndex(id);
    if (index != -1) {
        return this.renderSlots[index].enabled;
    }

    return false;
};


MapRenderSlots.prototype.processRenderSlots = function() {
    if (this.draw.drawChannel != 1) {
        this.renderer.gpu.setViewport(); //just in case
    }

    for (let i = 0, li = this.renderSlots.length; i < li; i++) {
        const slot = this.renderSlots[i];

        if (slot.enabled && slot.callback) {
            this.renderer.gpu.setState(this.draw.drawTileState);
            slot.callback(this.draw.drawChannelNames[this.draw.drawChannel]);
        }
    }
};


/* harmony default export */ __webpack_exports__["default"] = (MapRenderSlots);


/***/ }),

/***/ "./src/core/map/resource-node.js":
/*!***************************************!*\
  !*** ./src/core/map/resource-node.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./texture */ "./src/core/map/texture.js");
/* harmony import */ var _subtexture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subtexture */ "./src/core/map/subtexture.js");
/* harmony import */ var _metatile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metatile */ "./src/core/map/metatile.js");
/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mesh */ "./src/core/map/mesh.js");
/* harmony import */ var _geodata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geodata */ "./src/core/map/geodata.js");
/* harmony import */ var _pointcloud__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pointcloud */ "./src/core/map/pointcloud.js");








//get rid of compiler mess
const MapTexture = _texture__WEBPACK_IMPORTED_MODULE_0__["default"];
const MapSubtexture = _subtexture__WEBPACK_IMPORTED_MODULE_1__["default"];
const MapMetatile = _metatile__WEBPACK_IMPORTED_MODULE_2__["default"];
const MapMesh = _mesh__WEBPACK_IMPORTED_MODULE_3__["default"];
const MapGeodata = _geodata__WEBPACK_IMPORTED_MODULE_4__["default"];
const MapPointCloud = _pointcloud__WEBPACK_IMPORTED_MODULE_5__["default"];


const MapResourceNode = function(map, parent, id) {
    this.map = map;
    this.id = id;
    this.parent = parent;

    this.metatiles = {};
    this.meshes = {};
    this.textures = {};
    this.subtextures = {};
    this.geodata = {};
    this.credits = {};

    this.children = [null, null, null, null];
};


MapResourceNode.prototype.kill = function() {
    //kill children
    for (let i = 0; i < 4; i++) {
        if (this.children[i] != null) {
            this.children[i].kill();
        }
    }

    this.children = [null, null, null, null];

    const parent = this.parent;
    this.parent = null;

    if (parent != null) {
        parent.removeChild(this);
    }

    //kill resources?
};


MapResourceNode.prototype.addChild = function(index) {
    if (this.children[index]) {
        return;
    }

    const id = this.id;
    const childId = [id[0] + 1, id[1] << 1, id[2] << 1];

    switch (index) {
    case 1: childId[1]++; break;
    case 2: childId[2]++; break;
    case 3: childId[1]++; childId[2]++; break;
    }

    this.children[index] = new MapResourceNode(this.map, this, childId);
};


MapResourceNode.prototype.removeChildByIndex = function(index) {
    if (this.children[index] != null) {
        this.children[index].kill();
        this.children[index] = null;
    }
};


MapResourceNode.prototype.removeChild = function(tile) {
    for (let i = 0; i < 4; i++) {
        if (this.children[i] == tile) {
            this.children[i].kill();
            this.children[i] = null;
        }
    }
};


// Meshes ---------------------------------

MapResourceNode.prototype.getMesh = function(path, tile) {
    let mesh = this.meshes[path];

    if (!mesh) {
        mesh = new MapMesh(this.map, path, tile);
        this.meshes[path] = mesh;
    }

    return mesh;
};


// Point Clouds ---------------------------------

MapResourceNode.prototype.getPointCloud = function(path, tile, offset, size) {
    if (!this.pointclouds) this.pointclouds = {};

    const path2 = offset ? path+'@'+offset : path;
    let pointcloud = this.pointclouds[path2];

    if (!pointcloud) {
        pointcloud = new MapPointCloud(this.map, path, tile, offset, size);
        this.pointclouds[path2] = pointcloud;
    }

    return pointcloud;
};


// Geodata ---------------------------------

MapResourceNode.prototype.getGeodata = function(path, extraInfo) {
    let geodata = this.geodata[path];

    if (!geodata) {
        geodata = new MapGeodata(this.map, path, extraInfo);
        this.geodata[path] = geodata;
    }

    return geodata;
};


// Textures ---------------------------------

MapResourceNode.prototype.getTexture = function(path, type, extraBound, extraInfo, tile, internal) {
    let texture;
    if (extraInfo && (extraInfo.layer || extraInfo.hmap)) {
        const id = path + (extraInfo.hmap ? '' : extraInfo.layer.id);
        texture = this.textures[id];

        if (!texture) {
            texture = new MapTexture(this.map, path, type, extraBound, extraInfo, tile, internal);
            this.textures[id] = texture;
        }
    } else {
        texture = this.textures[path];

        if (!texture) {
            texture = new MapTexture(this.map, path, type, extraBound, extraInfo, tile, internal);
            this.textures[path] = texture;
        }
    }

    return texture;
};


// SubTextures ---------------------------------

MapResourceNode.prototype.getSubtexture = function(texture, path, type, extraBound, extraInfo, tile, internal) {
    texture = this.subtextures[path];

    if (!texture) {
        texture = new MapSubtexture(this.map, path, type, extraBound, extraInfo, tile, internal);
        this.subtextures[path] = texture;
    }

    return texture;
};


// Metatiles ---------------------------------

MapResourceNode.prototype.addMetatile = function(path, metatile) {
    this.metatiles[path] = metatile;
};


MapResourceNode.prototype.removeMetatile = function(metatile) {
    for (let key in this.metatiles) {
        if (this.metatiles[key] == metatile) {
            delete this.metatiles[key];
        }
    }
};


MapResourceNode.prototype.getMetatile = function(surface, allowCreation, tile) {
    const metatiles = this.metatiles;
    let metatile;
    for (let key in metatiles) {
        if (metatiles[key].surface == surface) {
            return metatiles[key];
        }
    }

    const path = surface.getMetaUrl(this.id);

    if (metatiles[path]) {
        metatile = metatiles[path].clone(surface);
        this.addMetatile(path, metatile);
        return metatile;
    }

    if (allowCreation) {
        metatile = new MapMetatile(this, surface, tile);
        this.addMetatile(path, metatile);
        return metatile;
    } else {
        return null;
    }
};


/* harmony default export */ __webpack_exports__["default"] = (MapResourceNode);


/***/ }),

/***/ "./src/core/map/resource-tree.js":
/*!***************************************!*\
  !*** ./src/core/map/resource-tree.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _resource_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resource-node */ "./src/core/map/resource-node.js");



//get rid of compiler mess
const MapResourceNode = _resource_node__WEBPACK_IMPORTED_MODULE_0__["default"];


const MapResourceTree = function(map) {
    this.map = map;
    this.tree = new MapResourceNode(map, null, [0,0,0]);
};


MapResourceTree.prototype.kill = function() {
    this.tree.kill();
};


MapResourceTree.prototype.findNode = function(id, createNonexisted) {
    let node = this.tree; //TODO: fix is it same way as findNavTile

    //console.log("--------------findNode: " + JSON.stringify(id));

//    for (const lod = 1; lod <= id[0]; lod++) {
    for (let lod = id[0]; lod > 0; lod--) {
        const mask = 1 << (lod-1);
        let index = 0;

        if ((id[1] & mask) != 0) {
            index += 1;
        }

        if ((id[2] & mask) != 0) {
            index += 2;
        }

        if (!node.children[index]) {
            if (createNonexisted) {
                node.addChild(index);
                //console.log("addNode: " + JSON.stringify(node.children[index].id));
            } else {
                return null;
            }
        }

        node = node.children[index];
    }

    return node;
};


MapResourceTree.prototype.findAgregatedNode = function(id, agregation, createNonexisted) {
    //const rootLod = 0;  //TODO: fix is it same way as findNavTile
    let node = this.tree;
    const ix = ((id[1] >> agregation) << agregation);
    const iy = ((id[2] >> agregation) << agregation);


//    for (const lod = id[0]; lod > rootLod; lod--) {
//        const i = lod - rootLod;
//        const index = 0;
//        const mask = 1 << (i-1);

    for (let lod = id[0]; lod > 0; lod--) {
        const mask = 1 << (lod-1);
        let index = 0;

        if ((ix & mask) != 0) {
            index += 1;
        }

        if ((iy & mask) != 0) {
            index += 2;
        }

        if (!node.children[index]) {
            if (createNonexisted) {
                node.addChild(index);
            } else {
                return null;
            }
        }

        node = node.children[index];
    }

    return node;
};


/* harmony default export */ __webpack_exports__["default"] = (MapResourceTree);


/***/ }),

/***/ "./src/core/map/srs.js":
/*!*****************************!*\
  !*** ./src/core/map/srs.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./texture */ "./src/core/map/texture.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var geographiclib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! geographiclib */ "./node_modules/geographiclib/geographiclib.js");
/* harmony import */ var geographiclib__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(geographiclib__WEBPACK_IMPORTED_MODULE_2__);





//get rid of compiler mess
const MapTexture = _texture__WEBPACK_IMPORTED_MODULE_0__["default"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_1__["math"];
const GeographicLib = geographiclib__WEBPACK_IMPORTED_MODULE_2___default.a;


const MapSrs = function(map, id, json) {
    this.map = map;
    this.id = id;
    this.proj4 = map.proj4;
    this.comment = json['comment'] || null;
    this.srsDef = json['srsDef'] || null;
    this.srsModifiers = json['srsModifiers'] || [];
    this.type = json['type'] || 'projected';
    this.vdatum = json['vdatum'] || 'orthometric';
    //this.srsDefEllps = json["srsDefEllps"] || "";
    this.srsDef = json['srsDefEllps'] || this.srsDef;
    this.periodicity = this.parsePeriodicity(json['periodicity']);
    this.srsInfo = this.proj4(this.srsDef).info();
    this.geoidGrid = null;
    this.geoidGridMap = null;
    this.srsProj4 = this.proj4(this.srsDef, null, null, true);
    this.latlonProj4 = null;
    this.proj4Cache = {};

    if (json['geoidGrid']) {
        const geoidGridData = json['geoidGrid'];

        this.geoidGrid = {
            definition : geoidGridData['definition'] || null,
            srsDefEllps : geoidGridData['srsDefEllps'] || null,
            valueRange : geoidGridData['valueRange'] || [0,1]
        };

        if (geoidGridData['extents']) {
            this.geoidGrid.extents = {
                ll : geoidGridData['extents']['ll'],
                ur : geoidGridData['extents']['ur']
            };
        } else {
            this.geoidGrid.extents = {
                ll : [0,0],
                ur : [1,1]
            };
        }

        if (this.geoidGrid.definition) {
            const url = this.map.url.makeUrl(this.geoidGrid.definition, {}, null);
            this.geoidGridMap = new MapTexture(this.map, url, true);
        }

        if (this.geoidGrid.srsDefEllps) {
            this.geoidGrid.srsProj4 = this.proj4(this.geoidGrid.srsDefEllps, null, null, true);
        }
    }

    if (this.type == 'geographic') {
        this.spheroid = json['spheroid'] || null;

        if (this.spheroid == null) {
            //TODO: return error
        }
    }
};


MapSrs.prototype.parsePeriodicity = function(periodicityData) {
    if (periodicityData == null) {
        return null;
    }

    const periodicity = {
        'type' : periodicityData['type'] || '',
        'period' : periodicityData['period'] || 0
    };

    return periodicity;
};


MapSrs.prototype.getInfo = function() {
    return {
        'comment' : this.comment,
        'srsDef' : this.srsDef,
        'srsModifiers' : this.srsModifiers,
        'type' : this.type,
        'vdatum' : this.vdatum,
        'srsDefEllps' : this.srsDef,
        'a' : this.srsInfo['a'],
        'b' : this.srsInfo['b']
    };
};


MapSrs.prototype.getSrsInfo = function() {
    return this.srsInfo;
};


MapSrs.prototype.isReady = function() {
    return this.isGeoidGridReady();
};


MapSrs.prototype.isGeoidGridReady = function() {
    return (this.geoidGrid == null ||
           (this.geoidGridMap != null && this.geoidGridMap.isReady()));
};


MapSrs.prototype.isProjected = function() {
    return (this.type == 'projected');
};


MapSrs.prototype.getOriginalHeight = function(coords) {
    let height = coords[2] || 0;
    height /= this.getVerticalAdjustmentFactor(coords);
    height += this.getGeoidGridDelta(coords);
    return height;
};


MapSrs.prototype.getFinalHeight = function(coords) {
    let height = coords[2] || 0;
    height -= this.getGeoidGridDelta(coords);
    height *= this.getVerticalAdjustmentFactor(coords);
    return height;
};


MapSrs.prototype.getGeoidGridDelta = function(coords) {
    if (this.geoidGridMap != null && this.isGeoidGridReady()) {
        //get cooords in geoidGrid space
        const mapCoords = this.proj4(this.srsProj4, this.geoidGrid.srsProj4, [coords[0], coords[1]]);

        //get image coords
        let px = mapCoords[0] - this.geoidGrid.extents.ll[0];
        let py = this.geoidGrid.extents.ur[1] - mapCoords[1];

        const imageExtens = this.geoidGridMap.getImageExtents();

        px *= imageExtens[0] / (this.geoidGrid.extents.ur[0] - this.geoidGrid.extents.ll[0]);
        py *= imageExtens[1] / (this.geoidGrid.extents.ur[1] - this.geoidGrid.extents.ll[1]);

        px = math.clamp(px, 0, imageExtens[0] - 2);
        py = math.clamp(py, 0, imageExtens[1] - 2);

        //get bilineary interpolated value from image
        const ix = Math.floor(px);
        const iy = Math.floor(py);
        const fx = px - ix;
        const fy = py - iy;

        const data = this.geoidGridMap.getImageData();
        const index = iy * imageExtens[0];
        const index2 = index + imageExtens[0];
        const h00 = data[(index + ix)*4];
        const h01 = data[(index + ix + 1)*4];
        const h10 = data[(index2 + ix)*4];
        const h11 = data[(index2 + ix + 1)*4];
        const w0 = (h00 + (h01 - h00)*fx);
        const w1 = (h10 + (h11 - h10)*fx);
        let delta = (w0 + (w1 - w0)*fy);

        //strech deta into value range
        delta = this.geoidGrid.valueRange[0] + (delta * ((this.geoidGrid.valueRange[1] - this.geoidGrid.valueRange[0]) / 255));

        return delta;
    }

    return 0;
};


MapSrs.prototype.getVerticalAdjustmentFactor = function(coords) {
    if (this.srsModifiers.indexOf('adjustVertical') != -1) {
        const info = this.getSrsInfo();

        //convert coords to latlon
        const latlonProj = '+proj=longlat ' +
                          ' +alpha=0' +
                          ' +gamma=0 +a=' + info['a'] +
                          ' +b=' + info['b'] +
                          ' +x0=0 +y0=0';

        if (!this.latlonProj4) {
            this.latlonProj4 = this.proj4(latlonProj, null, null, true);
        }

        let coords2 = this.proj4(this.srsProj4, this.latlonProj4, [coords[0], coords[1]]);

        //move coors 1000m
        const geod = new GeographicLib.Geodesic.Geodesic(info['a'],
                                                       (info['a'] / info['b']) - 1.0);


        const r = geod.Direct(coords2[1], coords2[0], 90, 1000);
        coords2 = [r.lon2, r.lat2];

        //convet coords from latlon back to projected
        coords2 = this.proj4(this.latlonProj4, this.srsProj4, coords2);

        //get distance between coords
        const dx = coords2[0] - coords[0];
        const dy = coords2[1] - coords[1];

        const distance = Math.sqrt(dx * dx + dy* dy);

        //get factor
        const factor = distance / 1000;

        return factor;
    }

    return 1.0;
};


MapSrs.prototype.convertCoordsTo = function(coords, srs, skipVerticalAdjust) {
    this.isReady();
    if (typeof srs !== 'string') {
        if (srs.id == this.id) {
            return coords.slice();
        }

        srs.isReady();
    }

    coords = coords.slice();

    const stringSrs = (typeof srs === 'string');

    //if (!skipVerticalAdjust && stringSrs) {
    coords[2] = this.getOriginalHeight(coords);
    //}

    const srsDef = (stringSrs) ? srs : srs.srsProj4;

    /*
    if (srsDef.isGeocent && this.srsProj4.projName == "merc") {
        const coords3 = coords.slice();
        this.convertMercToWGS(coords3);
        this.convertWGSToGeocent(coords3, srsDef);
        return coords3;
    }*/


    const srsDef2 = (stringSrs) ? srs : srs.srsDef;
    //const coords2 = this.proj4(this.srsProj4, srsDef, coords);

    let proj = this.proj4Cache[srsDef2];

    if (!proj) {
        proj = this.proj4(this.srsProj4, srsDef);
        this.proj4Cache[srsDef2] = proj;
    }

    const coords2 = proj.forward(coords);

    if (!skipVerticalAdjust && !stringSrs) {
        coords2[2] = srs.getFinalHeight(coords2);
    }

    return coords2;
};


MapSrs.prototype.convertCoordsToFast = function(coords, srs, skipVerticalAdjust, coords2, index, index2) {

    //if (!skipVerticalAdjust && stringSrs) {
        //coords[2] = this.getOriginalHeight(coords);
    //}

    const srsDef = srs.srsProj4;

    /*
    if (srsDef.isGeocent && this.srsProj4.projName == "merc") {
        this.convertMercToWGS(coords, coords2, index, index2);
        this.convertWGSToGeocent(coords2, srsDef, coords2, index2, index2);
        return;
    }*/

    const srsDef2 = srs.srsDef;

    let proj = this.proj4Cache[srsDef2];

    if (!proj) {
        proj = this.proj4(this.srsProj4, srsDef);
        this.proj4Cache[srsDef2] = proj;
    }

    const coords3 = proj.forward(coords);

    coords2[index2] = coords3[0];
    coords2[index2+1] = coords3[1];
    coords2[index2+2] = coords3[2];


    //if (!skipVerticalAdjust && stringSrs) {
        //coords2[2] = srs.getFinalHeight(coords2);
    //}

    if (srs.geoidGrid) {
        coords2[index2+2] -= srs.getGeoidGridDelta(coords);
    }
};


MapSrs.prototype.convertCoordsFrom = function(coords, srs) {
    this.isReady();
    if (typeof srs !== 'string') {
        if (srs.id == this.id) {
            return coords.slice();
        }

        srs.isReady();
    }

    coords = coords.slice();

    if (typeof srs !== 'string') {
        coords[2] = srs.getOriginalHeight(coords);
    }

    const srsDef = (typeof srs === 'string') ? srs : srs.srsProj4;
    const srsDef2 = (typeof srs === 'string') ? srs : srs.srsDef;

    //const coords2 = this.proj4(srsDef, this.srsProj4, coords);

    let proj = this.proj4Cache[srsDef2];

    if (!proj) {
        proj = this.proj4(this.srsProj4, srsDef);
        this.proj4Cache[srsDef2] = proj;
    }

    const coords2 = proj.inverse(coords);

    coords2[2] = this.getFinalHeight(coords2);

    return coords2;
};


MapSrs.prototype.phi2z = function(eccent, ts) {
    const HALFPI = Math.PI*0.5;
    const eccnth = 0.5 * eccent;
    let phi = HALFPI - 2 * Math.atan(ts);
    let con, dphi;
    for (let i = 0; i <= 15; i++) {
        con = eccent * Math.sin(phi);
        dphi = HALFPI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
        phi += dphi;
        if (Math.abs(dphi) <= 0.0000000001) {
            return phi;
        }
    }
  //console.log("phi2z has NoConvergence");
    return -9999;
};


MapSrs.prototype.convertMercToWGS = function(coords, coords2, index, index2) {
    const TWOPI = Math.PI * 2;
    const HALFPI = Math.PI*0.5;
    const proj = this.srsProj4;
    let x = coords[index] - proj.x0;
    let y = coords[index+1] - proj.y0;

    if (proj.sphere) {
        coords2[index2+1] = HALFPI - 2 * Math.atan(Math.exp(-y / (proj.a * proj.k0)));
    } else {
        const ts = Math.exp(-y / (proj.a * proj.k0));
        const yy = this.phi2z(proj.e, ts);
        coords2[index2+1] = yy;
        if (yy === -9999) {
            return;
        }
    }

    //coords[0] = adjustlon(proj.long0 + x / (proj.a * proj.k0));
    x = proj.long0 + x / (proj.a * proj.k0);
    const SPI = 3.14159265359;
    coords2[index2] = (Math.abs(x) <= SPI) ? x : (x - ((x < 0) ? -1 : 1) * TWOPI);
    coords2[index2+2] = coords[index+2];
};


MapSrs.prototype.convertWGSToGeocent = function(coords, srs, coords2, index, index2) {
    const datum = srs.datum;

    const HALFPI = Math.PI*0.5;
    let Longitude = coords[index];
    let Latitude = coords[index+1];
    const Height = coords[index+2]; //Z value not always supplied

    let Rn; /*  Earth radius at location  */
    let SinLat; /*  Math.sin(Latitude)  */
    let Sin2Lat; /*  Square of Math.sin(Latitude)  */
    let CosLat; /*  Math.cos(Latitude)  */

    /*
     ** Don't blow up if Latitude is just a little out of the value
     ** range as it may just be a rounding issue.  Also removed longitude
     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
     */
    if (Latitude < -HALFPI && Latitude > -1.001 * HALFPI) {
        Latitude = -HALFPI;
    }
    else if (Latitude > HALFPI && Latitude < 1.001 * HALFPI) {
        Latitude = HALFPI;
    }
    else if ((Latitude < -HALFPI) || (Latitude > HALFPI)) {
      /* Latitude out of range */
      //..reportError('geocent:lat out of range:' + Latitude);
        return null;
    }

    if (Longitude > Math.PI) {
        Longitude -= (2 * Math.PI);
    }

    SinLat = Math.sin(Latitude);
    CosLat = Math.cos(Latitude);
    Sin2Lat = SinLat * SinLat;
    Rn = datum.a / (Math.sqrt(1.0e0 - datum.es * Sin2Lat));
    coords2[index2] = (Rn + Height) * CosLat * Math.cos(Longitude);
    coords2[index2+1] = (Rn + Height) * CosLat * Math.sin(Longitude);
    coords2[index2+2] = ((Rn * (1 - datum.es)) + Height) * SinLat;
};


/* harmony default export */ __webpack_exports__["default"] = (MapSrs);


/***/ }),

/***/ "./src/core/map/stats.js":
/*!*******************************!*\
  !*** ./src/core/map/stats.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const MapStats = function(map) {
    this.map = map;
    this.core = map.core;
    this.inspector = map.core.inspector;
    this.drawnTiles = 0;
    this.drawnGeodataTiles = 0;
    this.drawnGeodataTilesFactor = 0;
    this.drawnGeodataTilesPerLayer = 0;
    this.drawnFaces = 0;
    this.drawCalls = 0;
    this.usedNodes = 0;
    this.processedNodes = 0;
    this.processedMetatiles = 0;
    this.counter = 0;
    this.statsCycle = 0;
    this.fps = 0;
    this.frameTime = 0;
    this.renderTime = 0;
    this.renderTimeTmp = 0;
    this.renderTimeBegin = 0;
    this.renderBuild = 0;
    this.lastRenderTime = 0;
    this.lastFrameTime = 0;
    this.renderedLods = new Array(32);
    this.debugIds = {};

    this.recordGraphs = false;
    this.graphsTimeIndex = 0;
    this.graphsLastTimeIndex = 0;
    this.graphsTimeSamples = 900;
    this.graphsRenderTimes = new Array(this.graphsTimeSamples);
    this.graphsCreateMeshTimes = new Array(this.graphsTimeSamples);
    this.graphsCreateGpuMeshTimes = new Array(this.graphsTimeSamples);
    this.graphsCreateTextureTimes = new Array(this.graphsTimeSamples);
    this.graphsFrameTimes = new Array(this.graphsTimeSamples);
    this.graphsCpuMemoryMetatiles = new Array(this.graphsTimeSamples);
    this.graphsCpuMemoryUsed = new Array(this.graphsTimeSamples);
    this.graphsGpuMemoryTextures = new Array(this.graphsTimeSamples);
    this.graphsGpuMemoryMeshes = new Array(this.graphsTimeSamples);
    this.graphsGpuMemoryGeodata = new Array(this.graphsTimeSamples);
    this.graphsGpuMemoryRender = new Array(this.graphsTimeSamples);
    this.graphsPolygons = new Array(this.graphsTimeSamples);
    this.graphsLODs = new Array(this.graphsTimeSamples);
    this.graphsBuild = new Array(this.graphsTimeSamples);
    this.graphsFluxTextures = new Array(this.graphsTimeSamples);
    this.graphsFluxMeshes = new Array(this.graphsTimeSamples);
    this.graphsFluxGeodatas = new Array(this.graphsTimeSamples);
    this.graphsFluxTexture = [[0,0],[0,0]];
    this.graphsFluxMesh = [[0,0],[0,0]];
    this.graphsFluxGeodata = [[0,0],[0,0]];
    this.graphsCreateTextureTime = 0;
    this.graphsCreateGpuMeshTime = 0;
    this.graphsCreateMeshTime = 0;
    this.resetGraphs();

    this.meshesFaces = 0;
    this.meshesUVArea = 0;
    this.gpuMeshes = 0;
    this.gpuTextures = 0;
    this.gpuGeodata = 0;
    this.gpuUsed = 0;
    this.resourcesUsed = 0;
    this.metaUsed = 0;
    this.gpuRenderUsed = 0;
    this.loadedCount = 0;
    this.loadErrorCount = 0;
    this.loadFirst = 0;
    this.loadLast = 0;
    this.gpuNeeded = 0;
    this.gpuNeeded2 = 0;
    this.octoNodes = 0;
    this.octoNodesMemSize = 0;

    this.heightClass = 0;
    this.heightLod = 0;
    this.heightNode = 0;
    this.heightTerrain = 0;
    this.heightDelta = 0;
    this.debugStr = null;
};

//Object.defineProperty(MapStats.prototype, 'gpuNeeded', {
    //get: function() { return this.gpuNeeded2; /*console.log(""+this.gpuNeeded);*/ },
    //set: function(value) {
        //this.gpuNeeded2 = value; console.log(""+this.gpuNeeded);
    //}
//});


MapStats.prototype.resetGraphs = function() {
    this.graphsTimeIndex = 0;

    for (let i = 0; i < this.graphsTimeSamples; i++) {
        this.graphsRenderTimes[i] = 0;
        this.graphsCreateMeshTimes[i] = 0;
        this.graphsCreateGpuMeshTimes[i] = 0;
        this.graphsCreateTextureTimes[i] = 0;
        this.graphsFrameTimes[i] = 0;
        this.graphsCpuMemoryUsed[i] = 0;
        this.graphsCpuMemoryMetatiles[i] = 0;
        this.graphsGpuMemoryTextures[i] = 0;
        this.graphsGpuMemoryMeshes[i] = 0;
        this.graphsGpuMemoryGeodata[i] = 0;
        this.graphsGpuMemoryRender[i] = 0;
        this.graphsPolygons[i] = 0;
        this.graphsLODs[i] = [0,[]];
        this.graphsBuild[i] = 0;
        this.graphsFluxTextures[i] = [[0,0],[0,0]];
        this.graphsFluxMeshes[i] = [[0,0],[0,0]];
        this.graphsFluxGeodatas[i] = [[0,0],[0,0]];
    }
};


MapStats.prototype.begin = function(dirty) {
    if (dirty) {
        this.drawnTiles = 0;
        this.drawnGeodataTiles = 0;
        this.drawnGeodataTilesFactor = 0;
        this.drawnGeodataTilesPerLayer = 0;
        this.drawCalls = 0;
        this.drawnFaces = 0;
        this.gpuRenderUsed = 0;
        this.gpuNeeded = 0;
        this.usedNodes = 0;
        this.processedNodes = 0;
        this.processedMetatiles = 0;
        this.meshesFaces = 0;
        this.meshesUVArea = 0;

        for (let i = 0, li = this.renderedLods.length; i < li; i++) {
            this.renderedLods[i] = 0;
        }
    }

    this.debugIds = {};

    this.counter++;
    this.statsCycle++;

    this.renderTimeBegin = performance.now();

    if (dirty) {
        if (this.lastFrameTime) {
            this.frameTime = this.renderTimeBegin - this.lastFrameTime;
        }

        this.lastFrameTime = this.renderTimeBegin;
    }
};


MapStats.prototype.end = function(dirty) {
    const timer = performance.now();

    const renderTime = timer - this.renderTimeBegin;
    //const frameTime = timer - this.frameTime;
    //this.frameTime = timer;
    if (dirty) {
        this.renderTimeTmp += renderTime;
        this.lastRenderTime = renderTime;
    } else {
        this.renderTimeTmp += this.lastRenderTime;
    }

    if (this.recordGraphs) {
        const i = this.graphsTimeIndex;

        this.graphsRenderTimes[i] = renderTime;
        this.graphsCreateMeshTimes[i] = 0;
        this.graphsCreateGpuMeshTimes[i] = 0;
        this.graphsCreateTextureTimes[i] = 0;
        this.graphsFrameTimes[i] = this.frameTime;
        this.graphsCpuMemoryUsed[i] = this.map.resourcesCache.totalCost;
        this.graphsCpuMemoryMetatiles[i] = this.map.metatileCache.totalCost;
        this.graphsGpuMemoryTextures[i] = this.gpuTextures;
        this.graphsGpuMemoryMeshes[i] = this.gpuMeshes;
        this.graphsGpuMemoryGeodata[i] = this.gpuGeodata;
        this.graphsGpuMemoryRender[i] = this.gpuRenderUsed;
        this.graphsPolygons[i] = this.drawnFaces;
        this.graphsFluxTextures[i] = [[this.graphsFluxTexture[0][0], this.graphsFluxTexture[0][1]], [this.graphsFluxTexture[1][0], this.graphsFluxTexture[1][1]] ];
        this.graphsFluxMeshes[i] = [[this.graphsFluxMesh[0][0], this.graphsFluxMesh[0][1]], [this.graphsFluxMesh[1][0], this.graphsFluxMesh[1][1]] ];
        this.graphsFluxGeodatas[i] = [[this.graphsFluxGeodata[0][0], this.graphsFluxGeodata[0][1]], [this.graphsFluxGeodata[1][0], this.graphsFluxGeodata[1][1]] ];
        this.graphsLODs[i] = [this.drawnTiles, this.renderedLods.slice()];
        this.graphsBuild[i] = this.renderBuild;

        this.graphsTimeIndex = (this.graphsTimeIndex + 1) % this.graphsTimeSamples;

        if (this.inspector && this.inspector.graphs) {
            this.inspector.graphs.updateGraphs(this);
        }
    }


    if ((this.statsCycle % 50) == 0) {
        this.renderTime = this.renderTimeTmp / 100;
        this.fps = 1000 / this.renderTime;
        this.renderTimeTmp = 0;

        if (this.inspector && this.inspector.stats) {
            this.gpuUsed = this.map.gpuCache.totalCost;
            this.resourcesUsed = this.map.resourcesCache.totalCost;
            this.metaUsed = this.map.metatileCache.totalCost;

            this.inspector.stats.updateStatsPanel(this);
        }
    }

    //do not reset flux data in begin function, because we to collect data from events which
    this.graphsFluxTexture = [[0,0],[0,0]];
    this.graphsFluxMesh = [[0,0],[0,0]];
    this.graphsFluxGeodata = [[0,0],[0,0]];
    this.debugStr = this.map.renderer.debugStr;
};


/* harmony default export */ __webpack_exports__["default"] = (MapStats);


/***/ }),

/***/ "./src/core/map/stylesheet.js":
/*!************************************!*\
  !*** ./src/core/map/stylesheet.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");



//get rid of compiler mess
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["utils"];


const MapStylesheet = function(map, id, url, freeLayer) {
    this.generateLines = true;
    this.map = map;
    this.renderer = this.map.renderer;
    this.stats = map.stats;
    this.id  = id;
    this.url  = null;
    this.data = null;
    this.loadState = 0;
    this.size = 0;
    this.fileSize = 0;
    this.freeLayer = freeLayer;
    this.fonts = {};
    this.fontsReady = false;

    if (typeof url === 'object') {
        this.data = url;
        this.setFonts(this.data);
        this.loadState = 2;
        this.map.markDirty();
    } else {
        if (this.freeLayer) {
            this.url = this.freeLayer.processUrl(url, '');
        } else {
            this.url = this.map.url.processUrl(url);
        }

        //load style directly
        utils.loadJSON(this.url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, (utils.useCredentials ? (this.url.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
        this.loadState = 1;
    }
};


MapStylesheet.prototype.kill = function() {
};


MapStylesheet.prototype.setData = function(data) {
    this.data = data;
    this.setFonts(data);
    this.loadState = 2;
    this.checkFonts();
};

MapStylesheet.prototype.checkFonts = function() {
    let ready = true;
    for (let key in this.fonts) {
        ready = (ready && this.renderer.getFont(this.fonts[key]).isReady());
    }

    this.fontsReady = ready;

    return ready;
};

MapStylesheet.prototype.isReady = function(doNotLoad, priority) {

    if (this.loadState == 2) { //loaded

        if (this.fontsReady) {
            return true;
        } else {
            return this.checkFonts();
        }

    } else {
        if (this.loadState == 0) {
            if (doNotLoad) {
                //remove from queue
                //if (this.mapLoaderUrl) {
                  //  this.map.loader.remove(this.mapLoaderUrl);
                //}
            } else {
                //not loaded
                //add to loading queue or top position in queue
                this.scheduleLoad(priority);
            }
        } //else load in progress
    }

    return false;
};


MapStylesheet.prototype.scheduleLoad = function(priority) {
    this.map.loader.load(this.url, this.onLoad.bind(this), priority);
};


MapStylesheet.prototype.onLoad = function() {
    //this.mapLoaderCallLoaded = onLoaded;
    //this.mapLoaderCallError = onError;

    this.loadState = 1;
};


MapStylesheet.prototype.onLoadError = function() {
    if (this.map.killed){
        return;
    }

    //this.mapLoaderCallError();
    //this.loadState = 2;
};

MapStylesheet.prototype.setFonts = function(data) {
    this.fonts = data['fonts'] || {};

    if (!this.fonts['#default']) {
        this.fonts['#default'] = this.map.core.config.mapDefaultFont;
    }
};

MapStylesheet.prototype.onLoaded = function(data) {
    if (this.map.killed){
        return;
    }

    this.data = data;
    this.setFonts(data);

    //this.mapLoaderCallLoaded();
    this.loadState = 2;
    this.map.markDirty();
};


// Returns RAM usage in bytes.
//MapStylesheet.prototype.getSize = function () {
  //  return this.size;
//};

//MapStylesheet.prototype.getFileSize = function () {
  //  return this.fileSize;
//};

/* harmony default export */ __webpack_exports__["default"] = (MapStylesheet);


/***/ }),

/***/ "./src/core/map/submesh.js":
/*!*********************************!*\
  !*** ./src/core/map/submesh.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var _renderer_bbox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/bbox */ "./src/core/renderer/bbox.js");
// An index-less mesh. Each triangle has three items in the array 'vertices'.



//import GpuMesh_ from '../renderer/gpu/mesh';


//get rid of compiler mess
const mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_1__["math"];
//const GpuMesh = GpuMesh_;
const BBox = _renderer_bbox__WEBPACK_IMPORTED_MODULE_2__["default"];


const MapSubmesh = function(mesh, stream) {
    this.generateLines = true;
    this.map = mesh.map;
    this.vertices = null;
    this.internalUVs = null;
    this.externalUVs = null;
    this.indices = null;
    this.mesh = mesh;
    this.statsCounter = 0;
    this.valid = true;
    this.killed = false;
    this.use16bit = mesh.use16bit;
    this.texture = null;

    this.bbox = new BBox();
    this.size = 0;
    this.faces = 0;
    this.uvArea = 0;
    this.uvAreaComputed = false;

    this.flagsInternalTexcoords =  1;
    this.flagsExternalTexcoords =  2;
    this.flagsPerVertexUndulation =  4;
    this.flagsTextureMode =  8;

    if (stream) {
        this.parseSubmesh(stream);
    }
};


MapSubmesh.prototype.kill = function () {
    this.killed = true;
    this.vertices = null;
    this.internalUVs = null;
    this.externalUVs = null;
    this.indices = null;

    if (this.texture) {
        this.texture.kill();
        this.texture = null;
    }
};


// Reads the mesh from the binary representation.
MapSubmesh.prototype.parseSubmesh = function (stream) {

/*
struct MapSubmesh {
    struct MapSubmeshHeader header;
    struct VerticesBlock vertices;
    struct TexcoordsBlock internalTexcoords;   // if header.flags & ( 1 << 0 )
    struct FacesBlock faces;
};
*/
    this.parseHeader(stream);
    if (this.mesh.version >= 3) {
        this.parseVerticesAndFaces2(stream);
    } else {
        this.parseVerticesAndFaces(stream);
    }
};


MapSubmesh.prototype.parseHeader = function (stream) {

/*
struct MapSubmeshHeader {
    char flags;                    // bit 0 - contains internal texture coords
                                   // bit 1 - contains external texture coords
                                   // bit 2 - contains per vertex undulation
                                   // bit 3 - texture mode (0 - internal, 1 - external)

    uchar surfaceReference;        // reference to the surface of origin, see bellow
    ushort textureLayer;           // applicable if texture mode is external: texture layer numeric id
    double boundingBox[2][3];      // read more about bounding box bellow
};
*/

    const streamData = stream.data;

    this.flags = streamData.getUint8(stream.index, true); stream.index += 1;

    if (this.mesh.version > 1) {
        this.surfaceReference = streamData.getUint8(stream.index, true); stream.index += 1;
    } else {
        this.surfaceReference = 0;
    }

    this.textureLayer = streamData.getUint16(stream.index, true); stream.index += 2;
    this.textureLayer2 = this.textureLayer; //hack for presentation

    const bboxMin = this.bbox.min;
    const bboxMax = this.bbox.max;

    bboxMin[0] = streamData.getFloat64(stream.index, true); stream.index += 8;
    bboxMin[1] = streamData.getFloat64(stream.index, true); stream.index += 8;
    bboxMin[2] = streamData.getFloat64(stream.index, true); stream.index += 8;

    bboxMax[0] = streamData.getFloat64(stream.index, true); stream.index += 8;
    bboxMax[1] = streamData.getFloat64(stream.index, true); stream.index += 8;
    bboxMax[2] = streamData.getFloat64(stream.index, true); stream.index += 8;

    this.bbox.updateMaxSize();
};


MapSubmesh.prototype.parseVerticesAndFaces = function (stream) {
/*
struct VerticesBlock {
    ushort numVertices;              // number of vertices

    struct Vertex {                  // array of vertices, size of array is defined by numVertices property
        // vertex coordinates
        ushort x;
        ushort y;
        ushort z;

        // if header.flags & ( 1 << 1 ): external texture coordinates
        // values in 2^16^ range represents the 0..1 normalized texture space
        ushort eu;
        ushort ev;

        // if header.flags & ( 1 << 2 ): undulation delta
        float16 undulationDelta;
    } vertices[];
};
*/

    const data = stream.data;
    const uint8Data = stream.uint8Data;
    let index = stream.index;

    const numVertices = data.getUint16(index, true); index += 2;

    if (!numVertices) {
        this.valid = false;
    }

    let internalUVs = null;
    let externalUVs = null;
    const onlyOneUVs = this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords);

    let vertices = this.use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));

    if (this.flags & this.flagsExternalTexcoords) {
        if (onlyOneUVs) {
            externalUVs = true;
        } else {
            externalUVs = this.use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));
        }
    }

    const uvfactor = this.use16bit ? 1.0 : (1.0 / 65535);
    let vindex = 0;
    let uvindex = 0;
    let i, li;

    for (i = 0; i < numVertices; i++) {
        vertices[vindex] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;
        vertices[vindex+1] = (uint8Data[index+2] + (uint8Data[index + 3]<<8)) * uvfactor;
        vertices[vindex+2] = (uint8Data[index+4] + (uint8Data[index + 5]<<8)) * uvfactor;
        vindex += 3;

        if (externalUVs) {
            if (!onlyOneUVs) {
                externalUVs[uvindex] = (uint8Data[index+6] + (uint8Data[index + 7]<<8)) * uvfactor;
                externalUVs[uvindex+1] = (65535 - (uint8Data[index+8] + (uint8Data[index + 9]<<8))) * uvfactor;
                uvindex += 2;
            }
            index += 10;
        } else {
            index += 6;
        }
    }


    this.tmpVertices = vertices;
    this.tmpExternalUVs = externalUVs;

/*
struct TexcoorsBlock {
    ushort numTexcoords;              // number of texture coordinates

    struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property

        // internal texture coordinates
        // values in 2^16^ range represents the 0..1 normalized texture space
        ushort u;
        ushort v;
    } texcoords[];
};
*/

    if (this.flags & this.flagsInternalTexcoords) {
        const numUVs = data.getUint16(index, true); index += 2;

        internalUVs = this.use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));

        for (i = 0, li = numUVs * 2; i < li; i+=2) {
            internalUVs[i] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;
            internalUVs[i+1] = (65535 - (uint8Data[index+2] + (uint8Data[index + 3]<<8))) * uvfactor;
            index += 4;
        }

        this.tmpInternalUVs = internalUVs;
    }

/*
struct FacesBlock {
    ushort numFaces;              // number of faces

    struct Face {                 // array of faces, size of array is defined by numFaces property

        ushort v[3]; // array of indices to stored vertices
        ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords

    } faces[];
};
*/

    const numFaces = data.getUint16(index, true); index += 2;
    let indices = null;

    internalUVs = null;
    externalUVs = null;

    const onlyExternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && !(this.flags & this.flagsInternalTexcoords));
    const onlyInternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords));
    const onlyIndices = onlyExternalIndices || onlyInternalIndices;

    if (onlyIndices) {
        indices = new Uint16Array(numFaces * 3);
    } else {
        vertices = this.use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));

        if (this.flags & this.flagsInternalTexcoords) {
            internalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));
        }

        if (!onlyOneUVs && (this.flags & this.flagsExternalTexcoords)) {
            externalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));
        }
    }

    let vtmp = this.tmpVertices;
    let eUVs = this.tmpExternalUVs;
    let iUVs = this.tmpInternalUVs;
    let v1, v2, v3, vv1, vv2, vv3, sindex;

    if (onlyExternalIndices) {
        vertices = this.tmpVertices;
        externalUVs = this.tmpExternalUVs;
    }

    if (onlyInternalIndices) {
        vertices = this.use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));
        internalUVs = this.tmpInternalUVs;
    }

    for (i = 0; i < numFaces; i++) {
        v1 = (uint8Data[index] + (uint8Data[index + 1]<<8));
        v2 = (uint8Data[index+2] + (uint8Data[index + 3]<<8));
        v3 = (uint8Data[index+4] + (uint8Data[index + 5]<<8));

        if (onlyIndices) {
            vindex = i * 3;

            if (internalUVs != null) {
                vv1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));
                vv2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));
                vv3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));

                vertices[vv1*3] = vtmp[v1*3];
                vertices[vv1*3+1] = vtmp[v1*3+1];
                vertices[vv1*3+2] = vtmp[v1*3+2];

                vertices[vv2*3] = vtmp[v2*3];
                vertices[vv2*3+1] = vtmp[v2*3+1];
                vertices[vv2*3+2] = vtmp[v2*3+2];

                vertices[vv3*3] = vtmp[v3*3];
                vertices[vv3*3+1] = vtmp[v3*3+1];
                vertices[vv3*3+2] = vtmp[v3*3+2];

                indices[vindex] = vv1;
                indices[vindex+1] = vv2;
                indices[vindex+2] = vv3;

                index += 12;
            } else {
                indices[vindex] = v1;
                indices[vindex+1] = v2;
                indices[vindex+2] = v3;

                index += 6;
            }

        } else {
            vindex = i * (3 * 3);

            sindex = v1 * 3;
            vertices[vindex] = vtmp[sindex];
            vertices[vindex+1] = vtmp[sindex+1];
            vertices[vindex+2] = vtmp[sindex+2];

            sindex = v2 * 3;
            vertices[vindex+3] = vtmp[sindex];
            vertices[vindex+4] = vtmp[sindex+1];
            vertices[vindex+5] = vtmp[sindex+2];

            sindex = v3 * 3;
            vertices[vindex+6] = vtmp[sindex];
            vertices[vindex+7] = vtmp[sindex+1];
            vertices[vindex+8] = vtmp[sindex+2];

            if (externalUVs != null) {
                vindex = i * (3 * 2);
                externalUVs[vindex] = eUVs[v1*2];
                externalUVs[vindex+1] = eUVs[v1*2+1];
                externalUVs[vindex+2] = eUVs[v2*2];
                externalUVs[vindex+3] = eUVs[v2*2+1];
                externalUVs[vindex+4] = eUVs[v3*2];
                externalUVs[vindex+5] = eUVs[v3*2+1];
            }

            if (internalUVs != null) {
                v1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));
                v2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));
                v3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));
                index += 12;

                vindex = i * (3 * 2);
                internalUVs[vindex] = iUVs[v1*2];
                internalUVs[vindex+1] = iUVs[v1*2+1];
                internalUVs[vindex+2] = iUVs[v2*2];
                internalUVs[vindex+3] = iUVs[v2*2+1];
                internalUVs[vindex+4] = iUVs[v3*2];
                internalUVs[vindex+5] = iUVs[v3*2+1];
            } else {
                index += 6;
            }
        }
    }

    this.vertices = vertices;
    this.internalUVs = internalUVs;
    this.externalUVs = externalUVs;
    this.indices = indices;

    this.tmpVertices = null;
    this.tmpInternalUVs = null;
    this.tmpExternalUVs = null;

    stream.index = index;

    this.size = this.vertices.byteLength;
    if (this.internalUVs) this.size += this.internalUVs.byteLength;
    if (this.externalUVs) this.size += this.externalUVs.byteLength;
    if (this.indices) this.size += this.indices.byteLength;
    this.faces = numFaces;
};


MapSubmesh.prototype.parseWord = function (data, res) {
    const value = data[res[1]];

    if (value & 0x80) {
        res[0] = (value & 0x7f) | (data[res[1]+1] << 7);
        res[1] += 2;
    } else {
        res[0] = value;
        res[1] ++;
    }
};


MapSubmesh.prototype.parseDelta = function (data, res) {
    let value = data[res[1]];

    if (value & 0x80) {
        value = (value & 0x7f) | (data[res[1]+1] << 7);

        if (value & 1) {
            res[0] = -((value >> 1)+1);
            res[1] += 2;
        } else {
            res[0] = (value >> 1);
            res[1] += 2;
        }
    } else {
        if (value & 1) {
            res[0] = -((value >> 1)+1);
            res[1] ++;
        } else {
            res[0] = (value >> 1);
            res[1] ++;
        }
    }
};


MapSubmesh.prototype.parseVerticesAndFaces2 = function (stream) {
/*
struct VerticesBlock {
    ushort numVertices;              // number of vertices
    ushort geomQuantCoef;            // geometry quantization coefficient

    struct Vertex {                  // array of vertices, size of array is defined by numVertices property
        // vertex coordinates
        delta x;
        delta y;
        delta z;
    } vertices[];
};
*/

    const data = stream.data;
    const uint8Data = stream.uint8Data;
    const onlyOneUVs = this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords);
    let index = stream.index;

    const numVertices = data.getUint16(index, true); index += 2;
    let quant = data.getUint16(index, true); index += 2;

    if (!numVertices) {
        this.valid = false;
    }

    const center = this.bbox.center();
    const scale = this.bbox.maxSize;

    let multiplier = 1.0 / quant;
    let externalUVs = null, internalUVs = null;

    let vertices = this.use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));
    let vindex;

    let x = 0, y = 0,z = 0;
    let cx = center[0], cy = center[1], cz = center[2];
    const mx = this.bbox.min[0];
    const my = this.bbox.min[1];
    const mz = this.bbox.min[2];
    const sx = 1.0 / (this.bbox.max[0] - this.bbox.min[0]);
    const sy = 1.0 / (this.bbox.max[1] - this.bbox.min[1]);
    const sz = 1.0 / (this.bbox.max[2] - this.bbox.min[2]);

    let res = [0, index];
    let i, li, t;

    if (this.use16bit) {
        for (i = 0; i < numVertices; i++) {
            this.parseDelta(uint8Data, res);
            x += res[0];
            this.parseDelta(uint8Data, res);
            y += res[0];
            this.parseDelta(uint8Data, res);
            z += res[0];

            vindex = i * 3;
            t = ((x * multiplier * scale + cx) - mx) * sx;
            if (t < 0) t = 0; if (t > 1.0) t = 1.0;
            vertices[vindex] = t * 65535;
            t = ((y * multiplier * scale + cy) - my) * sy;
            if (t < 0) t = 0; if (t > 1.0) t = 1.0;
            vertices[vindex+1] = t * 65535;
            t = ((z * multiplier * scale + cz) - mz) * sz;
            if (t < 0) t = 0; if (t > 1.0) t = 1.0;
            vertices[vindex+2] = t * 65535;
        }
    } else {
        for (i = 0; i < numVertices; i++) {
            this.parseDelta(uint8Data, res);
            x += res[0];
            this.parseDelta(uint8Data, res);
            y += res[0];
            this.parseDelta(uint8Data, res);
            z += res[0];

            vindex = i * 3;
            vertices[vindex] = ((x * multiplier * scale + cx) - mx) * sx;
            vertices[vindex+1] = ((y * multiplier * scale + cy) - my) * sy;
            vertices[vindex+2] = ((z * multiplier * scale + cz) - mz) * sz;
        }
    }

    index = res[1];

    if (this.flags & this.flagsExternalTexcoords) {
        quant = data.getUint16(index, true); index += 2;
        res[1] = index;

        if (onlyOneUVs) {

            for (i = 0; i < numVertices; i++) {
                this.parseDelta(uint8Data, res);
                this.parseDelta(uint8Data, res);
            }

        } else {
            multiplier = (this.use16bit) ? (65535 / quant) : (1.0 / quant);
            externalUVs = this.use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));
            x = 0, y = 0;

            if (this.use16bit) {
                for (i = 0; i < numVertices; i++) {
                    this.parseDelta(uint8Data, res);
                    x += res[0];
                    this.parseDelta(uint8Data, res);
                    y += res[0];

                    const uvindex = i * 2;
                    t = x * multiplier;
                    if (t < 0) t = 0; if (t > 65535) t = 65535;
                    externalUVs[uvindex] = t;
                    t = y * multiplier;
                    if (t < 0) t = 0; if (t > 65535) t = 65535;
                    externalUVs[uvindex+1] = 65535 - t;
                }
            } else {
                for (i = 0; i < numVertices; i++) {
                    this.parseDelta(uint8Data, res);
                    x += res[0];
                    this.parseDelta(uint8Data, res);
                    y += res[0];

                    const uvindex = i * 2;
                    externalUVs[uvindex] = x * multiplier;
                    externalUVs[uvindex+1] = 1 - (y * multiplier);
                }
            }
        }
    }

    index = res[1];

    this.tmpVertices = vertices;
    this.tmpExternalUVs = externalUVs;

/*
struct TexcoorsBlock {
    ushort numTexcoords;              // number of texture coordinates

    struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property

        // internal texture coordinates
        // values in 2^16^ range represents the 0..1 normalized texture space
        ushort u;
        ushort v;
    } texcoords[];
};
*/

    if (this.flags & this.flagsInternalTexcoords) {
        const numUVs = data.getUint16(index, true); index += 2;
        const quantU = data.getUint16(index, true); index += 2;
        const quantV = data.getUint16(index, true); index += 2;
        const multiplierU = (this.use16bit) ? (65536.0 / quantU) : (1.0 / quantU);
        const multiplierV = (this.use16bit) ? (65536.0 / quantV) : (1.0 / quantV);
        x = 0, y = 0;

        internalUVs = this.use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));
        res[1] = index;7

        if (this.use16bit) {
            for (i = 0, li = numUVs * 2; i < li; i+=2) {
                this.parseDelta(uint8Data, res);
                x += res[0];
                this.parseDelta(uint8Data, res);
                y += res[0];

                t = x * multiplierU;
                if (t < 0) t = 0; if (t > 65535) t = 65535;
                internalUVs[i] = t;
                t = y * multiplierV;
                if (t < 0) t = 0; if (t > 65535) t = 65535;
                internalUVs[i+1] = 65535 - t;
            }
        } else {
            for (i = 0, li = numUVs * 2; i < li; i+=2) {
                this.parseDelta(uint8Data, res);
                x += res[0];
                this.parseDelta(uint8Data, res);
                y += res[0];

                internalUVs[i] = x * multiplierU;
                internalUVs[i+1] = 1 - (y * multiplierV);
            }
        }

        index = res[1];

        this.tmpInternalUVs = internalUVs;
    }

/*
struct FacesBlock {
    ushort numFaces;              // number of faces

    struct Face {                 // array of faces, size of array is defined by numFaces property

        ushort v[3]; // array of indices to stored vertices
        ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords

    } faces[];
};
*/

    const numFaces = data.getUint16(index, true); index += 2;
    let indices = null;

    internalUVs = null;
    externalUVs = null;

    const onlyExternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && !(this.flags & this.flagsInternalTexcoords));
    const onlyInternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords));
    const onlyIndices = onlyExternalIndices || onlyInternalIndices;

    if (onlyIndices) {
        indices = new Uint16Array(numFaces * 3);
    } else {
        vertices = this.use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));

        if (this.flags & this.flagsInternalTexcoords) {
            internalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));
        }

        if (!onlyOneUVs && (this.flags & this.flagsExternalTexcoords)) {
            externalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));
        }
    }

    let vtmp = this.tmpVertices;
    let eUVs = this.tmpExternalUVs;
    let iUVs = this.tmpInternalUVs;
    let high = 0;
    let v1, v2, v3, vv1, vv2, vv3;
    res[1] = index;

    for (i = 0; i < numFaces; i++) {
        this.parseWord(uint8Data, res);
        v1 = high - res[0];
        if (!res[0]) { high++; }

        this.parseWord(uint8Data, res);
        v2 = high - res[0];
        if (!res[0]) { high++; }

        this.parseWord(uint8Data, res);
        v3 = high - res[0];
        if (!res[0]) { high++; }

        if (onlyIndices) {
            vindex = i * 3;
            indices[vindex] = v1;
            indices[vindex+1] = v2;
            indices[vindex+2] = v3;
        } else {
            vindex = i * (3 * 3);
            let sindex = v1 * 3;
            vertices[vindex] = vtmp[sindex];
            vertices[vindex+1] = vtmp[sindex+1];
            vertices[vindex+2] = vtmp[sindex+2];

            sindex = v2 * 3;
            vertices[vindex+3] = vtmp[sindex];
            vertices[vindex+4] = vtmp[sindex+1];
            vertices[vindex+5] = vtmp[sindex+2];

            sindex = v3 * 3;
            vertices[vindex+6] = vtmp[sindex];
            vertices[vindex+7] = vtmp[sindex+1];
            vertices[vindex+8] = vtmp[sindex+2];

            if (externalUVs != null) {
                vindex = i * (3 * 2);
                externalUVs[vindex] = eUVs[v1*2];
                externalUVs[vindex+1] = eUVs[v1*2+1];
                externalUVs[vindex+2] = eUVs[v2*2];
                externalUVs[vindex+3] = eUVs[v2*2+1];
                externalUVs[vindex+4] = eUVs[v3*2];
                externalUVs[vindex+5] = eUVs[v3*2+1];
            }
        }
    }

    if (onlyExternalIndices) {
        vertices = this.tmpVertices;
        externalUVs = this.tmpExternalUVs;
    }

    if (onlyInternalIndices) {
        vertices = this.use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));
        internalUVs = this.tmpInternalUVs;
    }

    high = 0;

    if (internalUVs != null) {
        for (i = 0; i < numFaces; i++) {
            this.parseWord(uint8Data, res);
            v1 = high - res[0];
            if (!res[0]) { high++; }

            this.parseWord(uint8Data, res);
            v2 = high - res[0];
            if (!res[0]) { high++; }

            this.parseWord(uint8Data, res);
            v3 = high - res[0];
            if (!res[0]) { high++; }

            if (onlyInternalIndices) {
                vindex = i * 3;

                vv1 = indices[vindex] * 3;
                vv2 = indices[vindex+1] * 3;
                vv3 = indices[vindex+2] * 3;

                vertices[v1*3] = vtmp[vv1];
                vertices[v1*3+1] = vtmp[vv1+1];
                vertices[v1*3+2] = vtmp[vv1+2];

                vertices[v2*3] = vtmp[vv2];
                vertices[v2*3+1] = vtmp[vv2+1];
                vertices[v2*3+2] = vtmp[vv2+2];

                vertices[v3*3] = vtmp[vv3];
                vertices[v3*3+1] = vtmp[vv3+1];
                vertices[v3*3+2] = vtmp[vv3+2];

                indices[vindex] = v1;
                indices[vindex+1] = v2;
                indices[vindex+2] = v3;
            } else {
                vindex = i * (3 * 2);
                internalUVs[vindex] = iUVs[v1*2];
                internalUVs[vindex+1] = iUVs[v1*2+1];
                internalUVs[vindex+2] = iUVs[v2*2];
                internalUVs[vindex+3] = iUVs[v2*2+1];
                internalUVs[vindex+4] = iUVs[v3*2];
                internalUVs[vindex+5] = iUVs[v3*2+1];
            }
        }
    }

    index = res[1];

    this.vertices = vertices;
    this.internalUVs = internalUVs;
    this.externalUVs = externalUVs;
    this.indices = indices;

    this.tmpVertices = null;
    this.tmpInternalUVs = null;
    this.tmpExternalUVs = null;

    stream.index = index;

    this.size = this.vertices.byteLength;
    if (this.internalUVs) this.size += this.internalUVs.byteLength;
    if (this.externalUVs) this.size += this.externalUVs.byteLength;
    if (this.indices) this.size += this.indices.byteLength;
    this.faces = numFaces;
};


// Returns RAM usage in bytes.
MapSubmesh.prototype.getSize = function () {
    return this.size;
};


MapSubmesh.prototype.getFileSize = function () {
    return this.fileSize;
};


MapSubmesh.prototype.buildGpuMesh = function () {

    return this.map.renderer.gpu.createMesh(

        {
            bbox: this.bbox,
            vertices: this.vertices,
            uvs: this.internalUVs,
            uvs2: this.externalUVs,
            indices: this.indices,
            use16bit: this.use16bit,
            direct: true
        }

    );

};


MapSubmesh.prototype.computeUVArea = function (texture) {
    const uvs = this.internalUVs || this.externalUVs;
    const fx = texture.width / 65535;
    const fy = texture.height / 65535;
    let area = 0;

    const faceArea = function(i1, i2, i3) {
        let dx = (uvs[i2] - uvs[i1])*fx, dy = (uvs[i2+1] - uvs[i1+1])*fy;
        const l1 = Math.sqrt(dx*dx+dy*dy);
        dx = (uvs[i3] - uvs[i2])*fx, dy = (uvs[i3+1] - uvs[i2+1])*fy;
        const l2 = Math.sqrt(dx*dx+dy*dy);
        dx = (uvs[i1] - uvs[i3])*fy, dy = (uvs[i1+1] - uvs[i3+1])*fy;
        const l3 = Math.sqrt(dx*dx+dy*dy);

        const sp = (l1+l2+l3)*0.5; //semi perimeter

        return Math.sqrt(Math.max(0.0,sp*(sp-l1)*(sp-l2)*(sp-l3)));
    }

    if (uvs) {
        const indices = this.indices;

        if (indices) {
            for (let i = 0, ii = 0, li = this.faces; i < li; i++, ii+=3) {
                area += faceArea(indices[i*3]*2, indices[i*3+1]*2, indices[i*3+2]*2);
            }
        } else {
            for (let i = 0, ii = 0, li = this.faces; i < li; i++, ii+=3) {
                area += faceArea(i*3*2, i*3*2 + 1, i*3*2 +2);
            }
        }
    }

    this.uvAreaComputed = true;
    this.uvArea = area;
};


MapSubmesh.prototype.getWorldMatrix = function(geoPos, matrix) {
    // Note: the current camera geographic position (geoPos) is not necessary
    // here, in theory, but for numerical stability (OpenGL ES is float only)
    // we get rid of the large UTM numbers in the following subtractions. The
    // camera effectively stays in the position [0,0] and the tiles travel
    // around it. (The Z coordinate is fine and is not handled in this way.)

    let m = matrix;

    if (m) {
        m[0] = this.bbox.side(0); m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = this.bbox.side(1); m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = this.bbox.side(2); m[11] = 0;
        m[12] = this.bbox.min[0] - geoPos[0]; m[13] = this.bbox.min[1] - geoPos[1]; m[14] = this.bbox.min[2] - geoPos[2]; m[15] = 1;
    } else {
        m = mat4.create();

        mat4.multiply( math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]),
                       math.scaleMatrix(this.bbox.side(0), this.bbox.side(1), this.bbox.side(2)), m);
    }

    return m;
};


MapSubmesh.prototype.getWorldMatrixSE = function(geoPos, matrix) {
    let m = matrix;

    if (m) {
        m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
        m[12] = this.bbox.min[0] - geoPos[0]; m[13] = this.bbox.min[1] - geoPos[1]; m[14] = this.bbox.min[2] - geoPos[2]; m[15] = 1;
    } else {
        m = math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]);
    }

    return m;
};


MapSubmesh.prototype.drawBBox = function(cameraPos) {
    const renderer = this.map.renderer;

    if (renderer.device === 2) {
        return;
    }

    renderer.gpu.useProgram(renderer.gpu.progBBox, ['aPosition']);

    const mvp = mat4.create();
    const mv = mat4.create();

    mat4.multiply(renderer.camera.getModelviewMatrix(), this.getWorldMatrix(cameraPos), mv);

    const proj = renderer.camera.getProjectionMatrix();
    mat4.multiply(proj, mv, mvp);

    renderer.gpu.progBBox.setMat4('uMVP', mvp);

    //draw bbox
    renderer.bboxMesh.draw(renderer.gpu.progBBox, 'aPosition');
};


/* harmony default export */ __webpack_exports__["default"] = (MapSubmesh);


/***/ }),

/***/ "./src/core/map/subtexture.js":
/*!************************************!*\
  !*** ./src/core/map/subtexture.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");


//import GpuTexture_ from '../renderer/gpu/texture';

//get rid of compiler mess
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["utils"];
//const GpuTexture = GpuTexture_;


const MapSubtexture = function(map, path, type, tile, internal) {
    this.map = map;
    this.stats = map.stats;
    this.tile = tile; // used only for stats
    this.internal = internal; // used only for stats
    this.image = null;
    this.imageData = null;
    this.imageExtents = null;
    this.gpuTexture = null;
    this.loadState = 0;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.neverReady = false;
    this.mapLoaderUrl = path;
    this.type = type || false;
    this.statsCounter = 0;
    this.checkStatus = 0;
    this.checkType = null;
    this.checkValue = null;
    this.fastHeaderCheck = false;
    this.gpuSize = 0;
    this.fileSize = 0;
    this.cacheItem = null; //store killImage
    this.gpuCacheItem = null; //store killGpuTexture
};


MapSubtexture.prototype.kill = function() {
    this.killImage();
    this.killGpuTexture();

    if (this.mask) {
        this.mask.killImage();
        this.mask.killGpuTexture();
    }

    //this.tile.validate();
};


MapSubtexture.prototype.killImage = function(killedByCache) {
    this.image = null;
    this.imageData = null;

    if (killedByCache !== true && this.cacheItem) {
        this.map.resourcesCache.remove(this.cacheItem);
        //this.tile.validate();
    }

    if (this.mask) {
        this.mask.killImage();
    }

    if (!this.gpuTexture) {
        this.loadState = 0;
    } //else {
        //this.loadState = this.loadState;
    //}

    this.cacheItem = null;
};


MapSubtexture.prototype.killGpuTexture = function(killedByCache) {
/*
    //debug only
    if (!this.map.lastRemoved) {
        this.map.lastRemoved = [];
    }

    //debug only
    if (this.map.lastRemoved.indexOf(this.mapLoaderUrl) != -1) {
        console.log("tex: " + this.mapLoaderUrl);
    }

    //debug only
    this.map.lastRemoved.unshift(this.mapLoaderUrl);
    this.map.lastRemoved = this.map.lastRemoved.slice(0,20);
*/

    if (this.gpuTexture != null) {

        this.stats.gpuTextures -= this.gpuSize;

        if (this.map.renderer.device === 2) {
            this.gpuTexture.dispose();
        } else {
            this.gpuTexture.kill();
        }


        this.stats.graphsFluxTexture[1][0]++;
        //this.stats.graphsFluxTexture[1][1] += this.gpuTexture.size;
        this.stats.graphsFluxTexture[1][1] += this.gpuSize;

        if (this.mask) {
            this.mask.killGpuTexture();
        }
    }

    this.gpuTexture = null;

    if (killedByCache !== true && this.gpuCacheItem) {
        this.map.gpuCache.remove(this.gpuCacheItem);
        //this.tile.validate();
    }

    if (!this.image && !this.imageData) {
        this.loadState = 0;
    }

    this.gpuCacheItem = null;
};


MapSubtexture.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu, texture) {
    const doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);
    doNotLoad = doNotLoad || doNotUseGpu;

    if (this.neverReady) {
        return false;
    }

    switch (texture.checkType) {
    case 2:
    case 3:
    case 4:

        if (this.checkStatus != 2) {
            this.checkType = texture.checkType;
            this.checkValue = texture.checkValue;

            if (this.checkStatus == 0) {
                this.scheduleHeadRequest(priority, (this.checkType == 4));
            } else if (this.checkStatus == 3) { //loadError
                if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&
                        performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {
                    this.scheduleHeadRequest(priority, (this.checkType == 4));
                }
            } else if (this.checkStatus == -1) {

                if (texture.extraInfo) { //find at least texture with lower resolution
                    if (!texture.extraBound) {
                        texture.extraBound = { tile: texture.extraInfo.tile, layer: texture.extraInfo.layer};
                        texture.setBoundTexture(texture.extraBound.tile.parent, texture.extraBound.layer);
                    }

                    while (texture.extraBound.texture.extraBound || texture.extraBound.texture.checkStatus == -1) {
                        //while (texture.extraBound.texture.checkStatus == -1) {
                        texture.setBoundTexture(texture.extraBound.sourceTile.parent, texture.extraBound.layer);
                    }
                }
            }

            return false;
        }

        break;
    }

    if (this.loadState == 2) { //loaded
        let t;

        if (!doNotLoad && this.cacheItem) {
            this.map.resourcesCache.updateItem(this.cacheItem);
        }

        /*
        if (((this.type == VTS_TEXTURETYPE_HEIGHT && !this.imageData) || (this.type != VTS_TEXTURETYPE_HEIGHT && !this.gpuTexture)) &&
              this.stats.renderBuild > this.map.config.mapMaxProcessingTime) {
            //console.log("testure resource build overflow");
            this.map.markDirty();
            return false;
        }*/

        if (doNotCheckGpu) {
            if (this.type == 1) {
                if (!this.imageData) {
                    t = performance.now();
                    this.buildHeightMap();
                    this.stats.renderBuild += performance.now() - t;
                }
            }

            return true;
        }

        if (this.type == 1) {
            if (!this.imageData) {
                t = performance.now();
                this.buildHeightMap();
                this.stats.renderBuild += performance.now() - t;
            }
        } else {
            if (!this.gpuTexture) {
                if (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed) {
                    return false;
                }

                if (doNotUseGpu) {
                    return false;
                }

                //if (this.stats.graphsFluxTexture [0][0] > 2) {
                   // return false;
                //}

                t = performance.now();
                this.buildGpuTexture();
                this.stats.renderBuild += performance.now() - t;
            }

            if (!doNotLoad && this.gpuCacheItem) {
                this.map.gpuCache.updateItem(this.gpuCacheItem);
            }
        }


        return true;
    } else {
        if (this.loadState == 0) {
            if (doNotLoad) {
                //remove from queue
                //if (this.mapLoaderUrl) {
                    //this.map.loader.remove(this.mapLoaderUrl);
                //}
            } else {
                //not loaded
                //add to loading queue or top position in queue
                this.scheduleLoad(priority);
            }
        } else if (this.loadState == 3) { //loadError
            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&
                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {

                this.scheduleLoad(priority);
            }
        } //else load in progress
    }

    return false;
};


MapSubtexture.prototype.scheduleLoad = function(priority, header) {
    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this, header), priority, this.tile, this.internal ? 'texture-in' : 'texture-ex');
};


MapSubtexture.prototype.onLoad = function(header, url, onLoaded, onError) {
    this.mapLoaderCallLoaded = onLoaded;
    this.mapLoaderCallError = onError;

    const onerror = this.onLoadError.bind(this);
    const onload = this.onLoaded.bind(this);

    if (header) {
        this.checkStatus = 1;
    } else {
        this.loadState = 1;
    }

    if (this.map.config.mapXhrImageLoad) {
        //utils.loadBinary(url, this.onBinaryLoaded.bind(this), onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');
        this.map.loader.processLoadBinary(url, this.onBinaryLoaded.bind(this), onerror, null, 'texture');
    } else {
        this.image = utils.loadImage(url, onload, onerror, (this.map.core.tokenCookieHost ? (url.indexOf(this.map.core.tokenCookieHost) != -1) : false));
    }
    //mapXhrImageLoad
};


MapSubtexture.prototype.onLoadError = function(killBlob) {
    if (this.map.killed){
        return;
    }

    if (killBlob) {
        window.URL.revokeObjectURL(this.image.src);
    }

    this.loadState = 3;
    this.loadErrorTime = performance.now();
    this.loadErrorCounter ++;

    //make sure we try to load it again
    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) {
        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);
    }

    this.mapLoaderCallError();
};


MapSubtexture.prototype.onBinaryLoaded = function(data, direct, filesize) {
    if (this.fastHeaderCheck && this.checkType && this.checkType != 1) {
        this.onHeadLoaded(null, data, null /*status*/);

        if (this.checkStatus == -1) {
            this.mapLoaderCallLoaded();
            return;
        }
    }

    if (direct) {
        this.onLoaded(false, data)
        this.fileSize = filesize;
        return;
    }

    this.fileSize = data.size;

    if (this.map.config.mapAsyncImageDecode) {
        createImageBitmap(data).then(this.onLoaded.bind(this, false));
    } else {
        const image = new Image();
        image.onerror = this.onLoadError.bind(this, true, null);
        image.onload = this.onLoaded.bind(this, true, null);
        this.image = image;
        image.src = window.URL.createObjectURL(data);
    }
};


MapSubtexture.prototype.onLoaded = function(killBlob, bitmap) {
    if (this.map.killed){
        return;
    }

    if (killBlob) {
        window.URL.revokeObjectURL(this.image.src);
    }

    if (bitmap) {
        this.image = bitmap;
        this.image.naturalWidth = bitmap.width;
        this.image.naturalHeight = bitmap.height;
    }

    const size = this.image.naturalWidth * this.image.naturalHeight * (this.heightMap ? 3 : 3);
    this.gpuSize = this.image.naturalWidth * this.image.naturalHeight * 4;  //aproximate size

    //if (!this.image.complete) {
       // size = size;
    //}

    //console.log(size);

    this.cacheItem = this.map.resourcesCache.insert(this.killImage.bind(this, true), size);

    this.map.markDirty();
    this.loadState = 2;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.mapLoaderCallLoaded();
};


MapSubtexture.prototype.scheduleHeadRequest = function(priority, downloadAll) {
    if (this.map.config.mapXhrImageLoad && this.fastHeaderCheck) {
        this.scheduleLoad(priority, true);
    } else {
        this.map.loader.load(this.mapLoaderUrl, this.onLoadHead.bind(this, downloadAll), priority, this.tile, this.internal, this.internal ? 'texture-in' : 'texture-ex');
    }
};


MapSubtexture.prototype.onLoadHead = function(downloadAll, url, onLoaded, onError) {
    this.mapLoaderCallLoaded = onLoaded;
    this.mapLoaderCallError = onError;

    const onerror = this.onLoadHeadError.bind(this, downloadAll);
    const onload = this.onHeadLoaded.bind(this, downloadAll);

    this.checkStatus = 1;

    if (downloadAll) {
        //utils.loadBinary(url, onload, onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');
        this.map.loader.processLoadBinary(url, onload, onerror, null, 'texture');
    } else {
        utils.headRequest(url, onload, onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');
    }
};


MapSubtexture.prototype.onLoadHeadError = function() {
    if (this.map.killed){
        return;
    }

    this.checkStatus = 3;
    this.loadErrorTime = performance.now();
    this.loadErrorCounter ++;

    //make sure we try to load it again
    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) {
        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);
    }

    this.mapLoaderCallError();
};


MapSubtexture.prototype.onHeadLoaded = function(downloadAll, data, status) {
    if (this.map.killed){
        return;
    }

    this.checkStatus = 2;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;

    if (this.map.config.mapXhrImageLoad && this.fastHeaderCheck) {

        switch (this.checkType) {
        case 4:
            if (data) {
                if (data.size == this.checkValue) {
                    this.checkStatus = -1;
                }
            }
            break;

        case 2:
            if (data) {
                if (data.type == this.checkValue) {
                    this.checkStatus = -1;
                }
            }
            break;

        case 3:
            if (status) {
                if (this.checkValue.indexOf(status) != -1) {
                    this.checkStatus = -1;
                }
            }
            break;
        }

    } else {

        switch (this.checkType) {
        case 4:
            if (data) {
                if (data.byteLength == this.checkValue) {
                    this.checkStatus = -1;
                }
            }
            break;

        case 2:
            if (data) {
                //if (!data.indexOf) {
                  //  data = data;
                //}

                if (data.indexOf(this.checkValue) != -1) {
                    this.checkStatus = -1;
                }
            }
            break;

        case 3:
            if (status) {
                if (this.checkValue.indexOf(status) != -1) {
                    this.checkStatus = -1;
                }
            }
            break;
        }

        this.mapLoaderCallLoaded();
    }
};


MapSubtexture.prototype.buildGpuTexture = function () {

    if (this.map.config.mapCheckTextureSize && (this.image.naturalWidth > 1024 || this.image.naturalHeight > 1024)) {
        console.log('very large texture: ' + this.image.naturalWidth + 'x' + this.image.naturalHeight + ' ' + this.mapLoaderUrl);

        /*const size = 16;
        const data = new Uint8Array( size * size * 4 );

        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                const index = (i*size+j)*4;
                data[index] = 0;
                data[index + 1] = 0;
                data[index + 2] = 0;
                data[index + 3] = 255;
            }
        }*/

        //this.gpuTexture = new GpuTexture(this.map.renderer.gpu);
        //this.gpuTexture.createFromData(size, size, data);

        if (this.map.renderer.device === 2) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;

            // eslint-disable-next-line
            const context = canvas.getContext('2d');

            this.gpuTexture = this.map.renderer.gpu.createTexture({ image: canvas, width: this.image.naturalWidth, height: this.image.naturalHeight});
        } else {
            this.gpuTexture = this.map.renderer.gpu.blackTexture;
        }

        this.gpuTexture.gpuSize = 16*16*4; //this.image.naturalWidth * this.image.naturalHeight * 4;
        return;
    }

    //this.gpuTexture = new GpuTexture(this.map.renderer.gpu, null, this.map.core);
    //this.gpuTexture.createFromImage(this.image, (this.type == VTS_TEXTURETYPE_CLASS) ? 'nearest' : 'linear', false);

    this.gpuTexture = this.map.renderer.gpu.createTexture({ image: this.image, width: this.image.naturalWidth, height: this.image.naturalHeight,
                                                            filter: (this.type == 2) ? 'nearest' : 'linear', repeat: false});

    this.gpuSize = this.gpuTexture.gpuSize;
    this.stats.gpuTextures += this.gpuSize;

    this.stats.graphsFluxTexture[0][0]++;
    this.stats.graphsFluxTexture[0][1] += this.gpuSize;

    this.gpuCacheItem = this.map.gpuCache.insert(this.killGpuTexture.bind(this, true), this.gpuSize);
};


MapSubtexture.prototype.buildHeightMap = function () {
    const canvas = document.createElement('canvas');
    canvas.width = this.image.naturalWidth;
    canvas.height = this.image.naturalHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(this.image, 0, 0);
    this.imageData = ctx.getImageData(0, 0, this.image.naturalWidth, this.image.naturalHeight).data;
    this.imageExtents = [this.image.naturalWidth, this.image.naturalHeight];
    this.image = null;
};


MapSubtexture.prototype.getGpuTexture = function() {
    return this.gpuTexture;
};


MapSubtexture.prototype.getHeightMapValue = function(x, y) {
    if (this.imageData) {
        return this.imageData[(y * this.imageExtents[0] + x)*4];
    }

    return 0;
};

/* harmony default export */ __webpack_exports__["default"] = (MapSubtexture);


/***/ }),

/***/ "./src/core/map/surface-sequence.js":
/*!******************************************!*\
  !*** ./src/core/map/surface-sequence.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const MapSurfaceSequence = function(map) {
    this.map = map;
};


MapSurfaceSequence.prototype.generateSurfaceSequence = function() {
    const view = this.map.currentView;
    const tree = this.map.tree;

    if (!tree) {
        return;
    }

    tree.surfaceSequence = [];
    tree.surfaceSequenceIndices = []; //probably not used
    tree.surfaceOnlySequence = [];

    let vsurfaces = {}, surface, glue;
    let vsurfaceCount = 0;
    let list = [], listId, i, li, j , lj, key;
    let strId = [];

    //add surfaces to the list
    for (key in view.surfaces) {
        surface = this.map.getSurface(key);

        if (surface) {
            strId.push(surface.id);
            vsurfaceCount++;
            vsurfaces[key] = surface.index + 1; //add one to avoid zero
            //list.push(["" + (surface.index + 1), surface, true]);
            list.push([ [(surface.index + 1)], surface, true, false]); //[surfaceId, surface, isSurface, isAlien]
        }
    }


    if (vsurfaceCount >= 1) { //do we have virtual surface?
        strId.sort();
        strId = strId.join(';');

        surface = this.map.virtualSurfaces[strId];
        if (surface) {
            list = [ [ [(surface.index + 1)], surface, true, false] ]; //[surfaceId, surface, isSurface, isAlien]
            vsurfaceCount = 1;
        }
    }

    if (vsurfaceCount > 1) {

        const glues = [];

        //add proper glues to the list
        for (key in this.map.glues) {
            glue = this.map.glues[key];

            //add only glue which contains desired surfaces

            if (!glue || !glue.id) continue;

            const id = glue.id;
            if (id.length <= vsurfaceCount) {

                let missed = false;
                for (j = 0, lj = id.length; j < lj; j++) {
                    if (!vsurfaces[id[j]]) {
                        missed = true;
                        break;
                    }
                }

                if (!missed) {
                    listId = [];

                    //create glue id in reverse order for sorting
                    for (j = 0, lj = id.length; j < lj; j++) {
                        //listId = vsurfaces[id[j]] + (j ? "." : "") + listId;
                        listId.unshift(vsurfaces[id[j]]);
                    }

                    glues.push([listId, glue, false, false]); //[surfaceId, surface, isSurface, isAlien]
                }
            }
        }

        //process glue flags
        for (i = 0, li = glues.length; i < li; i++) {
            const item = glues[i];
            glue = item[1];

            glue.flagProper = true;
            glue.flagAlien = true;

            if (glue.flagProper) {
                list.push(item);
            }

            if (glue.flagAlien) {
                //remove first surface from id
                listId = item[0].slice(1);

                //add same glue as alien
                list.push([listId, item[1], false, true]); //[surfaceId, surface, isSurface, isAlien]
            }
        }

        //sort list alphabetically
        let sorted;

        do {
            sorted = true;

            for (i = 0, li = list.length - 1; i < li; i++) {
                const a1 = list[i][0];
                const a2 = list[i+1][0];

                let lesser = false;

                for (j = 0, lj = Math.min(a1.length, a2.length); j < lj; j++) {
                    if (a1[j] < a2[j] || (j == (lj -1) && a1[j] == a2[j] && a2.length > a1.length)) {
                        lesser = true;
                        break;
                    }
                }

                if (lesser) {
                    const t = list[i];
                    list[i] = list[i+1];
                    list[i+1] = t;
                    sorted = false;
                }
            }

        } while(!sorted);

        let lastIndex = vsurfaceCount - 1;

        //convert list to surface sequence
        for (i = 0, li = list.length; i < li; i++) {
            tree.surfaceSequence.push([list[i][1], list[i][3]]); //[surface, isAlien]
            //this.surfaceSequence.push(list[i][1]);
            list[i][1].viewSurfaceIndex = lastIndex;

            if (list[i][2]) {
                lastIndex--;
                tree.surfaceOnlySequence.push(list[i][1]);
            }
        }

        //this.generateSurfaceSequenceOld();

    } else {
        if (vsurfaceCount == 1) {
            tree.surfaceSequence.push([list[0][1], list[0][3]]); //[surface, isAlien]
            list[0][1].viewSurfaceIndex = vsurfaceCount - 1;
            tree.surfaceOnlySequence = [list[0][1]];
        }
    }

    this.map.freeLayersHaveGeodata = false;

    //free layers
    for (key in view.freeLayers) {
        const freeLayer = this.map.getFreeLayer(key);
        if (freeLayer) {
            freeLayer.surfaceSequence = [freeLayer];
            freeLayer.surfaceOnlySequence = [freeLayer];

            if (freeLayer.geodata) {
                this.map.freeLayersHaveGeodata = true;
            }
        }
    }

    //just in case
    this.map.renderer.gpu.draw.clearJobBuffer();
};


MapSurfaceSequence.prototype.generateBoundLayerSequence = function() {
    const view = this.map.currentView;
    let key, item, layer, alpha, i, li, item2, surface;

    //zero bound layer filters
    const layers = this.map.boundLayers;
    for (key in layers) {
        layers[key].shaderFilters = null;
    }

    //surfaces
    for (key in view.surfaces) {
        const surfaceLayers = view.surfaces[key];
        surface = this.map.getSurface(key);
        if (surface != null) {
            surface.boundLayerSequence = [];

            for (i = 0, li = surfaceLayers.length; i < li; i++) {
                item = surfaceLayers[i];

                if (typeof item === 'string') {
                    layer = this.map.getBoundLayerById(item);
                    if (layer) {
                        surface.boundLayerSequence.push([layer, 1]);
                    }
                } else {
                    layer = this.map.getBoundLayerById(item['id']);
                    if (layer) {

                        alpha = 1;
                        if (typeof item['alpha'] !== 'undefined') {
                            alpha = parseFloat(item['alpha']);
                        }

                        surface.boundLayerSequence.push([layer, alpha]);

                        item2 = item['options'] || item;

                        if (item2['shaderVarFlatShade']) {
                            if (!layer.shaderFilters) {
                                layer.shaderFilters = {};
                            }

                            if (!layer.shaderFilters[surface.id]) {
                                layer.shaderFilters[surface.id] = {};
                            }

                            layer.shaderFilters[surface.id].varFlatShade = item2['shaderVarFlatShade'];
                        }

                        if (item2['shaderFilter']) {
                            if (!layer.shaderFilters) {
                                layer.shaderFilters = {};
                            }

                            if (!layer.shaderFilters[surface.id]) {
                                layer.shaderFilters[surface.id] = {};
                            }

                            layer.shaderFilters[surface.id].filter = item2['shaderFilter'];
                        }
                    }
                }
            }
        }
    }

    //free layers
    for (key in view.freeLayers) {
        const freeLayersProperties = view.freeLayers[key];
        const freeLayer = this.map.getFreeLayer(key);
        if (freeLayer != null && freeLayer.ready) {

            freeLayer.options = freeLayersProperties['options'] || {};

            let flatShade = freeLayersProperties['shader'] || freeLayer.options['shader'];

            if (flatShade) {
                freeLayer.flatShade = (flatShade == 'flatShade');
            } else {
                freeLayer.flatShade = freeLayer.flatShadeOriginal;
            }

            freeLayer.boundLayerSequence = [];

            const boundLayers = freeLayersProperties['boundLayers'];

            if (boundLayers && Array.isArray(boundLayers)) {

                for (i = 0, li = boundLayers.length; i < li; i++) {
                    item = boundLayers[i];

                    if (typeof item === 'string') {
                        layer = this.map.getBoundLayerById(item);
                        if (layer) {
                            freeLayer.boundLayerSequence.push([layer, 1]);
                        }
                    } else {
                        layer = this.map.getBoundLayerById(item['id']);
                        if (layer) {

                            alpha = 1;
                            if (typeof item['alpha'] !== 'undefined') {
                                alpha = parseFloat(item['alpha']);
                            }

                            freeLayer.boundLayerSequence.push([layer, alpha]);

                            if (item['shaderVarFlatShade']) {
                                if (!layer.shaderFilters) {
                                    layer.shaderFilters = {};
                                }

                                if (!layer.shaderFilters[surface.id]) {
                                    layer.shaderFilters[surface.id] = {};
                                }

                                layer.shaderFilters[surface.id].varFlatShade = item['shaderVarFlatShade'];
                            }

                            if (item['shaderFilter']) {
                                if (!layer.shaderFilters) {
                                    layer.shaderFilters = {};
                                }

                                if (!layer.shaderFilters[surface.id]) {
                                    layer.shaderFilters[surface.id] = {};
                                }

                                layer.shaderFilters[surface.id].filter = item['shaderFilter'];
                            }
                        }
                    }
                }
            }
        }
    }
};


/* harmony default export */ __webpack_exports__["default"] = (MapSurfaceSequence);


/***/ }),

/***/ "./src/core/map/surface-tile.js":
/*!**************************************!*\
  !*** ./src/core/map/surface-tile.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");


//import GpuTexture_ from '../renderer/gpu/texture';


//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"];
const mat3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"];
const mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
//const GpuTexture = GpuTexture_;
const math = _utils_math__WEBPACK_IMPORTED_MODULE_1__["math"];

 const tileBorderTable = [
    [-1, -1, 0, 0],
    [0, -1, 0.5, 1], //
    [1, -1, 1, 0],

    [-1, 0, 0, 0.5],
    [0, 0, 0.5, 0.5],
    [1, 0, 1, 0.5],

    [-1, 1, 0, 1],
    [0, 1, 0.5, 0], //
    [1, 1, 1, 1]
];

const tileCornerTable = [
    [0,1,3],
    [2,1,5],
    [6,3,7],
    [8,7,5]
];


const MapSurfaceTile = function(map, parent, id) {
    this.map = map;
    this.id = id;
    this.parent = parent;
    this.viewCounter = map.viewCounter;
    this.drawCounter = 0;
    this.childrenReadyCount = 0;
    this.renderReady = false;
    this.geodataCounter = 0;
    this.gridRenderCounter = 0; //draw grid only once
    this.texelSize = 1;
    this.texelSize2 = 1;
    this.distance = 1;
    this.tiltAngle = 1;
    this.seCounter = 0;

    this.metanode = null;  //[metanode, cacheItem]
    this.lastMetanode = null;
    this.boundmetaresources = null; //link to bound layers metatile storage

    this.surface = null; //surface or glue
    this.surfaceMesh = null;
    this.surfaceGeodata = null;     //probably only used in free layers
    this.surfaceGeodataView = null; //probably only used in free layers
    this.surfaceTextures = [];
    this.resourceSurface = null; //surface directing to resources

    this.virtual = false;
    this.virtualReady = false;
    this.virtualSurfaces = [];

    this.resetDrawCommands = false;
    this.drawCommands = [[], [], []];

    this.bounds = {};
    this.boundLayers = {};
    this.boundTextures = {};
    this.updateBounds = true;

    this.hmap = null;
    this.heightMap = null;
    this.drawCommands = [[], [], []];
    this.imageryCredits = {};
    this.glueImageryCredits = {};
    this.mapdataCredits = {};

    this.resources = this.map.resourcesTree.findNode(id, true);   // link to resource tree
    this.metaresources = this.map.resourcesTree.findAgregatedNode(id, 5, true); //link to meta resource tree
    this.boundresources = this.map.resourcesTree.findAgregatedNode(id, 8, true); //link to meta resource tree

    this.children = [null, null, null, null];
};


MapSurfaceTile.prototype.kill = function() {
    //kill children
    for (let i = 0; i < 4; i++) {
        if (this.children[i] != null) {
            this.children[i].kill();
        }
    }
/*
    if (this.surfaceMesh != null) {
        this.surfaceMesh.kill();
    }

    for (let key in this.surfaceTextures) {
        if (this.surfaceTextures[key] != null) {
            this.surfaceTextures[key].kill();
        }
    }

    if (this.surfaceGeodata != null) {
        this.surfaceGeodata.kill();
    }

    if (this.surfaceGeodataView != null) {
        this.surfaceGeodataView.kill();
    }

    if (this.heightMap != null) {
        this.heightMap.kill();
    }

    for (let key in this.boundTextures) {
        if (this.boundTextures[key] != null) {
            this.boundTextures[key].kill();
        }
    }
*/
    this.resources = null;
    this.metaresources = null;
    this.metanode = null;

    this.surface = null;
    this.surfaceMesh = null;
    this.surfaceTextures = [];
    this.surfaceGeodata = null;
    this.surfaceGeodataView = null;
    this.resourceSurface = null;

    this.bounds = {};
    this.boundLayers = {};
    this.boundTextures = {};
    this.updateBounds = true;

    this.virtual = false;
    this.virtualReady = false;
    this.virtualSurfaces = [];

    this.renderReady = false;
    this.lastSurface = null;
    this.lastState = null;
    this.lastRenderState = null;

    this.hmap = null;
    this.heightMap = null;
    this.drawCommands = [[], [], []];
    this.imageryCredits = {};
    this.glueImageryCredits = {};
    this.mapdataCredits = {};

    this.verifyChildren = false;
    this.children = [null, null, null, null];

    const parent = this.parent;
    this.parent = null;

    if (parent != null) {
        parent.removeChild(this);
    }
};


MapSurfaceTile.prototype.validate = function() {
    //is tile empty?
    if (this.metaresources == null || !this.metaresources.getMetatile(this.surface, null, this)) {
        //this.kill();
    }
};


MapSurfaceTile.prototype.viewSwitched = function() {
    //store last state for view switching
    this.lastSurface = this.surface;
    this.lastState = {
        surfaceMesh : this.surfaceMesh,
        surfaceTextures : this.surfaceTextures,
        boundTextures : this.boundTextures,
        surfaceGeodata : this.surfaceGeodata,
        surfaceGeodataView : this.surfaceGeodataView,
        resourceSurface : this.resourceSurface
    };

    if (this.drawCommands[0].length > 0) {  // check only visible chanel
        this.lastRenderState = {
            drawCommands : this.drawCommands,
            imageryCredits : this.imageryCredits,
            mapdataCredits : this.mapdataCredits
        };
    } else {
        this.lastRenderState = null;
    }

    //zero surface related data
    this.verifyChildren = true;
    this.renderReady = false;
    this.lastMetanode = this.metanode;
    this.metanode = null; //quick hack for switching virtual surfaeces //keep old value for smart switching

    if (!this.map.config.mapSoftViewSwitch) {

        if (this.metanode) {
            this.metanode.border = null;
            this.metanode.border2 = null;
            this.metanode.border3 = null;
            this.metanode.borderNodes = null;
            this.metanode.borderReady = null;
        }

        this.lastState = null;
        this.lastRenderState = null;
        this.lastMetanode = null;
        this.metanode = null;
        this.gridPoints = null;
    }

    //this.lastMetanode = null;
    //this.metanode = null;

    for (let key in this.bounds) {
        this.bounds[key] = {
            sequence : [],
            alpha : [],
            transparent : false,
            viewCoutner : 0
        };
    }

    this.boundLayers = {};
    this.boundTextures = {};
    this.updateBounds = true;
    this.transparentBounds = false;

    this.surface = null;
    this.surfaceMesh = null;
    this.surfaceTextures = [];
    this.surfaceGeodata = null;
    this.surfaceGeodataView = null;
    this.resourceSurface = null;

    this.virtual = false;
    this.virtualReady = false;
    this.virtualSurfaces = [];
    this.virtualSurfacesUncomplete = false;

    this.drawCommands = [[], [], []];
    this.imageryCredits = {};
    this.glueImageryCredits = {};
    this.mapdataCredits = {};
};


MapSurfaceTile.prototype.restoreLastState = function() {
    if (!this.lastState) {
        return;
    }
    this.surfaceMesh = this.lastState.surfaceMesh;
    this.surfaceTextures = this.lastState.surfaceTextures;
    this.boundTextures = this.lastState.boundTextures;
    this.surfaceGeodata = this.lastState.surfaceGeodata;
    this.surfaceGeodataView = this.lastState.surfaceGeodataView;
    this.resourceSurface = this.lastState.resourceSurface;
    this.lastSurface = null;
    this.lastState = null;
    this.lastResourceSurface = null;
};


MapSurfaceTile.prototype.addChild = function(index) {
    if (this.children[index]) {
        return;
    }

    const id = this.id;
    const childId = [id[0] + 1, id[1] << 1, id[2] << 1];

    switch (index) {
    case 1: childId[1]++; break;
    case 2: childId[2]++; break;
    case 3: childId[1]++; childId[2]++; break;
    }

    this.children[index] = new MapSurfaceTile(this.map, this, childId);
};


MapSurfaceTile.prototype.removeChildByIndex = function(index) {
    if (this.children[index] != null) {
        this.children[index].kill();
        this.children[index] = null;
    }

    //remove resrource node?
};


MapSurfaceTile.prototype.removeChild = function(tile) {
    for (let i = 0; i < 4; i++) {
        if (this.children[i] == tile) {
            this.children[i].kill();
            this.children[i] = null;
        }
    }
};


MapSurfaceTile.prototype.isMetanodeReady = function(tree, priority, preventLoad) {

    //has map view changed?
    if (this.map.viewCounter != this.viewCoutner) {
        this.viewSwitched();
        this.viewCoutner = this.map.viewCounter;
        this.map.markDirty();
    }

    if (!preventLoad) {

        //provide surface for tile
        if (this.virtualSurfacesUncomplete || (this.surface == null && this.virtualSurfaces.length == 0) ) { //|| this.virtualSurfacesUncomplete) {
            this.checkSurface(tree, priority);
        }

        //provide metanode for tile
        if (this.metanode == null || this.lastMetanode) {

            if (!this.virtualSurfacesUncomplete) {
                const ret = this.checkMetanode(tree, priority);

                if (!ret && !(this.metanode != null && this.lastMetanode)) { //metanode is not ready yet
                    return false;
                }
            }

            /*if (this.lastMetanode) {
                processFlag2 = true;
            }*/
        }

    }

    if (this.metanode == null) { // || processFlag3) { //only for wrong data
        return false;
    }

    this.metanode.metatile.used();

    if (this.lastSurface && this.lastSurface == this.surface) {
        this.lastSurface = null;
        this.restoreLastState();
        //return;
    }

    if (this.surface) {
        if (this.surface.virtual) {
            this.resourceSurface = this.surface.getSurface(this.metanode.sourceReference);
            if (!this.resourceSurface) {
                this.resourceSurface = this.surface;
            }
        } else {
            this.resourceSurface = this.surface;
        }
    }

    if (this.seCounter != this.map.renderer.seCounter) {
        const renderer = this.map.renderer;
        this.seCounter = renderer.seCounter;
        const node = this.metanode;

        if (renderer.useSuperElevation) {
            node.minZ = renderer.getSuperElevatedHeight(node.minZ2);
            node.maxZ = renderer.getSuperElevatedHeight(node.maxZ2);
        } else {
            node.minZ = node.minZ2;
            node.maxZ = node.maxZ2;
        }

        if (renderer.seCounter > 0) {
            this.gridPoints = null;
            node.border = null;
            node.border2 = null;
            node.border3 = null;
            node.borderReady = false;

            node.generateCullingHelpers();
        }
    }

    return true;
};


MapSurfaceTile.prototype.checkSurface = function(tree, priority) {
    this.surface = null;
    this.virtual = false;
    this.virtualReady = false;
    this.virtualSurfaces = [];
    this.virtualSurfacesUncomplete = false;

    if (tree.freeLayerSurface) {  //free layer has only one surface
        this.surface = tree.freeLayerSurface;
        return;
    }

    const sequence = tree.surfaceSequence;

    //multiple surfaces
    //build virtual surfaces array
    //find surfaces with content
    for (let i = 0, li = sequence.length; i < li; i++) {
        const surface = sequence[i][0];
        const alien = sequence[i][1];

        const res = surface.hasTile2(this.id);
        if (res[0]) {

            //check if tile exist
            if (this.id[0] > 0) { //surface.lodRange[0]) {
                // removed for debug !!!!!
                // ????????

                const parent = this.parent;
                if (parent) {

                    if (parent.virtualSurfacesUncomplete) {
                        this.virtualSurfacesUncomplete = true;
                        this.virtualSurfaces = [];
                        return;
                    }

                    const metatile = parent.metaresources.getMetatile(surface, null, this);
                    if (metatile) {

                        if (!metatile.isReady(priority)) {
                            this.virtualSurfacesUncomplete = true;
                            continue;
                        }

                        const node = metatile.getNode(parent.id);
                        if (node) {
                            if (!node.hasChildById(this.id)) {
                                continue;
                            }
                        } else {
                            continue;
                        }
                    } else {
                        continue;
                    }
                }
            }

            //store surface
            this.virtualSurfaces.push([surface, alien]);
        }
    }

    if (this.virtualSurfaces.length > 1) {
        this.virtual = true;
    } else {
        this.surface = (this.virtualSurfaces[0]) ? this.virtualSurfaces[0][0] : null;
    }
};


MapSurfaceTile.prototype.checkMetanode = function(tree, priority) {
    if (this.virtual) {
        if (this.isVirtualMetanodeReady(tree, priority)) {
            this.metanode = this.createVirtualMetanode(tree, priority);
            this.lastMetanode = null;
            this.map.markDirty();
        } else {
            return false;
        }
    }

    const surface = this.surface;

    if (surface == null) {
        return false;
    }

    const metatile = this.metaresources.getMetatile(surface, true, this);

    if (metatile.isReady(priority)) {

        if (!this.virtual) {
            this.metanode = metatile.getNode(this.id);
            this.lastMetanode = null;
            this.map.markDirty();
        }

        if (this.metanode != null) {
            this.metanode.tile = this; //used only for validate
            this.lastMetanode = null;
            this.map.markDirty();

            for (let i = 0; i < 4; i++) {
                if (this.metanode.hasChild(i)) {
                    this.addChild(i);
                } else {
                    this.removeChildByIndex(i);
                }
            }
        }

    } else {
        return false;
    }

    return true;
};


MapSurfaceTile.prototype.isVirtualMetanodeReady = function(tree, priority) {
    const surfaces = this.virtualSurfaces;
    let readyCount = 0, i, li;

    for (i = 0, li = surfaces.length; i < li; i++) {
        const surface = surfaces[i][0];
        const metatile = this.metaresources.getMetatile(surface, true, this);

        if (metatile.isReady(priority)) {
            readyCount++;
        }
    }

    if (readyCount == li) {
        return true;
    } else {
        return false;
    }
};


MapSurfaceTile.prototype.createVirtualMetanode = function(tree, priority) {
    const surfaces = this.virtualSurfaces;
    let node = null, i, li, surface, metatile, metanode;

    //get top most existing surface
    for (i = 0, li = surfaces.length; i < li; i++) {
        surface = surfaces[i][0];
        const alien = surfaces[i][1];
        metatile = this.metaresources.getMetatile(surface, null, this);

        if (metatile.isReady(priority)) {
            metanode = metatile.getNode(this.id);

            if (metanode != null) {
                if (alien != metanode.alien) {
                    continue;
                }

                //does metanode have surface reference?
                //internalTextureCount is reference to surface
                if (!alien && surface.glue && !metanode.hasGeometry() &&
                    metanode.internalTextureCount > 0) {

                    let desiredSurfaceIndex = metanode.internalTextureCount - 1;
                    desiredSurfaceIndex = this.map.getSurface(surface.id[desiredSurfaceIndex]).viewSurfaceIndex;

                    let jump = false;

                    for (let j = i; j < li; j++) {
                        if (surfaces[j].viewSurfaceIndex <= desiredSurfaceIndex) {
                            jump = (j > i);
                            i = j - 1;
                            break;
                        }
                    }

                    if (jump) {
                        continue;
                    }
                }

                if (metanode.hasGeometry()) {
                    node = metanode.clone();
                    this.surface = surface;
                    break;
                }
            }
        }
    }

    //extend bbox, credits and children flags by other surfaces
    for (i = 0, li = surfaces.length; i < li; i++) {
        surface = surfaces[i][0];
        metatile = this.metaresources.getMetatile(surface, null, this);

        if (metatile.isReady(priority)) {
            metanode = metatile.getNode(this.id);

            if (metanode != null) {
                //does metanode have surface reference?
                //internalTextureCount is reference to surface
                /*
                if (surface.glue && !metanode.hasGeometry() &&
                    metanode.internalTextureCount > 0) {
                    i = this.map.surfaceSequenceIndices[metanode.internalTextureCount - 1] - 1;
                    continue;
                }*/

                if (!node) { //just in case all surfaces are without geometry
                    node = metanode.clone();
                    this.surface = surface;
                } else {
                    node.flags |= metanode.flags & ((15)<<4);

                    /*
                    for (let j = 0, lj = metanode.credits.length; j <lj; j++) {
                        if (node.credits.indexOf(metanode.credits[j]) == -1) {
                            node.credits.push(metanode.credits[j]);
                        }
                    }*/

                    if (metatile.useVersion < 4) {
                        // removed for debug !!!!!
                        node.bbox.min[0] = Math.min(node.bbox.min[0], metanode.bbox.min[0]);
                        node.bbox.min[1] = Math.min(node.bbox.min[1], metanode.bbox.min[1]);
                        node.bbox.min[2] = Math.min(node.bbox.min[2], metanode.bbox.min[2]);
                        node.bbox.max[0] = Math.max(node.bbox.max[0], metanode.bbox.max[0]);
                        node.bbox.max[1] = Math.max(node.bbox.max[1], metanode.bbox.max[1]);
                        node.bbox.max[2] = Math.max(node.bbox.max[2], metanode.bbox.max[2]);
                    }
                }
            }
        }
    }

    if (node) {
        node.generateCullingHelpers(true);
    }

    return node;
};


MapSurfaceTile.prototype.bboxVisible = function(id, bbox, cameraPos, node) {
    const map = this.map;
    const camera = map.camera;
    if (id[0] < map.measure.minDivisionNodeDepth) {
        return true;
    }

    const skipGeoTest = map.config.mapDisableCulling;
    if (!skipGeoTest && map.isGeocent) {
        if (node) {
            //if (true) {  //version with perspektive
            const p2 = node.diskPos;
            const p1 = camera.position;
            const rayVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
            const distance = vec3.normalize4(rayVec) * camera.distanceFactor;
                //vec3.normalize(camVec);

            const a = vec3.dot(rayVec, node.diskNormal);
            //} else { //version without perspektive
            //    const a = vec3.dot(camera.vector, node.diskNormal);
            //}
            this.tiltAngle = a;

            if (distance > 150000 && a > node.diskAngle) {
                return false;
            }
        }
    }

    if (node.metatile.useVersion >= 4) {
        return camera.camera.pointsVisible(node.bbox2, cameraPos);
    } else {
        if (!(map.isGeocent && (map.config.mapPreciseBBoxTest)) || id[0] < 4) {
            return camera.camera.bboxVisible(bbox, cameraPos);
        } else {
            return camera.camera.pointsVisible(node.bbox2, cameraPos);
        }
    }
};

MapSurfaceTile.prototype.insideCone = function(coneVec, angle, node) {

    if (this.map.isGeocent) { // && node.diskPos && node.diskNormal) {
        const a = Math.acos(vec3.dot(coneVec, node.diskNormal));

        return (a < angle + node.diskAngle2A);
    }

    return false;
};


MapSurfaceTile.prototype.getPixelSize = function(bbox, screenPixelSize, cameraPos, worldPos, returnDistance) {
    const min = bbox.min;
    const max = bbox.max;
    const tilePos1x = min[0] - cameraPos[0];
    const tilePos1y = min[1] - cameraPos[1];
    const tilePos2x = max[0] - cameraPos[0];
    const tilePos2y = min[1] - cameraPos[1];
    const tilePos3x = max[0] - cameraPos[0];
    const tilePos3y = max[1] - cameraPos[1];
    const tilePos4x = min[0] - cameraPos[0];
    const tilePos4y = max[1] - cameraPos[1];
    const h1 = min[2] - cameraPos[2];
    const h2 = max[2] - cameraPos[2];

    //camera inside bbox
    if (cameraPos[0] > min[0] && cameraPos[0] < max[0] &&
        cameraPos[1] > min[1] && cameraPos[1] < max[1] &&
        cameraPos[2] > min[2] && cameraPos[2] < max[2]) {

        if (returnDistance) {
            return [Number.POSITIVE_INFINITY, 0.1];
        }

        return Number.POSITIVE_INFINITY;
    }

    let factor = 0;
    const camera = this.map.camera.camera;

    //find bbox sector
    if (0 < tilePos1y) { //top row - zero means camera position in y
        if (0 < tilePos1x) { // left top corner
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos1x, tilePos1y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos1x, tilePos1y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos1x, tilePos1y, (h1 + h2)*0.5], returnDistance);
            }
        } else if (0 > tilePos2x) { // right top corner
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos2x, tilePos2y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos2x, tilePos2y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos2x, tilePos2y, (h1 + h2)*0.5], returnDistance);
            }
        } else { //top side
            if (0 > h2) { // hi
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, (h1 + h2)*0.5], returnDistance);
            }
        }
    } else if (0 > tilePos4y) { //bottom row
        if (0 < tilePos4x) { // left bottom corner
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos4x, tilePos4y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos4x, tilePos4y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos4x, tilePos4y, (h1 + h2)*0.5], returnDistance);
            }
        } else if (0 > tilePos3x) { // right bottom corner
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos3x, tilePos3y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos3x, tilePos3y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos3x, tilePos3y, (h1 + h2)*0.5], returnDistance);
            }
        } else { //bottom side
            if (0 > h2) { // hi
                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, (h1 + h2)*0.5], returnDistance);
            }
        }
    } else { //middle row
        if (0 < tilePos4x) { // left side
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);
            }
        } else if (0 > tilePos3x) { // right side
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);
            }
        } else { //center
            if (0 > h2) { // hi
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);
            }
        }
    }

    //console.log("new: " + (factor * screenPixelSize) + " old:" + this.tilePixelSize2(node) );

    if (returnDistance) {
        return [(factor[0] * screenPixelSize), factor[1]];
    }

    return (factor * screenPixelSize);
};


MapSurfaceTile.prototype.getPixelSize3Old = function(node, screenPixelSize, factor) {
    const camera = this.map.camera;
    let d = (camera.geocentDistance*factor) - node.diskDistance;
    if (d < 0) {
        d = -d;
        //return [Number.POSITIVE_INFINITY, 0.1];
    }

    let a = vec3.dot(camera.geocentNormal, node.diskNormal);

    if (a < node.diskAngle2) {
        let a2 = Math.acos(a);
        const a3 = Math.acos(node.diskAngle2);
        a2 = a2 - a3;

        const l1 = Math.tan(a2) * node.diskDistance;
        d = Math.sqrt(l1*l1 + d*d);
    }

    factor = camera.camera.scaleFactor2(d);
    return [factor * screenPixelSize, d];
};


MapSurfaceTile.prototype.getPixelSize3 = function(node, screenPixelSize) {
    //if (this.map.drawIndices) {
      //  return this.getPixelSize3Old(node, screenPixelSize, factor);
    //}
    const camera = this.map.camera;
    const cameraDistance = camera.geocentDistance;// * factor;

    const a = vec3.dot(camera.geocentNormal, node.diskNormal); //get angle between tile normal and cameraGeocentNormal
    let d = cameraDistance - (node.diskDistance + (node.maxZ - node.minZ)), d2; //vertical distance from top bbox level

    if (a < node.diskAngle2) { //is camera inside tile conus?

        //get horizontal distance
        let a2 = Math.acos(a);
        const a3 = node.diskAngle2A;
        a2 = a2 - a3;
        const l1 = Math.tan(a2) * node.diskDistance;// * factor;

        if (d < 0) { //is camera is belown top bbox level?
            d2 = cameraDistance - node.diskDistance;
            if (d2 < 0) { //is camera is belown bottom bbox level?
                d = -d2;
                d = Math.sqrt(l1*l1 + d*d);
            } else { //is camera inside bbox
                d = l1;
            }
        } else {
            d = Math.sqrt(l1*l1 + d*d);
        }

    } else {
        if (d < 0) { //is camera is belown top bbox level?
            d2 = cameraDistance - node.diskDistance;
            if (d2 < 0) { //is camera is belown bottom bbox level?
                d = -d2;
            } else { //is camera inside bbox
                return [Number.POSITIVE_INFINITY, 0.1];
            }
        }
    }

    return [camera.camera.scaleFactor2(d) * screenPixelSize, d];
};

/*

MapSurfaceTile.prototype.getPixelSize22 = function(bbox, screenPixelSize, cameraPos, worldPos, returnDistance) {
    const min = bbox.min;
    const max = bbox.max;
    const p1 = bbox.center();
    bbox.updateMaxSize();
    const d = bbox.maxSize * 0.5;

    const dd = [cameraPos[0]-p1[0],
               cameraPos[1]-p1[1],
               cameraPos[2]-p1[2]];

    const d2 = vec3.length(dd) - (bbox.maxSize * 0.5);

    const factor = this.camera.scaleFactor2(d2);

    if (returnDistance) {
        return [(factor[0] * screenPixelSize), factor[1]];
    }

    return (factor * screenPixelSize);
};
*/

MapSurfaceTile.prototype.updateTexelSize = function() {
    const map = this.map;
    const draw = map.draw;
    const camera = map.camera;
    const texelSizeFit = draw.texelSizeFit;
    const node = this.metanode;
    const cameraPos = map.camera.position;
    const preciseDistance = (map.isGeocent && (map.config.mapPreciseDistanceTest || node.metatile.useVersion >= 4));
    let pixelSize, factor, v, p;

    if (node.hasGeometry()) {
        let screenPixelSize = Number.POSITIVE_INFINITY;

        if (node.usedTexelSize()) {
            screenPixelSize = draw.ndcToScreenPixel * node.pixelSize;
        } else if (node.usedDisplaySize()) {
            screenPixelSize = draw.ndcToScreenPixel * ((node.bbox ? node.bbox.maxSize : node.bboxMaxSize) / node.displaySize);
        }

        if (camera.camera.ortho) {
            const height = camera.camera.getViewHeight();
            pixelSize = [(screenPixelSize*2.0) / height, height];
        } else {

            if (node.usedDisplaySize()) {

                if (!preciseDistance) {
                    screenPixelSize = draw.ndcToScreenPixel * ((node.bbox ? node.bbox.maxSize : node.bboxMaxSize) / 256);

                    factor = (node.displaySize / 256) * camera.distance;

                    v = camera.vector; //move camera away hack
                    p = [cameraPos[0] - v[0] * factor, cameraPos[1] - v[1] * factor, cameraPos[2] - v[2] * factor];

                    pixelSize = this.getPixelSize(node.bbox, screenPixelSize, p, p, true);
                } else {
                    if (draw.isGeocent) {
                        screenPixelSize = draw.ndcToScreenPixel * ((node.diskAngle2A * draw.planetRadius * 1.41421356236) / node.displaySize);
                    } else {
                        screenPixelSize = draw.ndcToScreenPixel * ((node.bbox ? node.bbox.maxSize : node.bboxMaxSize) / node.displaySize);
                    }

                    pixelSize = this.getPixelSize3(node, screenPixelSize);
                }
            } else {

                if (!preciseDistance && texelSizeFit > 1.1) {
                    screenPixelSize = draw.ndcToScreenPixel * node.pixelSize * (texelSizeFit / 1.1);
                    factor = (texelSizeFit / 1.1) * camera.distance;

                    v = camera.vector; //move camera away hack
                    p = [cameraPos[0] - v[0] * factor, cameraPos[1] - v[1] * factor, cameraPos[2] - v[2] * factor];

                    pixelSize = this.getPixelSize(node.bbox, screenPixelSize, p, p, true);
                } else {
                    if (preciseDistance) {
                        pixelSize = this.getPixelSize3(node, screenPixelSize);
                    } else {
                        pixelSize = this.getPixelSize(node.bbox, screenPixelSize, cameraPos, cameraPos, true);
                    }
                }
            }
        }
    } else {
        if (preciseDistance) {
            pixelSize = this.getPixelSize3(node, 1, 1);
        } else {
            pixelSize = this.getPixelSize(node.bbox, 1, cameraPos, cameraPos, true);
        }

        //pixelSize = this.getPixelSize(node.bbox, 1, cameraPos, cameraPos, true);
        pixelSize[0] = Number.POSITIVE_INFINITY;
    }

    this.texelSize = pixelSize[0];
    this.distance = pixelSize[1];

    //degrade horizont
    if (!map.config.mapDegradeHorizon || draw.degradeHorizonFactor < 1.0) {
        return;
    }

    const degradeHorizon = map.config.mapDegradeHorizonParams;
    const degradeFadeStart = degradeHorizon[1];
    const degradeFadeEnd = degradeHorizon[2];

    //reduce degrade factor by tilt
    let degradeFactor = draw.degradeHorizonFactor * draw.degradeHorizonTiltFactor;
    const distance = this.distance * camera.distanceFactor;

    //apply degrade factor smoothly from specified tile distance
    if (distance < degradeFadeStart) {
        degradeFactor = 1.0;
    } else if (distance > degradeFadeStart && distance < degradeFadeEnd) {
        degradeFactor = 1.0 + (degradeFactor-1.0) * ((distance - degradeFadeStart) / (degradeFadeEnd - degradeFadeStart));
    }

    degradeFactor = Math.max(degradeFactor, 1.0);

    //reduce degrade factor by observed distance
    const observerDistance = camera.perceivedDistance;
    const distanceFade = degradeHorizon[3];

    if (observerDistance > distanceFade) {
        degradeFactor = 1.0;
    } else if (observerDistance < distanceFade && degradeFactor > 1.0) {
        degradeFactor = 1.0 + ((degradeFactor - 1.0) * (1.0-(observerDistance / distanceFade)));
    }

    //console.log("degrade: " + degradeFactor);

    this.texelSize /= degradeFactor;
};


// eslint-disable-next-line
MapSurfaceTile.prototype.drawGrid = function(cameraPos, divNode, angle, onlySetBorderData, subdiv) {
    /* if (!(subdiv || onlySetBorderData)) {
        if (this.gridRenderCounter != this.map.draw.drawCounter) {
            this.gridRenderCounter = this.map.draw.drawCounter;
        } else {
            return; //prevent rendering same grid more then on time
        }
    } */

    if ((this.texelSize == Number.POSITIVE_INFINITY || this.texelSize > 4.4) && this.metanode && this.metanode.hasChildren()) {
        return;
    }

    if (!this.metanode) {
        return;
    }

    const map = this.map;
    let node, ll, ur, res;

    if (map.draw.gridSkipped) {
        return;
    }


    if (divNode) {
        node = divNode[0];
        ll = divNode[1][0];
        ur = divNode[1][1];
    } else {
        res = map.measure.getSpatialDivisionNodeAndExtents(this.id);
        node = res[0];
        ll = res[1][0];
        ur = res[1][1];
    }

    let middle = [(ur[0] + ll[0])* 0.5, (ur[1] + ll[1])* 0.5];

    const hasPoles = map.referenceFrame.hasPoles;

    angle = angle || this.metanode.diskAngle2;

    if ((hasPoles && !node.isPole) &&  Math.acos(angle) > Math.PI*0.1) {
        angle = Math.cos(Math.acos(angle) * 0.5);

        this.drawGrid(cameraPos, [node, [ [ll[0], ll[1]],  [middle[0], middle[1]] ] ], angle, false, true);
        this.drawGrid(cameraPos, [node, [ [middle[0], ll[1]],  [ur[0], middle[1]] ] ], angle, false, true);

        this.drawGrid(cameraPos, [node, [ [ll[0], middle[1]],  [middle[0], ur[1]] ] ], angle, false, true);
        this.drawGrid(cameraPos, [node, [ [middle[0], middle[1]],  [ur[0], ur[1]] ] ], angle, false, true);

        return;
    }

    //const desiredSamplesPerViewExtent = 5;
    //const nodeExtent = node.extents.ur[1] - node.extents.ll[1];
    //const viewExtent = this.distance ;//* 0.1;
    //let lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / map.log2;
    //lod = Math.max(0,lod - 8 + node.id[0]);

    let h, factor, prog, mnode;

    const draw = map.draw;
    const sx = cameraPos[0];
    const sy = cameraPos[1];
    const sz = cameraPos[2];
    const buffer = draw.planeBuffer;
    const flatGrid = draw.gridFlat;
    const joinGrids = draw.gridGlues; //this.map.draw.debug.drawFog;
    const gridPoints = this.gridPoints;
    const useSurrogatez = map.config.mapGridSurrogatez;

    if (!gridPoints) {

        h = useSurrogatez ? this.metanode.surrogatez : this.metanode.minZ;
        const n1 = node.getPhysicalCoords([ur[0], ur[1], h], true);
        const n2 = node.getPhysicalCoords([ur[0], ll[1], h], true);
        const n3 = node.getPhysicalCoords([ll[0], ll[1], h], true);
        const n4 = node.getPhysicalCoords([ll[0], ur[1], h], true);
        const mtop = node.getPhysicalCoords([middle[0], ur[1], h], true);
        const mbottom = node.getPhysicalCoords([middle[0], ll[1], h], true);
        const mleft = node.getPhysicalCoords([ll[0], middle[1], h], true);
        const mright = node.getPhysicalCoords([ur[0], middle[1], h], true);

        middle[2] = h;
        middle = node.getPhysicalCoords(middle, true);

        if (!divNode) {

            const gridPoints = [
                n4[0], n4[1], n4[2],
                mtop[0], mtop[1], mtop[2],
                n1[0], n1[1], n1[2],

                mleft[0], mleft[1], mleft[2],
                middle[0], middle[1], middle[2],
                mright[0], mright[1], mright[2],

                n3[0], n3[1], n3[2],
                mbottom[0], mbottom[1], mbottom[2],
                n2[0], n2[1], n2[2]
            ];

            this.gridPoints = gridPoints;

        } else {
            buffer[0] = n4[0] - sx;
            buffer[1] = n4[1] - sy;
            buffer[2] = n4[2] - sz;

            buffer[3] = mtop[0] - sx;
            buffer[4] = mtop[1] - sy;
            buffer[5] = mtop[2] - sz;

            buffer[6] = n1[0] - sx;
            buffer[7] = n1[1] - sy;
            buffer[8] = n1[2] - sz;

            buffer[9] = mleft[0] - sx;
            buffer[10] = mleft[1] - sy;
            buffer[11] = mleft[2] - sz;

            buffer[12] = middle[0] - sx;
            buffer[13] = middle[1] - sy;
            buffer[14] = middle[2] - sz;

            buffer[15] = mright[0] - sx;
            buffer[16] = mright[1] - sy;
            buffer[17] = mright[2] - sz;

            buffer[18] = n3[0] - sx;
            buffer[19] = n3[1] - sy;
            buffer[20] = n3[2] - sz;

            buffer[21] = mbottom[0] - sx;
            buffer[22] = mbottom[1] - sy;
            buffer[23] = mbottom[2] - sz;

            buffer[24] = n2[0] - sx;
            buffer[25] = n2[1] - sy;
            buffer[26] = n2[2] - sz;
        }
     }


    if (!flatGrid) {

        mnode = this.metanode;

        let border = mnode.border, borderNodes = mnode.borderNodes;
        let i, li, n, tree = map.tree, id = this.id;

        if (!border) {
            mnode.border = new Array(9);
            mnode.borderNodes = new Array(9);
            border = mnode.border, borderNodes = mnode.borderNodes;
            border[4] = useSurrogatez ? mnode.surrogatez : mnode.minZ;
        }


        const borderTable = tileBorderTable;
        let skip = false;

        if (!mnode.borderReady) {

            for (i = 0; i < 9; i++) {
                if (i != 4 && !borderNodes[i]) {
                    n = tree.getNodeById([id[0], id[1] + borderTable[i][0], id[2] + borderTable[i][1]], true);

                    if (n) {
                        borderNodes[i] = n;
                        border[i] = (useSurrogatez ? n.surrogatez : n.minZ);
                    } else {
                        border[i] = border[4];
                        skip = true;
                    }
                }
            }

        }

        let border2 = mnode.border2;
        h = useSurrogatez ? mnode.surrogatez : mnode.minZ

        if (!border2 || !mnode.borderReady) {
            border2 = [
                ((border[0] + border[1] + border[3] + border[4]) * 0.25) - h,
                ((border[1] + border[4]) * 0.5) - h,
                ((border[2] + border[1] + border[5] + border[4]) * 0.25) - h,

                ((border[3] + border[4]) * 0.5) - h,
                border[4] - h,
                ((border[5] + border[4]) * 0.5) - h,

                ((border[6] + border[7] + border[3] + border[4]) * 0.25) - h,
                ((border[7] + border[4]) * 0.5) - h,
                ((border[8] + border[7] + border[5] + border[4]) * 0.25) - h
            ];

            mnode.border2 = border2;
        }

        if (!skip) {
            mnode.borderReady = true;
        }

        if (onlySetBorderData) {
            return;
        }

        if (joinGrids) {
            const cornerTable = tileCornerTable;
            let nodeTable = this.nodeTable;

            if (!nodeTable) {
                nodeTable = new Array(9);
                this.nodeTable = nodeTable;
            }

            //get bodrer nodes
            for (i = 0, li = borderTable.length; i < li; i++) {
                if (i != 4) {
                    nodeTable[i] = tree.getRenderedNodeById([id[0], id[1] + borderTable[i][0], id[2] + borderTable[i][1]], draw.drawCounter);
                }
            }

            let border3 = mnode.border3;

            if (!border3) {
                border3 = new Array(9);
                mnode.border3 = border3;
            }

            //solve corners
            for (i = 0, li = cornerTable.length; i < li; i++) {
                let lowestNode = nodeTable[cornerTable[i][0]];

                for (let j = 1; j < 3; j++) {
                    n = nodeTable[cornerTable[i][j]];

                    if (n) {
                        if (lowestNode) {
                            if (n.id[0] < lowestNode.id[0]) {
                                lowestNode = n;
                            }
                        } else {
                            lowestNode = n;
                        }
                    }
                }

                nodeTable[cornerTable[i][0]] = lowestNode;
            }

            for (i = 0, li = borderTable.length; i < li; i++) {
                n = nodeTable[i];

                if (i != 4 && (n && n.id[0] < id[0])) {
                    let bcoords;

                    switch(i) {
                        case 0:  bcoords = [mnode.llx, mnode.lly]; break;
                        case 1:  bcoords = [(mnode.urx+mnode.llx)*0.5, mnode.lly]; break;
                        case 2:  bcoords = [mnode.urx, mnode.lly]; break;

                        case 3:  bcoords = [mnode.llx, (mnode.ury+mnode.lly)*0.5]; break;
                        case 5:  bcoords = [mnode.urx, (mnode.ury+mnode.lly)*0.5]; break;

                        case 6:  bcoords = [mnode.llx, mnode.ury]; break;
                        case 7:  bcoords = [(mnode.urx+mnode.llx)*0.5, mnode.ury]; break;
                        case 8:  bcoords = [mnode.urx, mnode.ury]; break;
                    }

                    if (!n.border2) {
                        n.tile.drawGrid(cameraPos, divNode, angle, true);
                    }

                    if (n.border2) {
                        mnode.border3[i] = (n.getGridHeight(bcoords, n.border2, 3) + (useSurrogatez ? n.surrogatez : n.minZ))  - h;
                    } else {
                        border2[i];
                    }
                } else {
                    mnode.border3[i] = border2[i];
                }
            }
        }
    }

    const renderer = map.renderer;
    const mv = renderer.camera.getModelviewMatrix();
    const proj = renderer.camera.getProjectionMatrix();

    if (gridPoints) {
        buffer[0] = gridPoints[0] - sx;
        buffer[1] = gridPoints[1] - sy;
        buffer[2] = gridPoints[2] - sz;

        buffer[3] = gridPoints[3] - sx;
        buffer[4] = gridPoints[4] - sy;
        buffer[5] = gridPoints[5] - sz;

        buffer[6] = gridPoints[6] - sx;
        buffer[7] = gridPoints[7] - sy;
        buffer[8] = gridPoints[8] - sz;

        buffer[9] = gridPoints[9] - sx;
        buffer[10] = gridPoints[10] - sy;
        buffer[11] = gridPoints[11] - sz;

        buffer[12] = gridPoints[12] - sx;
        buffer[13] = gridPoints[13] - sy;
        buffer[14] = gridPoints[14] - sz;

        buffer[15] = gridPoints[15] - sx;
        buffer[16] = gridPoints[16] - sy;
        buffer[17] = gridPoints[17] - sz;

        buffer[18] = gridPoints[18] - sx;
        buffer[19] = gridPoints[19] - sy;
        buffer[20] = gridPoints[20] - sz;

        buffer[21] = gridPoints[21] - sx;
        buffer[22] = gridPoints[22] - sy;
        buffer[23] = gridPoints[23] - sz;

        buffer[24] = gridPoints[24] - sx;
        buffer[25] = gridPoints[25] - sy;
        buffer[26] = gridPoints[26] - sz;
    }

    if (hasPoles && !map.poleRadius && node.id[0] == 1 && !node.isPole) {
        const p = node.getPhysicalCoords([node.extents.ur[0], node.extents.ur[1], 0]);
        map.poleRadius = Math.sqrt(p[0]*p[0]+p[1]*p[1]);
        map.poleRadiusFactor = 8 * Math.pow(2.0, 552058 / map.poleRadius);
    }

    factor = 1;

    let useTexture = (map.config.mapGridTextureLayer != '');

    if (useTexture) {
        if (!this.gridTexture) {

            const layer = map.boundLayers[map.config.mapGridTextureLayer];
            let sourceTile = this;

            if (!layer || sourceTile < layer.lodRange[0]) {
                useTexture = false;
            } else {
                const sourceLod = math.clamp(sourceTile.id[0] - map.config.mapGridTextureLevel, layer.lodRange[0], layer.lodRange[3]);

                while (sourceTile.id[0] > sourceLod) {
                    sourceTile = sourceTile.parent;
                }

                //(path, type, extraBound, extraInfo, tile, internal)
                this.gridTexture = this.resources.getTexture("gmap#"+map.config.mapGridTextureLayer, null, {sourceTile: sourceTile, layer:layer, tile: this }, null, null, null);
                //this.gridTexture.isReady(false, 0, false);
            }

        }

        if (useTexture && !this.gridTexture.isReady(false, 0, false)) {  //TODO: set params with max priority
            useTexture = false;
        }
    }

    const hitmapRender = renderer.onlyDepth;

    if (hasPoles && node.isPole) {
        factor = map.poleRadiusFactor;
        prog = hitmapRender ? renderer.gpu.progPlane2D :renderer.gpu.progPlane2;
        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);
        prog.setVec4('uParams4', [-sx, -sy, map.poleRadius, 0]);
    } else {

        if (!flatGrid) {
            prog = hitmapRender ? renderer.gpu.progPlane3D : renderer.gpu.progPlane3;
            renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);

            let border;

            if (joinGrids) {
                border =  mnode.border3;
            } else {
                border = mnode.border2;
            }

            prog.setFloatArray('uHeights', border);
            prog.setVec3('uVector', mnode.diskNormal);

        } else {
            prog = hitmapRender ? renderer.gpu.progPlane : renderer.gpu.progPlane;
            renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);
        }
    }

    prog.setMat4('uMV', mv);
    prog.setMat4('uProj', proj);
    prog.setFloatArray('uPoints', buffer);

    /*
    const lx = (ur[0] - ll[0]);
    const ly = (ll[1] - ur[1]);
    const px = (ll[0] - node.extents.ll[0]) / lx;
    const py = (ur[1] - node.extents.ll[1]) / ly;

    const llx = (node.extents.ur[0] - node.extents.ll[0]) / lx;
    const lly = (node.extents.ur[1] - node.extents.ll[1]) / ly;

    px = px / llx;
    py = py / lly;
    llx = 1.0/llx;
    lly = 1.0/lly;

    llx *= step1;
    lly *= step1;
    px *= step1;
    py *= step1;
    */

    const step1 = node.gridStep1 * factor;

    const lx = 1.0 / (ur[0] - ll[0]);
    const ly = 1.0 / (ll[1] - ur[1]);
    const llx = step1 / ((node.extents.ur[0] - node.extents.ll[0]) * lx);
    const lly = step1 / ((node.extents.ur[1] - node.extents.ll[1]) * ly);
    const px = (ll[0] - node.extents.ll[0]) * lx * llx;
    const py = (ur[1] - node.extents.ll[1]) * ly * lly;


    if (useTexture) {
        renderer.gpu.bindTexture(this.gridTexture.getGpuTexture());
        prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/15, node.gridStep2 * factor]);

        const tt = this.gridTexture.getTransform();

//        prog.setVec4('uParams3', [tt[2], tt[3]+tt[1], tt[0], tt[1]]);
        prog.setVec4('uParams3', [tt[2], tt[3], tt[0], tt[1]]);

        //prog.setVec4('uParams3', [(py - Math.floor(py)), (px - Math.floor(px)), lly*0.5, llx*0.5]);
        prog.setVec4('uParams2', [0, 0, 0, 0]);
    } else {
        renderer.gpu.bindTexture(renderer.gpu.heightmapTexture);
        prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/15, node.gridStep2 * factor]);
        prog.setVec4('uParams3', [(py - Math.floor(py)), (px - Math.floor(px)), lly, llx]);
        prog.setVec4('uParams2', [0, 0, node.gridBlend, 0]);
    }

    prog.setVec4('uFogColor', draw.atmoColor);

    //draw bbox
    renderer.gpu.planeMesh.draw(prog, 'aPosition', 'aTexCoord');

    this.map.stats.drawnFaces += renderer.gpu.planeMesh.polygons;
};


MapSurfaceTile.prototype.drawHmapTile = function(cameraPos, divNode, angle, pipeline, texture) {
    //if ((this.texelSize == Number.POSITIVE_INFINITY || this.texelSize > 4.4) && this.metanode && this.metanode.hasChildren()) {
      //  return;
    //}

    if (!this.metanode) {
        return;
    }

    let node, ll, ur, res;
    const renderer = map.renderer, map = this.map, draw = map.draw;

    if (!renderer.gpu.progHmapPlane) {
        renderer.initProceduralShaders();
    }

    if (divNode) {
        node = divNode[0];
        ll = divNode[1][0];
        ur = divNode[1][1];
    } else {
        res = map.measure.getSpatialDivisionNodeAndExtents(this.id);
        node = res[0];
        ll = res[1][0];
        ur = res[1][1];
    }

    let middle = [(ur[0] + ll[0])* 0.5, (ur[1] + ll[1])* 0.5];
    const hasPoles = map.referenceFrame.hasPoles;
    angle = angle || this.metanode.diskAngle2;

    if ((hasPoles && !node.isPole) &&  Math.acos(angle) > Math.PI*0.1) {
        angle = Math.cos(Math.acos(angle) * 0.5);

        this.drawHmapTile(cameraPos, [node, [ [ll[0], ll[1]],  [middle[0], middle[1]] ] ], angle);
        this.drawHmapTile(cameraPos, [node, [ [middle[0], ll[1]],  [ur[0], middle[1]] ] ], angle);

        this.drawHmapTile(cameraPos, [node, [ [ll[0], middle[1]],  [middle[0], ur[1]] ] ], angle);
        this.drawHmapTile(cameraPos, [node, [ [middle[0], middle[1]],  [ur[0], ur[1]] ] ], angle);

        return;
    }

    //const desiredSamplesPerViewExtent = 5;
    //const nodeExtent = node.extents.ur[1] - node.extents.ll[1];
    //const viewExtent = this.distance ;//* 0.1;
    //let lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / map.log2;
    //lod = Math.max(0,lod - 8 + node.id[0]);

    let h, factor, prog;

    const sx = cameraPos[0];
    const sy = cameraPos[1];
    const sz = cameraPos[2];
    const buffer = draw.planeBuffer;
    const gridPoints = this.gridPoints;
    //const useSurrogatez = map.config.mapGridSurrogatez;

    if (!gridPoints) {

//        h = this.metanode.minZ;
        h = 0;//this.metanode.minHeight;
        const n1 = node.getPhysicalCoords([ur[0], ur[1], h], true);
        const n2 = node.getPhysicalCoords([ur[0], ll[1], h], true);
        const n3 = node.getPhysicalCoords([ll[0], ll[1], h], true);
        const n4 = node.getPhysicalCoords([ll[0], ur[1], h], true);
        const mtop = node.getPhysicalCoords([middle[0], ur[1], h], true);
        const mbottom = node.getPhysicalCoords([middle[0], ll[1], h], true);
        const mleft = node.getPhysicalCoords([ll[0], middle[1], h], true);
        const mright = node.getPhysicalCoords([ur[0], middle[1], h], true);

        middle[2] = h;
        middle = node.getPhysicalCoords(middle, true);

        if (!divNode) {

            const gridPoints = [
                n4[0], n4[1], n4[2],
                mtop[0], mtop[1], mtop[2],
                n1[0], n1[1], n1[2],

                mleft[0], mleft[1], mleft[2],
                middle[0], middle[1], middle[2],
                mright[0], mright[1], mright[2],

                n3[0], n3[1], n3[2],
                mbottom[0], mbottom[1], mbottom[2],
                n2[0], n2[1], n2[2]
            ];

            this.gridPoints = gridPoints;

        } else {
            buffer[0] = n4[0] - sx;
            buffer[1] = n4[1] - sy;
            buffer[2] = n4[2] - sz;

            buffer[3] = mtop[0] - sx;
            buffer[4] = mtop[1] - sy;
            buffer[5] = mtop[2] - sz;

            buffer[6] = n1[0] - sx;
            buffer[7] = n1[1] - sy;
            buffer[8] = n1[2] - sz;

            buffer[9] = mleft[0] - sx;
            buffer[10] = mleft[1] - sy;
            buffer[11] = mleft[2] - sz;

            buffer[12] = middle[0] - sx;
            buffer[13] = middle[1] - sy;
            buffer[14] = middle[2] - sz;

            buffer[15] = mright[0] - sx;
            buffer[16] = mright[1] - sy;
            buffer[17] = mright[2] - sz;

            buffer[18] = n3[0] - sx;
            buffer[19] = n3[1] - sy;
            buffer[20] = n3[2] - sz;

            buffer[21] = mbottom[0] - sx;
            buffer[22] = mbottom[1] - sy;
            buffer[23] = mbottom[2] - sz;

            buffer[24] = n2[0] - sx;
            buffer[25] = n2[1] - sy;
            buffer[26] = n2[2] - sz;
        }
     }

    const mv = renderer.camera.getModelviewMatrix();
    const proj = renderer.camera.getProjectionMatrix();

    if (gridPoints) {
        buffer[0] = gridPoints[0] - sx;
        buffer[1] = gridPoints[1] - sy;
        buffer[2] = gridPoints[2] - sz;

        buffer[3] = gridPoints[3] - sx;
        buffer[4] = gridPoints[4] - sy;
        buffer[5] = gridPoints[5] - sz;

        buffer[6] = gridPoints[6] - sx;
        buffer[7] = gridPoints[7] - sy;
        buffer[8] = gridPoints[8] - sz;

        buffer[9] = gridPoints[9] - sx;
        buffer[10] = gridPoints[10] - sy;
        buffer[11] = gridPoints[11] - sz;

        buffer[12] = gridPoints[12] - sx;
        buffer[13] = gridPoints[13] - sy;
        buffer[14] = gridPoints[14] - sz;

        buffer[15] = gridPoints[15] - sx;
        buffer[16] = gridPoints[16] - sy;
        buffer[17] = gridPoints[17] - sz;

        buffer[18] = gridPoints[18] - sx;
        buffer[19] = gridPoints[19] - sy;
        buffer[20] = gridPoints[20] - sz;

        buffer[21] = gridPoints[21] - sx;
        buffer[22] = gridPoints[22] - sy;
        buffer[23] = gridPoints[23] - sz;

        buffer[24] = gridPoints[24] - sx;
        buffer[25] = gridPoints[25] - sy;
        buffer[26] = gridPoints[26] - sz;
    }

    if (hasPoles && !map.poleRadius && node.id[0] == 1 && !node.isPole) {
        const p = node.getPhysicalCoords([node.extents.ur[0], node.extents.ur[1], 0]);
        map.poleRadius = Math.sqrt(p[0]*p[0]+p[1]*p[1]);
        map.poleRadiusFactor = 8 * Math.pow(2.0, 552058 / map.poleRadius);
    }

    let mnode = this.metanode;
    const testMode = draw.debug.drawTestMode;

    factor = 1;

    if (hasPoles && node.isPole) {
        factor = map.poleRadiusFactor;
        prog = renderer.gpu.progPlane2;
        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);
        prog.setVec4('uParams4', [-sx, -sy, map.poleRadius, 0]);
    } else {

        switch(testMode) {
            default:
            case 0: prog = renderer.gpu.progHmapPlane; break;
            case 1: prog = renderer.gpu.progHmapPlane2; break;
            case 2: prog = renderer.gpu.progHmapPlane5; break;
            case 3: prog = renderer.gpu.progHmapPlane6; break;
            case 4: prog = renderer.gpu.progHmapPlane7; break;

            case 8: prog = renderer.gpu.progHmapPlane4; break;
            case 9: prog = pipeline == 1 ? renderer.gpu.progHmapPlane3 : renderer.gpu.progHmapPlane8; break;
        }


        if (testMode == 3 || testMode == 4) {
            if (!renderer.ntextures) {
                renderer.ntextures = [
                    /*
                    new GpuTexture(renderer.gpu, './textures/test/test001.png', renderer.core, null), //0
                    new GpuTexture(renderer.gpu, './textures/test/test002.png', renderer.core, null), //1
                    new GpuTexture(renderer.gpu, './textures/test003.jpg', renderer.core, null),      //2
                    new GpuTexture(renderer.gpu, './textures/download.png', renderer.core, null),     //3
                    new GpuTexture(renderer.gpu, './textures/test009.jpg', renderer.core, null),      //4
                    new GpuTexture(renderer.gpu, './textures/test004.jpg', renderer.core, null),      //5
                    new GpuTexture(renderer.gpu, './textures/test005.jpg', renderer.core, null),      //6
                    new GpuTexture(renderer.gpu, './textures/nor_sand.jpg', renderer.core, null),     //7
                    new GpuTexture(renderer.gpu, './textures/test007.jpg', renderer.core, null),      //8
                    new GpuTexture(renderer.gpu, './textures/test008.jpg', renderer.core, null),      //9

                    new GpuTexture(renderer.gpu, './textures/download (1).png', renderer.core, null),  //10
                    new GpuTexture(renderer.gpu, './textures/test010.jpg', renderer.core, null),      //11
                    new GpuTexture(renderer.gpu, './textures/test011.jpg', renderer.core, null),      //12
                    new GpuTexture(renderer.gpu, './textures/test012.jpg', renderer.core, null),      //13
                    new GpuTexture(renderer.gpu, './textures/test013.jpg', renderer.core, null),      //14
                    new GpuTexture(renderer.gpu, './textures/test014.jpg', renderer.core, null),      //15
                    new GpuTexture(renderer.gpu, './textures/test015.jpg', renderer.core, null),      //16
                    new GpuTexture(renderer.gpu, './textures/test016.jpg', renderer.core, null),      //17
                    new GpuTexture(renderer.gpu, './textures/test017.jpg', renderer.core, null),      //18
                    new GpuTexture(renderer.gpu, './textures/test018.jpg', renderer.core, null)      //18
                    */

                    renderer.gpu.createTexture({path: './textures/test/test001.png'}), //0
                    renderer.gpu.createTexture({path: './textures/test/test002.png'}), //1
                    renderer.gpu.createTexture({path: './textures/test003.jpg'}),      //2
                    renderer.gpu.createTexture({path: './textures/download.png'}),     //3
                    renderer.gpu.createTexture({path: './textures/test009.jpg'}),      //4
                    renderer.gpu.createTexture({path: './textures/test004.jpg'}),      //5
                    renderer.gpu.createTexture({path: './textures/test005.jpg'}),      //6
                    renderer.gpu.createTexture({path: './textures/nor_sand.jpg'}),     //7
                    renderer.gpu.createTexture({path: './textures/test007.jpg'}),      //8
                    renderer.gpu.createTexture({path: './textures/test008.jpg'}),      //9

                    renderer.gpu.createTexture({path: './textures/download (1).png'}),  //10
                    renderer.gpu.createTexture({path: './textures/test010.jpg'}),      //11
                    renderer.gpu.createTexture({path: './textures/test011.jpg'}),      //12
                    renderer.gpu.createTexture({path: './textures/test012.jpg'}),      //13
                    renderer.gpu.createTexture({path: './textures/test013.jpg'}),      //14
                    renderer.gpu.createTexture({path: './textures/test014.jpg'}),      //15
                    renderer.gpu.createTexture({path: './textures/test015.jpg'}),      //16
                    renderer.gpu.createTexture({path: './textures/test016.jpg'}),      //17
                    renderer.gpu.createTexture({path: './textures/test017.jpg'}),      //18
                    renderer.gpu.createTexture({path: './textures/test018.jpg'})      //18

                    ];
            }
        }

//        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aBarycentric']);
        //renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);
        renderer.gpu.useProgram(prog, ['aPosition']);
        prog.setVec3('uVector', mnode.diskNormal);

        //prog.setVec3('uRight', mnode.diskNormal);

        if (gridPoints) {
            const vecRight = [gridPoints[15] - gridPoints[12], gridPoints[16] - gridPoints[13], gridPoints[17] - gridPoints[14]];
            const vecTop = [gridPoints[21] - gridPoints[12], gridPoints[22] - gridPoints[13], gridPoints[23] - gridPoints[14]];

            vec3.normalize(vecRight);
            vec3.normalize(vecTop);

            const vecDir = mnode.diskNormal.slice();
            //vecDir = [-vecDir[0], -vecDir[1], -vecDir[2]];

            //prog.setVec3('uRight', vecRight);
            //prog.setVec3('uTop', vecTop);


            const mv = map.camera.camera.modelview;
            const mv2 = mat3.create();

            mat4.toInverseMat3(mv, mv2);

            //vts.mat4.toMat3(mv, mv2);
            mat3.transpose(mv2);

            mat3.multiplyVec3(mv2, vecTop);
            mat3.multiplyVec3(mv2, vecDir);
            mat3.multiplyVec3(mv2, vecRight);

            const space = [
                vecRight[0], vecRight[1], vecRight[2],
                vecTop[0], vecTop[1], vecTop[2],
                vecDir[0], vecDir[1], vecDir[2],
            ];

            /*
            const mv3 = vts.mat3.toMat4(mv2);
            vts.mat4.multiply(mv3, vts.mat3.toMat4(space), mv3);
            prog.setMat3('uSpace', vts.mat4.toMat3(mv3));
            */

            prog.setMat3('uSpace', space);
        }
    }

    prog.setMat4('uMV', mv);
    prog.setMat4('uProj', proj);
    prog.setFloatArray('uPoints', buffer);


    const step1 = node.gridStep1 * factor;
    prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/127, node.gridStep2 * factor]);

    if (testMode >= 3 && testMode <= 4) {
        prog.setVec4('uParams3', [1,1,0,0]);
    } else {
        if (texture) {
            prog.setVec4('uParams3', texture.getTransform());
        } else {
            const lx = 1.0 / (ur[0] - ll[0]);
            const ly = 1.0 / (ll[1] - ur[1]);
            const llx = step1 / ((node.extents.ur[0] - node.extents.ll[0]) * lx);
            const lly = step1 / ((node.extents.ur[1] - node.extents.ll[1]) * ly);
            const px = (ll[0] - node.extents.ll[0]) * lx * llx;
            const py = (ur[1] - node.extents.ll[1]) * ly * lly;

            prog.setVec4('uParams3', [lly, llx, (py - Math.floor(py)), (px - Math.floor(px))]);
        }
    }

    prog.setVec4('uParams2', [0, 0, node.gridBlend, 0]);
    prog.setVec4('uFogColor', draw.atmoColor);


    if (this.hmap.extraBound) {
        //get height form parent
        mnode = this.hmap.extraBound.sourceTile.metanode;
        prog.setVec3('uHeights', [mnode.minHeight, mnode.maxHeight, (1.0/mnode.pixelSize)]);
        prog.setVec4('uTransform', this.hmap.getTransform());
    } else {
        prog.setVec3('uHeights', [mnode.minHeight, mnode.maxHeight, (1.0/mnode.pixelSize)]);
        prog.setVec4('uTransform', [1,1,0,0]);
    }

    if (testMode >= 3 && testMode <= 4) {
        if (!renderer.ntextures[draw.debug.drawTestData].loaded) {
            return;
        }
        renderer.gpu.bindTexture(renderer.ntextures[draw.debug.drawTestData]);
    } else {
        if (texture) {
            renderer.gpu.bindTexture(texture.getGpuTexture());
        } else {
            renderer.gpu.bindTexture(renderer.gpu.heightmapTexture);
        }
    }

    prog.setSampler('uSampler', 0);

//    if(this.hmap) {
        renderer.gpu.bindTexture(this.hmap.getGpuTexture(), 1);
  //  } else {
        //renderer.gpu.bindTexture(renderer.blackTexture, 1);
  //      renderer.gpu.bindTexture(renderer.blackTexture2, 1);
   // }

    prog.setSampler('uSampler2', 1);

    //draw bbox
    //renderer.gpu.planeMesh2.draw(prog, 'aPosition', 'aTexCoord');
    renderer.gpu.planeMesh2.draw(prog, 'aPosition');

    /*
    if (vecRight && gridPoints) {
        //renderer.gpu.draw.drawLineString(points, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState);
        renderer.gpu.draw.drawLineString([[gridPoints[12], gridPoints[13], gridPoints[14]], [gridPoints[15], gridPoints[16], gridPoints[17]]], false, 4, [1,0,0,1], null, false, false, false, false);
        renderer.gpu.draw.drawLineString([[gridPoints[12], gridPoints[13], gridPoints[14]], [gridPoints[21], gridPoints[22], gridPoints[23]]], false, 4, [0,0,1,1], null, false, false, false, false);

        renderer.gpu.draw.drawLineString([[0, 0, 0], [9000000, 0, 0]], false, 4, [1,0,0,1], null, false, false, false, false);
        renderer.gpu.draw.drawLineString([[0, 0, 0], [0, 9000000, 0, 0]], false, 4, [0,1,0,1], null, false, false, false, false);
        renderer.gpu.draw.drawLineString([[0, 0, 0], [0, 0, 9000000]], false, 4, [0,0,1,1], null, false, false, false, false);
    }*/


    this.map.stats.drawnFaces += renderer.gpu.planeMesh2.polygons;
};


/* harmony default export */ __webpack_exports__["default"] = (MapSurfaceTile);


/***/ }),

/***/ "./src/core/map/surface-tree.js":
/*!**************************************!*\
  !*** ./src/core/map/surface-tree.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _surface_tile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./surface-tile */ "./src/core/map/surface-tile.js");




//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"];
const MapSurfaceTile = _surface_tile__WEBPACK_IMPORTED_MODULE_1__["default"];


const MapSurfaceTree = function(map, freeLayer, freeLayerSurface) {
    this.map = map;
    this.camera = map.camera;
    this.rootId = [0,0,0];
    this.freeLayer = freeLayer;
    this.freeLayerSurface = freeLayerSurface;
    this.metaBinaryOrder = this.map.referenceFrame.params.metaBinaryOrder;
    //this.initialized = false;
    //this.geocent = !this.map.getNavigationSrs().isProjected();

    this.surfaceTree = new MapSurfaceTile(this.map, null, this.rootId);

    //if (freeLayer !== true) {
        //this.heightTracer = new MapMetanodeTracer(this, null, this.traceTileHeight.bind(this), this.traceHeightChild.bind(this));
        //this.heightTracerNodeOnly = new MapMetanodeTracer(this, null, this.traceTileHeightNodeOnly.bind(this), this.traceHeightChild.bind(this));
    //}

    this.surfaceSequence = [];
    this.surfaceOnlySequence = [];

    this.config = this.map.config;
    this.cameraPos = [0,0,0];
    this.worldPos = [0,0,0];
    this.ndcToScreenPixel = 1.0;
    this.counter = 0;
};


MapSurfaceTree.prototype.kill = function() {
    this.surfaceTree = null;
    this.metastorageTree = null;
    this.surfaceTracer = null;
    this.heightTracer = null;
};


/*MapSurfaceTree.prototype.init = function() {
    const url = this.map.url.makeUrl(surface.metaUrl, {lod:result[0], ix:result[1], iy:result[2] });  //result???
    map.loader.load(url, metatile.load.bind(metatile, url));

    this.metatileTree.load();
    this.surfaceTree.metatile = 1;

    this.initialized = true;
};*/


MapSurfaceTree.prototype.findSurfaceTile = function(id) {
    let tile = this.surfaceTree;

//    for (const lod = 1; lod <= id[0]; lod++) {
//        const mask = 1 << (lod-1);
//        const index = 0;

    for (let lod = id[0]; lod > 0; lod--) {
        const mask = 1 << (lod-1);
        let index = 0;

        if ((id[1] & mask) != 0) {
            index += 1;
        }

        if ((id[2] & mask) != 0) {
            index += 2;
        }

        tile = tile.children[index];

        if (!tile) {
            return null;
        }
    }

    return tile;
};


MapSurfaceTree.prototype.findNavTile = function(id) {
    let tile = this.surfaceTree;

    if (id[0] == 0) {
        if (tile.metanode && tile.metanode.hasNavtile()) {
            return tile;
        } else {
            return null;
        }
    }

    let navtile = null;

//    for (const lod = 1; lod <= id[0]; lod++) {
//        const mask = 1 << (id[0] - lod);
//        const index = 0;
    for (let lod = id[0]; lod > 0; lod--) {
        const mask = 1 << (lod-1);
        let index = 0;

        if ((id[1] & mask) != 0) {
            index += 1;
        }

        if ((id[2] & mask) != 0) {
            index += 2;
        }

        tile = tile.children[index];

        if (!tile) {
            return navtile;
        } else {
            if (tile.metanode && tile.metanode.hasNavtile()) {
                navtile = tile;
            }
        }
    }

    return navtile;
};


MapSurfaceTree.prototype.draw = function(storeTilesOnly) {
    this.cameraPos = [0,0,0];
    this.worldPos = [0,0,0];

    const map = this.map;
    const draw = map.draw;
    this.ndcToScreenPixel = draw.ndcToScreenPixel;

    const srs = map.getPhysicalSrs();

    //const divisionNode = this.divisionNode;
    const periodicity = srs.periodicity;

    //if (this.map.config.mapBasicTileSequence) {
        //this.surfaceTracer = this.surfaceTracerBasic;
    //}

    if (this.freeLayerSurface && this.freeLayerSurface.geodata && draw.drawChannel != 0) {
        return;
    }

    if (periodicity != null) {
        this.drawSurface([0,0,0]);

        if (periodicity.type == 'X') {
            this.drawSurface([periodicity.period,0,0], storeTilesOnly);
            this.drawSurface([-periodicity.period,0,0], storeTilesOnly);
        }

    } else {
        let mode;

        if (this.freeLayerSurface && this.freeLayerSurface.geodata) {
            mode = map.config.mapGeodataLoadMode;
        } else {
            mode = map.config.mapLoadMode;
        }

        switch(mode) {
        case 'topdown':

            if (map.config.mapSplitMeshes) {
                this.drawSurfaceWithSpliting([0,0,0], storeTilesOnly);
            } else {
                this.drawSurface([0,0,0], storeTilesOnly);
            }

            break;

        case 'downtop': this.drawSurfaceDownTop([0,0,0], storeTilesOnly); break;
        case 'fit':     this.drawSurfaceFit([0,0,0], storeTilesOnly); break;
        case 'fitonly': this.drawSurfaceFitOnly([0,0,0], storeTilesOnly); break;
        }

    }
};


MapSurfaceTree.prototype.updateNodeHeightExtents = function(tile, node) {

    if (!node.heightReady && node.metatile.useVersion < 4) {
        let parent = tile.parent;

        //if (node.hasNavtile()) {
          //  node = node;
        //}

        while (parent) {
            const parentNode = parent.metanode;
            if (parentNode.hasNavtile()) {

                //if (node.hasNavtile()) {
                  //  node = node;
                //}

                node.minHeight = parentNode.minHeight;
                node.maxHeight = parentNode.maxHeight;
                node.minZ = parentNode.minZ;
                node.maxZ = parentNode.maxZ;
                node.minZ2 = parentNode.minZ2;
                node.maxZ2 = parentNode.maxZ2;
                node.generateCullingHelpers();
                break;
            }

            parent = parent.parent;
        }

        node.heightReady = true;
    }
};


MapSurfaceTree.prototype.logTileInfo = function(tile, node, cameraPos) {
    if (!tile || !node) {
        return;
    }

    const visible = tile.bboxVisible(tile.id, node.bbox, cameraPos, node);
    tile.updateTexelSize();

    // eslint-disable-next-line
    console.log('tile: ' + JSON.stringify(tile.id) + ' visible: ' + visible + ' texelsize: ' +  tile.texelSize + ' center: '  + JSON.stringify(node.diskPos) + ' vec: ' + node.diskNormal + 'ang: ' + node.diskAngle + ' dist: ' + node.diskDistance);
};


//loadmode = topdown
MapSurfaceTree.prototype.drawSurface = function(shift, storeTilesOnly) {
    this.counter++;

    let tile = this.surfaceTree;

    if (!tile.isMetanodeReady(this, 0)) {
        return;
    }

    let node = tile.metanode;
    const map = this.map;
    const cameraPos = map.camera.position;

    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {
        return;
    }

    tile.updateTexelSize();

    const typeFactor = this.freeLayerSurface ? 1 : 1;

    const draw = map.draw;
    const drawTiles = draw.drawTiles;
    const drawBuffer = draw.drawBuffer;
    const replay = draw.replay;
    const storeNodes = replay.storeNodes || replay.storeFreeNodes;
    const storeNodesBuffer = replay.nodeBuffer;
    let drawBufferIndex = 0;
    let processBuffer = draw.processBuffer;
    let processBufferIndex = 0;
    let newProcessBuffer = draw.processBuffer2;
    let newProcessBufferIndex = 0;
    let gpuNeeded = 0;
    let gpuNeededForRender = 0;
    let size = 0;

    processBuffer[0] = tile;
    processBufferIndex = 1;

    let texelSizeFit = draw.texelSizeFit;
    let best2 = 0;

    draw.drawCounter++;

    let pocessedNodes = 1;
    let pocessedMetatiles = 1;
    let usedNodes = 1;
    let drawCounter = draw.drawCounter, i, j, lj;

    do {
        let best = 0;
        newProcessBufferIndex = 0;

        for (i = processBufferIndex - 1; i >= 0; i--) {
            tile = processBuffer[i];
            node = tile.metanode;

            if (node) {
                pocessedNodes++;
                if (node.metatile.drawCounter != drawCounter) {
                    node.metatile.drawCounter = drawCounter;
                    pocessedMetatiles++;
                }
            }

            //if (this.map.drawIndices) {
              //  this.logTileInfo(tile, node, cameraPos);
            //}

            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {

                usedNodes++;

                if (tile.texelSize != Number.POSITIVE_INFINITY){
                    if (tile.texelSize > best) {
                        best = tile.texelSize;
                    }
                }

                if (storeNodes) { //used only for inspector
                    storeNodesBuffer.push(tile);
                }

                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit /*|| gpuNeeded > gpuMax*/) {
                    size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);

                    gpuNeeded += size;
                    gpuNeededForRender += size;

                    tile.drawCounter = draw.drawCounter;
                    drawBuffer[drawBufferIndex] = tile;
                    drawBufferIndex++;

                } else { //go deeper
                    size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);
                    gpuNeeded += size;

                    let childrenCount = 0;
                    let readyCount = 0;
                    let childrenBuffer = [];

                    for (j = 0; j < 4; j++) {
                        const child = tile.children[j];
                        if (child) {
                            childrenCount++;

                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority

                                this.updateNodeHeightExtents(child, child.metanode);
                                child.updateTexelSize();

                                const priority = child.id[0] * typeFactor * child.distance;

                                if (!tile.surface || !child.metanode.hasGeometry()) {

                                    readyCount++;
                                    //child.updateTexelSize();
                                    childrenBuffer.push(child);

                                } else {

                                    //are draw buffers ready? preventRender=true, preventLoad=false, doNotCheckGpu=true
                                    if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, true)) {

                                        readyCount++;
                                        //child.updateTexelSize();
                                        childrenBuffer.push(child);
                                    }

                                }
                            }
                        }
                    }

                    if (/*!(gpuNeeded > gpuMax) &&*/ childrenCount > 0 && childrenCount == readyCount) {
                        //sort children by distance

                        let sorted;

                        do {
                            sorted = true;

                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {
                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {
                                    const t = childrenBuffer[j];
                                    childrenBuffer[j] = childrenBuffer[j+1];
                                    childrenBuffer[j+1] = t;
                                    sorted = false;
                                }
                            }

                        } while(!sorted);


                        //add children to new process buffer
                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {

                            /*const n = childrenBuffer[j].metanode.divisionNode;
                            if ((n.id[0] == 1 && n.id[1] == 1 && n.id[2] == 0)) {*/
                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];
                            newProcessBufferIndex++;
                            /*}*/

                        }
                    } else {
                        // eslint-disable-next-line
                        gpuNeededForRender += size;

                        tile.drawCounter = draw.drawCounter;
                        drawBuffer[drawBufferIndex] = tile;
                        drawBufferIndex++;
                    }

                }
            }
        }

        const tmp = processBuffer;
        processBuffer = newProcessBuffer;
        newProcessBuffer = tmp;
        processBufferIndex = newProcessBufferIndex;

    } while(processBufferIndex > 0);

    if (storeTilesOnly) {
        this.storeDrawBufferGeometry(drawBufferIndex);
        return;
    }

    if (best2 > draw.bestMeshTexelSize) {
        draw.bestMeshTexelSize = best2;
    }

    const stats = map.stats;

    stats.usedNodes = usedNodes;
    stats.processedNodes = pocessedNodes;
    stats.processedMetatiles = pocessedMetatiles;
    stats.gpuNeeded = gpuNeeded;

    //console.log("texel: "+ this.map.bestMeshTexelSize);
    //console.log("more: "+ more + "more2: " + more2);

    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, false, false, replay, drawBuffer, drawBufferIndex, true);
};


//loadmode = topdown + split
MapSurfaceTree.prototype.drawSurfaceWithSpliting = function(shift, storeTilesOnly) {
    this.counter++;

    let tile = this.surfaceTree;

    if (!tile.isMetanodeReady(this, 0)) {
        return;
    }

    const map = this.map;
    const cameraPos = map.camera.position;
    let node = tile.metanode;

    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {
        return;
    }

    tile.updateTexelSize();

    const typeFactor = this.freeLayerSurface ? 1 : 1;

    const draw = map.draw;
    const drawTiles = draw.drawTiles;
    const drawBuffer = draw.drawBuffer;
    const replay = draw.replay;
    const storeNodes = replay.storeNodes || replay.storeFreeNodes;
    const storeNodesBuffer = replay.nodeBuffer;

    let drawBufferIndex = 0;
    let processBuffer = draw.processBuffer;
    let processBufferIndex = 0;
    let newProcessBuffer = draw.processBuffer2;
    let newProcessBufferIndex = 0;
    let gpuNeeded = 0;
    let gpuNeededForRender = 0;
    let size = 0;

    processBuffer[0] = tile;
    processBufferIndex = 1;

    let texelSizeFit = draw.texelSizeFit;

    let best2 = 0;

    draw.drawCounter++;

    let pocessedNodes = 1;
    let pocessedMetatiles = 1;
    let usedNodes = 1;
    let drawCounter = draw.drawCounter, i, j, lj;

    do {
        let best = 0;
        newProcessBufferIndex = 0;

        for (i = processBufferIndex - 1; i >= 0; i--) {
            tile = processBuffer[i];
            node = tile.metanode;

            if (node) {
                pocessedNodes++;
                if (node.metatile.drawCounter != drawCounter) {
                    node.metatile.drawCounter = drawCounter;
                    pocessedMetatiles++;
                }
            }

            //if (this.map.drawIndices) {
              //  this.logTileInfo(tile, node, cameraPos);
            //}

            tile.splitMask = null;
            //tile.splitMask = [0,0,0,1];

            if (tile.visibleCounter == drawCounter || tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {

                usedNodes++;

                if (tile.texelSize != Number.POSITIVE_INFINITY){
                    if (tile.texelSize > best) {
                        best = tile.texelSize;
                    }
                }

                if (storeNodes) { //used only for inspector
                    storeNodesBuffer.push(tile);
                }

                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit /*|| gpuNeeded > gpuMax*/) {

                    if (tile.skipRenderCounter != drawCounter) {

                        size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);

                        gpuNeeded += size;
                        gpuNeededForRender += size;

                        //if (tile.parent && tile.parent.children[3] == tile) {
                            tile.drawCounter = drawCounter;
                            drawBuffer[drawBufferIndex] = tile;
                            drawBufferIndex++;
                        //}
                    }

                } else { //go deeper
                    size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);
                    gpuNeeded += size;

                    let childrenCount = 0;
                    let childrenBuffer = [];
                    let mask = [1,1,1,1];
                    let useMask = false;

                    for (j = 0; j < 4; j++) {
                        const child = tile.children[j];
                        if (child) {
                            childrenCount++;
                            child.skipRenderCounter = tile.skipRenderCounter;

                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority

                                this.updateNodeHeightExtents(child, child.metanode);
                                child.updateTexelSize();

                                if (child.bboxVisible(child.id, child.metanode.bbox, cameraPos, child.metanode)) {
                                    child.visibleCounter = draw.drawCounter;
                                } else {
                                    continue;
                                }

                                const priority = child.id[0] * typeFactor * child.distance;

                                if (!tile.surface || !child.metanode.hasGeometry()) {
                                    childrenBuffer.push(child);
                                } else {
                                    //are draw buffers ready? preventRender=true, preventLoad=false, doNotCheckGpu=true
                                    if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, true)) {
                                        childrenBuffer.push(child);
                                        mask[j] = 0;
                                    } else {
                                        childrenBuffer.push(child);
                                        child.skipRenderCounter = drawCounter;
                                        useMask = true;
                                    }
                                }

                            } else {
                                //mask[j] = 0;
                                useMask = true;
                            }
                        }
                    }

                    if (childrenBuffer.length > 0) {
                        //sort children by distance

                        let sorted = true;

                        do {
                            sorted = true;

                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {
                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {
                                    const t = childrenBuffer[j];
                                    childrenBuffer[j] = childrenBuffer[j+1];
                                    childrenBuffer[j+1] = t;
                                    sorted = false;
                                }
                            }

                        } while(!sorted);


                        //add children to new process buffer
                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {
                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];
                            newProcessBufferIndex++;
                        }
                    }

                    if (childrenCount == 0 || useMask) {

                        //if (tile.parent && tile.parent.children[3] == tile) {

                        if (tile.skipRenderCounter != drawCounter) {
                            // eslint-disable-next-line
                            gpuNeededForRender += size;
                            tile.splitMask = useMask ? mask : null;
                            tile.drawCounter = drawCounter;

                            drawBuffer[drawBufferIndex] = tile;
                            drawBufferIndex++;
                        }

                        //}
                    }


                }
            }
        }

        const tmp = processBuffer;
        processBuffer = newProcessBuffer;
        newProcessBuffer = tmp;
        processBufferIndex = newProcessBufferIndex;

    } while(processBufferIndex > 0);

    if (storeTilesOnly) {
        this.storeDrawBufferGeometry(drawBufferIndex);
        return;
    }

    if (best2 > draw.bestMeshTexelSize) {
        draw.bestMeshTexelSize = best2;
    }

    const stats = map.stats;

    stats.usedNodes = usedNodes;
    stats.processedNodes = pocessedNodes;
    stats.processedMetatiles = pocessedMetatiles;
    stats.gpuNeeded = gpuNeeded;

    //console.log("texel: "+ this.map.bestMeshTexelSize);
    //console.log("more: "+ more + "more2: " + more2);

    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, false, false, replay, drawBuffer, drawBufferIndex, true);
};


//loadmode = fitonly
MapSurfaceTree.prototype.drawSurfaceFitOnly = function(shift, storeTilesOnly, useDrawBufferOnly) {
    this.counter++;
//    this.surfaceTracer.trace(this.surfaceTree);//this.rootId);

    let tile = this.surfaceTree;

    if (!tile.isMetanodeReady(this, 0)) {
        return;
    }

    const map = this.map;
    const cameraPos = map.camera.position;
    let node = tile.metanode;

    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {
        return;
    }

    tile.updateTexelSize();

    //const typeFactor = this.freeLayerSurface ? 1 : 1;

    const draw = map.draw;
    const drawTiles = draw.drawTiles;
    const drawBuffer = draw.drawBuffer;
    const replay = map.draw.replay;
    const storeNodes = replay.storeNodes || replay.storeFreeNodes;
    const storeNodesBuffer = replay.nodeBuffer;
    let drawBufferIndex = 0;
    let processBuffer = draw.processBuffer;
    let processBufferIndex = 0;
    let newProcessBuffer = draw.processBuffer2;
    let newProcessBufferIndex = 0;

    processBuffer[0] = tile;
    processBufferIndex = 1;

    let texelSizeFit = draw.texelSizeFit;

    draw.drawCounter++;

    let usedNodes = 1;
    let pocessedNodes = 1;
    let pocessedMetatiles = 1;
    let drawCounter = draw.drawCounter, i, j, lj;
    //let grids = false;

    do {
        let best = 0;
        newProcessBufferIndex = 0;

        for (i = processBufferIndex - 1; i >= 0; i--) {
            tile = processBuffer[i];
            node = tile.metanode;

            if (node) {
                pocessedNodes++;
                if (node.metatile.drawCounter != drawCounter) {
                    node.metatile.drawCounter = drawCounter;
                    pocessedMetatiles++;
                }
            }

            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {

                usedNodes++;

                if (storeNodes) { //used only for inspector
                    storeNodesBuffer.push(tile);
                }

                if (tile.texelSize  != Number.POSITIVE_INFINITY){
                    if (tile.texelSize > best) {
                        best = tile.texelSize;
                    }
                }

                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit) {

                    tile.drawCounter = draw.drawCounter;
                    drawBuffer[drawBufferIndex] = tile;
                    drawBufferIndex++;

                } else { //go deeper

                    let childrenCount = 0;
                    let nodesReadyCount = 0;
                    let childrenBuffer = [];

                    for (j = 0; j < 4; j++) {
                        const child = tile.children[j];
                        if (child) {
                            childrenCount++;

                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority

                                this.updateNodeHeightExtents(child, child.metanode);
                                child.updateTexelSize();

                                childrenBuffer.push(child);
                                nodesReadyCount++;

                            } /*else if (useDrawBufferOnly) { //used in downtop
                                //drawBuffer[drawBufferIndex] = [child, true];
                                //drawBufferIndex++;
                            }*/
                        }
                    }

                    if (childrenCount > 0 && (!useDrawBufferOnly || childrenCount == nodesReadyCount)) {
                        //sort children by distance
                        let sorted;

                        do {
                            sorted = true;

                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {
                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {
                                    const t = childrenBuffer[j];
                                    childrenBuffer[j] = childrenBuffer[j+1];
                                    childrenBuffer[j+1] = t;
                                    sorted = false;
                                }
                            }

                        } while(!sorted);

                        //add childrn to new process buffer
                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {

                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];
                            newProcessBufferIndex++;
                        }
                    } else {
                        tile.drawCounter = draw.drawCounter;
                        drawBuffer[drawBufferIndex] = tile;
                        drawBufferIndex++;
                    }

                }
            }
        }

        const tmp = processBuffer;
        processBuffer = newProcessBuffer;
        newProcessBuffer = tmp;
        processBufferIndex = newProcessBufferIndex;

    } while(processBufferIndex > 0);

    if (storeTilesOnly) {
        if (useDrawBufferOnly) {
            const tmp = draw.drawBuffer2;
            draw.drawBuffer2 = draw.drawBuffer;
            draw.drawBuffer = tmp;
            //draw.drawBufferIndex = drawBufferIndex;
        } else {
            this.storeDrawBufferGeometry(drawBufferIndex);
        }
        return drawBufferIndex;
    }

    const stats = map.stats;

    stats.usedNodes = usedNodes;
    stats.processedNodes = pocessedNodes;
    stats.processedMetatiles = pocessedMetatiles;

    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, false, false, replay, drawBuffer, drawBufferIndex, true);
};


//loadmode = fit
MapSurfaceTree.prototype.drawSurfaceFit = function(shift, storeTilesOnly) {
    this.counter++;

    let tile = this.surfaceTree;

    if (!tile.isMetanodeReady(this, 0)) {
        return;
    }

    const map = this.map;
    const cameraPos = map.camera.position;
    let node = tile.metanode;

    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {
        return;
    }

    tile.updateTexelSize();

    const geodata = tile.surface ? tile.surface.geodata : null;
    const maxLod = tile.surface.maxLod || tile.surface.lodRange[1];
    const free = tile.surface ? tile.surface.free : null;
    const drawGrid = (!geodata && !free && map.config.mapHeightfiledWhenUnloaded);
    let checkGpu = true;

    let lodShift = 4;//this.freeLayerSurface ? 1 : 1;
    let typeFactor = 2000;//this.freeLayerSurface ? 1 : 1;

    if (this.freeLayerSurface) {
        lodShift = 0;//this.freeLayerSurface ? 1 : 1;
        typeFactor = 0.1;//this.freeLayerSurface ? 1 : 1;
    }

    const draw = map.draw;
    const drawTiles = draw.drawTiles;
    const replay = draw.replay;
    let drawBuffer = draw.drawBuffer;
    let drawBufferIndex = 0;
    let processBuffer = draw.processBuffer;
    let processBufferIndex = 0;
    let newProcessBuffer = draw.processBuffer2;
    let newProcessBufferIndex = 0;
    let lastProcessBufferIndex = newProcessBufferIndex;
    let lastDrawBufferIndex = drawBufferIndex;

    processBuffer[0] = [tile, 0];
    processBufferIndex = 1;

    let texelSizeFit = draw.texelSizeFit;

    let storeNodes = replay.storeNodes || replay.storeFreeNodes;
    let storeNodesBuffer = replay.nodeBuffer;

    draw.drawCounter++;

    let usedNodes = 1;
    let pocessedNodes = 1;
    let pocessedMetatiles = 1;
    let drawCounter = draw.drawCounter;
    let maxHiresLodLevels = map.config.mapMaxHiresLodLevels, i, j, lj, child, priority, parent, parent2, children2;
    let grids = false;

    do {
        let best = 0;
        newProcessBufferIndex = 0;

        /*if (this.map.drawIndices) {
            console.log("processed begin==============================================");
        }*/

        for (i = processBufferIndex - 1; i >= 0; i--) {
            const pack = processBuffer[i];
            tile = pack[0];
            let depth = pack[1];

            tile.childrenReadyCount = 0;

            /*if (this.map.drawIndices) {
                console.log(JSON.stringify(tile.id));
            }*/

            if (depth >= maxHiresLodLevels) {
                if (drawGrid) {
                    parent = tile;

                    //make sure that we draw grid with lowest possible detail
                    parent2 = parent.parent;

                    if (parent.id[0] > 3 && depth !=0 && parent2 && parent2.childrenReadyCount == 0) {
                        children2 = parent2.children;

                        if (!(depth >= 1 && parent.parent && ((children2[0] && children2[0].childrenReadyCount != 0) ||
                             (children2[1] && children2[1].childrenReadyCount != 0) ||
                             (children2[2] && children2[2].childrenReadyCount != 0) ||
                             (children2[3] && children2[3].childrenReadyCount != 0)))) {
                            parent = parent.parent;
                        }
                    }

                    //make sure that grid tile is rendered only one time
                    if (parent.drawCounter != draw.drawCounter && (!parent.parent || parent.parent.drawCounter != draw.drawCounter )) {
                        parent.drawCounter = draw.drawCounter;

                        drawBuffer[drawBufferIndex] = [parent, true]; //draw grid
                        drawBufferIndex++;
                        grids = true;
                    }
                }

                continue;
            }

            node = tile.metanode;

            if (node) {
                pocessedNodes++;
                if (node.metatile.drawCounter != drawCounter) {
                    node.metatile.drawCounter = drawCounter;
                    pocessedMetatiles++;
                }
            }


            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {

                usedNodes++;

                if (tile.texelSize  != Number.POSITIVE_INFINITY){
                    if (tile.texelSize > best) {
                        best = tile.texelSize;
                    }
                }

                if (storeNodes) { //used only for inspaector
                    storeNodesBuffer.push(tile);
                }

                lastProcessBufferIndex = newProcessBufferIndex;
                lastDrawBufferIndex = drawBufferIndex;

                if (!node.hasChildren() || tile.texelSize <= texelSizeFit || (geodata && tile.id[0] >= maxLod)) {

                    priority = ((tile.id[0] + lodShift) * typeFactor) * tile.distance;

                    if (node.hasChildren() && !drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, (depth > 0), checkGpu)) {

                        depth++; //we dont have tile ready, so we try to draw more detailed tiles

                        for (j = 0; j < 4; j++) {
                            child = tile.children[j];
                            if (child) {

                                if (child.isMetanodeReady(this, child.id[0], true)) { //lod is used as priority

                                    this.updateNodeHeightExtents(child, child.metanode);
                                    child.updateTexelSize();

                                    //are draw buffers ready? preventRender=true, preventLoad=false
                                    if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, (depth > 0), checkGpu)) {
                                        tile.childrenReadyCount++;
                                        child.drawCounter = draw.drawCounter;

                                        drawBuffer[drawBufferIndex] = [child, false];
                                        drawBufferIndex++;
                                    } else {
                                        newProcessBuffer[newProcessBufferIndex] = [child, depth];
                                        newProcessBufferIndex++;
                                    }
                                }
                            }
                        }

                        if (lastProcessBufferIndex == newProcessBufferIndex && lastDrawBufferIndex == drawBufferIndex) {
                            depth--;
                        }

                    } else {
                        tile.drawCounter = draw.drawCounter;

                        drawBuffer[drawBufferIndex] = [tile, false];
                        drawBufferIndex++;
                    }

                } else if (depth == 0 && node.hasGeometry() && tile.texelSize <= (texelSizeFit * 2)) {

                    //are all children ready? if not then draw carser lod
                    let childrenCount = 0;
                    let readyCount = 0;
                    let childrenBuffer = [];

                    for (j = 0; j < 4; j++) {
                        child = tile.children[j];
                        if (child) {
                            childrenCount++;

                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority

                                this.updateNodeHeightExtents(child, child.metanode);
                                child.updateTexelSize();

                                priority = ((child.id[0] + lodShift) * typeFactor) * child.distance;

                                //are draw buffers ready? preventRender=true, preventLoad=true
                                if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, true, checkGpu)) {
                                    readyCount++;
                                    childrenBuffer.push(child);
                                }
                            }
                        }
                    }

                    if (childrenCount > 0 && childrenCount == readyCount) {
                        //sort children by distance

                        let sorted;

                        do {
                            sorted = true;

                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {
                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {
                                    let t = childrenBuffer[j];
                                    childrenBuffer[j] = childrenBuffer[j+1];
                                    childrenBuffer[j+1] = t;
                                    sorted = false;
                                }
                            }

                        } while(!sorted);

                        //add children to new process buffer
                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {
                            newProcessBuffer[newProcessBufferIndex] = [childrenBuffer[j], depth];
                            newProcessBufferIndex++;
                        }
                    } else {

                        //can i use coarser lod
                        priority = ((tile.id[0] + lodShift) * typeFactor) * tile.distance;

                        if (drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, true, checkGpu)) {
                            tile.drawCounter = draw.drawCounter;

                            drawBuffer[drawBufferIndex] = [tile, false];
                            drawBufferIndex++;

                            for (j = 0; j < 4; j++) {
                                child = tile.children[j];
                                if (child) {
                                    if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority
                                        priority = ((child.id[0] + lodShift) * typeFactor) * child.distance;
                                        drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, checkGpu);
                                    }
                                }
                            }

                        } else {

                            //add children to new process buffer
                            for (j = 0; j < 4; j++) {
                                child = tile.children[j];
                                if (child) {
                                    if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority
                                        this.updateNodeHeightExtents(child, child.metanode);
                                        child.updateTexelSize();

                                        newProcessBuffer[newProcessBufferIndex] = [child, depth];
                                        newProcessBufferIndex++;
                                    }
                                }
                            }

                        }
                    }

                }  else  {  //go deeper


                    for (j = 0; j < 4; j++) {
                        child = tile.children[j];
                        if (child) {

                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority
                                this.updateNodeHeightExtents(child, child.metanode);
                                child.updateTexelSize();

                                newProcessBuffer[newProcessBufferIndex] = [child, depth];
                                newProcessBufferIndex++;
                            }
                        }
                    }
                }
            }


            if (drawGrid && lastProcessBufferIndex == newProcessBufferIndex && lastDrawBufferIndex == drawBufferIndex) {
                parent = tile;

                //make sure that we draw grid with lowest possible detail
                parent2 = parent.parent;

                if (parent.id[0] > 3 && depth !=0 && parent2 && parent2.childrenReadyCount == 0) {
                    children2 = parent2.children;

                    if (!(depth >= 1 && parent.parent && ((children2[0] && children2[0].childrenReadyCount != 0) ||
                         (children2[1] && children2[1].childrenReadyCount != 0) ||
                         (children2[2] && children2[2].childrenReadyCount != 0) ||
                         (children2[3] && children2[3].childrenReadyCount != 0)))) {
                        parent = parent.parent;
                    }
                }

                //make sure that grid tile is rendered only one time
                if (parent && parent.drawCounter != draw.drawCounter) {
                    parent.drawCounter = draw.drawCounter;

                    drawBuffer[drawBufferIndex] = [parent, true]; //draw grid
                    drawBufferIndex++;
                    grids = true;
                }
            }

        }

        /*if (this.map.drawIndices) {
            console.log("processed end==============================================");
        }*/

        const tmp = processBuffer;
        processBuffer = newProcessBuffer;
        newProcessBuffer = tmp;
        processBufferIndex = newProcessBufferIndex;

    } while(processBufferIndex > 0);

    if (storeTilesOnly) {
        this.storeDrawBufferGeometry(drawBufferIndex);
        return;
    }

    const stats = map.stats;

    stats.usedNodes = usedNodes;
    stats.processedNodes = pocessedNodes;
    stats.processedMetatiles = pocessedMetatiles;

    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, drawGrid, grids, replay, drawBuffer, drawBufferIndex);
};


//loadmode = downtop
// eslint-disable-next-line
MapSurfaceTree.prototype.drawSurfaceDownTop = function(shift, storeTilesOnly) {
    this.counter++;

    const map = this.map;
    const cameraPos = map.camera.position;
    let tile = this.surfaceTree;

    if (!tile.isMetanodeReady(this, 0)) {
        return;
    }

    tile.updateTexelSize();

    const root = tile;
    let node = tile.metanode;

    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {
        return;
    }

    //const drawBufferIndex2 = this.drawSurfaceFitOnly(shift, true, true);
    //if (drawBufferIndex2 == 0) {
      //  return;
    //}

    const draw = map.draw;
    const drawTiles = draw.drawTiles;
    let drawBuffer = draw.drawBuffer;
    let drawBuffer2 = draw.drawBuffer2;
    let drawBufferIndex = 0;
    let texelSizeFit = draw.texelSizeFit;
    let tilesToLoad = 0, priority, parent, child;

    let processBuffer = draw.processBuffer;
    let newProcessBuffer = draw.processBuffer2;
    let processBufferIndex = 0;
    let newProcessBufferIndex = 0;

    processBuffer[0] = tile;
    processBufferIndex = 1;

    draw.drawCounter++;

    const replay = map.draw.replay;
    const storeNodes = replay.storeNodes || replay.storeFreeNodes;
    const storeNodesBuffer = replay.nodeBuffer;

    let usedNodes = 1;
    let pocessedNodes = 1;
    let pocessedMetatiles = 1;
    let drawCounter = draw.drawCounter, i, j, lj;
    let grids = false, item, hit;

    do {
        let best = 0;
        newProcessBufferIndex = 0;

        for (i = processBufferIndex - 1; i >= 0; i--) {
            tile = processBuffer[i];
            node = tile.metanode;

            if (node) {
                // eslint-disable-next-line
                pocessedNodes++;
                if (node.metatile.drawCounter != drawCounter) {
                    node.metatile.drawCounter = drawCounter;
                    // eslint-disable-next-line
                    pocessedMetatiles++;
                }
            }

            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {

                // eslint-disable-next-line
                usedNodes++;

                if (storeNodes) { //used only for inspector
                    storeNodesBuffer.push(tile);
                }

                if (tile.texelSize  != Number.POSITIVE_INFINITY){
                    if (tile.texelSize > best) {
                        best = tile.texelSize;
                    }
                }

                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit) {

                    tile.drawCounter = drawCounter;
                    drawBuffer[drawBufferIndex] = tile;
                    drawBufferIndex++;

                } else { //go deeper

                    let childrenCount = 0;
                    let nodesReadyCount = 0;
                    let childrenBuffer = [];

                    for (j = 0; j < 4; j++) {
                        const child = tile.children[j];
                        if (child) {
                            childrenCount++;

                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority

                                this.updateNodeHeightExtents(child, child.metanode);
                                child.updateTexelSize();

                                childrenBuffer.push(child);
                                nodesReadyCount++;

                            } /*else if (useDrawBufferOnly) { //used in downtop
                                //drawBuffer[drawBufferIndex] = [child, true];
                                //drawBufferIndex++;
                            }*/
                        }
                    }

                    if (childrenCount > 0 && (childrenCount == nodesReadyCount)) {
                        //sort children by distance
                        let sorted;

                        do {
                            sorted = true;

                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {
                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {
                                    const t = childrenBuffer[j];
                                    childrenBuffer[j] = childrenBuffer[j+1];
                                    childrenBuffer[j+1] = t;
                                    sorted = false;
                                }
                            }

                        } while(!sorted);

                        //add childrn to new process buffer
                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {

                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];
                            newProcessBufferIndex++;
                        }
                    } else {
                        tile.drawCounter = drawCounter;
                        drawBuffer[drawBufferIndex] = [tile,true];
                        drawBufferIndex++;
                    }

                }
            }
        }

        const tmp = processBuffer;
        processBuffer = newProcessBuffer;
        newProcessBuffer = tmp;
        processBufferIndex = newProcessBufferIndex;

    } while(processBufferIndex > 0);

    if (drawBufferIndex == 0) {
        return;
    }

    let tmp = draw.drawBuffer2;
    draw.drawBuffer2 = draw.drawBuffer;
    draw.drawBuffer = tmp;

    drawBuffer = draw.drawBuffer;
    drawBuffer2 = draw.drawBuffer2;
    let drawBufferIndex2 = drawBufferIndex;
    drawBufferIndex = 0;

    //draw.drawCounter++;
    //drawCounter++;

    let lodShift = 4;
    let typeFactor = 2000;

    if (this.freeLayerSurface) {
        lodShift = 0;
        typeFactor = 0.1;
    }

    const findLoadedParent = (function(){

        //TODO: NEW RULES
            // search parent
               // if exist load from parent down (there can be configurable limit e.g. max 3 lods up)
               // if not exist (root) load only fit lod


        let hasLoadedParent = false;

        if (/*tile.texelSize != 1 && tile.texelSize <= texelSizeFit &&*/ tile != root) {
            parent = tile.parent;

            while (parent != root) {
                priority = ((parent.id[0] + lodShift) * typeFactor);

                // preventRender=true, preventLoad=true, checkGpu = false
                if (drawTiles.drawSurfaceTile(parent, parent.metanode, cameraPos, parent.texelSize, priority, true, true, false)) {
                    //render parent
                    drawBuffer[drawBufferIndex] = [parent, false];
                    parent.drawCounter = drawCounter;
                    hasLoadedParent = true;

                    //load children
                    for (let j = 0; j < 4; j++) {
                        child = parent.children[j];
                        if (child) {
                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority
                                // preventRender=true, preventLoad=false, checkGpu = false
                                if (!drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, false)) {
                                    tilesToLoad++;
                                }
                            }
                        }
                    }

                    break;
                }

                parent = parent.parent;
            }


            if (!hasLoadedParent) {
                priority = ((tile.id[0] + lodShift) * typeFactor);

                // preventRender=true, preventLoad=false, checkGpu = false
                if (!drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, false, false)) {
                    drawBuffer[drawBufferIndex] = [tile, true];
                    tile.drawCounter = drawCounter;
                    tilesToLoad++;
                } else {
                    drawBuffer[drawBufferIndex] = [tile, false];
                    tile.drawCounter = drawCounter;
                }
            }
        }


    });


    //draw surface
    for (i = drawBufferIndex2 - 1; i >= 0; i--) {
        item = drawBuffer2[i];
        //tile = (noGrid) ? item : item[0];

        if (item[1]) {
            tile = item[0];

            if (!tile.isMetanodeReady(this, tile.id[0])) { //lod is used as priority
                continue;
            }

            drawBuffer[drawBufferIndex] = [tile, true];
            grids = true;
            priority = 20;

            //TODO: search parents
                // if parent exist render parent (limit parent level?), load children,
                // remove parent children from draw buffer?

            //if (!node.hasChildren() || ) {

            findLoadedParent();

        } else {
            tile = item;
            node = tile.metanode;
            drawBuffer[drawBufferIndex] = [tile, false];
            priority = ((tile.id[0] + lodShift) * typeFactor);

            //are draw buffers ready? preventRender=true, preventLoad=false, checkGpu = false
            if (!drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, false, false)) {

                findLoadedParent();

                tilesToLoad++;
            } else {
                tile.drawCounter = drawCounter;
            }
        }

        drawBufferIndex++;
    }


    //filter out children
    tmp = drawBuffer2;
    drawBuffer2 = drawBuffer;
    drawBuffer = tmp;

    drawBufferIndex2 = drawBufferIndex;
    drawBufferIndex = 0;

    for (i = 0; i < drawBufferIndex2; i++) {
        item = drawBuffer2[i];

        tile = item[0];
        hit = false;

        if (tile != root) {
            parent = tile.parent;

            while (parent != root) {

                if (parent.drawCounter == drawCounter) {
                    hit = true;
                    break;
                }

                parent = parent.parent;
            }
        }

        if (!hit) {
            drawBuffer[drawBufferIndex] = drawBuffer2[i];
            drawBufferIndex++;
        }
    }


    //TODO: if everything loaded then load parents
        // use drawCounter as optimization

    if (tilesToLoad == 0) {

        for (i = 0; i < drawBufferIndex; i++) {
            item = drawBuffer[i];

            tile = item[0];
            hit = false;

            if (tile != root) {
                parent = tile.parent;

                while (parent != root) {

                    priority = (((100-tile.id[0]) + lodShift) * typeFactor);

                    //are draw buffers ready? preventRender=true, preventLoad=false, checkGpu = false
                    if (!drawTiles.drawSurfaceTile(parent, parent.metanode, cameraPos, parent.texelSize, priority, true, false, false)) {
                        break;
                    }

                    parent = parent.parent;
                }
            }

        }

    }


    //if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit) {

    const stats = map.stats;
    //const draw = map.draw;
    //const drawTiles = draw.drawTiles;
    //const replay = draw.replay;

    const geodata = tile.surface ? tile.surface.geodata : null;
    const free = tile.surface ? tile.surface.free : null;
    const drawGrid = (!geodata && !free && map.config.mapHeightfiledWhenUnloaded);

    //stats.usedNodes = usedNodes;
    //stats.processedNodes = pocessedNodes;
    //stats.processedMetatiles = pocessedMetatiles;

    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, drawGrid, grids, replay, drawBuffer, drawBufferIndex);
};


MapSurfaceTree.prototype.processDrawBuffer = function(draw, drawTiles, cameraPos, map, stats, drawGrid, grids, replay, drawBuffer, drawBufferIndex, noGrid) {

    if (replay.storeTiles || replay.storeFreeTiles) { //used only in inspectors
        if (!draw.tileBuffer[0]) {
            draw.tileBuffer[0] = [];
        }

        const tiles = draw.tileBuffer[0];
        for (i = drawBufferIndex - 1; i >= 0; i--) {
            tiles.push(drawBuffer[i]);
        }
    }

    const scanExtents = (!this.freeLayerSurface && map.config.mapFeatureStickMode[0] == 2); // && this.freeLayerSurface.geodata && draw.drawChannel == 0);
    const renderer = map.renderer;
    let hmax = -999999, hmin = 999999;
    let p1, p2, camVec, length, tilt, factor, i, tile, node;

    map.gpuCache.skipCostCheck = true;

    const underSurfaceGrid = (drawGrid && map.config.mapGridUnderSurface > 0 && grids);

    if (underSurfaceGrid) {
        //draw only grid
        for (i = drawBufferIndex - 1; i >= 0; i--) {
            drawBuffer[i][0].drawGrid(cameraPos);
        }

        //clear zbuffer
        map.renderer.gpu.clear(true, false);
    }

    //draw surface
    for (i = drawBufferIndex - 1; i >= 0; i--) {
        const item = drawBuffer[i];
        tile = (noGrid) ? item : item[0];
        node = tile.metanode;

        if (scanExtents && node) {
            // TODO noramlize by distance and tilt

            p2 = node.diskPos;
            p1 = renderer.cameraPosition;
            camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
            length = vec3.normalize4(camVec);
            tilt = -vec3.dot(camVec, node.diskNormal);

            if (tilt < 0) {
                tilt = 0;
            }

            tilt = 1 - tilt;

            factor = (renderer.camera.fovDist / length) * tilt;
            //renderer.camera.scaleFactor2(d) * screenPixelSize
            //pp = this.renderer.project2(tile.diskPos, mvp);

            if (node.minZ * factor < hmin) {
                hmin = node.minZ * factor;
            }

            if (node.maxZ * factor > hmax) {
                hmax = node.maxZ * factor;
            }
        }


        if (noGrid)  {

            if (stats.gpuRenderUsed >= draw.maxGpuUsed)  {
                break;
            }

            //draw tile,  preventRender=false, preventLoad=false
            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false);

        } else {

            if (underSurfaceGrid) {

                if (!item[1] && !(stats.gpuRenderUsed >= draw.maxGpuUsed))  {
                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false /*, checkGpu*/);
                } else {
                    if (drawTiles.debug.drawBBoxes) {
                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);
                    }
                }

            } else {

                if ((drawGrid && item[1]) || stats.gpuRenderUsed >= draw.maxGpuUsed)  {

                    if (drawTiles.debug.drawBBoxes) {
                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);
                    }

                    tile.drawGrid(cameraPos);
                } else if (!item[1]) {
                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false /*, checkGpu*/);
                }
            }

        }
    }

    if (scanExtents) {
        renderer.gridHmax = hmax;
        renderer.gridHmin = hmin;
    }

    map.gpuCache.skipCostCheck = false;
    map.gpuCache.checkCost();

};



MapSurfaceTree.prototype.storeDrawBufferGeometry = function(drawBufferIndex) {
    const map = this.map;
    const drawBuffer = map.draw.drawBuffer;

    this.storeGeometry(drawBuffer, drawBufferIndex);
};


MapSurfaceTree.prototype.storeGeometry = function(array, length) {
    const map = this.map;
    const drawBuffer = array;
    map.storedTilesRes = new Array(length);

    for (let i = length - 1; i >= 0; i--) {
        const tile = drawBuffer[i];

        if (tile.metanode && tile.surface && tile.metanode.hasGeometry() &&
            tile.surfaceMesh && tile.surfaceMesh.isReady(true, 0, true)) {

            const mesh = tile.surfaceMesh;
            const submeshes = [];

            for (let j = 0, lj = mesh.submeshes.length; j < lj; j++) {
                const submesh = mesh.submeshes[j],
                    vertices = submesh.vertices.slice(),
                    min = submesh.bbox.min,
                    max = submesh.bbox.max,
                    delta = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];

                for (let k = 0, lk = vertices.length; k < lk; k+=3) {
                    vertices[k] = vertices[k]*delta[0] + min[0];
                    vertices[k+1] = vertices[k+1]*delta[1] + min[1];
                    vertices[k+2] = vertices[k+2]*delta[2] + min[2];
                }

                submeshes.push({
                    "bbox": [min.slice(), max.slice()],
                    "vertices" : vertices });
            }

            map.storedTilesRes[i] = {
                "id": tile.id.slice(),
                "type": "mesh",
                "submeshes": submeshes
            };
        }
    }
};


MapSurfaceTree.prototype.traceHeight = function(tile, params, nodeOnly) {
    if (!tile) {
        return;
    }

    this.params = params;

    const heightFunction = nodeOnly ? this.traceHeightTileByNodeOnly : this.traceHeightTileByMap;

    if (tile.id[0] == 1) { //update root, get height in VTS2015 starts in division node which has lod 1
        this.traceHeightTile(tile.parent, 0, true);
        if (!tile.parent.metanode) {
            return;
        }
    }

    this.traceHeightTile(tile, 0, false, heightFunction);
};


MapSurfaceTree.prototype.traceHeightTile = function(tile, priority, nodeReadyOnly, heightFunction) {
    if (tile == null) {
        return;
    }

    if (!tile.isMetanodeReady(this, 0) || nodeReadyOnly) {
        this.params.waitingForNode = true;
        return;
    }

    tile.metanode.metatile.used();

    if (tile.lastSurface && tile.lastSurface == tile.surface) {
        tile.lastSurface = null;
        tile.restoreLastState();
        //return;
    }

    //process tile e.g. draw or get height
    const res = heightFunction(tile, this.params, priority);

    if (res) { //we need to go deeper
        const childIndex = this.traceHeightChild(tile, this.params);
        const child = tile.children[childIndex];

        if (!child) {
            this.params.finalNode = true;
        }

        this.traceHeightTile(child, 0, false, heightFunction);
    }
};


MapSurfaceTree.prototype.traceHeightChild = function(tile, params) {
    const coords = params.coords;
    const extents = params.extents;
    const center = [(extents.ll[0] + extents.ur[0]) *0.5,
        (extents.ll[1] + extents.ur[1]) *0.5];

    //ul,ur,ll,lr
    //deside in which quadrant are provided coodinates
    const right = (coords[0] >= center[0]);
    const bottom = (coords[1] >= center[1]);

    if (right) {
        extents.ll[0] = center[0];
        if (bottom) {
            extents.ll[1] = center[1];
        } else {
            extents.ur[1] = center[1];
        }
    } else {
        extents.ur[0] = center[0];
        if (bottom) {
            extents.ll[1] = center[1];
        } else {
            extents.ur[1] = center[1];
        }
    }

    /*
    if (extents.ll[0] > extents.ur[0]) {
        right = !right;
    }

    if (extents.ll[1] < extents.ur[1]) {
        bottom = !bottom;
    }*/

    //trace only resulting quadrant
    if (right) {
        return bottom ? 1 : 3;
    } else {
        return bottom ? 0 : 2;
    }
};


MapSurfaceTree.prototype.traceHeightTileByMap = function(tile, params) {
    if (!tile || (tile.id[0] > params.desiredLod && params.heightMap)) {
        return false;
    }

    const node = tile.metanode;

    if (!node) {
        return false;
    }

    if (node.hasNavtile()) {
        params.bestHeightMap = tile.id[0];

        if (!tile.heightMap) {
            //if (!preventLoad) {
                //if (!tile.surface || tile.surface.virtual) {
            if (!tile.surface || !tile.resourceSurface) { //surface.virtual) {
                return false; //is it best way how to do it?
            }

            if (!tile.resourceSurface.getNavUrl) { //virtual surface is as resource surface. Is it bug??!!
                return false; //is it best way how to do it?
            }

            const path = tile.resourceSurface.getNavUrl(tile.id);
            tile.heightMap = tile.resources.getTexture(path, true);
            //}
        } else {
            if (tile.heightMap.isReady(null, null, true)) {
                params.parent = {
                    metanode : params.metanode,
                    heightMap : params.heightMap,
                    heightMapExtents : params.heightMapExtents
                };

                params.metanode =  node;
                params.heightMap = tile.heightMap;
                params.heightMapExtents = {
                    ll : params.extents.ll.slice(),
                    ur : params.extents.ur.slice()
                };
                return (tile.id[0] != params.desiredLod);
            }
        }
    } else {
        if (!params.heightMap) {
            params.metanode =  node;
        }

        return true;
    }

    return false;
};


MapSurfaceTree.prototype.traceHeightTileByNodeOnly = function(tile, params) {
    if (!tile || tile.id[0] > params.desiredLod) {
        return false;
    }

    const node = tile.metanode;

    if (!node) {
        return false;
    }

    params.parent = {
        metanode : params.metanode
    };

    params.metanode =  node;
    return (tile.id[0] != params.desiredLod);
};


MapSurfaceTree.prototype.getNodeById = function(id, preventLoad) {
    let tile = this.surfaceTree;

    if (tile == null) {
        return;
    }

    for (let lod = id[0]; lod > 0; lod--) {
        const mask = 1 << (lod-1);
        let index = 0;

        if ((id[1] & mask) != 0) {
            index += 1;
        }

        if ((id[2] & mask) != 0) {
            index += 2;
        }

        if (!tile.children[index]) {

            if (!tile.isMetanodeReady(this, 0, preventLoad)) {
                return null;
            }

            if (!tile.metanode.hasChild(index)) {
                return null;
            }

            tile.addChild(index);
        }

        tile = tile.children[index];
    }

    if (!tile) {
        return;
    }

    if (!tile.isMetanodeReady(this, 0, preventLoad)) {
        return;
    }

    const node = tile.metanode;
    tile.metanode.metatile.used();

    return node;

	/*
    if (tile.lastSurface && tile.lastSurface == tile.surface) {
        tile.lastSurface = null;
        tile.restoreLastState();
        //return;
    }*/
};


MapSurfaceTree.prototype.getRenderedNodeById = function(id, drawCounter) {
    let tile = this.surfaceTree;

    if (tile == null) {
        return;
    }

    if (tile.drawCounter == drawCounter) {
        if (!tile.isMetanodeReady(this, 0)) {
            return;
        }

        return tile.metanode;
    }

    for (let lod = id[0]; lod > 0; lod--) {
        const mask = 1 << (lod-1);
        let index = 0;

        if ((id[1] & mask) != 0) {
            index += 1;
        }

        if ((id[2] & mask) != 0) {
            index += 2;
        }

        if (!tile.children[index]) {

            if (!tile.isMetanodeReady(this, 0)) {
                return;
            }

            if (!tile.metanode.hasChild(index)) {
                return;
            }
        }

        tile = tile.children[index];

        if (tile.drawCounter == drawCounter) {
            if (!tile.isMetanodeReady(this, 0)) {
                return;
            }

            return tile.metanode;
        } else {
            if (lod == 1) { //rendered lod is probably from more detailed lod so we take one which is from same lod
                return tile.metanode;
            }
        }
    }

    return;
};


MapSurfaceTree.prototype.chekTileMesh = function(tile) {
    if (this.params.loadMeshes || this.params.loadTextures) {

        const tmp = this.config.mapNoTextures;
        this.config.mapNoTextures = !this.params.loadTextures;

        //are resources ready? priority=0, preventRender=true, preventLoad=false, doNotCheckGpu=true
        if (!this.map.draw.drawTiles.drawSurfaceTile(tile, tile.metanode, this.map.renderer.cameraPosition, tile.texelSize, 0, true, false, true)) {
            this.params.loaded = false;
        }

        this.config.mapNoTextures = tmp;
    }
};


MapSurfaceTree.prototype.traceAreaTiles = function(tile, priority, nodeReadyOnly) {
    if (tile == null) {
        return;
    }

    if (!tile.isMetanodeReady(this, 0) || nodeReadyOnly) {
        this.params.loaded = false;
        //console.log('(L)' + JSON.stringify(tile.id));
        tile.isMetanodeReady(this, 0);
        return;
    }

    tile.metanode.metatile.used();

    if (tile.lastSurface && tile.lastSurface == tile.surface) {
        tile.lastSurface = null;
        tile.restoreLastState();
        //return;
    }

    if (!tile.insideCone(this.params.coneVec, this.params.coneAngle, tile.metanode)) {
        return;
    }

    const fit = (this.params.mode == 'lod') ? (tile.id[0] >= this.params.limit) : (tile.metanode.pixelSize <= this.params.limit);

    if (fit) {
        //console.log('(A)' + JSON.stringify(tile.id));
        this.chekTileMesh(tile);
        this.params.areaTiles.push(tile);
        return;
    }

    if (!tile.metanode.hasChildren()) {
        //console.log('(A)' + JSON.stringify(tile.id));
        this.chekTileMesh(tile);
        this.params.areaTiles.push(tile);
    } else {
        for (let i = 0; i < 4; i++) {
            this.traceAreaTiles(tile.children[i], priority, nodeReadyOnly);
        }
    }
};



/* harmony default export */ __webpack_exports__["default"] = (MapSurfaceTree);


/***/ }),

/***/ "./src/core/map/surface.js":
/*!*********************************!*\
  !*** ./src/core/map/surface.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _credit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./credit */ "./src/core/map/credit.js");
/* harmony import */ var _stylesheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stylesheet */ "./src/core/map/stylesheet.js");
/* harmony import */ var _surface_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./surface-tree */ "./src/core/map/surface-tree.js");
/* harmony import */ var _renderer_bbox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/bbox */ "./src/core/renderer/bbox.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _utils_url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/url */ "./src/core/utils/url.js");







//get rid of compiler mess
const MapCredit = _credit__WEBPACK_IMPORTED_MODULE_0__["default"];
const MapStylesheet = _stylesheet__WEBPACK_IMPORTED_MODULE_1__["default"];
const MapSurfaceTree = _surface_tree__WEBPACK_IMPORTED_MODULE_2__["default"];
const BBox = _renderer_bbox__WEBPACK_IMPORTED_MODULE_3__["default"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_4__["utils"];
const utilsUrl = _utils_url__WEBPACK_IMPORTED_MODULE_5__["utilsUrl"];


const MapSurface = function(map, json, type) {
    this.map = map;
    this.id = null;
    this.type = 'basic';
    this.metaBinaryOrder = 1;
    this.metaUrl = '';
    this.navUrl = '';
    this.navDelta = 1;
    this.meshUrl = '';
    this.textureUrl = '';
    this.baseUrl = this.map.url.baseUrl;
    this.baseUrlSchema = this.map.url.baseUrlSchema;
    this.baseUrlOrigin = this.map.url.baseUrlOrigin;
    this.lodRange = [0,0];
    this.tileRange = [[0,0],[0,0]];
    this.textureLayer = null;
    this.boundLayerSequence = [];
    this.glue = (type == 'glue');
    this.free = (type == 'free');
    this.virtual = false;
    this.zFactor = 0;
    this.ready = false;
    this.geodataProcessor = null;
    this.geodataCounter = 0;
    this.geodataNavtileInfo = false;
    this.monoGeodata = null;
    this.monoGeodataView = null;
    this.monoGeodataCounter = -1;
    this.creditsNumbers = [];
    this.surfaceCounter = map.surfaceCounter;
    map.surfaceCounter++;

    this.style = null;
    this.stylesheet = null;
    this.originalStyle = null;
    this.originalStylesheet = null;
    this.styleChanged = true;

    if (this.free) { //each free layer has its own data tree
        this.tree = new MapSurfaceTree(this.map, true, this);
    } else {
        this.tree = null;
    }

    if (typeof json === 'string') {
        this.jsonUrl = this.map.url.processUrl(json);
        this.baseUrl = utilsUrl.getBase(this.jsonUrl);
        this.baseUrlSchema = utilsUrl.getSchema(this.jsonUrl);
        this.baseUrlOrigin = utilsUrl.getOrigin(this.jsonUrl);

        const onLoaded = (function(data){
            this.parseJson(data);
            this.ready = true;
            this.map.refreshView();
        }).bind(this);

        const onError = (function(){ }).bind(this);

        utils.loadJSON(this.jsonUrl, onLoaded, onError, null,(utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
        //utils.loadJSON(this.url, onLoaded, onError, null, utils.useCredentials);
    } else {
        this.parseJson(json);
        this.ready = true;
    }
};


MapSurface.prototype.parseJson = function(json) {
    this.id = json['id'] || null;
    this.type = json['type'] || 'basic';
    this.metaBinaryOrder = json['metaBinaryOrder'] || 1;
    this.metaUrl = this.processUrl(json['metaUrl'], '');
    this.navUrl = this.processUrl(json['navUrl'], '');
    this.hmapUrl = this.processUrl(json['hmapUrl'], json['navUrl'] + '00');
    //this.cmapUrl = this.processUrl(json['cmapUrl'], '');
    this.pipeline = this.map.config.mapForcePipeline ? this.map.config.mapForcePipeline : (json['pipeline']); // || VTS_PIPELINE_HMAP);//VTS_PIPELINE_BASIC);
    //this.pipeline = json['pipeline'] || VTS_PIPELINE_BASIC;
    this.navDelta = json['navDelta'] || 1;
    this.meshUrl = this.processUrl(json['meshUrl'], '');
    this.textureUrl = this.processUrl(json['textureUrl'], '');
    this.geodataUrl = this.processUrl(json['geodataUrl'] || json['geodata'], '');
    this.lodRange = json['lodRange'] || [0,0];
    this.tileRange = json['tileRange'] || [[0,0],[0,0]];
    this.textureLayer = json['textureLayer'] || null;
    this.geodata = (this.type == 'geodata' || this.type == 'geodata-tiles');
    this.credits = json['credits'] || [];
    this.creditsUrl = null;
    this.displaySize = json['displaySize'] || 1024;
    this.hitable = this.geodata ? (json['hitable'] || false) : false;
    this.flatShade = false;

    if (json['options']) {
        this.flatShade = (json['options']['shader'] === 'flatShade');
    }

    this.flatShadeOriginal = this.flatShade;

    let i, li;

    if (json['extents']) {
        const ll = json['extents']['ll'];
        const ur = json['extents']['ur'];
        this.extents = new BBox(ll[0], ll[1], ll[2], ur[0], ur[1], ur[2]);
    } else {
        this.extents = new BBox(0,0,0,1,1,1);
    }

    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));

    switch(typeof this.credits) {
    case 'string':
        this.creditsUrl = this.credits;
        this.credits = [];
        break;

    case 'object':

        if (!Array.isArray(this.credits)) {
            const credits = this.credits;
            this.credits = [];

            for (let key in credits){
                this.map.addCredit(key, new MapCredit(this.map, credits[key]));
                this.credits.push(key);
            }
        }

        for (i = 0, li = this.credits.length; i < li; i++) {
            const credit = this.map.getCreditById(this.credits[i]);
            this.creditsNumbers.push(credit ? credit.id : null);
        }

        break;
    }


    if (this.geodataUrl && (typeof this.geodataUrl === 'string') && this.geodataUrl.indexOf('{geonavtile}') != -1) {
        //this.geodataNavtileInfo = true;
        this.geodataNavtileInfo = false;
    }

    //load stylesheet
    if (this.geodata) {
        let style = json['style'];

        if (typeof this.credits === 'string') {
            style = this.processUrl(style, '');
        }

        this.originalStyle = style;

        if (style) {
            this.setStyle(style);
            this.originalStylesheet = this.stylesheet;
        }
    }

    this.surfaceReference = [];
    if (this.glue) {
        for (i = 0, li = this.id.length; i < li; i++) {
            this.surfaceReference.push(this.map.getSurface(this.id[i]));
        }
    }
};


MapSurface.prototype.kill = function() {
    if (this.geodataProcessor) {
        this.geodataProcessor.kill();
        this.geodataProcessor = null;
    }

    this.geodataUrl = null;
    this.style = null;
    this.stylesheet = null;
    this.originalStyle = null;
    this.originalStylesheet = null;
};


MapSurface.prototype.setOptions = function() {
};


MapSurface.prototype.getOptions = function() {
    return this.getInfo();
};


MapSurface.prototype.getInfo = function() {
    if (this.geodata) {
        return {
            'type' : this.type,
            'metaUrl' : this.metaUrl,
            'geodataUrl' : this.geodataUrl,
            'lodRange' : this.lodRange,
            'tileRange' : this.tileRange,
            'style' : this.originalStyle
        };
    } else {
        return {
            'type' : this.type,
            'metaUrl' : this.metaUrl,
            'navUrl' : this.navUrl,
            'meshUrl' : this.meshUrl,
            'textureUrl' : this.textureUrl,
            'lodRange' : this.lodRange,
            'tileRange' : this.tileRange,
            'textureLayer' : this.textureLayer
        };
    }
};


MapSurface.prototype.processUrl = function(url, fallback) {
    if (!url) {
        return fallback;
    }

    if (typeof url !== 'string') {
        return url;
    }

    url = url.trim();

    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return this.baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return this.baseUrlOrigin + url;
    } else {  //relative
        return this.baseUrl + url;
    }
};


MapSurface.prototype.hasTile = function(id) {
    const shift = id[0] - this.lodRange[0];

    if (shift < 0) {
        return false;
    }

    const x = id[1] >> shift;
    const y = id[2] >> shift;

    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||
        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
        return false;
    }

    return true;
};


MapSurface.prototype.hasTile2 = function(id) {
    let shift = id[0] - this.lodRange[0];
    const above = (shift < 0);

    if (id[0] < this.lodRange[0]) {
        shift = -shift;
        const x1 = this.tileRange[0][0] >> shift;
        const y1 = this.tileRange[0][1] >> shift;
        const x2 = this.tileRange[1][0] >> shift;
        const y2 = this.tileRange[1][1] >> shift;

        if (id[0] > this.lodRange[1] ||
            id[1] < x1 || id[1] > x2 ||
            id[2] < y1 || id[2] > y2 ) {
            return [false , false];
        }
    } else {
        const x = id[1] >> shift;
        const y = id[2] >> shift;

        if (id[0] > this.lodRange[1] ||
            x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
            return [false , false];
        }
    }

    return [true, above];
};


MapSurface.prototype.hasMetatile = function(id) {
    if (id[0] > this.lodRange[1]) {
        return false;
    }

    let shift = id[0] - this.lodRange[0];

    if (shift >= 0) {
        const x = id[1] >> shift;
        const y = id[2] >> shift;

        if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
            return false;
        }
    } else {
        shift = -shift;

        if (id[1] < (this.tileRange[0][0]>>shift) || id[1] > (this.tileRange[1][0]>>shift) ||
            id[2] < (this.tileRange[0][1]>>shift) || id[2] > (this.tileRange[1][1]>>shift) ) {
            return false;
        }
    }

    return true;
};


MapSurface.prototype.setStyle = function(style) {
    if (this.style == style) {
        return;
    }

    let id = style;

    if (typeof id !== 'object') {
        id = this.processUrl(id, '');
    } else {
        id = JSON.stringify(id);
        id = utils.getHash(id);
        id = "#obj#" + id.toString(16);
    }

    this.stylesheet = this.map.getStylesheet(id);

    if (!this.stylesheet) {
        this.stylesheet = new MapStylesheet(this.map, id, style, this);
        this.map.addStylesheet(id, this.stylesheet);
    }

    this.style = style;
    this.styleChanged = true;
    this.geodataCounter++;

    //this.map.setStylesheetData(id); //force update

    this.map.markDirty();
};


//used only for glues
MapSurface.prototype.getSurfaceReference = function(index) {
    return this.surfaceReference[index - 1];
};


MapSurface.prototype.getMetaUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


MapSurface.prototype.getNavUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.navUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


MapSurface.prototype.getHMapUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.hmapUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};

MapSurface.prototype.getMeshUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.meshUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


MapSurface.prototype.getTextureUrl = function(id, subId, skipBaseUrl) {
    return this.map.url.makeUrl(this.textureUrl, {lod:id[0], ix:id[1], iy:id[2] }, subId, skipBaseUrl);
};


MapSurface.prototype.getGeodataUrl = function(id, navtileStr, skipBaseUrl) {
//    return this.map.makeUrl(this.geodataUrl + "&v=1", {lod:id[0], ix:id[1], iy:id[2] }, navtileStr, skipBaseUrl);
    return this.map.url.makeUrl(this.geodataUrl, {lod:id[0], ix:id[1], iy:id[2] }, navtileStr, skipBaseUrl);
};


MapSurface.prototype.getMonoGeodataUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.geodataUrl, {}, null, skipBaseUrl);
};


/* harmony default export */ __webpack_exports__["default"] = (MapSurface);


/***/ }),

/***/ "./src/core/map/texture.js":
/*!*********************************!*\
  !*** ./src/core/map/texture.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _subtexture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subtexture */ "./src/core/map/subtexture.js");



//get rid of compiler mess
const MapSubtexture = _subtexture__WEBPACK_IMPORTED_MODULE_0__["default"];


const MapTexture = function(map, path, type, extraBound, extraInfo, tile, internal) {
    this.map = map;
    this.stats = map.stats;
    this.tile = tile; // used only for stats
    this.internal = internal; // used only for stats

    if (tile) {
        this.mainTexture = tile.resources.getSubtexture(this, path, type, tile, internal);
    } else {
        this.mainTexture = new MapSubtexture(map, path, type, tile, internal);
    }

    this.maskTexture = null;

    this.loadState = 0;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.neverReady = false;
    this.maskTexture = null;
    this.mapLoaderUrl = path;
    this.type = type || 0;
    this.extraBound = extraBound;
    this.extraInfo = extraInfo;
    this.statsCounter = 0;
    this.checkStatus = 0;
    this.checkType = null;
    this.checkValue = null;
    this.fastHeaderCheck = false;
    this.fileSize = 0;

    if (extraInfo && extraInfo.layer) {
        const layer = extraInfo.layer;

        if (layer.availability) {
            this.checkType = layer.availability.type;
            switch (this.checkType) {
            case 2: this.checkValue = layer.availability.mime; break;
            case 3: this.checkValue = layer.availability.codes; break;
            case 4: this.checkValue = layer.availability.size; break;
            }
        }
    }
};


MapTexture.prototype.kill = function() {
    this.mainTexture.killImage();
    this.mainTexture.killGpuTexture();
    this.mainTexture = null;

    if (this.maskTexture) {
        this.maskTexture.killImage();
        this.maskTexture.killGpuTexture();
    }
};


MapTexture.prototype.killImage = function() {
    this.mainTexture.killImage();

    if (this.maskTexture) {
        this.maskTexture.killImage();
    }
};


MapTexture.prototype.killGpuTexture = function() {
    this.mainTexture.killGpuTexture();

    if (this.maskTexture) {
        this.maskTexture.killGpuTexture();
    }
};


MapTexture.prototype.setBoundTexture = function(tile, layer, hmap) {
    if (tile) {
        if (hmap) {
            this.extraBound.sourceTile = tile;
            this.extraBound.hmap = hmap;

            if (!tile.hmap) {
                const path = tile.resourceSurface.getHMapUrl(tile.id, true);
                tile.hmap = tile.resources.getTexture(path, null, null, {tile: tile, hmap: hmap}, this.tile, this.internal);
            }

            this.extraBound.texture = tile.hmap;

        } else if (layer) {
            this.extraBound.sourceTile = tile;
            this.extraBound.layer = layer;

            if (!tile.boundTextures[layer.id]) {
                tile.boundLayers[layer.id] = layer;
                const path = layer.getUrl(tile.id);
                tile.boundTextures[layer.id] = tile.resources.getTexture(path, null, null, {tile: tile, layer: layer}, this.tile, this.internal);
            }

            this.extraBound.texture = tile.boundTextures[layer.id];
        }

        this.extraBound.transform = this.map.draw.drawTiles.getTileTextureTransform(tile, this.extraBound.tile);
        this.map.markDirty();
    }
};


MapTexture.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {
    const doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);
    doNotLoad = doNotLoad || doNotUseGpu;
/*
   if (this.mapLoaderUrl == "https://ecn.t3.tiles.virtualearth.net/tiles/a1202310323212333.jpeg?g=5549") {
       this.mapLoaderUrl = this.mapLoaderUrl;
   }
*/
    if (this.neverReady) {
        return false;
    }

    let parent;

    if (this.extraBound) {
        if (this.extraBound.texture) {
            while (this.extraBound.texture.extraBound || this.extraBound.texture.checkStatus == -1) {
//            while (this.extraBound.texture.checkStatus == -1) {
                parent = this.extraBound.sourceTile.parent;

                if (this.extraBound.hmap) {
                    if (!parent || parent.id[0] < 1) {
                        this.neverReady = true;
                        this.extraBound.tile.resetDrawCommands = true;
                        this.map.markDirty();
                        return false;
                    }
                } else if (this.extraBound.layer) {
                    if (parent.id[0] < this.extraBound.layer.lodRange[0]) {
                        this.neverReady = true;
                        this.extraBound.tile.resetDrawCommands = true;
                        this.map.markDirty();
                        return false;
                    }
                }

                this.setBoundTexture(parent, this.extraBound.layer);
            }

            let ready = this.extraBound.texture.isReady(doNotLoad, priority, doNotCheckGpu);

            if (ready && this.checkMask) {
                this.extraBound.tile.resetDrawCommands = (this.extraBound.texture.getMaskTexture() != null);
                this.checkMask = false;
            }

            return ready;

        } else {
            this.setBoundTexture(this.extraBound.sourceTile, this.extraBound.layer, this.extraBound.hmap);
            return this.isReady(doNotLoad, priority, doNotCheckGpu);
        }

        // eslint-disable-next-line
        return false;
    }

    /*
    if (!this.extraBound && this.extraInfo && !this.maskTexture) {
        const layer = this.extraInfo.layer;

        if (layer && layer.maskUrl && this.checkType != "metatile") {
            const path = layer.getMaskUrl(this.tile.id);
            this.maskTexture = this.tile.resources.getTexture(path, null, null, null, this.tile, this.internal);
        }
    }*/

    switch (this.checkType) {
    case 1:

        if (this.checkStatus != 2) {
            if (this.checkStatus == 0) {
                if (this.extraInfo && this.extraInfo.tile) {
                    let metaresources = this.extraInfo.tile.boundmetaresources;
                    if (!metaresources) {
                        metaresources = this.map.resourcesTree.findAgregatedNode(this.extraInfo.tile.id, 8);
                        this.extraInfo.tile.boundmetaresources = metaresources;
                    }

                    const layer = this.extraInfo.layer;
                    let path = this.extraInfo.metaPath;

                    if(!this.extraInfo.metaPath) {
                        path = layer.getMetatileUrl(metaresources.id);
                        this.extraInfo.metaPath = path;
                    }

                    const texture = metaresources.getTexture(path, true, null, null, this.tile, this.internal);

                    if (this.maskTexture) {
                        if (this.maskTexture.isReady(doNotLoad, priority, doNotCheckGpu, this)) {
                            this.checkStatus = 2;
                        }
                    } else {
                        if (texture.isReady(doNotLoad, priority, doNotCheckGpu)) {
                            const tile = this.extraInfo.tile;
                            const value = texture.getHeightMapValue(tile.id[1] & 255, tile.id[2] & 255);
                            this.checkStatus = (value & 128) ? 2 : -1;

                            if (this.checkStatus == 2) {
                                if (!(value & 64)) { //load mask
                                    path = layer.getMaskUrl(tile.id);
                                    this.maskTexture = tile.resources.getTexture(path, null, null, null, this.tile, this.internal);
                                    this.checkStatus = 0;
                                }
                            }

                            tile.resetDrawCommands = true;
                            this.map.markDirty();
                        }
                    }
                }
            }

            if (this.checkStatus == -1) {
                if (!this.extraBound) {
                    parent = this.extraInfo.tile.parent;
                    if (parent.id[0] < this.extraInfo.layer.lodRange[0]) {
                        this.neverReady = true;
                        this.extraInfo.tile.resetDrawCommands = true;
                        this.map.markDirty();
                        return false;
                    }

                    this.extraBound = { tile: this.extraInfo.tile, layer: this.extraInfo.layer};
                    this.setBoundTexture(this.extraBound.tile.parent, this.extraBound.layer);
                    this.checkMask = true;
                }

                while (this.extraBound.texture.extraBound || this.extraBound.texture.checkStatus == -1) {
                    //while (this.extraBound.texture.checkStatus == -1) {
                    parent = this.extraBound.sourceTile.parent;
                    if (parent.id[0] < this.extraBound.layer.lodRange[0]) {
                        this.neverReady = true;
                        this.extraBound.tile.resetDrawCommands = true;
                        this.map.markDirty();
                        return false;
                    }

                    this.setBoundTexture(parent, this.extraBound.layer);
                }
            }

            return false;
        }

        break;
    }

    let maskState = true;

    if (this.maskTexture) {
        maskState = this.maskTexture.isReady(doNotLoad, priority, doNotCheckGpu, this);
    }


    return this.mainTexture.isReady(doNotLoad, priority, doNotCheckGpu, this) && maskState;
};

MapTexture.prototype.isMaskPosible = function() {
    let texture = this;

    if (this.extraBound) {
        if (this.extraBound.texture) {
            texture = this.extraBound.texture;
        }
    }

    if (texture.checkType == 1) {
        return true;
    } else {
        return false;
    }
};

MapTexture.prototype.isMaskInfoReady = function() {
    let texture = this;

    if (this.extraBound) {
        if (this.extraBound.texture) {
            texture = this.extraBound.texture;
        }
    }

    if (texture.checkType == 1) {
        if (this.maskTexture || texture.checkStatus == 2 || texture.checkStatus ==  -1) {
            return true;
        }

        return false;
    }

    return true;
}

MapTexture.prototype.getGpuTexture = function() {
    if (this.extraBound) {
        if (this.extraBound.texture) {
            return this.extraBound.texture.getGpuTexture();
        }
        return null;
    }

    return this.mainTexture.getGpuTexture();
};


MapTexture.prototype.getMaskTexture = function() {
    if (this.extraBound) {
        if (this.extraBound.texture) {
            return this.extraBound.texture.getMaskTexture();
        }
    }

    return this.maskTexture;
};


MapTexture.prototype.getGpuMaskTexture = function() {
    if (this.extraBound) {
        if (this.extraBound.texture && this.extraBound.texture.maskTexture) {
            return this.extraBound.texture.getGpuMaskTexture();
        }
        return null;
    }

    if (this.maskTexture) {
        return this.maskTexture.getGpuTexture();
    }

    return null;
};

MapTexture.prototype.getGpuSize = function() {
    return (this.mainTexture ? (this.mainTexture.gpuSize ? this.mainTexture.gpuSize : 0) : 0) + (this.maskTexture ? (this.maskTexture.gpuSize ? this.maskTexture.gpuSize : 0) : 0);
};

MapTexture.prototype.getImageData = function() {
    return this.mainTexture.imageData;
};


MapTexture.prototype.getImageExtents = function() {
    return this.mainTexture.imageExtents;
};


MapTexture.prototype.getHeightMapValue = function(x, y) {
    return this.mainTexture.getHeightMapValue(x, y);
};


MapTexture.prototype.getTransform = function() {
    if (this.extraBound) {
        if (this.extraBound.texture) {
            return this.extraBound.transform;
        }
        return null;
    }

    return [1,1,0,0];
};


/* harmony default export */ __webpack_exports__["default"] = (MapTexture);


/***/ }),

/***/ "./src/core/map/trajectory.js":
/*!************************************!*\
  !*** ./src/core/map/trajectory.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");



//get rid of compiler mess
const math = _utils_math__WEBPACK_IMPORTED_MODULE_0__["math"];


const MapTrajectory = function(map, p1, p2, options) {
    this.map = map;
    this.p1 = p1.clone();
    this.p2 = p2.clone();
    this.op2 = p2.clone();

    const hm1 = this.p1.getHeightMode();
    const hm2 = this.p2.getHeightMode();

    if (hm1 == 'fix' && hm2 == 'float') {
        this.p1 = this.map.convert.convertPositionHeightMode(this.p1, 'float', true);
    } else if (hm1 == 'float' && hm2 == 'fix') {
        this.p1 = this.map.convert.convertPositionHeightMode(this.p1, 'fix', true);
    }

    const vm1 = this.p1.getViewMode();
    const vm2 = this.p2.getViewMode();

    if (vm1 == 'subj' && vm2 == 'obj') {
        this.p2 = this.map.convert.convertPositionViewMode(this.p2, 'subj');
    } else if (vm1 == 'obj' && vm2 == 'subj') {
        this.p1 = this.map.convert.convertPositionViewMode(this.p1, 'subj');
    }

    this.p1.pos[5] = this.p1.pos[5] < 0 ? (360 + (this.p1.pos[5] % 360)) : (this.p1.pos[5] % 360);
    this.p2.pos[5] = this.p2.pos[5] < 0 ? (360 + (this.p2.pos[5] % 360)) : (this.p2.pos[5] % 360);

    this.pp1 = this.p1.clone();

    this.mode = options['mode'] || 'auto';
    this.submode = options['submode'] || 'none';
    this.submode = 'none';
    this.maxHeight = options['maxHeight'] || 1000000000;
    this.minDuration = options['minDuration'] || 0;
    this.maxDuration = options['maxDuration'] || 10000;
    this.samplePeriod = options['samplePeriod'] || 10;
    this.fade = options['fade'] || 'none';
    this.fadePower = options['fadePower'] || 1;
    this.yawInterpolation = options['yawInterpolation'] || 'shortest';

    this.pv = options['pv'] || 0.15;

    if (!this.map.getNavigationSrs().isProjected()) {
        this.geodesic = this.map.measure.getGeodesic();
    }

    if (options['distanceAzimuth']) {
        this.distanceAzimuth = true;

        this.pp2 = this.p1.clone();
        if (options['destHeight']) {
            this.pp2.setHeight(options['destHeight']);
        }

        if (options['destOrientation']) {
            this.pp2.setHeight(options['destOrientation']);
        }

        if (options['destFov']) {
            this.pp2.setHeight(options['destFov']);
        }

        this.geoAzimuth = options['azimuth'] || 0;
        this.geoDistance = options['distance'] || 100;
        this.distance = this.geoDistance;
        this.azimuth = this.geoAzimuth % 360;
        this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;

    } else {
        this.distanceAzimuth = false;

        this.pp2 = this.p2.clone();

        //get distance and azimut
        let res = this.map.measure.getDistance(this.pp1.getCoords(), this.pp2.getCoords());
        this.distance = res[0];
        this.azimuth = (res[1] + 90) % 360;
        this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;

        if (!this.map.getNavigationSrs().isProjected()) {
            res = this.geodesic.Inverse(this.pp1.pos[2], this.pp1.pos[1], this.pp2.pos[2], this.pp2.pos[1]);
            this.geoAzimuth = res.azi1;
            this.geoDistance = res.s12;
            this.azimuth = this.geoAzimuth % 360;
            this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;
        }
    }

    //console.log("azim: " + Math.round(this.azimuth) + " p1: " + this.p1.pos[5]  + " p2: " + this.p2.pos[5]);

    this.detectMode();
    this.detectDuration();
    this.detectFlightHeight(options['height']);
};


MapTrajectory.prototype.detectFlightHeight = function(flightHeight) {
    if (this.mode == 'ballistic') {
        this.flightHeight = Math.max(this.pp1.getHeight(), this.pp2.getHeight());
        this.flightHeight += flightHeight || (this.distance * 0.5);
        this.flightHeight = Math.min(this.flightHeight, this.maxHeight);
        this.flightHeight -= Math.max(this.pp1.getHeight(), this.pp2.getHeight());
    }
};


MapTrajectory.prototype.detectMode = function() {
    if (this.mode == 'auto') {
        this.mode = (this.distance > 2000) ? 'ballistic' : 'direct';
    }
};


MapTrajectory.prototype.detectDuration = function() {
    this.duration = 0;
    this.headingDuration = 1000;

    if (this.distance < 500) {
        this.duration = 1000;
    } else if (this.distance < 2000) {
        this.duration = 2000;
    } else {
        this.duration = this.distance / 100;

        if (this.duration < 300) {
            this.duration = 3000;
        } else {
            this.headingDuration = 1500;
        }

        if (this.duration < 6000) {
            this.duration = 6000;
        }

        if (this.duration > 10000) {
            this.duration = 10000;
        }

        if (this.mode != 'direct') {
            this.duration *= 1.8;
            this.headingDuration *= 1.8;
        }
    }

    if (this.mode != 'direct') {
        const minDuration = 3 * this.headingDuration;
        this.duration = Math.max(this.duration, minDuration);

        if (this.maxDuration < minDuration) {
            this.duration = this.maxDuration;
            this.headingDuration = this.maxDuration / 3;
        }
    }

    this.duration = Math.min(this.duration, this.maxDuration);
    this.duration = Math.max(this.duration, this.minDuration);
};


MapTrajectory.prototype.generate = function() {
    const samples = new Array(Math.ceil(this.duration / this.samplePeriod)+(this.distanceAzimuth?0:1));
    let index = 0;

    for (let time = 0; time <= this.duration; time += this.samplePeriod) {
        let factor = time / this.duration;

        let p = this.pp1.clone(), x, coords;

        if (this.mode == 'direct') {

            x = factor;

            switch(this.fade) {
            case 'in':
                switch(this.fadePower) {
                case 1: factor = x*x; break;
                case 2: factor = x*x*x; break;
                case 3: factor = x*x*x*x; break;
                case 4: factor = x*x*x*x*x; break;
                case 5: factor = x*x*x*x*x*x; break;
                case 6: factor = x*x*x*x*x*x*x; break;
                }
                break;

            case 'out':
                x = 1 - x;
                switch(this.fadePower) {
                case 1: factor = 1 - (x*x); break;
                case 2: factor = 1 - (x*x*x); break;
                case 3: factor = 1 - (x*x*x*x); break;
                case 4: factor = 1 - (x*x*x*x*x); break;
                case 5: factor = 1 - (x*x*x*x*x*x); break;
                case 6: factor = 1 - (x*x*x*x*x*x*x); break;
                }
                break;

            case 'inout':
                switch(this.fadePower) {
                case 1: factor = x*x*(3 - 2*x); break;
                case 2: factor = x*x*x * (x * (6*x - 15) + 10); break;
                case 3: factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); break;
                case 4: factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); break;
                case 5: factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); break;
                case 6: factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); break;
                }
                break;
            }

            p.setCoords(this.getInterpolatedCoords(factor));
            p.setHeight(this.getInterpolatedHeight(factor));

            const o1 = this.pp1.getOrientation();
            const o2 = this.pp2.getOrientation();

            p.setOrientation(this.getInterpolatedOrinetation(o1, o2, factor));
            p.setFov(this.getInterpolatedFov(factor));
            p.setViewExtent(this.getInterpolatedViewExtent(factor));

            samples[index] = p.pos;
            index++;
        } else {

            //http://en.wikipedia.org/wiki/Smoothstep
            x = factor;
            factor =  x*x*(3 - 2*x);
            x = factor;
            factor =  x*x*(3 - 2*x);

            //factor2 includes slow start and end of flight
            const factor2 =  this.getSmoothFactor(time);

            if (this.submode == 'piha') {

                const distanceFactor = (this.distance / this.duration * (time - this.duration / (2 * Math.PI) * Math.sin(2 * Math.PI / this.duration * time))) / this.distance;

                //const f = (time / this.duration) * Math.PI * 2;
                //const distanceFactor = ((f - Math.sin(f)) / (2 * Math.PI));

                const pv = this.pv;
                const h1 = this.pp1.getCoords()[2];
                const h2 = this.pp2.getCoords()[2];

                const height = this.distance / ((this.duration*0.001) * pv * Math.tan(math.radians(this.pp1.getFov()) * 0.5))
                              * (1 - Math.cos(2 * Math.PI * time / this.duration))
                              + h1 + (h2 - h1) * time  / this.duration;

                coords = this.getInterpolatedCoords(distanceFactor);

                p.setCoords(coords);
                p.setHeight(height);
            } else {

                coords = this.getInterpolatedCoords(factor2);

                p.setCoords(coords);
                p.setHeight(this.getSineHeight(factor));
            }

            if (coords[3] != null) { //used for correction in planet mode
                this.azimuth = -coords[3];
            }

            p.setOrientation(this.getFlightOrienation(time));
            p.setFov(this.getInterpolatedFov(factor));
            p.setViewExtent(this.getInterpolatedViewExtent(factor));

            //p.convertViewMode("subj");
            //console.log("pos: " + p.toString());

            samples[index] = p.pos;
            samples[index] = p.pos;
            index++;
        }
    }

    if (!this.distanceAzimuth) {
        samples[index] = this.op2.clone().pos;
    }

    //console.log("pos2: " + this.p2.toString());

    return samples;
};


MapTrajectory.prototype.getInterpolatedCoords = function(factor) {
    const c1 = this.pp1.getCoords();
    const c2 = this.pp2.getCoords();

    if (!this.map.getNavigationSrs().isProjected()) {
        const res = this.geodesic.Direct(c1[1], c1[0], this.geoAzimuth, this.geoDistance * factor);

        let azimut = res.azi1 - res.azi2;

        azimut = (this.azimuth < 0) ? (360 + azimut) : azimut;

        return [ res.lon2, res.lat2,
            c1[2] + (c2[2] - c1[2]) * factor, azimut];

    } else {
        return [ c1[0] + (c2[0] - c1[0]) * factor,
            c1[1] + (c2[1] - c1[1]) * factor,
            c1[2] + (c2[2] - c1[2]) * factor ];
    }
};


MapTrajectory.prototype.getInterpolatedOrinetation = function(o1, o2, factor) {
    let od1 = o2[0] - o1[0];
    const od2 = o2[1] - o1[1];
    const od3 = o2[2] - o1[2];

    if (this.yawInterpolation == 'shortest' || this.yawInterpolation == 'longest') {
        if (Math.abs(od1) > 180) {
            if (od1 > 0) {
                od1 = -(360 - od1);
            } else {
                od1 = 360 - Math.abs(od1);
            }
        }
    }

    if (this.yawInterpolation == 'longest') {
        if (od1 < 0) {
            od1 = 360 + od1;
        } else {
            od1 = (-360) + od1;
        }
    }

    return [ o1[0] + od1 * factor,
        o1[1] + od2 * factor,
        o1[2] + od3 * factor ];
};


MapTrajectory.prototype.getInterpolatedFov = function(factor) {
    const f1 = this.pp1.getFov();
    const f2 = this.pp2.getFov();
    return f1 + (f2 - f1) * factor;
};


MapTrajectory.prototype.getInterpolatedViewExtent = function(factor) {
    const v1 = this.pp1.getViewExtent();
    const v2 = this.pp2.getViewExtent();
    return v1 + (v2 - v1) * factor;
};


MapTrajectory.prototype.getInterpolatedHeight = function(factor) {
    const h1 = this.pp1.getHeight();
    const h2 = this.pp2.getHeight();
    return h1 + (h2 - h1) * factor;
};


MapTrajectory.prototype.getSineHeight = function(factor) {
    const c1 = this.pp1.getCoords();
    const c2 = this.pp2.getCoords();

    return c1[2] + (c2[2] - c1[2]) * factor +
           Math.sin(Math.PI * factor) * this.flightHeight;
};


MapTrajectory.prototype.getSmoothFactor = function(time) {
    let x = 0;

    if (time < this.headingDuration) {
        x = 0;
    } else if (time > (this.duration - this.headingDuration)) {
        x = 1.0;
    } else {
        x = Math.min(1.0, (time-this.headingDuration) / (this.duration - this.headingDuration*2));
    }

    x = x*x*(3 - 2*x);
    return x*x*(3 - 2*x);
};


MapTrajectory.prototype.getFlightOrienation = function(time) {
    let o1 = null;
    let o2 = null;
    let fo = [0, -90, 0]; //flight orientation
    let factor = 0;

    //get fly direction angle
    fo[0] = this.azimuth % 360;

    if (fo[0] < 0) {
        fo[0] = 360 - Math.abs(fo[0]);
    }

    if (time <= this.headingDuration) { //start sequence
        factor = time / this.headingDuration;
        o1 = this.pp1.getOrientation();
        o2 = fo;
    } else if (time >= this.duration - this.headingDuration) { //end sequence
        factor = (time - (this.duration - this.headingDuration)) / this.headingDuration;
        o1 = fo;
        o2 = this.pp2.getOrientation();
    } else { //fly sequence
        factor = 0;
        o1 = fo;
        o2 = fo;
    }

    return this.getInterpolatedOrinetation(o1, o2, factor);
};


/* harmony default export */ __webpack_exports__["default"] = (MapTrajectory);


/***/ }),

/***/ "./src/core/map/url.js":
/*!*****************************!*\
  !*** ./src/core/map/url.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _utils_url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/url */ "./src/core/utils/url.js");




//get rid of compiler mess
const utilsUrl = _utils_url__WEBPACK_IMPORTED_MODULE_1__["utilsUrl"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["utils"];


const MapUrl = function(map, path) {
    this.map = map;

    path = path.trim();
    this.baseUrl = utilsUrl.getBase(path);
    this.baseUrlSchema = utilsUrl.getSchema(path);
    this.baseUrlOrigin = utilsUrl.getOrigin(path);

    this.urlCounter = 0;
};


MapUrl.prototype['quad'] = function(lod, ix, iy) {
    let quadKey = '';
    //ty = Math.pow(2,zoom - 1) - ty;
    for (let i = lod; i > 0; i--) {
        let digit = 0;
        const mask = 1 << (i-1);
        if ((ix & mask) != 0) {
            digit += 1;
        }

        if ((iy & mask) != 0) {
            digit += 2;
        }

        quadKey += digit;
    }

    return quadKey;
};


MapUrl.prototype['msDigit'] = function(iy, ix) {
    return (((iy & 3) << 1) + (ix & 1));
};


MapUrl.prototype.hex = function(v) {
    let s = v.toString(16);
    while (s.length < 8) {
        s = '0' + s;
    }
    return s;
};


MapUrl.prototype['ppx'] = function(lod, ix) {
    return this.hex(ix << (28 - lod), 7);
};


MapUrl.prototype['ppy'] = function(lod, iy) {
    return this.hex((1 << 28) - ((iy + 1) << (28 - lod)), 7);
};


MapUrl.prototype.processUrlFunction = function(id, counter, string) {
    let string2, fc;
    if (typeof string == 'string') {
        if (string.indexOf('quad') != -1) {
            string2 = '(function(lod,x,y,loclod,locx,locy){' + string.replace('quad', 'return this.quad') + '})';

            try {
                fc = eval(string2).bind(this);
                return fc(id.lod, id.ix, id.iy, id.loclod, id.locx, id.locy);
            } catch(e) {
                return string;
            }
        } else if (string.indexOf('msdigit') != -1) {
            string2 = '(function(x,y,loclod,locx,locy){' + string.replace('msdigit', 'return this.msDigit') + '})';

            try {
                fc = eval(string2).bind(this);
                return fc(id.ix, id.iy, id.loclod, id.locx, id.locy);
            } catch(e) {
                return string;
            }

        } else if (string.indexOf('alt') != -1) {
            const result = /\(([^)]*)\)/.exec(string);

            if (result && result[1]) {
                const strings = result[1].match(/([^,]+)/g);

                if (strings.length > 0) {
                    return strings[(counter % strings.length)];
                }
            }

            return string;

        } else if (string.indexOf('ppx') != -1) {
            string2 = '(function(lod,x,loclod,locx){' + string.replace('ppx', 'return this.ppx') + '})';

            try {
                fc = eval(string2).bind(this);
                return fc(id.lod, id.ix, id.loclod, id.locx);
            } catch(e) {
                return string;
            }

        } else if (string.indexOf('ppy') != -1) {
            string2 = '(function(lod,y,loclod,locy){' + string.replace('ppy', 'return this.ppy') + '})';

            try {
                fc = eval(string2).bind(this);
                return fc(id.lod, id.iy, id.loclod, id.locy);
            } catch(e) {
                return string;
            }

        } else {
            return string;
        }

    } else {
        return string;
    }
};


MapUrl.prototype.findLocalRoot = function(id) {
    const nodes = this.map.referenceFrame.getSpatialDivisionNodes();
    const validNodes = [];

    for (let i = 0, li = nodes.length; i < li; i++) {
        const node = nodes[i];

        const delta = id[0] - node.id[0];
        const ix = id[1] >> delta;
        const iy = id[2] >> delta;

        if (ix == node.id[1] && iy == node.id[2]) {
            validNodes.push(node);
        }
    }

    let bestNode = null;
    let bestLod = -1;

    for (let i = 0, li = validNodes.length; i < li; i++) {
        if (validNodes[i].id[0] > bestLod) {
            bestNode = validNodes[i];
        }
    }

    if (bestNode) {
        return bestNode.id.slice();
    } else {
        return [0,0,0];
    }
};


MapUrl.prototype.makeUrl = function(templ, id, subId, skipBaseUrl) {
    //if (templ.indexOf("jpg") != -1) {
       //templ = "{lod}-{easting}-{northing}.jpg?v=4";
       //templ = "{lod}-{x}-{y}.jpg?v=4";
       //templ = "{quad(lod,x,y)}.jpg?v=4";
       //templ = "{quad(lod,x+1,y*2)}.jpg?v=4";
       //templ = "{lod}-{msdigit(x,y)}.jpg?v=4";
    //}
    //templ = "maps{alt(1,2,3,4)}.irist-test.citationtech.net/map/{lod}-{x}-{y}.jpg?v=4";

    let locx = 0;
    let locy = 0;
    let loclod = 0;

    if (id.lod) {
        const localRoot = this.findLocalRoot([id.lod, id.ix, id.iy]);
        loclod = id.lod - localRoot[0];
        const mask = (1 << loclod) - 1;
        locx = id.ix & mask;
        locy = id.iy & mask;
    }

    const id2 = {
        lod: id.lod,
        ix : id.ix,
        iy : id.iy,
        loclod: loclod,
        locx : locx,
        locy : locy
    };

    //remove white spaces from template
    templ = templ.replace(/ /g, '');

    const url = utils.simpleFmtObjOrCall(templ, {'lod':id.lod,  'x':id.ix, 'y':id.iy, 'sub': subId,
        'locx':locx, 'locy':locy, 'loclod':loclod, 'geonavtile': subId,
        'hereappid': 'abcde', 'hereappcode':'12345'},
                                               this.processUrlFunction.bind(this, id2, this.urlCounter));

    this.urlCounter++;

    skipBaseUrl = (url.indexOf('//') != -1);

    /* //useful for debug
    let tmp;

    if (skipBaseUrl) {
        tmp =  url;
    } else {
        tmp = this.baseUrl + url;
    }
    */

    if (skipBaseUrl) {
        if (url.indexOf('//') == 0) {
            return this.baseUrlSchema + url;
        } else {
            return url;
        }
    } else {
        return this.baseUrl + url;
    }
};


MapUrl.prototype.processUrl = function(url, fallback) {
    if (!url) {
        return fallback;
    }

    url = url.trim();

    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return this.baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return this.baseUrlOrigin + url;
    } else {  //relative
        return this.baseUrl + url;
    }
};


/* harmony default export */ __webpack_exports__["default"] = (MapUrl);


/***/ }),

/***/ "./src/core/map/view.js":
/*!******************************!*\
  !*** ./src/core/map/view.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const MapView = function(map, json, fixPaths) {
    this.map = map;
    //this.id = json["id"] || null;
    this.parse(json, fixPaths);
};


MapView.prototype.parse = function(json, fixPaths) {
    //this.description = json['description'] || '';
    //this.boundLayers = json["boundLayers"] || [];
    this.freeLayers = json['freeLayers'] || {};
    this.surfaces = {};
    this.options = json['options'] || {};

    if (json['surfaces']) {
        const surfaces = json['surfaces'];
        if (Array.isArray(surfaces)) { //convert from old version
            for (let i = 0, li = surfaces.length; i < li; i++) {
                this.surfaces[surfaces[i]] = [];
            }
        } else {
            this.surfaces = surfaces;
        }
    }

    if (!this.freeLayers || Array.isArray(this.freeLayers)) { //convert from old version
        this.freeLayers = {};
    } else {
        this.freeLayers = JSON.parse(JSON.stringify(this.freeLayers));

        if (fixPaths) {
            for (let key in this.freeLayers) {
                const layer = this.freeLayers[key];

                if (typeof layer['style'] === 'string') {
                    layer['style'] = this.processUrl(layer['style'], '');
                }
            }
        }
    }

    this.surfaces = JSON.parse(JSON.stringify(this.surfaces));
    this.options = JSON.parse(JSON.stringify(this.options));
};


MapView.prototype.processUrl = function(url, fallback) {
    if (!url) {
        return fallback;
    }

    if (typeof url !== 'string') {
        return url;
    }

    url = url.trim();

    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return this.map.url.baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return this.map.url.baseUrlOrigin + url;
    } else {  //relative
        return this.map.url.baseUrl + url;
    }
};


MapView.prototype.getInfo = function() {
    const view = {
        //'description' : JSON.parse(JSON.stringify(this.description)),
        'surfaces' : JSON.parse(JSON.stringify(this.surfaces)),
        'freeLayers' : JSON.parse(JSON.stringify(this.freeLayers)),
        'options' : JSON.parse(JSON.stringify(this.options)),
    };

    //const renderer = this.map.renderer;

    if (this.map.renderer.getSuperElevationState()) {
        const se = this.map.renderer.getSuperElevation();

        view['options'] = {
            'superelevation' : [[se[0],se[2]],[se[1],se[3]]]
        }
    }

    return view;
};


/* harmony default export */ __webpack_exports__["default"] = (MapView);


/***/ }),

/***/ "./src/core/map/virtual-surface.js":
/*!*****************************************!*\
  !*** ./src/core/map/virtual-surface.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _renderer_bbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/bbox */ "./src/core/renderer/bbox.js");




//get rid of compiler mess
const BBox = _renderer_bbox__WEBPACK_IMPORTED_MODULE_1__["default"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["utils"];


const MapVirtualSurface = function(map, json) {
    this.map = map;
    this.id = null;
    this.metaUrl = '';
    this.mappingUrl = '';
    this.baseUrl = this.map.url.baseUrl;
    this.baseUrlSchema = this.map.url.baseUrlSchema;
    this.baseUrlOrigin = this.map.url.baseUrlOrigin;
    this.lodRange = [0,0];
    this.tileRange = [[0,0],[0,0]];
    this.surfaces = [];
    this.parseJson(json);
    this.virtual = true;
    this.ready = false;
};


MapVirtualSurface.prototype.parseJson = function(json) {
    this.id = json['id'] || null;
    this.metaUrl = this.processUrl(json['metaUrl'], '');
    this.mappingUrl = this.processUrl(json['mapping'], '');
    this.lodRange = json['lodRange'] || [0,0];
    this.tileRange = json['tileRange'] || [[0,0],[0,0]];
    this.strId = this.id ? this.id.join(';') : null;

    if (this.id) {
        const tmp = this.id.slice();
        tmp.sort();
        this.strId = tmp.join(';');
    }

    if (json['extents']) {
        const ll = json['extents']['ll'];
        const ur = json['extents']['ur'];
        this.extents = new BBox(ll[0], ll[1], ll[2], ur[0], ur[1], ur[2]);
    } else {
        this.extents = new BBox(0,0,0,1,1,1);
    }

    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));

    utils.loadBinary(this.mappingUrl, this.onMappingFileLoaded.bind(this), this.onMappingFileLoadError.bind(this), (utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
};


MapVirtualSurface.prototype.onMappingFileLoaded = function(data) {
    this.parseMappingFile(new DataView(data));
    this.ready = true;
    this.map.refreshView();
};


MapVirtualSurface.prototype.onMappingFileLoadError = function() {
};


MapVirtualSurface.prototype.parseMappingFile = function(data) {
    let index = 0;

    let magic = '';
    magic += String.fromCharCode(data.getUint8(index, true)); index += 1;
    magic += String.fromCharCode(data.getUint8(index, true)); index += 1;

    if (magic != 'TM') {
        return false;
    }

    let count = data.getUint16(index, true); index += 2;

    for (let i = 0; i < count; i++) {
        const size = data.getUint8(index, true); index += 1;
        const id = [];

        for (let j = 0; j < size; j++) {
            let s = data.getUint16(index, true); index += 2;
            s = this.id[s];

            if (s) {
                id.push(s);
            }
        }

        if (id.length == 1) { //get surface
            this.surfaces.push(this.map.getSurface(id[0]));
        } else { //get glue
            this.surfaces.push(this.map.getGlue(id.join(';')));
        }
    }

    return true;
};


MapVirtualSurface.prototype.getInfo = function() {
    return {
        'metaUrl' : this.metaUrl,
        'mapping' : this.mappingUrl,
        'lodRange' : this.lodRange,
        'tileRange' : this.tileRange
    };
};


MapVirtualSurface.prototype.processUrl = function(url, fallback) {
    if (!url) {
        return fallback;
    }

    url = url.trim();

    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return this.baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return this.baseUrlOrigin + url;
    } else {  //relative
        return this.baseUrl + url;
    }
};


MapVirtualSurface.prototype.hasTile = function(id) {
    const shift = id[0] - this.lodRange[0];

    if (shift < 0) {
        return false;
    }

    const x = id[1] >> shift;
    const y = id[2] >> shift;

    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||
        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
        return false;
    }

    return true;
};


MapVirtualSurface.prototype.hasTile2 = function(id) {
    let shift = id[0] - this.lodRange[0];
    const above = (shift < 0);

    if (id[0] < this.lodRange[0]) {
        shift = -shift;
        const x1 = this.tileRange[0][0] >> shift;
        const y1 = this.tileRange[0][1] >> shift;
        const x2 = this.tileRange[1][0] >> shift;
        const y2 = this.tileRange[1][1] >> shift;

        if (id[0] > this.lodRange[1] ||
            id[1] < x1 || id[1] > x2 ||
            id[2] < y1 || id[2] > y2 ) {
            return [false , false];
        }
    } else {
        const x = id[1] >> shift;
        const y = id[2] >> shift;

        if (id[0] > this.lodRange[1] ||
            x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
            return [false , false];
        }
    }

    return [true, above];
};


MapVirtualSurface.prototype.hasMetatile = function(id) {
    if (id[0] > this.lodRange[1]) {
        return false;
    }

    let shift = id[0] - this.lodRange[0];

    if (shift >= 0) {
        const x = id[1] >> shift;
        const y = id[2] >> shift;

        if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
            return false;
        }

    } else {
        shift = -shift;

        if (id[1] < (this.tileRange[0][0]>>shift) || id[1] > (this.tileRange[1][0]>>shift) ||
            id[2] < (this.tileRange[0][1]>>shift) || id[2] > (this.tileRange[1][1]>>shift) ) {
            return false;
        }
    }

    return true;
};


//used only for glues
MapVirtualSurface.prototype.getSurface = function(index) {
    return this.surfaces[index - 1];
};


MapVirtualSurface.prototype.getMetaUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


/* harmony default export */ __webpack_exports__["default"] = (MapVirtualSurface);


/***/ }),

/***/ "./src/core/renderer/bbox.js":
/*!***********************************!*\
  !*** ./src/core/renderer/bbox.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const BBox = function(xmin, ymin, zmin, xmax, ymax, zmax) {
    this.min = [];
    this.max = [];

    this.min[0] = (xmin != null) ? xmin : Number.POSITIVE_INFINITY;
    this.min[1] = (ymin != null) ? ymin : Number.POSITIVE_INFINITY;
    this.min[2] = (zmin != null) ? zmin : Number.POSITIVE_INFINITY;

    this.max[0] = (xmax != null) ? xmax : Number.NEGATIVE_INFINITY;
    this.max[1] = (ymax != null) ? ymax : Number.NEGATIVE_INFINITY;
    this.max[2] = (zmax != null) ? zmax : Number.NEGATIVE_INFINITY;

    this.updateMaxSize();
};


BBox.prototype.clone = function() {
    return new BBox(this.min[0], this.min[1], this.min[2],
                    this.max[0], this.max[1], this.max[2]);
};


BBox.prototype.side = function(index) {
    return this.max[index] - this.min[index];
};


BBox.prototype.updateMaxSize = function() {
    this.maxSize = Math.abs(Math.max(this.max[0] - this.min[0],
                                     this.max[1] - this.min[1],
                                     this.max[2] - this.min[2]));
};


BBox.prototype.center = function(vec) {
    if (vec != null) {
        vec[0] = (this.min[0] + this.max[0])*0.5;
        vec[1] = (this.min[1] + this.max[1])*0.5;
        return vec;
    } else {
        if (!this.middle) {
            this.middle = [(this.min[0] + this.max[0])*0.5, (this.min[1] + this.max[1])*0.5, (this.min[2] + this.max[2])*0.5];

            if (isNaN(this.middle[0])) {
                this.middle[0] = 0;
            }

            if (isNaN(this.middle[1])) {
                this.middle[1] = 0;
            }

            if (isNaN(this.middle[2])) {
                this.middle[2] = 0;
            }
        }

        return this.middle;
    }
};


BBox.prototype.translateXY = function(delta) {
    return new BBox(this.min[0] - delta[0], this.min[1] - delta[1], this.min[2],
                    this.max[0] - delta[0], this.max[1] - delta[1], this.max[2]);
};


/* harmony default export */ __webpack_exports__["default"] = (BBox);


/***/ }),

/***/ "./src/core/renderer/camera.js":
/*!*************************************!*\
  !*** ./src/core/renderer/camera.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math */ "./src/core/utils/math.js");




//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"], vec4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"], mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_1__["math"];


const Camera = function(parent, fov, near, far) {
    this.parent = parent;
    this.position = [0,0,0];
    this.orientation = [0,0,0];
    this.aspect = 1;
    this.fov = fov;
    this.fovTan = Math.tan(fov * Math.PI / 180.0);
    this.fovDist = 1;
    this.near = near;
    this.far = far;
    this.rotationByMatrix = false;

    // derived quantities, calculated from camera parameters by update()
    this.modelview = mat4.create();
    this.rotationview = mat4.create();
    this.projection = mat4.create();
    this.mvp = mat4.create();
    this.mvp32 = new Float32Array(16);
    this.modelview32 = new Float32Array(16);
    this.rotationview32 = new Float32Array(16);
    this.projection32 = new Float32Array(16);

    this.frustumPlanes = [ [0,0,0,0], [0,0,0,0], [0,0,0,0],
                           [0,0,0,0], [0,0,0,0], [0,0,0,0] ];
    this.bboxPoints = [
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ]
    ];

    //reduce garbage collection
    this.scaleFactorVec = [0,0,0,0];
    this.dirty = true;
};


Camera.prototype.setPosition = function(position) {
    this.position = position;
    this.dirty = true;
};


Camera.prototype.setOrientation = function(orientation) {
    this.rotationByMatrix = false;
    this.orientation = orientation;
    this.dirty = true;
};


Camera.prototype.setRotationMatrix = function(matrix){
    this.rotationByMatrix = true;
    this.rotationview = matrix.slice();
    this.dirty = true;
};


// Sets the viewport aspect ratio (width / height). Should be called
// whenever the rendering viewport changes.
Camera.prototype.setAspect = function(aspect) {
    this.aspect = aspect;
    this.dirty = true;
};


Camera.prototype.setViewHeight = function(height) {
    this.viewHeight = height;
    this.dirty = true;
};


Camera.prototype.setOrtho = function(state) {
    this.ortho = state;
    this.dirty = true;
};


Camera.prototype.setParams = function(fov, near, far) {
    this.fov = fov;
    this.near = near;
    this.far = far;
    this.dirty = true;
};


Camera.prototype.clone = function(newFov) {
    const camera = new Camera(this. parent, (newFov != null) ? newFov : this.getFov(), this.getNear(), this.getFar());

    camera.setPosition(this.getPosition());
    camera.setOrientation(this.getOrientation());
    camera.setAspect(this.getAspect());
    camera.update();

    return camera;
};


// simple getters
Camera.prototype.getPosition = function(){ return [this.position[0], this.position[1], this.position[2]]; };
Camera.prototype.getOrientation = function(){ return [this.orientation[0], this.orientation[1], this.orientation[2]]; };
Camera.prototype.getAspect = function(){ return this.aspect; };
Camera.prototype.getFov = function(){ return this.fov; };
Camera.prototype.getNear = function(){ return this.near; };
Camera.prototype.getFar = function(){ return this.far; };
Camera.prototype.getViewHeight = function(){ return this.viewHeight; };
Camera.prototype.getOrtho = function(){ return this.ortho; };


// Returns rotation matrix
Camera.prototype.getRotationviewMatrix = function() {
    if (this.dirty) this.update();
    return this.rotationview;
};

Camera.prototype.getRotationviewFMatrix = function() {
    if (this.dirty) this.update();
    return this.rotationview32;
};

// Returns a matrix that transforms the world space to camera space.
Camera.prototype.getModelviewMatrix = function(){
    if (this.dirty) this.update();
    return this.modelview;
};

Camera.prototype.getModelviewFMatrix = function(){
    if (this.dirty) this.update();
    return this.modelview32;
};


// Returns a matrix that transforms the camera space to screen space.
Camera.prototype.getProjectionMatrix = function() {
    if (this.dirty) this.update();
    return this.projection;
};

Camera.prototype.getProjectionFMatrix = function() {
    if (this.dirty) this.update();
    return this.projection32;
};


// Returns projectionMatrix() * modelviewMatrix()
Camera.prototype.getMvpMatrix = function() {
    if (this.dirty) this.update();
    return this.mvp;
};

Camera.prototype.getMvpFMatrix = function() {
    if (this.dirty) this.update();
    return this.mvp32;
};

// Returns how much a length unit located at a point in world space is
// stretched when projected to the sceen space.
Camera.prototype.scaleFactor = function(worldPos, returnDist) {
    if (this.dirty) this.update();

    //const camPos = vec4.create();
    //mat4.multiplyVec4(this.modelview, worldPos, camPos);
    mat4.multiplyVec3(this.modelview, worldPos, this.scaleFactorVec);
    const dist = vec3.length(this.scaleFactorVec); // distance from camera

    // the expression "projection(0,0) / depth" is the derivative of the
    // screen X position by the camera space X coordinate.

    // ('dist' is used instead of camera depth (camPos(2)) to make the tile
    // resolution independent of camera rotation)

    if (returnDist) {
        if (dist < this.near) return [Number.POSITIVE_INFINITY, dist];
        return [this.projection[0] / dist, dist];
        //return [(this.projection[5]*0.5) / dist, dist]; //projection by sy
    }

    if (dist < this.near) return Number.POSITIVE_INFINITY;
    return this.projection[0] / dist;
    //return (this.projection[5]*0.5) / dist; //projection by sy
};


Camera.prototype.scaleFactor2 = function(dist) {
    if (this.dirty) this.update();

    if (dist < this.near) return Number.POSITIVE_INFINITY;
    return this.projection[0] / dist;
    //return (this.projection[5]*0.5) / dist; //projection by sy
};


Camera.prototype.distance = function(worldPos) {
    const delta = vec3.create();
    vec3.subtract(this.position, worldPos, delta);
    return vec3.length(delta);
};


// Returns true if point is inside camera frustum.
Camera.prototype.pointVisible = function(point, shift) {
    if (this.dirty) this.update();

    let p;

    if (shift) {
        p = [ point[0] - shift[0], point[1] - shift[1], point[2] - shift[2], 1 ];
    } else {
        p = [ point[0], point[1], point[2], 1 ];
    }

    // test all frustum planes quickly
    for (let i = 0; i < 6; i++) {
        // check if point lie on the negative side of the frustum plane
        if (vec4.dot(this.frustumPlanes[i], p) < 0) {
            return false;
        }
    }

    // the box might be inside - further testing should be done here - TODO!
    return true;
};


// Returns true if the box intersects the camera frustum.
Camera.prototype.pointsVisible = function(points, shift) {
    if (this.dirty) this.update();

    const planes = this.frustumPlanes;
    let lj = points.length, sx, sy, sz;

    if (shift) {
        sx = shift[0];
        sy = shift[1];
        sz = shift[2];
    } else {
        sx = 0;
        sy = 0;
        sz = 0;
    }

    const dot = vec4.dot3;

    // test all frustum planes quickly
    for (let i = 0; i < 6; i++) {
        // check if all points lie on the negative side of the frustum plane
        let negative = true;
        const plane = planes[i];
        for (let j = 0; j < lj; j+=3) {
            if (dot(plane, points, j, sx, sy, sz) >= 0) {
                //return false;
                negative = false;
                break;
            }
        }
        if (negative) return false;
    }

    return true;
};


Camera.prototype.pointsVisible2 = function(points, shift) {
    if (this.dirty) this.update();

    const planes = this.frustumPlanes;
    let lj = points.length, sx, sy, sz;

    if (shift) {
        sx = shift[0];
        sy = shift[1];
        sz = shift[2];
    } else {
        sx = 0;
        sy = 0;
        sz = 0;
    }

    const dot = vec4.dot3;

    // test all frustum planes quickly
    for (let i = 0; i < 6; i++) {
        // check if all points lie on the negative side of the frustum plane
        let negative = true;
        const plane = planes[i];
        for (let j = 0; j < lj; j++) {
            if (dot(plane, points[j], 0, sx, sy, sz) >= 0) {
                //return false;
                negative = false;
                break;
            }
        }
        if (negative) return false;
    }

    return true;
};


// Returns true if the box intersects the camera frustum.
Camera.prototype.bboxVisible = function(bbox, shift) {
    if (this.dirty) this.update();

    const min = bbox.min;
    const max = bbox.max;
    const points = this.bboxPoints;
    let p, minX, minY, minZ, maxX, maxY, maxZ;

    if (shift) {
        minX = min[0] - shift[0];
        minY = min[1] - shift[1];
        minZ = min[2] - shift[2];

        maxX = max[0] - shift[0];
        maxY = max[1] - shift[1];
        maxZ = max[2] - shift[2];
    } else {
        minX = min[0];
        minY = min[1];
        minZ = min[2];

        maxX = max[0];
        maxY = max[1];
        maxZ = max[2];
    }

    p = points[0];
    p[0] = minX;  p[1] = minY; p[2] = minZ;
    p = points[1];
    p[0] = minX;  p[1] = minY; p[2] = maxZ;
    p = points[2];
    p[0] = minX;  p[1] = maxY; p[2] = minZ;
    p = points[3];
    p[0] = minX;  p[1] = maxY; p[2] = maxZ;

    p = points[4];
    p[0] = maxX;  p[1] = minY; p[2] = minZ;
    p = points[5];
    p[0] = maxX;  p[1] = minY; p[2] = maxZ;
    p = points[6];
    p[0] = maxX;  p[1] = maxY; p[2] = minZ;
    p = points[7];
    p[0] = maxX;  p[1] = maxY; p[2] = maxZ;


    const dot = vec4.dot2;
    const planes = this.frustumPlanes;

    // test all frustum planes quickly
    for (let i = 0; i < 6; i++) {
        // check if all points lie on the negative side of the frustum plane
        let negative = true;
        const plane = planes[i];
        for (let j = 0; j < 8; j++) {
            if (dot(plane, points[j]) >= 0) {
                //return false;
                negative = false;
                break;
            }
        }
        if (negative) return false;
    }

    // the box might be inside - further testing should be done here - TODO!
    return true;
};

// eslint-disable-next-line
Camera.prototype.update = function(zoffset) {
    // modelview matrix, this is essentially the inverse of a matrix that
    // brings the camera from the origin to its world position (the inverse
    // is trivial here -- negative angles, reverse order of transformations)
    //this.modelview = mat4.create();

    if (!this.rotationByMatrix) {
        mat4.multiply(math.rotationMatrix(2, math.radians(-this.orientation[2])), math.rotationMatrix(0, math.radians(-this.orientation[1] - 90.0)), this.rotationview);
        mat4.multiply(this.rotationview, math.rotationMatrix(2, math.radians(-this.orientation[0])), this.rotationview);
    }

    mat4.multiply(this.rotationview, math.translationMatrix(-this.position[0], -this.position[1], -this.position[2]), this.modelview);

    if (this.ortho) {
        const near = -2*this.viewHeight;
        const far = 2*this.viewHeight;

        this.projection = math.orthographicMatrix(this.viewHeight, this.aspect, near, far);
    } else {
        this.projection = math.perspectiveMatrix(this.fov, this.aspect, this.near, this.far);
    }

    mat4.multiply(this.projection, this.modelview, this.mvp);

    // prepare frustum planes (in normalized device coordinates)
    this.frustumPlanes[0] = [ 0, 0, 1, 1 ]; // far
    this.frustumPlanes[1] = [ 0, 0,-1, 1 ]; // near
    this.frustumPlanes[2] = [ 1, 0, 0, 1 ]; // left
    this.frustumPlanes[3] = [-1, 0, 0, 1 ]; // right
    this.frustumPlanes[4] = [ 0, 1, 0, 1 ]; // bottom
    this.frustumPlanes[5] = [ 0,-1, 0, 1 ]; // top

    // transform the frustum planes to the world space, remember that
    // planes in homogeneous coordinates transform as p' = M^{-T} * p, where
    // M^{-T} is the transpose of inverse of M
    const mvpt = mat4.create();
    mat4.transpose(this.mvp, mvpt); //without zoffset
    for (let i = 0; i < 6; i++) {
        this.frustumPlanes[i] = mat4.multiplyVec4(mvpt, this.frustumPlanes[i]);
    }

    this.mvp32.set(this.mvp);
    this.projection32.set(this.projection);
    this.modelview32.set(this.modelview);
    this.rotationview32.set(this.rotationview);

    this.fovDist = (this.parent.curSize[1] *0.5) / this.fovTan;

    // the derived quantities are now in sync with the parameters
    this.dirty = false;
};


/* harmony default export */ __webpack_exports__["default"] = (Camera);


/***/ }),

/***/ "./src/core/renderer/devices/three/device.js":
/*!***************************************************!*\
  !*** ./src/core/renderer/devices/three/device.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders */ "./src/core/renderer/devices/three/shaders.js");
/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./group */ "./src/core/renderer/devices/three/group.js");
/* harmony import */ var _libs_three_module_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/three.module.js */ "./src/core/renderer/devices/three/libs/three.module.js");

//import {mat4 as mat4_} from '../../../utils/matrix';
//import ThreeDraw_ from './draw';




//import * as THREE from './libs/three.module.js';

//get rid of compiler mess
//const mat4 = mat4_;
const ThreeShaders = _shaders__WEBPACK_IMPORTED_MODULE_0__["default"];
//const ThreeInit = ThreeInit_;
//const ThreeDraw = ThreeDraw_;
const ThreeGroup = _group__WEBPACK_IMPORTED_MODULE_1__["default"];
const THREE = _libs_three_module_js__WEBPACK_IMPORTED_MODULE_2__;

var matCounter = 1;

const ThreeDevice = function(renderer, div, size, keepFrameBuffer, antialias, aniso) {
    this.renderer = renderer;
    this.div = div;
    this.config = renderer.config;
    this.canvas =  null;
    this.curSize = size;

    this.keepFrameBuffer = (keepFrameBuffer == null) ? false : keepFrameBuffer;
    this.antialias = antialias ? true : false;
    this.anisoLevel = aniso;

    //compatibility stuff
    this.createState = (function(){});
    this.clear = (function(){});
    this.setState = (function(){});
    this.setViewport = (function(){});

    this.draw = {

        getTextSize : (function(size, text){
            return this.getTextSize(size, text);
        }).bind(this),

        drawText : (function(x, y, size, text, color, depth){
            this.addText(x,y,depth, color[0]*255, color[1]*255, color[2]*255, size, text);
        }).bind(this),

        drawBall : (function(){}),

        drawGpuJobs : (function(){}),

        clearJobHBuffer : (function(){}),
        clearJobBuffer : (function(){}),
    }


};


ThreeDevice.prototype.init = function() {

    this.box = new THREE.Box3();
    this.box.setFromCenterAndSize( new THREE.Vector3( 0,0,0 ), new THREE.Vector3( 1,1,1) );

    this.helper = new THREE.Box3Helper( this.box, 0x0000ff );

    this.scene = new THREE.Scene();
    //this.scene.background = new THREE.Color( 0xaaaaaa );
    this.scene.background = new THREE.Color( 0xaa0000 );

    this.scene2 = new THREE.Scene();
    this.scene2D = new THREE.Scene();

    this.camera2 = new THREE.PerspectiveCamera( 45, this.aspectRatio, 0.1, 10000);
    this.camera2.position.set(  0, 200, 0 );
    this.camera2.lookAt( new THREE.Vector3() );

    let widthOrtho = 1024, heightOrtho = 768;
    //this.orthoCamera = new THREE.OrthographicCamera( widthOrtho / - 2, widthOrtho / 2, heightOrtho / 2, heightOrtho / - 2, 0.001, 1000 );
    this.orthoCamera = new THREE.OrthographicCamera( widthOrtho / - 2, widthOrtho / 2, heightOrtho / 2, heightOrtho / - 2, 0, 1000 );
    this.orthoCamera2 = new THREE.OrthographicCamera( widthOrtho / - 2, widthOrtho / 2, heightOrtho / 2, heightOrtho / - 2, 0.1, 10000 );

    this.models = new THREE.Group();
    this.models.frustumCulled = false;
    this.scene.add(this.models);

    this.models2 = new THREE.Group();
    this.models2.frustumCulled = false;
    this.scene.add(this.models2);

    this.scene.add(this.helper);

    this.tileMaterialInjectVersion = this.generateMaterial(new THREE.MeshBasicMaterial({}), {
        uniforms: {  uvTrans : { value: new THREE.Vector4(1,1,0,0) } },
        vertUniforms: 'uniform vec4 uvTrans;\n',
        vertUvCode: 'vUv = vec2(vUv.x * uvTrans.x + uvTrans.z, vUv.y * uvTrans.y + uvTrans.w);',
        onRender: (function(texture, t){

            //texture.needsUpdate = true;
            this.material.map = texture;
            //this.material.needsUpdate = true;

            if (this.material.userData.shader) {
                this.material.userData.shader.uniforms.uvTrans.value.set(t[0],t[1],t[2],t[3]);
                this.material.userData.shader.uniforms.map.value = texture;
                this.material.userData.shader.uniforms.map.needsUpdate = true;
                //this.material.userData.shader.needsUpdate = true;
                //this.material.userData.shader.uniformsNeedUpdate = true;
                this.material.uniformsNeedUpdate = true;
                this.material.isShaderMaterial = true;      // THIS IS HACK, I SHOULD CREATE IT AS SHADER MATERIAL !!!!
            }

        })

     });

     this.tileMaterial = this.generateTileMaterial({

         onRender: (function(texture, t, flags, splitMask, params, paramsC8){

             //if (this.material.userData.shader) {
                 //this.material.userData.shader.uniforms.uvTrans.value.set(t[0],t[1],t[2],t[3]);
                 //this.material.userData.shader.uniforms.map.value = texture;
                 //this.material.userData.shader.uniforms.map.needsUpdate = true;

                 if (texture) {
                     this.material.uniforms.uvTrans.value.set(t[0],t[1],t[2],t[3]);
                     this.material.uniforms.map.value = texture;
                     this.material.uniforms.map.needsUpdate = true;
                 }

                 if (flags & 2){
                     this.material.uniforms.uClip.value = splitMask.slice();
                     this.material.uniforms.uClip.needsUpdate = true;
                 }

                 if (flags & 4){
                     this.material.uniforms.uClip.value = splitMask.slice();
                     this.material.uniforms.uClip.needsUpdate = true;

                     this.material.uniforms.uParams.value.fromArray(params);
                     this.material.uniforms.uParams.needsUpdate = true;

                     this.material.uniforms.uParamsC8.value.fromArray(paramsC8);
                     this.material.uniforms.uParamsC8.needsUpdate = true;
                 }

                 this.material.uniformsNeedUpdate = true;
             //}

         })

     });

     this.tileMaterials = new Array(128);
     this.tileMaterials[0] = this.tileMaterial;

     this.bboxMaterial = this.generateBBoxMaterial();
     this.bboxMesh2 = this.createBBox2();

     this.textTexture = (new THREE.TextureLoader()).load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAACACAMAAADTa0c4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAZQTFRFAAAA////pdmf3QAABIFJREFUeNrsnNuyqzAIhsP7v/Se6Yxra0L4OUVNCzetVqP5DAQItrVOiLg95739NnfOaR99RDj6esBw+CKZXiMK4PiuBkAcANoHAP3J5fzzAV2jePQIt6f4Ndb/MIChlVcCEFpAACZPfN4KUAF0/ufboDW3AuBMFgBwHTCfg2ftYgDUKBuA1ABuHKvA2P+5XdONIEt7BO2o2MdlAJoTQOsV6GEAswt0Zq/bsBhdeQQkqEDMwmIAnJHzA8i3ASkWRFKBbADyLGB3mlYD6DyhA4DfBlgsBDtirUPcBgC5woStYMgVtgKATWcB6DskKUEkGFLYrGw3+l3ydR16wKbbPDlWp4Xfo9vZwR1jtOMA6GkABrdvNmt1Vluy6pyvxu4Xt62fquyTggCTsIkCoIuv8gAA08w+ATBXAdSRY56xPDFPx/VPWFZp5v65kFMPgFjP70YASMfRsDn01xLPcwkRq1HLMoK647hR8v+nId74MQBjvIbUQePra42ZVXVcBCR3mIY89mYAlNGLflqA0V1seosCQNMg80B0bsLGAIDNwvFyiqu66ngVGGMGVBwyWwIwpty2DqEr/qf0Bq+DbjYkkcr4VUoOxiRjrYn3YY5SC4BQB/cF0Lq4kD1RCJ+tN4g6Jps5zfWu+QmSz9sUABkA0BIAXocmBwCJ99MDIASATkmtLQAIft4IgE/ZDStZ59yQbOQQAGZWYMbZ3FFCAGRHnwHQznegGAE+zwxNi8kALCOgS9tzAC4jYG1Qo0myRm0Ae/z8eleqewBoZLwfUswCsbT1KgBZD6QAzAEoXUe3K+xxVf2uLf5U3nBeMPRyACW/LtrwVX989id3PRQOG5Io6vh9XwC6stHIdGdJozun03lxNlwvH4u6UgDM8/LmJyx7ak12feEebaXmUwCOYJWk1JcYKsl74HL74wAaH93NqkE1FSKXc4cv0AjaPEEPgE4ru/ieWdvzVq/4psG3AYDFHlEAioQCuEgMgPjK1VDrqlkbTABAiQBGK38B0BlBSf9xtiAJQDM4NtDqMlaeyduTtkDjHgAtEQBj5ZGK2QE0aCcMAIxLSw0WVYlGDgOQXWE+afouAM0S398O4Nej3wIQf4cIHSfz9pbWugyep4MFIAFARvspbm8BcE2DOdvWnCJQAWFhJ/hKzh4AaB2A7NxedKmLPc+6PN4cL2S8GYC1QMIEQJvmFsJfxdvkEQAoLV4AogBS8/kNvdXlWe5GKhABvQUAZASDALJffY1XfsrToFXFbvYD1gBo6wC8LR7/uvj9CwHcfWuoUJItsVl5nwWAnhxxqsXatUq0OYCcaS/fkbK61u5H8jwAuUIEZXHNL1Jmub5oSKZWiDR9FttM4HEAigqRpn8TeB2AuWNiByAXSHCGbB7/3qYCfgCgPgADEEskbjCCaJDB/+kR6wP4P1Obl8jsBwDUB4yAxqKkthaATjX0KmCtDyCxm+yIMLjCbwBgrg94FYC3h8vLPPmfAVBSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlLy9fJPgAEAvWMULbGsSjwAAAAASUVORK5CYII=');
     this.textTexture.magFilter = THREE.NearestFilter;
     this.textTexture.minFilter = THREE.NearestFilter;
     this.textTexture.flipY = false;


     this.textMaterial = new THREE.ShaderMaterial( {
         uniforms: {
            map : { value: this.textTexture },
            uProj : { value : new THREE.Matrix4() }
         },
         vertexShader: ThreeShaders.textVertexShader,
         fragmentShader: ThreeShaders.textFragmentShader
     } );

     this.textMaterial.side = THREE.DoubleSide;

     this.textBuffers = [];
     this.textBufferIndex = 0;
     this.textBufferSize = 3*2*256;

     this.wireferameMaterial = new THREE.MeshBasicMaterial({color:0x000000,wireframe:true, /*depthTest:false*/ });

     this.testScreenPlane = new THREE.Mesh( new THREE.PlaneGeometry( this.renderer.hitmapSize*0.25, this.renderer.hitmapSize*0.25 ), new THREE.MeshBasicMaterial( { /*color: 0xffffff,*/ depthTest: false, depthWrite: false, side: THREE.DoubleSide } ));
     this.testScreenPlane.material.map = this.textTexture;
     //this.testScreenPlane.needsUpdate = true;

     this.textureRenderTarget = this.createRenderTarget( this.renderer.hitmapSize, this.renderer.hitmapSize, false);

     //this.testScreenPlane.material.uniforms.map.value = this.textureRenderTarget.texture;
     this.testScreenPlane.material.map = this.textureRenderTarget.texture;

};


ThreeDevice.prototype.kill = function() {

};


ThreeDevice.prototype.contextLost = function() {
};


ThreeDevice.prototype.contextRestored = function() {
};


ThreeDevice.prototype.setSize = function(width, height) {

    this.textMaterial.uniforms.uProj.value = (new THREE.Matrix4()).fromArray(this.renderer.imageProjectionMatrix),
    this.textMaterial.uniforms.uProj.needsUpdate = true;

    if (!this.gpu2) {
       this.gpu2 = new THREE.WebGLRenderer( { antialias: false } );

       this.gpu2.autoClear = false;
       this.gpu2.autoUpdateScene = false;
       this.gpu2.outputEncoding = THREE.sRGBEncoding;
       this.gpu2.setPixelRatio( window.devicePixelRatio );
       this.gpu2.setSize( width, height );

       //    this.gpu = new GpuDevice(this, div, this.curSize, this.config.rendererAllowScreenshots, this.config.rendererAntialiasing, this.config.rendererAnisotropic);

       this.div.appendChild( this.gpu2.domElement );
   } else {
       this.gpu2.setSize( width, height );
   }

    this.camera2.aspect = width / height;
    this.camera2.updateProjectionMatrix();

    this.orthoCamera.left = width / -2;
    this.orthoCamera.right = width / 2;
    this.orthoCamera.top = height / -2;
    this.orthoCamera.bottom = height / 2;
    this.orthoCamera.updateProjectionMatrix();

};


ThreeDevice.prototype.cleanTexts = function() {

    for (let i = 0, li = this.textBufferIndex + 1; i < li; i++) {
        let buffer = this.textBuffers[i];
        if (buffer) {
            buffer.index = 0;
            buffer.index2 = 0;
        }
    }

    this.textBufferIndex = 0;
}


ThreeDevice.prototype.addText = function(x,y,z,r,g,b, size, text) {

    const memorySize = (text.length + 1) * 18;

    let buffer = this.textBuffers[this.textBufferIndex];

    if (!buffer) {
        buffer = { mesh:this.createTextBuffer(this.textBufferSize), index:0, index2:0 };
        this.textBuffers[this.textBufferIndex] = buffer;
    }

    if (buffer.index + memorySize > this.textBufferSize) {
        this.textBufferIndex++

        buffer = this.textBuffers[this.textBufferIndex];

        if (!buffer) {
            buffer = { mesh:this.createTextBuffer(this.textBufferSize), index:0, index2:0 };
            this.textBuffers[this.textBufferIndex] = buffer;
        }
    }

    const vertices = buffer.mesh.geometry.attributes.position.array;
    const colors = buffer.mesh.geometry.attributes.color.array;
    const uvs = buffer.mesh.geometry.attributes.uv.array;

    const sizeX = size - 1;
    const sizeY = size;
    const sizeX2 = Math.round(size*0.5);

    let index = buffer.index;
    let index2 = buffer.index2;

    const lx = this.getTextSize(size, text) + 2;

    //draw black line before text
    let char = 0;
    let charPosX = (char & 15) << 4;
    let charPosY = (char >> 4) << 4;
    let x1,x2,y1,y2,u1,u2,v1,v2;

    x1 = x-2, y1 = y-2, u1 = charPosX, v1 = charPosY;
    x2 = x-2 + lx, u2 = charPosX+15;
    y2 = y + sizeY+1, v2 = charPosY+15;

    //black box
    for (let i = index, li = i+18; i < li; i+=3) {
        colors[i] = 0;
        colors[i+1] = 0;
        colors[i+2] = 0;
    }

    //same color for all letters
    for (let i = index + 18, li = i + text.length * 18; i < li; i+=3) {
        colors[i] = r;
        colors[i+1] = g;
        colors[i+2] = b;
    }

    for (let i = -1, li = text.length; i < li; i++) {

        if (i != -1) {
            char = text.charCodeAt(i) - 32;
            charPosX = (char & 15) << 4;
            charPosY = (char >> 4) << 4;

            switch(char) {
            case 12:
            case 14:
            case 27: //:
            case 28: //;
            case 64: //'
            case 73: //i
            case 76: //l
            case 84: //t

                x1 = x, y1 = y,  u1 = charPosX, v1 = charPosY,
                x2 = x + sizeX2, u2 = charPosX+8,
                y2 = y + sizeY, v2 = charPosY+16;
                x += sizeX2;
                break;

            default:

                x1 = x, y1 = y,  u1 = charPosX, v1 = charPosY;
                x2 = x + sizeX, u2 = charPosX+15;
                y2 = y + sizeY, v2 = charPosY+16;
                x += sizeX;
                break;
            }
        }

        vertices[index] = x1;
        vertices[index+1] = y1;
        vertices[index+2] = z;
        vertices[index+3] = x2;
        vertices[index+4] = y1;
        vertices[index+5] = z;
        vertices[index+6] = x2;
        vertices[index+7] = y2;
        vertices[index+8] = z;

        vertices[index+9] = x2;
        vertices[index+10] = y2;
        vertices[index+11] = z;
        vertices[index+12] = x1;
        vertices[index+13] = y2;
        vertices[index+14] = z;
        vertices[index+15] = x1;
        vertices[index+16] = y1;
        vertices[index+17] = z;

        uvs[index2] = u1;
        uvs[index2+1] = v1;
        uvs[index2+2] = u2;
        uvs[index2+3] = v1;
        uvs[index2+4] = u2;
        uvs[index2+5] = v2;

        uvs[index2+6] = u2;
        uvs[index2+7] = v2;
        uvs[index2+8] = u1;
        uvs[index2+9] = v2;
        uvs[index2+10] = u1;
        uvs[index2+11] = v1;

        index += 18;
        index2 += 12;
    }

    buffer.index = index;
    buffer.index2 = index2;
};


ThreeDevice.prototype.getTextSize = function(size, text) {

    const sizeX = size - 1;
    const sizeX2 = Math.round(size*0.5);
    let x = 0;

    for (let i = 0, li = text.length; i < li; i++) {
        const char = text.charCodeAt(i) - 32;

        switch(char) {
        case 12:
        case 14:
        case 27: //:
        case 28: //;7
        case 64: //'
        case 73: //i
        case 76: //l
        case 84: //t
            x += sizeX2;
            break;

        default:
            x += sizeX;
            break;
        }
    }

    return x;
};

// eslint-disable-next-line
ThreeDevice.prototype.createRenderTarget = function(width, height, depthTexture) {

    const target = new THREE.WebGLRenderTarget( width, height );

/*
    target.texture.format = THREE.RGBAFormat;
    target.texture.minFilter = THREE.NearestFilter;
    target.texture.magFilter = THREE.NearestFilter;
    target.texture.generateMipmaps = false;
    target.stencilBuffer = true;
    target.depthBuffer = true;

    if (depthTexture) {
        target.depthTexture = new THREE.DepthTexture();
        target.depthTexture.format = THREE.DepthStencilFormat;
        target.depthTexture.type = THREE.UnsignedInt248Type;
    }
*/
    return target;
};


ThreeDevice.prototype.generateMaterial = function(material, options) {

    material.onBeforeCompile = function ( shader ) {

        if (options.uniforms) {

            for (let key in options.uniforms) {
                shader.uniforms[key] = options.uniforms[key];
            }

        }

        material.userData.shader = shader;

        if (options.vertUniforms) {
            shader.vertexShader = options.vertUniforms + shader.vertexShader;
        }

        if (options.vertUvCode) {
            shader.vertexShader = shader.vertexShader.replace('#include <uv_vertex>',
                                                              '#include <uv_vertex>\n\t' + options.vertUvCode);
        }

    };

    material.customProgramCacheKey = function () {
        return matCounter++;
    };

    if (options.onRender) {
        material.userData.onRender = options.onRender;
    }

    return material;
};


ThreeDevice.prototype.generateTileMaterial = function(options) {

    const defines = (options.defines || {});

    const uniforms = {

        uvTrans : { value: new THREE.Vector4(1,1,0,0) },
        map : { value: null }

    };

    //str += '#define TMIN ' + (0.5-map.config.mapSplitMargin) + '\n' + '#define TMAX ' + (0.5+map.config.mapSplitMargin) + '\n';

    if (options.flags) {

        if (options.flags & 64){
            defines.depth = true;
        }

        if (options.flags & 2){
            defines.clip4 = true;
            defines.TMIN = (0.5-this.config.mapSplitMargin);
            defines.TMAX = (0.5+this.config.mapSplitMargin);
            uniforms.uClip = { value: [1,1,1,1] };
        }

        if (options.flags & 4){
            defines.clip8 = true;
            uniforms.uClip = { value: [1,1,1,1, 1,1,1,1] };
            uniforms.uParams = { value: new THREE.Matrix4() };
            uniforms.uParamsC8 = { value: new THREE.Matrix4() };
        }

        if (options.flags & 8) defines.flatShade = true, defines.flatShadeVar = true;
        if (options.flags & 128) defines.flatShadeInner = true;
        if (options.flags & 1) defines.uvs = true;
    }

    const material = new THREE.ShaderMaterial( {

        defines : defines,
        uniforms: uniforms,
        vertexShader: ThreeShaders.tileVertexShader,
        fragmentShader: ThreeShaders.tileFragmentShader

    } );

    if (options.onRender) {
        material.userData.onRender = options.onRender;
    }

    return material;

}


ThreeDevice.prototype.generateBBoxMaterial = function() {

    const points = new Array(32);

    for (let i = 0; i < 32; i++) {
        points[i] = 0;
    }

    const uniforms = {
        uPoints : { value: points }
    };

    const material = new THREE.ShaderMaterial( {
        uniforms: uniforms,
        vertexShader: ThreeShaders.bbox2VertexShader,
        fragmentShader: ThreeShaders.bboxFragmentShader

    } );

    material.userData.onRender = (function(v){

        this.material.uniforms.uPoints.value = v;
        this.material.uniforms.uPoints.needsUpdate = true;
        this.material.uniformsNeedUpdate = true;

    });

    return material;

}

// eslint-disable-next-line
ThreeDevice.prototype.startRender = function(options) {

    this.scene.updateMatrixWorld();
    this.models.clear();

    this.camera2.position.fromArray(this.renderer.camera.position);
    this.camera2.setRotationFromMatrix( new THREE.Matrix4().fromArray(this.renderer.camera.rotationview).invert());
    this.camera2.fov = this.renderer.camera.fov * 2;
    this.camera2.near = this.renderer.camera.near;
    this.camera2.far = this.renderer.camera.far;
    this.camera2.updateProjectionMatrix();

    this.orthoCamera2.position.fromArray(this.renderer.camera.position);
    this.orthoCamera2.setRotationFromMatrix( new THREE.Matrix4().fromArray(this.renderer.camera.rotationview).invert());
    //this.camera2.fov = this.renderer.camera.fov * 2;
    this.orthoCamera2.near = -2*this.renderer.camera.viewHeight;
    this.orthoCamera2.far = 2*this.renderer.camera.viewHeight;

    const factor = 2;
    const height = this.renderer.camera.viewHeight;
    const width = height * this.renderer.camera.aspect;

    this.orthoCamera2.left = width / -factor;
    this.orthoCamera2.right = width / factor;
    this.orthoCamera2.top = height / factor;
    this.orthoCamera2.bottom = height / -factor;
    this.orthoCamera2.updateProjectionMatrix();

    //console.log(JSON.stringify(this.renderer.camera.projection));

    this.cleanTexts();
}


ThreeDevice.prototype.addSceneObject = function(object) {

    this.models.add(object);

}

// eslint-disable-next-line
ThreeDevice.prototype.finishRender = function(options) {

    if (this.onBeforeFinish) {
        this.onBeforeFinish();
    }

    let camera = this.renderer.camera.ortho ? this.orthoCamera2 : this.camera2;

    if (this.renderer.core.map.draw.drawChannel == 1) {
        this.scene.background = new THREE.Color( 0xffffff );
        this.gpu2.setRenderTarget( this.textureRenderTarget );
        this.models2.visible = false;
        this.gpu2.render( this.scene, camera );
        this.models2.visible = true;
        this.gpu2.setRenderTarget( null );
        return;
    }

    if (this.renderer.core.map.draw.debug.drawWireframe == 1) {
        this.scene.background = new THREE.Color( 0xf9f9f9 );
    } else {
        this.scene.background = new THREE.Color( 0x000000 );
    }

    this.gpu2.setRenderTarget( null );
    this.gpu2.render( this.scene, camera );


    /*
    const drawWireframe = this.core.map.draw.debug.drawWireframe;

    if (drawWireframe == 1 || drawWireframe == 2) {

        const models = this.models.children;

        for (let i = 0, li = models.length; i < li; i++) {
            const model = models[i];

            if (model.geometry) {
                const model2 = new THREE.Mesh(model.geometry, this.wireferameMaterial);

                this.scene2.clear();
                this.scene2.add(model2);
                this.gpu2.render(this.scene2, this.camera2 );
            }

        }
    }*/


    if (this.textBuffers.length && this.textBuffers[0].index > 0) {
        this.scene2D.clear();

        for (let i = 0, li = this.textBufferIndex + 1; i < li; i++) {
            const buffer = this.textBuffers[i];
            buffer.mesh.geometry.attributes.position.needsUpdate = true;
            buffer.mesh.geometry.attributes.color.needsUpdate = true;
            buffer.mesh.geometry.attributes.uv.needsUpdate = true;

            buffer.mesh.geometry.setDrawRange(0, Math.floor(buffer.index / 3));
            this.scene2D.add(buffer.mesh);
        }

        this.gpu2.render( this.scene2D, this.orthoCamera );
    }


    /*this.scene2D.clear();
    this.scene2D.add(this.testScreenPlane);
    this.gpu2.render( this.scene2D, this.orthoCamera );*/

}


ThreeDevice.prototype.createRenderGroup = function(id, bbox, origin) {
    return new ThreeGroup(id, bbox, origin, this, this.renderer);
};


ThreeDevice.prototype.createTexture = function(options) {

    const texture = new THREE.Texture(options.image);
    texture.width = options.width;
    texture.height = options.height;
    //texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;

    texture.flipY = false;
    texture.gpuSize = texture.width * texture.height * 4;
    texture.needsUpdate = true;


    return texture;
};

ThreeDevice.prototype.createDataTexture = function(options) {

    const texture = new THREE.DataTexture( options.data, options.width, options.height, THREE.RGBFormat );
    //texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.gpuSize = texture.width * texture.height * 4;
    texture.needsUpdate = true;

    return texture;
};

// eslint-disable-next-line
ThreeDevice.prototype.createBBox = function(bbox) {

    const box = new THREE.Box3();
    //box.setFromCenterAndSize( new THREE.Vector3(0,0,0),
    //                          new THREE.Vector3(1,1,1) );
    //new THREE.Vector3( (bbox.max[0] - bbox.min[0]), (bbox.max[1] - bbox.min[1]), (bbox.max[2] - bbox.min[2])) );

    const helper = new THREE.Box3Helper( box, 0x0000ff );
    helper.frustumCulled = false;

    return helper;
};

// eslint-disable-next-line
ThreeDevice.prototype.createBBox2 = function(bbox) {

    const geometry = new THREE.BufferGeometry();
    const vertices = new Uint16Array([0,1,1,2,2,3,3,0,
                                      4,5,5,6,6,7,7,4,
                                      0,4,1,5,2,6,3,7]);

    geometry.setAttribute( 'position', new THREE.Uint16BufferAttribute( vertices, 1 ) );

    const lines = new THREE.LineSegments( geometry, this.bboxMaterial);
    lines.frustumCulled = false;

    return lines;
};


ThreeDevice.prototype.createTextBuffer = function(size) {

    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array(size*3);
    const colors = new Uint8Array(size*3);
    const uvs = new Uint8Array(size*2);

    const att = new THREE.Float32BufferAttribute( vertices, 3, false )
    geometry.setAttribute( 'position', att );

    const att2 = new THREE.Uint8BufferAttribute( colors, 3, true )
    geometry.setAttribute( 'color', att2 );

    const att3 = new THREE.Uint8BufferAttribute( uvs, 2, false )
    geometry.setAttribute( 'uv', att3 );

    const mesh = new THREE.Mesh( geometry, this.textMaterial);
    mesh.frustumCulled = false;

    return mesh;
};

ThreeDevice.prototype.createWiredMesh = function(mesh) {

    const mesh2 = new THREE.Mesh(mesh.geometry, this.wireferameMaterial);//gpuSubmesh.clone();
    //gpuSubmesh.userData.wiredMesh.material = renderer.wireferameMaterial;
    //mesh2.onBeforeRender = (function(){});
    mesh2.frustumCulled = false;
    mesh2.bbox = mesh.bbox;
    mesh2.scale.set(mesh.scale.x,mesh.scale.y,mesh.scale.z);


    return mesh2;
};


ThreeDevice.prototype.createMesh = function(options) {
/*
    {
        bbox: this.bbox,
        vertices: this.vertices,
        uvs: this.internalUVs,
        uvs2: this.externalUVs,
        indices: this.indices,
        use16bit: this.use16bit
    }
*/

    const geometry = new THREE.BufferGeometry();

    if (options.vertices) {
        if (options.use16bit) {
            geometry.setAttribute( 'position', new THREE.Uint16BufferAttribute( options.vertices, 3, true ) );
        } else {
            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( options.vertices, 3 )/*.onUpload( disposeArray )*/ );
        }
    }

    const uv = options.uvs || options.uvs2;

    if (uv) {
        if (options.use16bit) {
            geometry.setAttribute( 'uv', new THREE.Uint16BufferAttribute( uv, 2, true ) );

            if (options.uvs && options.uvs2) {
                geometry.setAttribute( 'uv2', new THREE.Uint16BufferAttribute( options.uvs2, 2, true ) );
            }
        } else {
            geometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uv, 2 )/*.onUpload( disposeArray )*/ );

            if (options.uvs && options.uvs2) {
                geometry.setAttribute( 'uv2', new THREE.Float32BufferAttribute( options.uvs2, 2 ) );
            }
        }
    }

    if (options.indices) {
        geometry.setIndex(options.indices);
    }

    const mesh = new THREE.Mesh( geometry, this.tileMaterial);

    const bbox = options.bbox;

    if (bbox) {
        mesh.bbox = options.bbox;
        mesh.scale.set( bbox.max[0] - bbox.min[0], bbox.max[1] - bbox.min[1], bbox.max[2] - bbox.min[2] );
    }

    mesh.frustumCulled = false;

    return mesh;
};


ThreeDevice.prototype.drawTileSubmesh = function (cameraPos, index, texture, type, alpha, layer, surface, splitMask, splitSpace, submesh, gpuSubmesh) {
    const renderer = this.renderer;
    const map = renderer.core.map;
    const stats = map.stats;
    let drawWireframe = map.draw.debug.drawWireframe;
    let gpuTexture = null, t = null;

    if (texture && !(map.draw.config.mapNoTextures || drawWireframe)) {
        gpuTexture = texture.getGpuTexture();
        t = texture.getTransform();
    }


    let flags = 0;
    let material = null;
    let params, paramsC8;

    if (map.draw.drawChannel == 1) {
        type = 1;
        drawWireframe = 0;
    }

    if (drawWireframe == 1) {
        gpuSubmesh.material = this.wireferameMaterial;
        gpuSubmesh.onBeforeRender = (function(){});

        /*if (!gpuSubmesh.userData.wiredMesh) {
            gpuSubmesh.userData.wiredMesh = renderer.createWiredMesh(gpuSubmesh);
            gpuSubmesh.userData.wiredMesh.renderOrder = 10;
        }

        renderer.addSceneObject(gpuSubmesh.userData.wiredMesh);

        return;*/

    } else {

        if (drawWireframe == 2 || drawWireframe == 3) {
            flags |= 8;
        }

        switch(type) {
        case 1:
            flags |= 64;
            break;
        case 4:
        case 5:

            flags |= 1;

            if (surface && surface.flatShade) {
                flags |= 8;
                flags |= 128;
            }

            break;
        case 2:
            flags |= 8;
            break;
        }

        //splitMask = [1,0,0,0];

        if (splitMask) {
            if (splitMask.length == 4) {
                flags |= 2;
            } else {
                flags |= 4;

                const p = map.camera.position;
                const s = splitSpace;

                params = new Array(16);
                paramsC8 = new Array(16);

                const m = paramsC8;

                m[0] = s[0][0] - p[0]; m[1] = s[0][1] - p[1]; m[2] = s[0][2] - p[2]; //c
                m[4] = s[1][0] - s[0][0]; m[5] = s[1][1] - s[0][1]; m[6] = s[1][2] - s[0][2]; //px
                m[8] = s[2][0] - s[1][0]; m[9] = s[2][1] - s[1][1]; m[10] = s[2][2] - s[1][2]; //py
                m[12] = s[4][0] - s[0][0]; m[13] = s[4][1] - s[0][1]; m[14] = s[4][2] - s[0][2]; m[15] = 0; //pz

                const bmin = submesh.bbox.min, bmax = submesh.bbox.max;

                m[3] = bmin[0] - p[0];
                m[7] = bmin[1] - p[1];
                m[11] = bmin[2] - p[2];

                const m2 = params;

                m2[0] = 0, m2[1] = 0, m2[2] = bmax[0] - bmin[0], m2[3] = bmax[1] - bmin[1];
                m2[4] = 0, m2[5] = 0, m2[6] = 0, m2[7] = 0;
                m2[8] = 0, m2[9] = 0, m2[10] = 0, m2[11] = 0;
                m2[12] = bmax[2] - bmin[2], m2[13] = bmin[0], m2[14] = bmin[1], m2[15] = bmin[2];
            }
        }

        material = this.tileMaterials[flags];

        if (!material) {
            material = this.generateTileMaterial({ flags: flags, onRender: this.tileMaterial.userData.onRender });
            this.tileMaterials[flags] = material;
        }

        if (drawWireframe == 2) {
            material.polygonOffset = true;
            material.polygonOffsetFactor = 1;
        } else {
            material.polygonOffset = false;
        }

        gpuSubmesh.material = material;
        gpuSubmesh.onBeforeRender = gpuSubmesh.material.userData.onRender.bind(gpuSubmesh, gpuTexture, t, flags, splitMask, params, paramsC8);

    }


    const bbox = gpuSubmesh.bbox;

    if (bbox) {
        gpuSubmesh.position.set( bbox.min[0] - cameraPos[0], bbox.min[1] - cameraPos[1], bbox.min[2] - cameraPos[2] );
    }

    if (submesh.statsCoutner != stats.counter) {
        submesh.statsCoutner = stats.counter;
        stats.gpuRenderUsed += gpuSubmesh.gpuSize;

        if (gpuTexture) {
            stats.gpuRenderUsed += gpuTexture.gpuSize;
        }
    }

    this.addSceneObject(gpuSubmesh);

    if (drawWireframe == 2) {
        if (!gpuSubmesh.userData.wiredMesh) {
            gpuSubmesh.userData.wiredMesh = this.createWiredMesh(gpuSubmesh);
            gpuSubmesh.userData.wiredMesh.renderOrder = 10;
        }

        if (bbox) {
            gpuSubmesh.userData.wiredMesh.position.set( bbox.min[0] - cameraPos[0], bbox.min[1] - cameraPos[1], bbox.min[2] - cameraPos[2] );
        }

        this.addSceneObject(gpuSubmesh.userData.wiredMesh);
    }

    stats.drawnFaces += this.faces;
    stats.drawCalls ++;

};


/* harmony default export */ __webpack_exports__["default"] = (ThreeDevice);


/***/ }),

/***/ "./src/core/renderer/devices/three/group.js":
/*!**************************************************!*\
  !*** ./src/core/renderer/devices/three/group.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../bbox */ "./src/core/renderer/bbox.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _map_resource_node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../map/resource-node */ "./src/core/map/resource-node.js");







//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"], mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
const BBox = _bbox__WEBPACK_IMPORTED_MODULE_1__["default"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_2__["math"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_3__["utils"];
const MapResourceNode = _map_resource_node__WEBPACK_IMPORTED_MODULE_4__["default"];

const ThreeGroup = function(id, bbox, origin, gpu, renderer) {
    this.id = id;
    this.bbox = null;
    this.origin = origin || [0,0,0];
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.renderer = renderer;
    this.jobs = [];
    this.reduced = 0;
    this.geometries = {};
    this.subjob = null;
    this.mv = new Float32Array(16);
    this.mvp = new Float32Array(16);
    this.loadMode = 0;
    //this.geFactor = 1/38;
    this.geFactor = 1/16;
    this.geFactor2 = 0.5;
    this.geNormalized = false;

    if (bbox != null && bbox[0] != null && bbox[1] != null) {
        this.bbox = new BBox(bbox[0][0], bbox[0][1], bbox[0][2], bbox[1][0], bbox[1][1], bbox[1][2]);
    }

    this.binFiles = [];

    this.size = 0;
    this.polygons = 0;
};

//destructor
ThreeGroup.prototype.kill = function() {
    for (let i = 0, li = this.jobs.length; i < li; i++) {
        const job = this.jobs[i];

        switch(job.type) {
        case 1:
        case 11:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;

        case 3:
        case 2:
        case 4:
        case 5:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexNormalBuffer) this.gl.deleteBuffer(job.vertexNormalBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;

        case 6:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexTexcoordBuffer) this.gl.deleteBuffer(job.vertexTexcoordBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;

        case 7:
        case 8:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexTexcoordBuffer) this.gl.deleteBuffer(job.vertexTexcoordBuffer);
            if (job.vertexOriginBuffer) this.gl.deleteBuffer(job.vertexOriginBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;
        }
    }

    //remove geometries
    for (let key in this.geometries) {
        const geometries = this.geometries[key];
        const globalGeometry = this.renderer.geometries[key];
        this.geometries[key] = null;

        //remove geometry from glbal stack
        for (let i = 0, li = geometries.length; i < li; i++) {
            if (geometries[i] == globalGeometry) {
                this.renderer.geometries[key] = null;
            }
        }
    }

    if (this.octreeParser) {
        this.octreeParser.kill();
        this.octreeParser = null;
    }

};


ThreeGroup.prototype.getSize = function() {
    return this.size;
};


ThreeGroup.prototype.getZbufferOffset = function() {
    return this.size;
};

ThreeGroup.prototype.addGeometry = function(data) {
    const id = data['id'];

    if (!this.geometries[id]) {
        this.geometries[id] = [data];
    } else {
        this.geometries[id].push(data);
    }

    this.renderer.geometries[id] = data;
};

ThreeGroup.prototype.convertColor = function(c) {
    const f = 1.0/255;
    return [c[0]*f, c[1]*f, c[2]*f, c[3]*f];
};

ThreeGroup.prototype.addLineJob = function(data) {
    const gl = this.gl;

    const vertices = data.vertexBuffer;

    const job = {};

    if (data.type == 13) {
        job.type = 11;
    } else {
        job.type = 1;
    }

    job.program = this.gpu.progLine;
    job.color = this.convertColor(data['color']);
    job.zIndex = data['z-index'] + 256;
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.advancedHit = data['advancedHit'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.style = data['style'] || 0;
    job.stencil = (data['stencil'] === false) ? false : true;
    job.culling = data['culling'] || 0;
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.lineWidth = data['line-width'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.reduced = false;
    job.ready = true;
    job.bbox = this.bbox;

    if (!job.program.isReady()) {
        return;
    }

    if (job.advancedHit) {
        job.program2 = this.gpu.progELine;

        if (!job.program2.isReady()) {
            return;
        }
    }

    //create vertex buffer
    job.vertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    job.vertexPositionBuffer.itemSize = 3;
    job.vertexPositionBuffer.numItems = vertices.length / 3;

    if (job.advancedHit) {
        job.program = this.gpu.progLine;

        const elements = data.elementBuffer;

        job.vertexElementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, elements, gl.STATIC_DRAW);
        job.vertexElementBuffer.itemSize = 1;
        job.vertexElementBuffer.numItems = elements.length;
    }

    this.jobs.push(job);

    this.size += vertices.length * 4;
    this.polygons += vertices.length / (3 * 3);
};


ThreeGroup.prototype.addExtentedLineJob = function(data) {
    const gl = this.gl;

    const vertices = data.vertexBuffer;
    const normals = data.normalBuffer;

    const job = {};
    job.type = data['type'];


    switch(job.type) {
    case 6:  job.type = 3;  break;
    case 7:  job.type = 2;  break;
    case 9:  job.type = 4;  break;
    case 10: job.type = 5; break;
    }

    job.color = this.convertColor(data['color']);
    job.zIndex = data['z-index'] + 256;
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.advancedHit = data['advancedHit'];
    job.widthByRatio = data['width-units'] == 'ratio',
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.lineWidth = data['line-width'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.reduced = false;
    job.ready = true;
    job.bbox = this.bbox;

    let background;

    if (data['texture'] != null) {
        const texture = data['texture'];
        const bitmap = texture[0];
        job.texture = [this.renderer.getBitmap(bitmap['url'], bitmap['filter'] || 'linear', bitmap['tiled'] || false),
            texture[1], texture[2], texture[3], texture[4]];
        background = this.convertColor(data['background']);

        if (background[3] != 0) {
            job.background = background;
        }
    }

    switch(job.type) {
    case 3:   job.program = (background[3] != 0) ? this.gpu.progTBLine : this.gpu.progTLine;  break;
    case 2:   job.program = this.gpu.progRLine;  break;
    case 4:   job.program = this.gpu.progLine3;  break;
    case 5:  job.program = (background[3] != 0) ? this.gpu.progTPBLine : this.gpu.progTPLine; break;
    }

    if (!job.program.isReady()) {
        return;
    }

    if (job.advancedHit) {
        switch(job.type) {
        case 3:   job.program2 = this.gpu.progETLine;  break;
        case 2:   job.program2 = this.gpu.progERLine;  break;
        case 4:   job.program2 = this.gpu.progELine3;  break;
        case 5:  job.program2 = this.gpu.progETPLine; break;
        }

        if (!job.program2.isReady()) {
            return;
        }
    }

    //create vertex buffer
    job.vertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    job.vertexPositionBuffer.itemSize = 4;
    job.vertexPositionBuffer.numItems = vertices.length / 4;

    //create normal buffer
    job.vertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
    job.vertexNormalBuffer.itemSize = 4;
    job.vertexNormalBuffer.numItems = normals.length / 4;

    if (job.advancedHit) {
        const elements = data.elementBuffer;

        job.vertexElementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, elements, gl.STATIC_DRAW);
        job.vertexElementBuffer.itemSize = 1;
        job.vertexElementBuffer.numItems = elements.length;
    }

    this.jobs.push(job);

    this.size += vertices.length * 4 + normals.length * 4;
    this.polygons += vertices.length / (4 * 3);
};


ThreeGroup.prototype.processReduce = function(job) {
    if (job.reduce) {
        switch(job.reduce[0]) {
            case 'tilt':       job.reduce[0] = 1; break;
            case 'tilt-cos':   job.reduce[0] = 2; break;
            case 'tilt-cos2':  job.reduce[0] = 3; break;
            case 'scr-count':  job.reduce[0] = 4; break;
            case 'scr-count2': job.reduce[0] = 5; this.renderer.drawnGeodataTilesUsed = true; break;
            case 'scr-count3': job.reduce[0] = 6; this.renderer.drawnGeodataTilesUsed = true; break;
            case 'scr-count4': job.reduce[0] = 7; break;
            case 'scr-count5': job.reduce[0] = 8; break;
            case 'scr-count6': job.reduce[0] = 9; break;
            case 'scr-count7': job.reduce[0] = 10; break;
            case 'scr-count8': job.reduce[0] = 11; break;
        }

        job.reduce[5] = 0; //zero debug value
        job.reduce[6] = 0;
        job.reduce[7] = 0;

        if (job.reduce[0] >= 7 && job.reduce[0] <= 11) {

            if (job.reduce[0] == 10 || job.reduce[0] == 11) {
                job.reduce[1] = Math.abs(job.reduce[1]);
                job.reduce[3] = job.reduce[1] * job.reduce[2];
                job.reduce[2] = job.reduce[1];
                job.reduce[4] = 0;
            } else {
                job.reduce[2] = Math.abs(job.reduce[1]); //copy prominence for prom / dist support

                if (this.renderer.config.mapFeaturesReduceFactor >= 1) { // prom / dists
                    job.reduce[1] = job.reduce[2];
                } else {
                    if (job.reduce[0] == 9) {
                        job.reduce[1] = job.reduce[2];
                    } else {
                        job.reduce[1] = Math.floor((Math.log(job.reduce[2] * 500) / Math.log(1.0017)) + 5000);
                    }
                }
            }
        }
    }
};


ThreeGroup.prototype.addLineLabelJob = function(data) {
    const gl = this.gl;
    let singleBuffer;
    let singleBuffer2;
    let vertices;
    let texcoords;

    if (data.singleBuffer) {
        singleBuffer = data.singleBuffer;
        singleBuffer2 = data.singleBuffer2;
    } else {
        vertices = data.vertexBuffer;
        texcoords = data.texcoordsBuffer;
    }

    const job = {};
    job.type = 6;
    job.program = this.gpu.progText;
    job.color = this.convertColor(data['color']);
    job.color2 = this.convertColor(data['color2']);
    job.outline = data['outline'];
    job.zIndex = data['z-index'] + 256;
    job.visibility = data['visibility'];
    job.culling = data['culling'];
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.labelPoints = data['labelPoints'];
    job.labelIndex = data['labelIndex'];
    job.labelSize = data['labelSize'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.hysteresis = data['hysteresis'];
    job.noOverlap = data['noOverlap'];
    job.labelPointsBuffer = { id: -1, points: [], points2: [] },
    job.id = job.hysteresis ? job.hysteresis[2] : null;
    job.reduced = false;
    job.ready = true;
    job.bbox = this.bbox;
    job.reduce = data['reduce'];

    this.processReduce(job);

    job.files = data['files'] || [];
    const fonts = data['fonts'] || ['#default'];
    job.fonts = fonts;

    for (let i = 0, li = fonts.length; i < li; i++) {
        fonts[i] = this.renderer.fonts[fonts[i]];
    }

    job.program = this.gpu.progText2;

    if (!job.program.isReady()) {
        return;
    }

    if (singleBuffer) {

        job.singleBuffer = singleBuffer;
        job.singleBuffer2 = singleBuffer2;
        job.textVector = data['textVector'];
        this.polygons += (singleBuffer.length / 12) * 2;

    } else {
        //create vertex buffer
        job.vertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        job.vertexPositionBuffer.itemSize = 4;
        job.vertexPositionBuffer.numItems = vertices.length / 4;

        //create normal buffer
        job.vertexTexcoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);
        job.vertexTexcoordBuffer.itemSize = 4;
        job.vertexTexcoordBuffer.numItems = texcoords.length / 4;

        this.size += vertices.length * 4 + texcoords.length * 4;
        this.polygons += vertices.length / (4 * 3);
    }

    this.jobs.push(job);
};


ThreeGroup.prototype.addIconJob = function(data, label, tile) {
    const gl = this.gl;

    const vertices = data.vertexBuffer;
    const texcoords = data.texcoordsBuffer;
    const origins = data.originBuffer;
    const singleBuffer = data.singleBuffer;
    const s = data['stick'];
    const f = 1.0/255;

    const job = { tile: tile };
    job.type = label ? 8 : 7;
    job.program = this.gpu.progIcon;
    job.color = this.convertColor(data['color']);
    job.zIndex = data['z-index'] + 256;
    job.visibility = data['visibility'];
    job.culling = data['culling'];
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.state = data['state'];
    job.center = data['center'];
    job.stick = [s[0], s[1], s[2], s[3]*f, s[4]*f, s[5]*f, s[6]*f, s[7]];
    job.lod = data['lod'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.hysteresis = data['hysteresis'];
    job.noOverlap = data['noOverlap'];
    job.id = job.hysteresis ? job.hysteresis[2] : null;
    job.reduced = false;
    job.ready = true;
    job.reduce = data['reduce'];

    this.processReduce(job);

    if (!job.program.isReady()) {
        return;
    }

    if (label !== true) {
        const icon = data['icon'];
        job.texture = this.renderer.getBitmap(null, icon['filter'] || 'linear', icon['tiled'] || false, icon['hash'], true);
        job.files = [];
    } else {
        job.color2 = this.convertColor(data['color2']);
        job.outline = data['outline'];
        job.size = data['size'];
        job.origin = data['origin'];
        job.files = data['files'] || [];
        job.index = data['index'] || 0;
        const fonts = data['fonts'] || ['#default'];
        job.fonts = fonts;
        job.gamma = [job.outline[2] * 1.4142 / job.size, job.outline[3] * 1.4142 / job.size];

        if (job.origin) {
            job.origin = new Float32Array(job.origin);
        }

        for (let i = 0, li = fonts.length; i < li; i++) {
            fonts[i] = this.renderer.fonts[fonts[i]];
        }

        job.program = this.gpu.progIcon2;
    }

    if (job.visibility != null && !Array.isArray(job.visibility)) {
        job.visibility = [job.visibility];
    }

    if (singleBuffer) {
        job.singleBuffer = singleBuffer;
        this.polygons += 2;

    } else {
        //create vertex buffer
        job.vertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        job.vertexPositionBuffer.itemSize = 4;
        job.vertexPositionBuffer.numItems = vertices.length / 4;

        //create normal buffer
        job.vertexTexcoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);
        job.vertexTexcoordBuffer.itemSize = 4;
        job.vertexTexcoordBuffer.numItems = texcoords.length / 4;

        //create origin buffer
        job.vertexOriginBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, origins, gl.STATIC_DRAW);
        job.vertexOriginBuffer.itemSize = 3;
        job.vertexOriginBuffer.numItems = origins.length / 3;

        this.size += job.vertexPositionBuffer.numItems * 4 +
                      job.vertexOriginBuffer.numItems * 4 +
                      job.vertexTexcoordBuffer.numItems * 4;
        this.polygons += job.vertexPositionBuffer.numItems / (4 * 3);
    }


    if (this.subjobs) {
        this.subjobs.push(job);
    } else {
        if (this.vsjobs) {
            this.vsjobs.push(job);
        } else {
            this.jobs.push(job);
        }
    }

};


ThreeGroup.prototype.addPack = function() {
    if (!this.subjobs.length) {
        this.subjobs = null;
        return;
    }

    const job = {
        type : 9,
        subjobs: this.subjobs,
        culling : 180,
        zIndex : 0,
        ready : true
    };

    //extract no overlap, remove it form subjobs
    for (let i = 0, li = job.subjobs.length; i < li; i++) {
        const subjob = job.subjobs[i];

        if (subjob.noOverlap) {

            if (!job.noOverlap) {
                job.noOverlap = subjob.noOverlap;
            } else {
                const o = job.noOverlap;
                const o2 = subjob.noOverlap;

                if (o2[0] < o[0]) o[0] = o2[0];
                if (o2[1] < o[1]) o[1] = o2[1];
                if (o2[2] > o[2]) o[2] = o2[2];
                if (o2[3] > o[3]) o[3] = o2[3];
            }

            subjob.noOverlap = null;
        }

        if (subjob.culling <= job.culling) {
            job.culling = subjob.culling;
            subjob.culling = 180;
        }

        if (subjob.visibility) {
            job.visibility = subjob.visibility;
            subjob.visibility = null;
        }

        if (subjob.stick) {
            job.stick = subjob.stick;
            subjob.stick = [0,0,0,255,255,255,255,0];
        }

        if (subjob.zIndex > job.zIndex) {
            job.zIndex = subjob.zIndex;
        }

        if (subjob.center) {
            job.center = subjob.center;
        }

        job.eventInfo = subjob.eventInfo;
        job.reduce = subjob.reduce;

        job.hysteresis = subjob.hysteresis;
        job.id = subjob.id;
    }

    if (this.vsjobs) {
        this.vsjobs.push(job);
    } else {
        this.jobs.push(job);
    }

    this.subjobs = null;
};


ThreeGroup.prototype.addVSPoint = function(data, tile){
    const job = { tile: tile };
    job.type = 10;
    job.zIndex = data['z-index'] + 256;
    job.visibility = data['visibility'];
    job.culling = data['culling'];
    job.hitable = false;
    job.eventInfo = data['eventInfo'];
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.hysteresis = data['hysteresis'];
    job.id = job.hysteresis ? job.hysteresis[2] : null;
    job.reduced = false;
    job.ready = true;
    job.reduce = data['reduce'];
    job.vswitch = [];

    this.vsjob = job;
};


ThreeGroup.prototype.storeVSJobs = function(data){
    this.vsjob.vswitch.push([data.viewExtent, this.vsjobs]);
    this.vsjobs = [];
};


ThreeGroup.prototype.addVSwitch = function(){
    if (this.vsjob) {
        this.jobs.push(this.vsjob);
    }

    this.vsjobs = null;
};

ThreeGroup.prototype.addMeshJob = function(data) {
    const job = {};

    job.type = 12;
    job.path = data['path'];

    job.textures = [];

    job.resources = new MapResourceNode(this.renderer.core.map, null, null);

    if (job.path) {
        const stmp = job.path.split(".");
        if (stmp.length > 1) {
            stmp.pop();
            job.texturePath = stmp.join('.');
        }

        job.mesh = job.resources.getMesh(job.path, null);
    }

    this.jobs.push(job);
};


ThreeGroup.prototype.copyBuffer = function(buffer, source, index) {
    const tmp = new Uint8Array(buffer.buffer);
    tmp.set(new Uint8Array(source.buffer, index, buffer.byteLength));
    return buffer;
};


ThreeGroup.prototype.addRenderJob2 = function(buffer, index, tile, direct) {
    let data, str, length, type, view;

    if (direct) {
        type = direct.type;
        data = direct.data;
    } else {
        view = new DataView(buffer.buffer);
        type = buffer[index]; index += 1;

        if (type != 15 && type != 16 &&
            type != 17 && type != 19 && type != 18) {

            length = view.getUint32(index); index += 4;
            str = utils.unint8ArrayToString(new Uint8Array(buffer.buffer, index, length)); index+= length;
            data = JSON.parse(str);
        }
    }

    switch(type) {
        case 13:
        case 6:
            data.type = type;
            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;

            if (data['advancedHit']) {
                length = view.getUint32(index); index += 4;
                data.elementBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.elementBuffer.byteLength;
            }

            this.addLineJob(data);
            break;

        case 8:
        case 7:
        case 9:
        case 10:
            data.type = type;
            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.normalBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.normalBuffer.byteLength;

            if (data['advancedHit']) {
                length = view.getUint32(index); index += 4;
                data.elementBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.elementBuffer.byteLength;
            }

            this.addExtentedLineJob(data);
            break;

        case 11:

            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.texcoordsBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.texcoordsBuffer.byteLength;
            this.addLineLabelJob(data);
            break;

        case 12:

            length = view.getUint32(index); index += 4;
            data.singleBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.singleBuffer2 = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer2.byteLength;
            this.addLineLabelJob(data);
            break;

        case 3:
        case 1:

            length = view.getUint32(index); index += 4;
            data.singleBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer.byteLength;
            this.addIconJob(data, (type == 1), tile);
            break;

        case 4:
        case 2:

            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.originBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.originBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.texcoordsBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.texcoordsBuffer.byteLength;
            this.addIconJob(data, (type == 2), tile);
            break;

        case 5:
        case 14:

            length = view.getUint32(index); index += 4;
            data.geometryBuffer = this.copyBuffer(new Float64Array(length), buffer, index); index += data.originBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.indicesBuffer = this.copyBuffer(new Uint32Array(length), buffer, index); index += data.indicesBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            this.addGeometry(data);
            break;

        case 15:
            this.subjobs = []; index += 4;
            break;

        case 16:
            this.addPack(); index += 4;
            break;

        case 20:
            this.addVSPoint(data, tile);
            break;

        case 17:
            this.vsjobs = []; this.vsjob = null; index += 4;
            break;

        case 19:
            this.addVSwitch(); index += 4;
            break;

        case 18:
            data = { viewExtent: view.getUint32(index) }; index += 4;
            this.storeVSJobs(data);
            break;

        case 21:
            {
                const node = data;
                node.nodes = [];
                node.jobs = [];
                node.parent = this.currentNode;

                if (node.volume) {
                    const p = node.volume.points;
                    const points = [
                        p[0][0],p[0][1],p[0][2],
                        p[1][0],p[1][1],p[1][2],
                        p[2][0],p[2][1],p[2][2],
                        p[3][0],p[3][1],p[3][2],
                        p[4][0],p[4][1],p[4][2],
                        p[5][0],p[5][1],p[5][2],
                        p[6][0],p[6][1],p[6][2],
                        p[7][0],p[7][1],p[7][2]
                    ];

                    node.volume.points2 = points;
                }

                if (this.rootNode) {
                    this.currentNode.nodes.push(node);
                    this.currentNode = node;
                } else {
                    this.rootNode = node;
                    this.currentNode = node;

                    this.oldJobs = this.jobs;
                }

                this.jobs = node.jobs;
            }
            break;

        case 22:

            if (this.currentNode.parent) {
                this.currentNode = this.currentNode.parent;
                this.jobs = this.currentNode.jobs;
            } else {
                this.currentNode = this.currentNode.parent;
                this.jobs = this.oldJobs;
            }

            break;

        case 23:
            this.addMeshJob(data, tile);
            break;

        case 24:
            if(this.currentNode) {
                this.currentNode.path = data['path'];
            }
            break;

    }

    return index;
};


ThreeGroup.prototype.addRenderJob = function(data, tile) {
    switch(data['type']) {
    case 'polygon':
    case 'flat-line':     this.addLineJob(data); break;
    case 'flat-tline':
    case 'flat-rline':
    case 'pixel-line':
    case 'pixel-tline':    this.addExtentedLineJob(data); break;
    case 'line-label':     this.addLineLabelJob(data); break;
    case 'icon':           this.addIconJob(data); break;
    case 'label':          this.addIconJob(data, true, tile); break;
    case 'point-geometry': this.addGeometry(data); break;
    case 'line-geometry':  this.addGeometry(data); break;
    case 'pack-begin':     this.subjobs = []; break;
    case 'pack-end':       this.addPack(); break;
    case 'vspoint':        this.addVSPoint(data, tile); break;
    case 'vswitch-begin':  this.vsjobs = []; this.vsjob = null; break;
    case 'vswitch-store':  this.storeVSJobs(data); break;
    case 'vswitch-end':    this.addVSwitch(); break;
    case 'node-begin':     this.nodeBegin(); break;
    case 'node-end':       this.nodeEnd(); break;
    case 'mesh':           this.addMesh(); break;
    }
};

/*
function drawLineString(options, renderer) {
    if (options == null || typeof options !== 'object') {
        return this;
    }

    if (options['points'] == null) {
        return this;
    }

    const points = options['points'];
    const depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;
    const size = options['size'] || 2;
    const screenSpace = (options['screenSpace'] != null) ? options['screenSpace'] : true;
    const depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;
    const blend = (options['blend'] != null) ? options['blend'] : false;
    const writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;
    const useState = (options['useState'] != null) ? options['useState'] : false;
    let color = options['color'] || [255,255,255,255];

    color = [ color[0] * (1.0/255), color[1] * (1.0/255), color[2] * (1.0/255), color[3] * (1.0/255) ];

    renderer.gpu.draw.drawLineString(points, screenSpace, size, color, depthOffset, depthTest, blend, writeDepth, useState);
    return this;
}
*/

ThreeGroup.prototype.draw = function(mv, mvp, applyOrigin, tiltAngle, texelSize) {
    if (this.id != null) {
        if (this.renderer.layerGroupVisible[this.id] === false) {
            return;
        }
    }

    const renderer = this.renderer;
    const renderCounter = [[renderer.geoRenderCounter, mv, mvp, this]];
    const map = renderer.core.map;
    this.map = map;

    if (this.binPath) {
        if (this.octreeParser) {
            this.octreeParser.draw(mv, mvp, applyOrigin, tiltAngle, texelSize);
        }
    }

    if (applyOrigin) {
        const mvp2 = mat4.create();
        const mv2 = mat4.create();
        const pos = this.renderer.position;

        /*
        const transform = this.renderer.layerGroupTransform[this.id];

        if (transform != null) {
            origin = transform[1];
            origin = [origin[0] - pos[0], origin[1] - pos[1], origin[2]];
            mat4.multiply(math.translationMatrix(origin[0], origin[1], origin[2]), transform[0], mv2);
            mat4.multiply(mv, mv2, mv2);
        } else {*/
            let origin = this.origin;
            origin = [origin[0] - pos[0], origin[1] - pos[1], origin[2]];
            mat4.multiply(mv, math.translationMatrix(origin[0], origin[1], origin[2]), mv2);
        /*}*/

        mat4.multiply(mvp, mv2, mvp2);
        mv = mv2;
        mvp = mvp2;
    }

    const cameraPos = renderer.cameraPosition;
    const jobZBuffer = renderer.jobZBuffer;
    const jobZBufferSize = renderer.jobZBufferSize;
    //const jobZBuffer2 = renderer.jobZBuffer2;
    //const jobZBuffer2Size = renderer.jobZBuffer2Size;

    const onlyHitable = renderer.onlyHitLayers;

    for (let i = 0, li = this.jobs.length; i < li; i++) {
        const job = this.jobs[i];

        if ((job.type == 7 || job.type == 8) && job.visibility > 0) {
            const center = job.center;
            if (vec3.length([center[0]-cameraPos[0],
                center[1]-cameraPos[1],
                center[2]-cameraPos[2]]) > job.visibility) {
                continue;
            }
        }

        if (onlyHitable && !job.hitable) {
            continue;
        }

        job.mv = mv;
        job.mvp = mvp;
        job.renderCounter = renderCounter;
        job.tiltAngle = tiltAngle;
        job.texelSize = texelSize;

        const zIndex = job.zIndex;

        jobZBuffer[zIndex][jobZBufferSize[zIndex]] = job;
        jobZBufferSize[zIndex]++;
    }
};


/* harmony default export */ __webpack_exports__["default"] = (ThreeGroup);


/***/ }),

/***/ "./src/core/renderer/devices/three/libs/three.module.js":
/*!**************************************************************!*\
  !*** ./src/core/renderer/devices/three/libs/three.module.js ***!
  \**************************************************************/
/*! exports provided: ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EdgesHelper, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, FaceColors, FileLoader, FlatShading, Float16BufferAttribute, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GammaEncoding, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, JSONLoader, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, Math, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColors, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBIntegerFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VideoTexture, WebGL1Renderer, WebGLCubeRenderTarget, WebGLMultipleRenderTargets, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, sRGBEncoding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function() { return ACESFilmicToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveAnimationBlendMode", function() { return AdditiveAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysStencilFunc", function() { return AlwaysStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return AmbientLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLightProbe", function() { return AmbientLightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function() { return AnimationClip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationLoader", function() { return AnimationLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() { return AnimationMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() { return AnimationObjectGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() { return AnimationUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return ArcCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() { return ArrayCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() { return ArrowHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() { return AudioAnalyser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return AudioContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioListener", function() { return AudioListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioLoader", function() { return AudioLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxesHelper", function() { return AxesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisHelper", function() { return AxisHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() { return BinaryTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bone", function() { return Bone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() { return BooleanKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() { return BoundingBoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box2", function() { return Box2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3", function() { return Box3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3Helper", function() { return Box3Helper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxHelper", function() { return BoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return BufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() { return BufferGeometryLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return Cache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return CameraHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() { return CanvasRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return CanvasTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return CatmullRomCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() { return CircleGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return CircleGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return Clock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() { return ColorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() { return CompressedTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() { return CompressedTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() { return ConeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return ConeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function() { return CubeCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return CubeTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return CubeTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return CubicBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return CubicBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() { return CubicInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CurvePath", function() { return CurvePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomToneMapping", function() { return CustomToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() { return CylinderGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return CylinderGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cylindrical", function() { return Cylindrical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return DataTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture2DArray", function() { return DataTexture2DArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture3D", function() { return DataTexture3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() { return DataTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataUtils", function() { return DataUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementStencilOp", function() { return DecrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementWrapStencilOp", function() { return DecrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() { return DefaultLoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTexture", function() { return DepthTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return DirectionalLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() { return DirectionalLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() { return DiscreteInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() { return DodecahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return DodecahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() { return DynamicBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicCopyUsage", function() { return DynamicCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDrawUsage", function() { return DynamicDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicReadUsage", function() { return DynamicReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return EdgesGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() { return EdgesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return EllipseCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualStencilFunc", function() { return EqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() { return ExtrudeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return ExtrudeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return FaceColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return FileLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float16BufferAttribute", function() { return Float16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() { return Float32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() { return Float64Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() { return Float64BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fog", function() { return Fog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FogExp2", function() { return FogExp2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Font", function() { return Font; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontLoader", function() { return FontLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return Frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLBufferAttribute", function() { return GLBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLSL1", function() { return GLSL1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLSL3", function() { return GLSL3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualStencilFunc", function() { return GreaterEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterStencilFunc", function() { return GreaterStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridHelper", function() { return GridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() { return HemisphereLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() { return HemisphereLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightProbe", function() { return HemisphereLightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() { return IcosahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return IcosahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return ImageLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function() { return ImageUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() { return ImmediateRenderObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementStencilOp", function() { return IncrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementWrapStencilOp", function() { return IncrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() { return InstancedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() { return InstancedBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() { return InstancedInterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedMesh", function() { return InstancedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() { return Int16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() { return Int32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() { return Int8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() { return InterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() { return InterleavedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function() { return Interpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InvertStencilOp", function() { return InvertStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return JSONLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeepStencilOp", function() { return KeepStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() { return KeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOD", function() { return LOD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() { return LatheGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return LatheGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LensFlare", function() { return LensFlare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualStencilFunc", function() { return LessEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessStencilFunc", function() { return LessStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Light", function() { return Light; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightProbe", function() { return LightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line3", function() { return Line3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return LineBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return LineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return LineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return LineDashedMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function() { return LineLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinePieces", function() { return LinePieces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return LineSegments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineStrip", function() { return LineStrip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() { return LinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapLinearFilter", function() { return LinearMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapNearestFilter", function() { return LinearMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoaderUtils", function() { return LoaderUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function() { return LoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return Material; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() { return MaterialLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math", function() { return MathUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MathUtils", function() { return MathUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return Mesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return MeshBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return MeshDepthMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() { return MeshDistanceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() { return MeshFaceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return MeshLambertMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshMatcapMaterial", function() { return MeshMatcapMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return MeshNormalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return MeshPhongMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return MeshPhysicalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return MeshStandardMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return MeshToonMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() { return MultiMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapLinearFilter", function() { return NearestMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapNearestFilter", function() { return NearestMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverStencilFunc", function() { return NeverStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return NoColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalAnimationBlendMode", function() { return NormalAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualStencilFunc", function() { return NotEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() { return NumberKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() { return ObjectLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return ObjectSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() { return OctahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return OctahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return OrthographicCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PMREMGenerator", function() { return PMREMGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() { return ParametricGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() { return ParticleBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() { return ParticleSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() { return ParticleSystemMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return PerspectiveCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneHelper", function() { return PlaneHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloud", function() { return PointCloud; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() { return PointCloudMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return PointLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() { return PointLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return PointsMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() { return PolarGridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() { return PolyhedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return PolyhedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() { return PositionalAudio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() { return PropertyBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() { return PropertyMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return QuadraticBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return QuadraticBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() { return QuaternionKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() { return QuaternionLinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAIntegerFormat", function() { return RGBAIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return RGBA_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return RGBA_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return RGBA_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return RGBA_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return RGBA_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return RGBA_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return RGBA_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return RGBA_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return RGBA_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return RGBA_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return RGBA_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return RGBA_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return RGBA_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return RGBA_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_BPTC_Format", function() { return RGBA_BPTC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ETC2_EAC_Format", function() { return RGBA_ETC2_EAC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBIntegerFormat", function() { return RGBIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC2_Format", function() { return RGB_ETC2_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGFormat", function() { return RGFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGIntegerFormat", function() { return RGIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return RawShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return Raycaster; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() { return RectAreaLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function() { return RedFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedIntegerFormat", function() { return RedIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaceStencilOp", function() { return ReplaceStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() { return RingGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return RingGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x10_Format", function() { return SRGB8_ALPHA8_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x5_Format", function() { return SRGB8_ALPHA8_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x6_Format", function() { return SRGB8_ALPHA8_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x8_Format", function() { return SRGB8_ALPHA8_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x10_Format", function() { return SRGB8_ALPHA8_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x12_Format", function() { return SRGB8_ALPHA8_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_4x4_Format", function() { return SRGB8_ALPHA8_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x4_Format", function() { return SRGB8_ALPHA8_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x5_Format", function() { return SRGB8_ALPHA8_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x5_Format", function() { return SRGB8_ALPHA8_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x6_Format", function() { return SRGB8_ALPHA8_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x5_Format", function() { return SRGB8_ALPHA8_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x6_Format", function() { return SRGB8_ALPHA8_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x8_Format", function() { return SRGB8_ALPHA8_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return Scene; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneUtils", function() { return SceneUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() { return ShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function() { return ShaderLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return ShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return ShadowMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() { return ShapeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return ShapeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapePath", function() { return ShapePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() { return ShapeUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function() { return Skeleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() { return SkeletonHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() { return SkinnedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() { return SphereGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return SphereGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spherical", function() { return Spherical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalHarmonics3", function() { return SphericalHarmonics3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return SplineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function() { return SpotLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() { return SpotLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return SpriteMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticCopyUsage", function() { return StaticCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticDrawUsage", function() { return StaticDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticReadUsage", function() { return StaticReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StereoCamera", function() { return StereoCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamCopyUsage", function() { return StreamCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamDrawUsage", function() { return StreamDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamReadUsage", function() { return StreamReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() { return StringKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return TangentSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() { return TetrahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return TetrahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextGeometry", function() { return TextGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return TextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() { return TorusGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return TorusGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() { return TorusKnotGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return TorusKnotGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return Triangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() { return TubeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return TubeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() { return Uint16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() { return Uint32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() { return Uint8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() { return Uint8ClampedAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uniform", function() { return Uniform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function() { return UniformsLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() { return UniformsUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSMShadowMap", function() { return VSMShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return Vector2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return Vector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() { return VectorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vertex", function() { return Vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return VertexColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return VideoTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGL1Renderer", function() { return WebGL1Renderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeRenderTarget", function() { return WebGLCubeRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMultipleRenderTargets", function() { return WebGLMultipleRenderTargets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMultisampleRenderTarget", function() { return WebGLMultisampleRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return WebGLRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() { return WebGLRenderTargetCube; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return WebGLRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUtils", function() { return WebGLUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return WireframeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() { return WireframeHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHRLoader", function() { return XHRLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroStencilOp", function() { return ZeroStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return sRGBEncoding; });
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '134';
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const SmoothShading = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;

const GLSL1 = '100';
const GLSL3 = '300 es';

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

class EventDispatcher {

	addEventListener( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	}

	hasEventListener( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	}

	removeEventListener( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	}

	dispatchEvent( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

}

let _seed = 1234567;

const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

//

const _lut = [];

for ( let i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

const hasRandomUUID = typeof crypto !== 'undefined' && 'randomUUID' in crypto;

function generateUUID() {

	if ( hasRandomUUID ) {

		return crypto.randomUUID().toUpperCase();

	}

	// TODO Remove this code when crypto.randomUUID() is available everywhere
	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toUpperCase() here flattens concatenated strings to save heap memory space.
	return uuid.toUpperCase();

}

function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

	} else {

		return 0;

	}

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s % 2147483647;

	// Park-Miller algorithm

	_seed = _seed * 16807 % 2147483647;

	return ( _seed - 1 ) / 2147483646;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}

var MathUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	generateUUID: generateUUID,
	clamp: clamp,
	euclideanModulo: euclideanModulo,
	mapLinear: mapLinear,
	inverseLerp: inverseLerp,
	lerp: lerp,
	damp: damp,
	pingpong: pingpong,
	smoothstep: smoothstep,
	smootherstep: smootherstep,
	randInt: randInt,
	randFloat: randFloat,
	randFloatSpread: randFloatSpread,
	seededRandom: seededRandom,
	degToRad: degToRad,
	radToDeg: radToDeg,
	isPowerOfTwo: isPowerOfTwo,
	ceilPowerOfTwo: ceilPowerOfTwo,
	floorPowerOfTwo: floorPowerOfTwo,
	setQuaternionFromProperEuler: setQuaternionFromProperEuler
});

class Vector2 {

	constructor( x = 0, y = 0 ) {

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

Vector2.prototype.isVector2 = true;

class Matrix3 {

	constructor() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	scale( sx, sy ) {

		const te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	}

	rotate( theta ) {

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		const te = this.elements;

		const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	}

	translate( tx, ty ) {

		const te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

Matrix3.prototype.isMatrix3 = true;

function arrayMax( array ) {

	if ( array.length === 0 ) return - Infinity;

	let max = array[ 0 ];

	for ( let i = 1, l = array.length; i < l; ++ i ) {

		if ( array[ i ] > max ) max = array[ i ];

	}

	return max;

}

const TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	Uint8ClampedArray: Uint8ClampedArray,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

function getTypedArray( type, buffer ) {

	return new TYPED_ARRAYS[ type ]( buffer );

}

function createElementNS( name ) {

	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

}

/**
  * cyrb53 hash for string from: https://stackoverflow.com/a/52171480
  *
  * Public Domain, @bryc - https://stackoverflow.com/users/815680/bryc
  *
  * It is roughly similar to the well-known MurmurHash/xxHash algorithms. It uses a combination
  * of multiplication and Xorshift to generate the hash, but not as thorough. As a result it's
  * faster than either would be in JavaScript and significantly simpler to implement. Keep in
  * mind this is not a secure algorithm, if privacy/security is a concern, this is not for you.
  *
  * @param {string} str
  * @param {number} seed, default 0
  * @returns number
  */
function hashString( str, seed = 0 ) {

	let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;

	for ( let i = 0, ch; i < str.length; i ++ ) {

		ch = str.charCodeAt( i );

		h1 = Math.imul( h1 ^ ch, 2654435761 );

		h2 = Math.imul( h2 ^ ch, 1597334677 );

	}

	h1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 ) ^ Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );

	h2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 ) ^ Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );

	return 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );

}

let _canvas;

class ImageUtils {

	static getDataURL( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

}

let textureId = 0;

class Texture extends EventDispatcher {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

		super();

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = generateUUID();

		this.name = '';

		this.image = image;
		this.mipmaps = [];

		this.mapping = mapping;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;

		this.userData = {};

		this.version = 0;
		this.onUpdate = null;

		this.isRenderTargetTexture = false;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			const image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = generateUUID(); // UGH

			}

			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

				let url;

				if ( Array.isArray( image ) ) {

					// process array of images e.g. CubeTexture

					url = [];

					for ( let i = 0, l = image.length; i < l; i ++ ) {

						// check cube texture with data textures

						if ( image[ i ].isDataTexture ) {

							url.push( serializeImage( image[ i ].image ) );

						} else {

							url.push( serializeImage( image[ i ] ) );

						}

					}

				} else {

					// process single image

					url = serializeImage( image );

				}

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: url
				};

			}

			output.image = image.uuid;

		}

		if ( JSON.stringify( this.userData ) !== '{}' ) output.userData = this.userData;

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;

Texture.prototype.isTexture = true;

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.prototype.slice.call( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;

	}

}

Vector4.prototype.isVector4 = true;

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class WebGLRenderTarget extends EventDispatcher {

	constructor( width, height, options = {} ) {

		super();

		this.width = width;
		this.height = height;
		this.depth = 1;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
		this.texture.isRenderTargetTexture = true;

		this.texture.image = { width: width, height: height, depth: 1 };

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	setTexture( texture ) {

		texture.image = {
			width: this.width,
			height: this.height,
			depth: this.depth
		};

		this.texture = texture;

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = depth;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();
		this.texture.image = { ...this.texture.image }; // See #20328.

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

class WebGLMultipleRenderTargets extends WebGLRenderTarget {

	constructor( width, height, count ) {

		super( width, height );

		const texture = this.texture;

		this.texture = [];

		for ( let i = 0; i < count; i ++ ) {

			this.texture[ i ] = texture.clone();

		}

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			for ( let i = 0, il = this.texture.length; i < il; i ++ ) {

				this.texture[ i ].image.width = width;
				this.texture[ i ].image.height = height;
				this.texture[ i ].image.depth = depth;

			}

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

		return this;

	}

	copy( source ) {

		this.dispose();

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.viewport.set( 0, 0, this.width, this.height );
		this.scissor.set( 0, 0, this.width, this.height );

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		this.texture.length = 0;

		for ( let i = 0, il = source.texture.length; i < il; i ++ ) {

			this.texture[ i ] = source.texture[ i ].clone();

		}

		return this;

	}

}

WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;

class WebGLMultisampleRenderTarget extends WebGLRenderTarget {

	constructor( width, height, options ) {

		super( width, height, options );

		this.samples = 4;

	}

	copy( source ) {

		super.copy.call( this, source );

		this.samples = source.samples;

		return this;

	}

}

WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerp( qa, qb, qm, t ) {

		console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		return qm.slerpQuaternions( qa, qb, t );

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		this.copy( qa ).slerp( qb, t );

	}

	random() {

		// Derived from http://planning.cs.uiuc.edu/node198.html
		// Note, this source uses w, x, y, z ordering,
		// so we swap the order below.

		const u1 = Math.random();
		const sqrt1u1 = Math.sqrt( 1 - u1 );
		const sqrtu1 = Math.sqrt( u1 );

		const u2 = 2 * Math.PI * Math.random();

		const u3 = 2 * Math.PI * Math.random();

		return this.set(
			sqrt1u1 * Math.cos( u2 ),
			sqrtu1 * Math.sin( u3 ),
			sqrtu1 * Math.cos( u3 ),
			sqrt1u1 * Math.sin( u2 ),
		);

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Quaternion.prototype.isQuaternion = true;

class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	randomDirection() {

		// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

		const u = ( Math.random() - 0.5 ) * 2;
		const t = Math.random() * Math.PI * 2;
		const f = Math.sqrt( 1 - u ** 2 );

		this.x = f * Math.cos( t );
		this.y = f * Math.sin( t );
		this.z = u;

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

Vector3.prototype.isVector3 = true;

const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

class Box3 {

	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const x = array[ i ];
			const y = array[ i + 1 ];
			const z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromBufferAttribute( attribute ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			const x = attribute.getX( i );
			const y = attribute.getY( i );
			const z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object ) {

		this.makeEmpty();

		return this.expandByObject( object );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( geometry.boundingBox === null ) {

				geometry.computeBoundingBox();

			}

			_box$3.copy( geometry.boundingBox );
			_box$3.applyMatrix4( object.matrixWorld );

			this.union( _box$3 );

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ] );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$3.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$3, _v1$7 );
		_f2.subVectors( _v0$2, _v2$3 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	}

	getBoundingSphere( target ) {

		this.getCenter( target.center );

		target.radius = this.getSize( _vector$b ).length() * 0.5;

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

Box3.prototype.isBox3 = true;

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$3 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the seperating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the seperating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is seperating and we can exit
			return false;

		}

	}

	return true;

}

const _box$2 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _toFarthestPoint = /*@__PURE__*/ new Vector3();
const _toPoint = /*@__PURE__*/ new Vector3();

class Sphere {

	constructor( center = new Vector3(), radius = - 1 ) {

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$2.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	expandByPoint( point ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

		_toPoint.subVectors( point, this.center );

		const lengthSq = _toPoint.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			const length = Math.sqrt( lengthSq );
			const missingRadiusHalf = ( length - this.radius ) * 0.5;

			// Nudge this sphere towards the target point. Add half the missing distance to radius,
			// and the other half to position. This gives a tighter enclosure, instead of if
			// the whole missing distance were just added to radius.

			this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
			this.radius += missingRadiusHalf;

		}

		return this;

	}

	union( sphere ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

		// To enclose another sphere into this sphere, we only need to enclose two points:
		// 1) Enclose the farthest point on the other sphere into this sphere.
		// 2) Enclose the opposite point of the farthest point into this sphere.

		_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

		this.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );
		this.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

class Ray {

	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector$a.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class Matrix4 {

	constructor() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$2.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$2.elements[ 0 ] *= invSX;
		_m1$2.elements[ 1 ] *= invSX;
		_m1$2.elements[ 2 ] *= invSX;

		_m1$2.elements[ 4 ] *= invSY;
		_m1$2.elements[ 5 ] *= invSY;
		_m1$2.elements[ 6 ] *= invSY;

		_m1$2.elements[ 8 ] *= invSZ;
		_m1$2.elements[ 9 ] *= invSZ;
		_m1$2.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$2 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

Matrix4.prototype.isMatrix4 = true;

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$2 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$1 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order = this._order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order = this._order, update = true ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix$1.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$1, order, update );

	}

	setFromVector3( v, order = this._order ) {

		return this.set( v.x, v.y, v.z, order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	toVector3( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new Vector3( this._x, this._y, this._z );

		}

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Euler.prototype.isEuler = true;

Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = 1 << channel | 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$1 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();

const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

class Object3D extends EventDispatcher {

	constructor() {

		super();

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	}

	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	localToWorld( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	}

	worldToLocal( vector ) {

		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	}

	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position$3, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	}

	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	clear() {

		for ( let i = 0; i < this.children.length; i ++ ) {

			const object = this.children[ i ];

			object.parent = null;

			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	}

	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		this.add( object );

		object.updateWorldMatrix( false, true );

		return this;

	}

	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	}

	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	raycast() {}

	traverse( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	}

	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	}

	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	}

	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	}

	toJSON( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isScene ) {

			if ( this.background ) {

				if ( this.background.isColor ) {

					object.background = this.background.toJSON();

				} else if ( this.background.isTexture ) {

					object.background = this.background.toJSON( meta ).uuid;

				}

			}

			if ( this.environment && this.environment.isTexture ) {

				object.environment = this.environment.toJSON( meta ).uuid;

			}

		} else if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	}

	clone( recursive ) {

		return new this.constructor().copy( this, recursive );

	}

	copy( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

}

Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype.isObject3D = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$1 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

class Triangle {

	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		this.getBarycoord( point, a, b, c, _v3$1 );

		return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

	}

	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3$1 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3$1.x );
		target.addScaledVector( uv2, _v3$1.y );
		target.addScaledVector( uv3, _v3$1.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

		this.a.fromBufferAttribute( attribute, i0 );
		this.b.fromBufferAttribute( attribute, i1 );
		this.c.fromBufferAttribute( attribute, i2 );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getUV( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

let materialId = 0;

class Material extends EventDispatcher {

	constructor() {

		super();

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;

		this.opacity = 1;
		this.format = RGBAFormat;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

		this._alphaTest = 0;

	}

	get alphaTest() {

		return this._alphaTest;

	}

	set alphaTest( value ) {

		if ( this._alphaTest > 0 !== value > 0 ) {

			this.version ++;

		}

		this._alphaTest = value;

	}

	onBuild( /* shaderobject, renderer */ ) {}

	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

	onBeforeCompile( /* shaderobject, renderer */ ) {}

	customProgramCacheKey() {

		return this.onBeforeCompile.toString();

	}

	setValues( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			// for backward compatability if shading is set in the constructor
			if ( key === 'shading' ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === FlatShading ) ? true : false;
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	toJSON( meta ) {

		const isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen !== undefined ) data.sheen = this.sheen;
		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;

			if ( this.combine !== undefined ) data.combine = this.combine;

		}

		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.transmission !== undefined ) data.transmission = this.transmission;
		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		if ( this.thickness !== undefined ) data.thickness = this.thickness;
		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		if ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;
		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.format !== RGBAFormat ) data.format = this.format;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;
		data.colorWrite = this.colorWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.flatShading === true ) data.flatShading = this.flatShading;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.fog = source.fog;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.format = source.format;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

Material.prototype.isMaterial = true;

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

class Color {

	constructor( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	set( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	}

	setRGB( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	}

	setHSL( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo( h, 1 );
		s = clamp( s, 0, 1 );
		l = clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	}

	setStyle( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 4 ] );

						return this;

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 4 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat( color[ 1 ] ) / 360;
						const s = parseInt( color[ 2 ], 10 ) / 100;
						const l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 4 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style );

		}

		return this;

	}

	setColorName( style ) {

		// color keywords
		const hex = _colorKeywords[ style.toLowerCase() ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copyGammaToLinear( color, gammaFactor = 2.0 ) {

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	}

	copyLinearToGamma( color, gammaFactor = 2.0 ) {

		const safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	}

	convertGammaToLinear( gammaFactor ) {

		this.copyGammaToLinear( this, gammaFactor );

		return this;

	}

	convertLinearToGamma( gammaFactor ) {

		this.copyLinearToGamma( this, gammaFactor );

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex() {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	}

	getHexString() {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	}

	getHSL( target ) {

		// h,s,l ranges are in 0.0 - 1.0

		const r = this.r, g = this.g, b = this.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getStyle() {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = lerp( _hslA.h, _hslB.h, alpha );
		const s = lerp( _hslA.s, _hslB.s, alpha );
		const l = lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		if ( attribute.normalized === true ) {

			// assuming Uint8Array

			this.r /= 255;
			this.g /= 255;
			this.b /= 255;

		}

		return this;

	}

	toJSON() {

		return this.getHex();

	}

}

Color.NAMES = _colorKeywords;

Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 * }
 */

class MeshBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		return this;

	}

}

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();

class BufferAttribute {

	constructor( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	copy( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	copyArray( array ) {

		this.array.set( array );

		return this;

	}

	copyColorsArray( colors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = colors.length; i < l; i ++ ) {

			let color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	}

	copyVector2sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	}

	copyVector3sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	}

	copyVector4sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	}

	applyMatrix3( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.x = this.getX( i );
			_vector$9.y = this.getY( i );
			_vector$9.z = this.getZ( i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.x = this.getX( i );
			_vector$9.y = this.getY( i );
			_vector$9.z = this.getZ( i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.x = this.getX( i );
			_vector$9.y = this.getY( i );
			_vector$9.z = this.getZ( i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	getX( index ) {

		return this.array[ index * this.itemSize ];

	}

	setX( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	}

	getY( index ) {

		return this.array[ index * this.itemSize + 1 ];

	}

	setY( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

	getZ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	}

	setZ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

	getW( index ) {

		return this.array[ index * this.itemSize + 3 ];

	}

	setW( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	clone() {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

	toJSON() {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
		if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

		return data;

	}

}

BufferAttribute.prototype.isBufferAttribute = true;

//

class Int8BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int8Array( array ), itemSize, normalized );

	}

}

class Uint8BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint8Array( array ), itemSize, normalized );

	}

}

class Uint8ClampedBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint8ClampedArray( array ), itemSize, normalized );

	}

}

class Int16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int16Array( array ), itemSize, normalized );

	}

}

class Uint16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

class Int32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Int32Array( array ), itemSize, normalized );

	}

}

class Uint32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint32Array( array ), itemSize, normalized );

	}

}

class Float16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

class Float32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float32Array( array ), itemSize, normalized );

	}

}

class Float64BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float64Array( array ), itemSize, normalized );

	}

}

let _id = 0;

const _m1 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$1 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();

class BufferGeometry extends EventDispatcher {

	constructor() {

		super();

		Object.defineProperty( this, 'id', { value: _id ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	getIndex() {

		return this.index;

	}

	setIndex( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	}

	getAttribute( name ) {

		return this.attributes[ name ];

	}

	setAttribute( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	}

	deleteAttribute( name ) {

		delete this.attributes[ name ];

		return this;

	}

	hasAttribute( name ) {

		return this.attributes[ name ] !== undefined;

	}

	addGroup( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	}

	clearGroups() {

		this.groups = [];

	}

	setDrawRange( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	}

	applyMatrix4( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	applyQuaternion( q ) {

		_m1.makeRotationFromQuaternion( q );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateX( angle ) {

		// rotate geometry around world x-axis

		_m1.makeRotationX( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateY( angle ) {

		// rotate geometry around world y-axis

		_m1.makeRotationY( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateZ( angle ) {

		// rotate geometry around world z-axis

		_m1.makeRotationZ( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	translate( x, y, z ) {

		// translate geometry

		_m1.makeTranslation( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	scale( x, y, z ) {

		// scale geometry

		_m1.makeScale( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	lookAt( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	}

	center() {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	}

	setFromPoints( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$1.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$1.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$1.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$1.min );
						this.boundingBox.expandByPoint( _box$1.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$1.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$1.min, _boxMorphTargets.min );
						_box$1.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$1.max, _boxMorphTargets.max );
						_box$1.expandByPoint( _vector$8 );

					} else {

						_box$1.expandByPoint( _boxMorphTargets.min );
						_box$1.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$1.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	}

	computeTangents() {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const indices = index.array;
		const positions = attributes.position.array;
		const normals = attributes.normal.array;
		const uvs = attributes.uv.array;

		const nVertices = positions.length / 3;

		if ( attributes.tangent === undefined ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		const tangents = attributes.tangent.array;

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < nVertices; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: indices.length
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					indices[ j + 0 ],
					indices[ j + 1 ],
					indices[ j + 2 ]
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4 ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( indices[ j + 0 ] );
				handleVertex( indices[ j + 1 ] );
				handleVertex( indices[ j + 2 ] );

			}

		}

	}

	computeVertexNormals() {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	}

	merge( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) {

			offset = 0;

			console.warn(
				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			);

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			const attribute1 = attributes[ key ];
			const attributeArray1 = attribute1.array;

			const attribute2 = geometry.attributes[ key ];
			const attributeArray2 = attribute2.array;

			const attributeOffset = attribute2.itemSize * offset;
			const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	}

	normalizeNormals() {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	}

	toNonIndexed() {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					index = indices[ i ] * attribute.data.stride + attribute.offset;

				} else {

					index = indices[ i ] * itemSize;

				}

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	}

	clone() {

		 return new this.constructor().copy( this );

	}

	copy( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		// geometry generator parameters

		if ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

BufferGeometry.prototype.isBufferGeometry = true;

const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
const _ray$2 = /*@__PURE__*/ new Ray();
const _sphere$3 = /*@__PURE__*/ new Sphere();

const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();

const _tempA = /*@__PURE__*/ new Vector3();
const _tempB = /*@__PURE__*/ new Vector3();
const _tempC = /*@__PURE__*/ new Vector3();

const _morphA = /*@__PURE__*/ new Vector3();
const _morphB = /*@__PURE__*/ new Vector3();
const _morphC = /*@__PURE__*/ new Vector3();

const _uvA$1 = /*@__PURE__*/ new Vector2();
const _uvB$1 = /*@__PURE__*/ new Vector2();
const _uvC$1 = /*@__PURE__*/ new Vector2();

const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

class Mesh extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		super();

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source ) {

		super.copy( source );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$3.copy( geometry.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		//

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		let intersection;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const position = geometry.attributes.position;
			const morphPosition = geometry.morphAttributes.position;
			const morphTargetsRelative = geometry.morphTargetsRelative;
			const uv = geometry.attributes.uv;
			const uv2 = geometry.attributes.uv2;
			const groups = geometry.groups;
			const drawRange = geometry.drawRange;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = index.getX( j );
							const b = index.getX( j + 1 );
							const c = index.getX( j + 2 );

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = index.getX( i );
						const b = index.getX( i + 1 );
						const c = index.getX( i + 2 );

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = j;
							const b = j + 1;
							const c = j + 2;

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = i;
						const b = i + 1;
						const c = i + 2;

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	}

}

Mesh.prototype.isMesh = true;

function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	_vA$1.fromBufferAttribute( position, a );
	_vB$1.fromBufferAttribute( position, b );
	_vC$1.fromBufferAttribute( position, c );

	const morphInfluences = object.morphTargetInfluences;

	if ( morphPosition && morphInfluences ) {

		_morphA.set( 0, 0, 0 );
		_morphB.set( 0, 0, 0 );
		_morphC.set( 0, 0, 0 );

		for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

			const influence = morphInfluences[ i ];
			const morphAttribute = morphPosition[ i ];

			if ( influence === 0 ) continue;

			_tempA.fromBufferAttribute( morphAttribute, a );
			_tempB.fromBufferAttribute( morphAttribute, b );
			_tempC.fromBufferAttribute( morphAttribute, c );

			if ( morphTargetsRelative ) {

				_morphA.addScaledVector( _tempA, influence );
				_morphB.addScaledVector( _tempB, influence );
				_morphC.addScaledVector( _tempC, influence );

			} else {

				_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
				_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
				_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );

			}

		}

		_vA$1.add( _morphA );
		_vB$1.add( _morphB );
		_vC$1.add( _morphC );

	}

	if ( object.isSkinnedMesh ) {

		object.boneTransform( a, _vA$1 );
		object.boneTransform( b, _vB$1 );
		object.boneTransform( c, _vC$1 );

	}

	const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA$1.fromBufferAttribute( uv, a );
			_uvB$1.fromBufferAttribute( uv, b );
			_uvC$1.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		if ( uv2 ) {

			_uvA$1.fromBufferAttribute( uv2, a );
			_uvB$1.fromBufferAttribute( uv2, b );
			_uvC$1.fromBufferAttribute( uv2, c );

			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;

	}

	return intersection;

}

class BoxGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	static fromJSON( data ) {

		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>
 * }
 */

class ShaderMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		this.glslVersion = null;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	copy( source ) {

		super.copy( source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	}

}

ShaderMaterial.prototype.isShaderMaterial = true;

class Camera extends Object3D {

	constructor() {

		super();

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		super.updateWorldMatrix( updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

Camera.prototype.isCamera = true;

class PerspectiveCamera extends Camera {

	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		super();

		this.type = 'PerspectiveCamera';

		this.fov = fov;
		this.zoom = 1;

		this.near = near;
		this.far = far;
		this.focus = 10;

		this.aspect = aspect;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	}

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	}

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength() {

		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	}

	getEffectiveFOV() {

		return RAD2DEG * 2 * Math.atan(
			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

	}

	getFilmWidth() {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	}

	getFilmHeight() {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const near = this.near;
		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = - 0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

}

PerspectiveCamera.prototype.isPerspectiveCamera = true;

const fov = 90, aspect = 1;

class CubeCamera extends Object3D {

	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

			console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
			return;

		}

		this.renderTarget = renderTarget;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

	}

	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const renderTarget = this.renderTarget;

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentXrEnabled = renderer.xr.enabled;
		const currentRenderTarget = renderer.getRenderTarget();

		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0 );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1 );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2 );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3 );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4 );
		renderer.render( scene, cameraPZ );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5 );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget );

		renderer.xr.enabled = currentXrEnabled;

	}

}

class CubeTexture extends Texture {

	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.flipY = false;

	}

	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

CubeTexture.prototype.isCubeTexture = true;

class WebGLCubeRenderTarget extends WebGLRenderTarget {

	constructor( size, options, dummy ) {

		if ( Number.isInteger( options ) ) {

			console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

			options = dummy;

		}

		super( size, size, options );

		options = options || {};

		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

		this.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
		this.texture.isRenderTargetTexture = true;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.texture._needsFlipEnvMap = false;

	}

	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.format = RGBAFormat; // see #18859
		this.texture.encoding = texture.encoding;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new BoxGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	clear( renderer, color, depth, stencil ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

class Plane {

	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	}

	intersectLine( line, target ) {

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( direction ).multiplyScalar( t ).add( line.start );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

Plane.prototype.isPlane = true;

const _sphere$2 = /*@__PURE__*/ new Sphere();
const _vector$7 = /*@__PURE__*/ new Vector3();

class Frustum {

	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	}

	intersectsObject( object ) {

		const geometry = object.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSprite( sprite ) {

		_sphere$2.center.set( 0, 0, 0 );
		_sphere$2.radius = 0.7071067811865476;
		_sphere$2.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

function WebGLAnimation() {

	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;

	function onAnimationFrame( time, frame ) {

		animationLoop( time, frame );

		requestId = context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			requestId = context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			context.cancelAnimationFrame( requestId );

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

function WebGLAttributes( gl, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	const buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		const array = attribute.array;
		const usage = attribute.usage;

		const buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		let type = 5126;

		if ( array instanceof Float32Array ) {

			type = 5126;

		} else if ( array instanceof Float64Array ) {

			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				if ( isWebGL2 ) {

					type = 5131;

				} else {

					console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

				}

			} else {

				type = 5123;

			}

		} else if ( array instanceof Int16Array ) {

			type = 5122;

		} else if ( array instanceof Uint32Array ) {

			type = 5125;

		} else if ( array instanceof Int32Array ) {

			type = 5124;

		} else if ( array instanceof Int8Array ) {

			type = 5120;

		} else if ( array instanceof Uint8Array ) {

			type = 5121;

		} else if ( array instanceof Uint8ClampedArray ) {

			type = 5121;

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		const array = attribute.array;
		const updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			if ( isWebGL2 ) {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array, updateRange.offset, updateRange.count );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			}

			updateRange.count = - 1; // reset range

		}

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isGLBufferAttribute ) {

			const cached = buffers.get( attribute );

			if ( ! cached || cached.version < attribute.version ) {

				buffers.set( attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				} );

			}

			return;

		}

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

class PlaneGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();
		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

	}

}

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";

var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	alphatest_pars_fragment: alphatest_pars_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normal_pars_fragment: normal_pars_fragment,
	normal_pars_vertex: normal_pars_vertex,
	normal_vertex: normal_vertex,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	output_fragment: output_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmission_fragment: transmission_fragment,
	transmission_pars_fragment: transmission_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	background_vert: vertex$g,
	background_frag: fragment$g,
	cube_vert: vertex$f,
	cube_frag: fragment$f,
	depth_vert: vertex$e,
	depth_frag: fragment$e,
	distanceRGBA_vert: vertex$d,
	distanceRGBA_frag: fragment$d,
	equirect_vert: vertex$c,
	equirect_frag: fragment$c,
	linedashed_vert: vertex$b,
	linedashed_frag: fragment$b,
	meshbasic_vert: vertex$a,
	meshbasic_frag: fragment$a,
	meshlambert_vert: vertex$9,
	meshlambert_frag: fragment$9,
	meshmatcap_vert: vertex$8,
	meshmatcap_frag: fragment$8,
	meshnormal_vert: vertex$7,
	meshnormal_frag: fragment$7,
	meshphong_vert: vertex$6,
	meshphong_frag: fragment$6,
	meshphysical_vert: vertex$5,
	meshphysical_frag: fragment$5,
	meshtoon_vert: vertex$4,
	meshtoon_frag: fragment$4,
	points_vert: vertex$3,
	points_frag: fragment$3,
	shadow_vert: vertex$2,
	shadow_frag: fragment$2,
	sprite_vert: vertex$1,
	sprite_frag: fragment$1
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {

	common: {

		diffuse: { value: new Color( 0xffffff ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: new Matrix3() },
		uv2Transform: { value: new Matrix3() },

		alphaMap: { value: null },
		alphaTest: { value: 0 }

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 }, // basic, lambert, phong
		ior: { value: 1.5 }, // standard, physical
		refractionRatio: { value: 0.98 },
		maxMipLevel: { value: 0 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaTest: { value: 0 },
		uvTransform: { value: new Matrix3() }

	},

	sprite: {

		diffuse: { value: new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		center: { value: new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaTest: { value: 0 },
		uvTransform: { value: new Matrix3() }

	}

};

const ShaderLib = {

	basic: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.meshnormal_vert,
		fragmentShader: ShaderChunk.meshnormal_frag

	},

	sprite: {

		uniforms: mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: new Matrix3() },
			t2D: { value: null },
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: mergeUniforms( [
			UniformsLib.envmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
			clearcoatNormalMap: { value: null },
			sheen: { value: 0 },
			sheenColor: { value: new Color( 0x000000 ) },
			sheenColorMap: { value: null },
			sheenRoughness: { value: 0 },
			sheenRoughnessMap: { value: null },
			transmission: { value: 0 },
			transmissionMap: { value: null },
			transmissionSamplerSize: { value: new Vector2() },
			transmissionSamplerMap: { value: null },
			thickness: { value: 0 },
			thicknessMap: { value: null },
			attenuationDistance: { value: 0 },
			attenuationColor: { value: new Color( 0x000000 ) },
			specularIntensity: { value: 0 },
			specularIntensityMap: { value: null },
			specularColor: { value: new Color( 1, 1, 1 ) },
			specularColorMap: { value: null },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

function WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {

	const clearColor = new Color( 0x000000 );
	let clearAlpha = 0;

	let planeMesh;
	let boxMesh;

	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;

	function render( renderList, scene ) {

		let forceClear = false;
		let background = scene.isScene === true ? scene.background : null;

		if ( background && background.isTexture ) {

			background = cubemaps.get( background );

		}

		// Ignore background in AR
		// TODO: Reconsider this.

		const xr = renderer.xr;
		const session = xr.getSession && xr.getSession();

		if ( session && session.environmentBlendMode === 'additive' ) {

			background = null;

		}

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// enable code injection for non-built-in material
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneGeometry( 2, 2 ),
					new ShaderMaterial( {
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// enable code injection for non-built-in material
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}


			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha = 1 ) {

			clearColor.set( color );
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}

function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

	const maxVertexAttributes = gl.getParameter( 34921 );

	const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
	const vaoAvailable = capabilities.isWebGL2 || extension !== null;

	const bindingStates = {};

	const defaultState = createBindingState( null );
	let currentState = defaultState;

	function setup( object, material, program, geometry, index ) {

		let updateBuffers = false;

		if ( vaoAvailable ) {

			const state = getBindingState( geometry, program, material );

			if ( currentState !== state ) {

				currentState = state;
				bindVertexArrayObject( currentState.object );

			}

			updateBuffers = needsUpdate( geometry, index );

			if ( updateBuffers ) saveCache( geometry, index );

		} else {

			const wireframe = ( material.wireframe === true );

			if ( currentState.geometry !== geometry.id ||
				currentState.program !== program.id ||
				currentState.wireframe !== wireframe ) {

				currentState.geometry = geometry.id;
				currentState.program = program.id;
				currentState.wireframe = wireframe;

				updateBuffers = true;

			}

		}

		if ( object.isInstancedMesh === true ) {

			updateBuffers = true;

		}

		if ( index !== null ) {

			attributes.update( index, 34963 );

		}

		if ( updateBuffers ) {

			setupVertexAttributes( object, material, program, geometry );

			if ( index !== null ) {

				gl.bindBuffer( 34963, attributes.get( index ).buffer );

			}

		}

	}

	function createVertexArrayObject() {

		if ( capabilities.isWebGL2 ) return gl.createVertexArray();

		return extension.createVertexArrayOES();

	}

	function bindVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

		return extension.bindVertexArrayOES( vao );

	}

	function deleteVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

		return extension.deleteVertexArrayOES( vao );

	}

	function getBindingState( geometry, program, material ) {

		const wireframe = ( material.wireframe === true );

		let programMap = bindingStates[ geometry.id ];

		if ( programMap === undefined ) {

			programMap = {};
			bindingStates[ geometry.id ] = programMap;

		}

		let stateMap = programMap[ program.id ];

		if ( stateMap === undefined ) {

			stateMap = {};
			programMap[ program.id ] = stateMap;

		}

		let state = stateMap[ wireframe ];

		if ( state === undefined ) {

			state = createBindingState( createVertexArrayObject() );
			stateMap[ wireframe ] = state;

		}

		return state;

	}

	function createBindingState( vao ) {

		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];

		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			newAttributes[ i ] = 0;
			enabledAttributes[ i ] = 0;
			attributeDivisors[ i ] = 0;

		}

		return {

			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,

			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null

		};

	}

	function needsUpdate( geometry, index ) {

		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;

		let attributesNum = 0;

		for ( const key in geometryAttributes ) {

			const cachedAttribute = cachedAttributes[ key ];
			const geometryAttribute = geometryAttributes[ key ];

			if ( cachedAttribute === undefined ) return true;

			if ( cachedAttribute.attribute !== geometryAttribute ) return true;

			if ( cachedAttribute.data !== geometryAttribute.data ) return true;

			attributesNum ++;

		}

		if ( currentState.attributesNum !== attributesNum ) return true;

		if ( currentState.index !== index ) return true;

		return false;

	}

	function saveCache( geometry, index ) {

		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			const data = {};
			data.attribute = attribute;

			if ( attribute.data ) {

				data.data = attribute.data;

			}

			cache[ key ] = data;

			attributesNum ++;

		}

		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;

		currentState.index = index;

	}

	function initAttributes() {

		const newAttributes = currentState.newAttributes;

		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;

		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

		if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

			gl.vertexAttribIPointer( index, size, type, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function setupVertexAttributes( object, material, program, geometry ) {

		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		}

		initAttributes();

		const geometryAttributes = geometry.attributes;

		const programAttributes = program.getAttributes();

		const materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( geometryAttribute !== undefined ) {

					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;

					const attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;

						if ( data && data.isInstancedInterleavedBuffer ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( 34962, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								stride * bytesPerElement,
								( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement
							);

						}

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( 34962, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								size * bytesPerElement,
								( size / programAttribute.locationSize ) * i * bytesPerElement
							);

						}

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					const value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								gl.vertexAttrib2fv( programAttribute.location, value );
								break;

							case 3:
								gl.vertexAttrib3fv( programAttribute.location, value );
								break;

							case 4:
								gl.vertexAttrib4fv( programAttribute.location, value );
								break;

							default:
								gl.vertexAttrib1fv( programAttribute.location, value );

						}

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	function dispose() {

		reset();

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometryId ];

		}

	}

	function releaseStatesOfGeometry( geometry ) {

		if ( bindingStates[ geometry.id ] === undefined ) return;

		const programMap = bindingStates[ geometry.id ];

		for ( const programId in programMap ) {

			const stateMap = programMap[ programId ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ programId ];

		}

		delete bindingStates[ geometry.id ];

	}

	function releaseStatesOfProgram( program ) {

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			if ( programMap[ program.id ] === undefined ) continue;

			const stateMap = programMap[ program.id ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ program.id ];

		}

	}

	function reset() {

		resetDefaultState();

		if ( currentState === defaultState ) return;

		currentState = defaultState;
		bindVertexArrayObject( currentState.object );

	}

	// for backward-compatilibity

	function resetDefaultState() {

		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;

	}

	return {

		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes

	};

}

function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawArraysInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawArraysInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLCapabilities( gl, extensions, parameters ) {

	let maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	/* eslint-disable no-undef */
	const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
		( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
	/* eslint-enable no-undef */

	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	const maxTextures = gl.getParameter( 34930 );
	const maxVertexTextures = gl.getParameter( 35660 );
	const maxTextureSize = gl.getParameter( 3379 );
	const maxCubemapSize = gl.getParameter( 34076 );

	const maxAttributes = gl.getParameter( 34921 );
	const maxVertexUniforms = gl.getParameter( 36347 );
	const maxVaryings = gl.getParameter( 36348 );
	const maxFragmentUniforms = gl.getParameter( 36349 );

	const vertexTextures = maxVertexTextures > 0;
	const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
	const floatVertexTextures = vertexTextures && floatFragmentTextures;

	const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

	return {

		isWebGL2: isWebGL2,

		drawBuffers: drawBuffers,

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,

		maxSamples: maxSamples

	};

}

function WebGLClipping( properties ) {

	const scope = this;

	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;

	const plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping, camera ) {

		const enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function ( material, camera, useCache ) {

		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;

		const materialProperties = properties.get( material );

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;

			let dstArray = materialProperties.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			for ( let i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

function WebGLCubeMaps( renderer ) {

	let cubemaps = new WeakMap();

	function mapTextureMapping( texture, mapping ) {

		if ( mapping === EquirectangularReflectionMapping ) {

			texture.mapping = CubeReflectionMapping;

		} else if ( mapping === EquirectangularRefractionMapping ) {

			texture.mapping = CubeRefractionMapping;

		}

		return texture;

	}

	function get( texture ) {

		if ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {

			const mapping = texture.mapping;

			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

				if ( cubemaps.has( texture ) ) {

					const cubemap = cubemaps.get( texture ).texture;
					return mapTextureMapping( cubemap, texture.mapping );

				} else {

					const image = texture.image;

					if ( image && image.height > 0 ) {

						const currentRenderTarget = renderer.getRenderTarget();

						const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
						renderTarget.fromEquirectangularTexture( renderer, texture );
						cubemaps.set( texture, renderTarget );

						renderer.setRenderTarget( currentRenderTarget );

						texture.addEventListener( 'dispose', onTextureDispose );

						return mapTextureMapping( renderTarget.texture, texture.mapping );

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemap = cubemaps.get( texture );

		if ( cubemap !== undefined ) {

			cubemaps.delete( texture );
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

class OrthographicCamera extends Camera {

	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		super();

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

OrthographicCamera.prototype.isOrthographicCamera = true;

class RawShaderMaterial extends ShaderMaterial {

	constructor( parameters ) {

		super( parameters );

		this.type = 'RawShaderMaterial';

	}

}

RawShaderMaterial.prototype.isRawShaderMaterial = true;

const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow( 2, LOD_MAX );

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const ENCODINGS = {
	[ LinearEncoding ]: 0,
	[ sRGBEncoding ]: 1,
	[ RGBEEncoding ]: 2,
	[ RGBM7Encoding ]: 3,
	[ RGBM16Encoding ]: 4,
	[ RGBDEncoding ]: 5,
	[ GammaEncoding ]: 6
};

const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3( 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._blurMaterial = _getBlurShader( MAX_SAMPLES );
		this._equirectShader = null;
		this._cubemapShader = null;

		this._compileMaterial( this._blurMaterial );

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = this._allocateTargets();

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );
		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular( equirectangular ) {

		return this._fromTexture( equirectangular );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap( cubemap ) {

		return this._fromTexture( cubemap );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {

		if ( this._cubemapShader === null ) {

			this._cubemapShader = _getCubemapShader();
			this._compileMaterial( this._cubemapShader );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {

		if ( this._equirectShader === null ) {

			this._equirectShader = _getEquirectShader();
			this._compileMaterial( this._equirectShader );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._blurMaterial.dispose();

		if ( this._cubemapShader !== null ) this._cubemapShader.dispose();
		if ( this._equirectShader !== null ) this._equirectShader.dispose();

		for ( let i = 0; i < _lodPlanes.length; i ++ ) {

			_lodPlanes[ i ].dispose();

		}

	}

	// private interface

	_cleanup( outputTarget ) {

		this._pingPongRenderTarget.dispose();
		this._renderer.setRenderTarget( _oldTarget );
		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture ) {

		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = this._allocateTargets( texture );
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets( texture ) { // warning: null texture is valid

		const params = {
			magFilter: NearestFilter,
			minFilter: NearestFilter,
			generateMipmaps: false,
			type: UnsignedByteType,
			format: RGBEFormat,
			encoding: _isLDR( texture ) ? texture.encoding : RGBEEncoding,
			depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( params );
		cubeUVRenderTarget.depthBuffer = texture ? false : true;
		this._pingPongRenderTarget = _createRenderTarget( params );
		return cubeUVRenderTarget;

	}

	_compileMaterial( material ) {

		const tmpMesh = new Mesh( _lodPlanes[ 0 ], material );
		this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;
		const outputEncoding = renderer.outputEncoding;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor( _clearColor );

		renderer.toneMapping = NoToneMapping;
		renderer.outputEncoding = LinearEncoding;
		renderer.autoClear = false;

		const backgroundMaterial = new MeshBasicMaterial( {
			name: 'PMREM.Background',
			side: BackSide,
			depthWrite: false,
			depthTest: false,
		} );

		const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

		let useSolidColor = false;
		const background = scene.background;

		if ( background ) {

			if ( background.isColor ) {

				backgroundMaterial.color.copy( background );
				scene.background = null;
				useSolidColor = true;

			}

		} else {

			backgroundMaterial.color.copy( _clearColor );
			useSolidColor = true;

		}

		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;
			if ( col == 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col == 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			_setViewport( cubeUVRenderTarget,
				col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );
			renderer.setRenderTarget( cubeUVRenderTarget );

			if ( useSolidColor ) {

				renderer.render( backgroundBox, cubeCamera );

			}

			renderer.render( scene, cubeCamera );

		}

		backgroundBox.geometry.dispose();
		backgroundBox.material.dispose();

		renderer.toneMapping = toneMapping;
		renderer.outputEncoding = outputEncoding;
		renderer.autoClear = originalAutoClear;
		scene.background = background;

	}

	_setEncoding( uniform, texture ) {

		if ( this._renderer.capabilities.isWebGL2 === true && texture.format === RGBAFormat && texture.type === UnsignedByteType && texture.encoding === sRGBEncoding ) {

			uniform.value = ENCODINGS[ LinearEncoding ];

		} else {

			uniform.value = ENCODINGS[ texture.encoding ];

		}

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

		if ( isCubeTexture ) {

			if ( this._cubemapShader == null ) {

				this._cubemapShader = _getCubemapShader();

			}

		} else {

			if ( this._equirectShader == null ) {

				this._equirectShader = _getEquirectShader();

			}

		}

		const material = isCubeTexture ? this._cubemapShader : this._equirectShader;
		const mesh = new Mesh( _lodPlanes[ 0 ], material );

		const uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		if ( ! isCubeTexture ) {

			uniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );

		}

		this._setEncoding( uniforms[ 'inputEncoding' ], texture );
		this._setEncoding( uniforms[ 'outputEncoding' ], cubeUVRenderTarget.texture );

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;

		for ( let i = 1; i < TOTAL_LODS; i ++ ) {

			const sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = new Mesh( _lodPlanes[ lodOut ], blurMaterial );
		const blurUniforms = blurMaterial.uniforms;

		const pixels = _sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i == 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;

		this._setEncoding( blurUniforms[ 'inputEncoding' ], targetIn.texture );
		this._setEncoding( blurUniforms[ 'outputEncoding' ], targetIn.texture );

		const outputSize = _sizeLods[ lodOut ];
		const x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );
		const y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}

function _isLDR( texture ) {

	if ( texture === undefined || texture.type !== UnsignedByteType ) return false;

	return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;

}

function _createPlanes() {

	const _lodPlanes = [];
	const _sizeLods = [];
	const _sigmas = [];

	let lod = LOD_MAX;

	for ( let i = 0; i < TOTAL_LODS; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		_sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > LOD_MAX - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];

		} else if ( i == 0 ) {

			sigma = 0;

		}

		_sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 1 );
		const min = - texelSize / 2;
		const max = 1 + texelSize / 2;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			const fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		_lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { _lodPlanes, _sizeLods, _sigmas };

}

function _createRenderTarget( params ) {

	const cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getBlurShader( maxSamples ) {

	const weights = new Float32Array( maxSamples );
	const poleAxis = new Vector3( 0, 1, 0 );
	const shaderMaterial = new RawShaderMaterial( {

		name: 'SphericalGaussianBlur',

		defines: { 'n': maxSamples },

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${ _getEncodings() }

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getEquirectShader() {

	const texelSize = new Vector2( 1, 1 );
	const shaderMaterial = new RawShaderMaterial( {

		name: 'EquirectangularToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'texelSize': { value: texelSize },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${ _getEncodings() }

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getCubemapShader() {

	const shaderMaterial = new RawShaderMaterial( {

		name: 'CubemapToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${ _getEncodings() }

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getCommonVertexShader() {

	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

}

function _getEncodings() {

	return /* glsl */`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;

}

function WebGLCubeUVMaps( renderer ) {

	let cubeUVmaps = new WeakMap();

	let pmremGenerator = null;

	function get( texture ) {

		if ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {

			const mapping = texture.mapping;

			const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
			const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

			if ( isEquirectMap || isCubeMap ) {

				// equirect/cube map to cubeUV conversion

				if ( cubeUVmaps.has( texture ) ) {

					return cubeUVmaps.get( texture ).texture;

				} else {

					const image = texture.image;

					if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

						const currentRenderTarget = renderer.getRenderTarget();

						if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

						const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
						cubeUVmaps.set( texture, renderTarget );

						renderer.setRenderTarget( currentRenderTarget );

						texture.addEventListener( 'dispose', onTextureDispose );

						return renderTarget.texture;

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function isCubeTextureComplete( image ) {

		let count = 0;
		const length = 6;

		for ( let i = 0; i < length; i ++ ) {

			if ( image[ i ] !== undefined ) count ++;

		}

		return count === length;


	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemapUV = cubeUVmaps.get( texture );

		if ( cubemapUV !== undefined ) {

			cubeUVmaps.delete( texture );
			cubemapUV.dispose();

		}

	}

	function dispose() {

		cubeUVmaps = new WeakMap();

		if ( pmremGenerator !== null ) {

			pmremGenerator.dispose();
			pmremGenerator = null;

		}

	}

	return {
		get: get,
		dispose: dispose
	};

}

function WebGLExtensions( gl ) {

	const extensions = {};

	function getExtension( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		let extension;

		switch ( name ) {

			case 'WEBGL_depth_texture':
				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		extensions[ name ] = extension;

		return extension;

	}

	return {

		has: function ( name ) {

			return getExtension( name ) !== null;

		},

		init: function ( capabilities ) {

			if ( capabilities.isWebGL2 ) {

				getExtension( 'EXT_color_buffer_float' );

			} else {

				getExtension( 'WEBGL_depth_texture' );
				getExtension( 'OES_texture_float' );
				getExtension( 'OES_texture_half_float' );
				getExtension( 'OES_texture_half_float_linear' );
				getExtension( 'OES_standard_derivatives' );
				getExtension( 'OES_element_index_uint' );
				getExtension( 'OES_vertex_array_object' );
				getExtension( 'ANGLE_instanced_arrays' );

			}

			getExtension( 'OES_texture_float_linear' );
			getExtension( 'EXT_color_buffer_half_float' );

		},

		get: function ( name ) {

			const extension = getExtension( name );

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			return extension;

		}

	};

}

function WebGLGeometries( gl, attributes, info, bindingStates ) {

	const geometries = {};
	const wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		const geometry = event.target;

		if ( geometry.index !== null ) {

			attributes.remove( geometry.index );

		}

		for ( const name in geometry.attributes ) {

			attributes.remove( geometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		const attribute = wireframeAttributes.get( geometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( geometry );

		}

		bindingStates.releaseStatesOfGeometry( geometry );

		if ( geometry.isInstancedBufferGeometry === true ) {

			delete geometry._maxInstanceCount;

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		if ( geometries[ geometry.id ] === true ) return geometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		geometries[ geometry.id ] = true;

		info.memory.geometries ++;

		return geometry;

	}

	function update( geometry ) {

		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for ( const name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], 34962 );

		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], 34962 );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;
			version = geometryIndex.version;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			const array = geometryPosition.array;
			version = geometryPosition.version;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		const attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		const currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			const geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	let type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawElementsInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawElementsInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case 4:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case 1:
				render.lines += instanceCount * ( count / 2 );
				break;

			case 3:
				render.lines += instanceCount * ( count - 1 );
				break;

			case 2:
				render.lines += instanceCount * count;
				break;

			case 0:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

class DataTexture2DArray extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

		this.needsUpdate = true;

	}

}

DataTexture2DArray.prototype.isDataTexture2DArray = true;

function numericalSort( a, b ) {

	return a[ 0 ] - b[ 0 ];

}

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function denormalize( morph, attribute ) {

	let denominator = 1;
	const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;

	if ( array instanceof Int8Array ) denominator = 127;
	else if ( array instanceof Int16Array ) denominator = 32767;
	else if ( array instanceof Int32Array ) denominator = 2147483647;
	else console.error( 'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array );

	morph.divideScalar( denominator );

}

function WebGLMorphtargets( gl, capabilities, textures ) {

	const influencesList = {};
	const morphInfluences = new Float32Array( 8 );
	const morphTextures = new WeakMap();
	const morph = new Vector3();

	const workInfluences = [];

	for ( let i = 0; i < 8; i ++ ) {

		workInfluences[ i ] = [ i, 0 ];

	}

	function update( object, geometry, material, program ) {

		const objectInfluences = object.morphTargetInfluences;

		if ( capabilities.isWebGL2 === true ) {

			// instead of using attributes, the WebGL 2 code path encodes morph targets
			// into an array of data textures. Each layer represents a single morph target.

			const numberOfMorphTargets = geometry.morphAttributes.position.length;

			let entry = morphTextures.get( geometry );

			if ( entry === undefined || entry.count !== numberOfMorphTargets ) {

				if ( entry !== undefined ) entry.texture.dispose();

				const hasMorphNormals = geometry.morphAttributes.normal !== undefined;

				const morphTargets = geometry.morphAttributes.position;
				const morphNormals = geometry.morphAttributes.normal || [];

				const numberOfVertices = geometry.attributes.position.count;
				const numberOfVertexData = ( hasMorphNormals === true ) ? 2 : 1; // (v,n) vs. (v)

				let width = numberOfVertices * numberOfVertexData;
				let height = 1;

				if ( width > capabilities.maxTextureSize ) {

					height = Math.ceil( width / capabilities.maxTextureSize );
					width = capabilities.maxTextureSize;

				}

				const buffer = new Float32Array( width * height * 4 * numberOfMorphTargets );

				const texture = new DataTexture2DArray( buffer, width, height, numberOfMorphTargets );
				texture.format = RGBAFormat; // using RGBA since RGB might be emulated (and is thus slower)
				texture.type = FloatType;

				// fill buffer

				const vertexDataStride = numberOfVertexData * 4;

				for ( let i = 0; i < numberOfMorphTargets; i ++ ) {

					const morphTarget = morphTargets[ i ];
					const morphNormal = morphNormals[ i ];

					const offset = width * height * 4 * i;

					for ( let j = 0; j < morphTarget.count; j ++ ) {

						morph.fromBufferAttribute( morphTarget, j );

						if ( morphTarget.normalized === true ) denormalize( morph, morphTarget );

						const stride = j * vertexDataStride;

						buffer[ offset + stride + 0 ] = morph.x;
						buffer[ offset + stride + 1 ] = morph.y;
						buffer[ offset + stride + 2 ] = morph.z;
						buffer[ offset + stride + 3 ] = 0;

						if ( hasMorphNormals === true ) {

							morph.fromBufferAttribute( morphNormal, j );

							if ( morphNormal.normalized === true ) denormalize( morph, morphNormal );

							buffer[ offset + stride + 4 ] = morph.x;
							buffer[ offset + stride + 5 ] = morph.y;
							buffer[ offset + stride + 6 ] = morph.z;
							buffer[ offset + stride + 7 ] = 0;

						}

					}

				}

				entry = {
					count: numberOfMorphTargets,
					texture: texture,
					size: new Vector2( width, height )
				};

				morphTextures.set( geometry, entry );

			}

			//

			let morphInfluencesSum = 0;

			for ( let i = 0; i < objectInfluences.length; i ++ ) {

				morphInfluencesSum += objectInfluences[ i ];

			}

			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

			program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
			program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );


		} else {

			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length;

			let influences = influencesList[ geometry.id ];

			if ( influences === undefined || influences.length !== length ) {

				// initialise list

				influences = [];

				for ( let i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			// Collect influences

			for ( let i = 0; i < length; i ++ ) {

				const influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			for ( let i = 0; i < 8; i ++ ) {

				if ( i < length && influences[ i ][ 1 ] ) {

					workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
					workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

				} else {

					workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
					workInfluences[ i ][ 1 ] = 0;

				}

			}

			workInfluences.sort( numericalSort );

			const morphTargets = geometry.morphAttributes.position;
			const morphNormals = geometry.morphAttributes.normal;

			let morphInfluencesSum = 0;

			for ( let i = 0; i < 8; i ++ ) {

				const influence = workInfluences[ i ];
				const index = influence[ 0 ];
				const value = influence[ 1 ];

				if ( index !== Number.MAX_SAFE_INTEGER && value ) {

					if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

						geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

					}

					if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

						geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

					}

					morphInfluences[ i ] = value;
					morphInfluencesSum += value;

				} else {

					if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

						geometry.deleteAttribute( 'morphTarget' + i );

					}

					if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

						geometry.deleteAttribute( 'morphNormal' + i );

					}

					morphInfluences[ i ] = 0;

				}

			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

	}

	return {

		update: update

	};

}

function WebGLObjects( gl, geometries, attributes, info ) {

	let updateMap = new WeakMap();

	function update( object ) {

		const frame = info.render.frame;

		const geometry = object.geometry;
		const buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				object.addEventListener( 'dispose', onInstancedMeshDispose );

			}

			attributes.update( object.instanceMatrix, 34962 );

			if ( object.instanceColor !== null ) {

				attributes.update( object.instanceColor, 34962 );

			}

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	function onInstancedMeshDispose( event ) {

		const instancedMesh = event.target;

		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		attributes.remove( instancedMesh.instanceMatrix );

		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	}

	return {

		update: update,
		dispose: dispose

	};

}

class DataTexture3D extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super( null );

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

		this.needsUpdate = true;

	}

}

DataTexture3D.prototype.isDataTexture3D = true;

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array( 16 );
const mat3array = new Float32Array( 9 );
const mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	const firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	let r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( let i = 0; i !== n; ++ i ) {

		r[ i ] = textures.allocateTextureUnit();

	}

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single integer / boolean

function setValueV1i( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

// Single integer / boolean vector (from flat array)

function setValueV2i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4iv( this.addr, v );

	copyArray( cache, v );

}

// Single unsigned integer

function setValueV1ui( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Single unsigned integer vector (from flat array)

function setValueV2ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2uiv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3uiv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4uiv( this.addr, v );

	copyArray( cache, v );

}


// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTexture2D( v || emptyTexture, unit );

}

function setValueT3D1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || emptyTexture3d, unit );

}

function setValueT6( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTextureCube( v || emptyCubeTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyTexture2dArray, unit );

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT
		case 0x8dc6: return setValueV2ui; // _VEC2
		case 0x8dc7: return setValueV3ui; // _VEC3
		case 0x8dc8: return setValueV4ui; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}


// Array of scalars

function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray( gl, v ) {

	const data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	const data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	const data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	const data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of integer / boolean

function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}

// Array of unsigned integer

function setValueV1uiArray( gl, v ) {

	gl.uniform1uiv( this.addr, v );

}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray( gl, v ) {

	gl.uniform2uiv( this.addr, v );

}

function setValueV3uiArray( gl, v ) {

	gl.uniform3uiv( this.addr, v );

}

function setValueV4uiArray( gl, v ) {

	gl.uniform4uiv( this.addr, v );

}


// Array of textures (2D / Cube)

function setValueT1Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x1405: return setValueV1uiArray; // UINT
		case 0x8dc6: return setValueV2uiArray; // _VEC2
		case 0x8dc7: return setValueV3uiArray; // _VEC3
		case 0x8dc8: return setValueV4uiArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

PureArrayUniform.prototype.updateCache = function ( data ) {

	const cache = this.cache;

	if ( data instanceof Float32Array && cache.length !== data.length ) {

		this.cache = new Float32Array( data.length );

	}

	copyArray( cache, data );

};

function StructuredUniform( id ) {

	this.id = id;

	this.seq = [];
	this.map = {};

}

StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

	const seq = this.seq;

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		u.setValue( gl, value[ u.id ], textures );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		const match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex;

		let id = match[ 1 ];
		const idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program ) {

	this.seq = [];
	this.map = {};

	const n = gl.getProgramParameter( program, 35718 );

	for ( let i = 0; i < n; ++ i ) {

		const info = gl.getActiveUniform( program, i ),
			addr = gl.getUniformLocation( program, info.name );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

	const u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, value, textures );

};

WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

	const v = object[ name ];

	if ( v !== undefined ) this.setValue( gl, name, v );

};


// Static interface

WebGLUniforms.upload = function ( gl, seq, values, textures ) {

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {

			// note: always updating when .needsUpdate is undefined
			u.setValue( gl, v.value, textures );

		}

	}

};

WebGLUniforms.seqWithValue = function ( seq, values ) {

	const r = [];

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		if ( u.id in values ) r.push( u );

	}

	return r;

};

function WebGLShader( gl, type, string ) {

	const shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

let programIdCount = 0;

function addLineNumbers( string ) {

	const lines = string.split( '\n' );

	for ( let i = 0; i < lines.length; i ++ ) {

		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	}

	return lines.join( '\n' );

}

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear', '( value )' ];
		case sRGBEncoding:
			return [ 'sRGB', '( value )' ];
		case RGBEEncoding:
			return [ 'RGBE', '( value )' ];
		case RGBM7Encoding:
			return [ 'RGBM', '( value, 7.0 )' ];
		case RGBM16Encoding:
			return [ 'RGBM', '( value, 16.0 )' ];
		case RGBDEncoding:
			return [ 'RGBD', '( value, 256.0 )' ];
		case GammaEncoding:
			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
		case LogLuvEncoding:
			return [ 'LogLuv', '( value )' ];
		default:
			console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
			return [ 'Linear', '( value )' ];

	}

}

function getShaderErrors( gl, shader, type ) {

	const status = gl.getShaderParameter( shader, 35713 );
	const errors = gl.getShaderInfoLog( shader ).trim();

	if ( status && errors === '' ) return '';

	// --enable-privileged-webgl-extension
	// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	return type.toUpperCase() + '\n\n' + errors + '\n\n' + addLineNumbers( gl.getShaderSource( shader ) );

}

function getTexelDecodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

}

function getTexelEncodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

}

function getToneMappingFunction( functionName, toneMapping ) {

	let toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			toneMappingName = 'Linear';

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateExtensions( parameters ) {

	const chunks = [
		( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	const chunks = [];

	for ( const name in defines ) {

		const value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	const attributes = {};

	const n = gl.getProgramParameter( program, 35721 );

	for ( let i = 0; i < n; i ++ ) {

		const info = gl.getActiveAttrib( program, i );
		const name = info.name;

		let locationSize = 1;
		if ( info.type === 35674 ) locationSize = 2;
		if ( info.type === 35675 ) locationSize = 3;
		if ( info.type === 35676 ) locationSize = 4;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = {
			type: info.type,
			location: gl.getAttribLocation( program, name ),
			locationSize: locationSize
		};

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

function includeReplacer( match, include ) {

	const string = ShaderChunk[ include ];

	if ( string === undefined ) {

		throw new Error( 'Can not resolve #include <' + include + '>' );

	}

	return resolveIncludes( string );

}

// Unroll Loops

const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string
		.replace( unrollLoopPattern, loopReplacer )
		.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

}

function deprecatedLoopReplacer( match, start, end, snippet ) {

	console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
	return loopReplacer( match, start, end, snippet );

}

function loopReplacer( match, start, end, snippet ) {

	let string = '';

	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

	if ( parameters.precision === 'highp' ) {

		precisionstring += '\n#define HIGH_PRECISION';

	} else if ( parameters.precision === 'mediump' ) {

		precisionstring += '\n#define MEDIUM_PRECISION';

	} else if ( parameters.precision === 'lowp' ) {

		precisionstring += '\n#define LOW_PRECISION';

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:
			case CubeUVRefractionMapping:

				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	// TODO Send this event to Three.js DevTools
	// console.log( 'WebGLProgram', cacheKey );

	const gl = renderer.getContext();

	const defines = parameters.defines;

	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;

	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	const envMapModeDefine = generateEnvMapModeDefine( parameters );
	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


	const gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

	const customDefines = generateDefines( defines );

	const program = gl.createProgram();

	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			customExtensions,
			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',

			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			( parameters.morphTargets && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE' : '',
			( parameters.morphTargets && parameters.isWebGL2 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			'	attribute mat4 instanceMatrix;',

			'#endif',

			'#ifdef USE_INSTANCING_COLOR',

			'	attribute vec3 instanceColor;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#if defined( USE_COLOR_ALPHA )',

			'	attribute vec4 color;',

			'#elif defined( USE_COLOR )',

			'	attribute vec3 color;',

			'#endif',

			'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.alphaTest ? '#define USE_ALPHATEST' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',
			parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',
			parameters.format === RGBFormat ? '#define OPAQUE' : '',

			ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
			parameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.specularColorMap ? getTexelDecodingFunction( 'specularColorMapTexelToLinear', parameters.specularColorMapEncoding ) : '',
			parameters.sheenColorMap ? getTexelDecodingFunction( 'sheenColorMapTexelToLinear', parameters.sheenColorMapEncoding ) : '',
			parameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

			parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';

		prefixVertex = [
			'precision mediump sampler2DArray;',
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#define varying in',
			( parameters.glslVersion === GLSL3 ) ? '' : 'out highp vec4 pc_fragColor;',
			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
	const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	// check for link errors
	if ( renderer.debug.checkShaderErrors ) {

		const programLog = gl.getProgramInfoLog( program ).trim();
		const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		let runnable = true;
		let haveDiagnostics = true;

		if ( gl.getProgramParameter( program, 35714 ) === false ) {

			runnable = false;

			const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
			const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

			console.error(
				'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
				'VALIDATE_STATUS ' + gl.getProgramParameter( program, 35715 ) + '\n\n' +
				'Program Info Log: ' + programLog + '\n' +
				vertexErrors + '\n' +
				fragmentErrors
			);

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

	}

	// Clean up

	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	let cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			cachedUniforms = new WebGLUniforms( gl, program );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	let cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function () {

		bindingStates.releaseStatesOfProgram( this );

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

	const programs = [];

	const isWebGL2 = capabilities.isWebGL2;
	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const floatVertexTextures = capabilities.floatVertexTextures;
	const maxVertexUniforms = capabilities.maxVertexUniforms;
	const vertexTextures = capabilities.vertexTextures;

	let precision = capabilities.precision;

	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	const parameterNames = [
		'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',
		'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',
		'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap',
		'objectSpaceNormalMap', 'tangentSpaceNormalMap',
		'clearcoat', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap',
		'displacementMap', 'specularMap', , 'roughnessMap', 'metalnessMap', 'gradientMap',
		'alphaMap', 'alphaTest', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',
		'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
		'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'morphTargetsCount', 'premultipliedAlpha',
		'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
		'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',
		'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
		'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'format',
		'specularIntensityMap', 'specularColorMap', 'specularColorMapEncoding',
		'transmission', 'transmissionMap', 'thicknessMap',
		'sheen', 'sheenColorMap', 'sheenColorMapEncoding', 'sheenRoughnessMap'
	];

	function getMaxBones( object ) {

		const skeleton = object.skeleton;
		const bones = skeleton.bones;

		if ( floatVertexTextures ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			const nVertexUniforms = maxVertexUniforms;
			const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			const maxBones = Math.min( nVertexMatrices, bones.length );

			if ( maxBones < bones.length ) {

				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				return 0;

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map ) {

		let encoding;

		if ( map && map.isTexture ) {

			encoding = map.encoding;

		} else if ( map && map.isWebGLRenderTarget ) {

			console.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.' );
			encoding = map.texture.encoding;

		} else {

			encoding = LinearEncoding;

		}

		if ( isWebGL2 && map && map.isTexture && map.format === RGBAFormat && map.type === UnsignedByteType && map.encoding === sRGBEncoding ) {

			encoding = LinearEncoding; // disable inline decode for sRGB textures in WebGL 2

		}

		return encoding;

	}

	function getParameters( material, lights, shadows, scene, object ) {

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;

		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );

		const shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		let vertexShader, fragmentShader;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];

			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;

		} else {

			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;

		}

		const currentRenderTarget = renderer.getRenderTarget();

		const useAlphaTest = material.alphaTest > 0;
		const useClearcoat = material.clearcoat > 0;

		const parameters = {

			isWebGL2: isWebGL2,

			shaderID: shaderID,
			shaderName: material.type,

			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,

			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,

			precision: precision,

			instancing: object.isInstancedMesh === true,
			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

			supportsVertexTextures: vertexTextures,
			outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map ),
			matcap: !! material.matcap,
			matcapEncoding: getTextureEncodingFromMap( material.matcap ),
			envMap: !! envMap,
			envMapMode: envMap && envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( envMap ),
			envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,

			clearcoat: useClearcoat,
			clearcoatMap: useClearcoat && !! material.clearcoatMap,
			clearcoatRoughnessMap: useClearcoat && !! material.clearcoatRoughnessMap,
			clearcoatNormalMap: useClearcoat && !! material.clearcoatNormalMap,

			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			specularIntensityMap: !! material.specularIntensityMap,
			specularColorMap: !! material.specularColorMap,
			specularColorMapEncoding: getTextureEncodingFromMap( material.specularColorMap ),

			alphaMap: !! material.alphaMap,
			alphaTest: useAlphaTest,

			gradientMap: !! material.gradientMap,

			sheen: material.sheen > 0,
			sheenColorMap: !! material.sheenColorMap,
			sheenColorMapEncoding: getTextureEncodingFromMap( material.sheenColorMap ),
			sheenRoughnessMap: !! material.sheenRoughnessMap,

			transmission: material.transmission > 0,
			transmissionMap: !! material.transmissionMap,
			thicknessMap: !! material.thicknessMap,

			combine: material.combine,

			vertexTangents: ( !! material.normalMap && !! object.geometry && !! object.geometry.attributes.tangent ),
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && !! object.geometry && !! object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || !! material.sheenColorMap || material.sheenRoughnessMap,
			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || material.transmission > 0 || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || !! material.sheen > 0 || !! material.sheenColorMap || !! material.sheenRoughnessMap ) && !! material.displacementMap,

			fog: !! fog,
			useFog: material.fog,
			fogExp2: ( fog && fog.isFogExp2 ),

			flatShading: !! material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: object.isSkinnedMesh === true && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: floatVertexTextures,

			morphTargets: !! object.geometry && !! object.geometry.morphAttributes.position,
			morphNormals: !! object.geometry && !! object.geometry.morphAttributes.normal,
			morphTargetsCount: ( !! object.geometry && !! object.geometry.morphAttributes.position ) ? object.geometry.morphAttributes.position.length : 0,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,

			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,

			format: material.format,
			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

			index0AttributeName: material.index0AttributeName,

			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
			rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

			customProgramCacheKey: material.customProgramCacheKey()

		};

		return parameters;

	}

	function getProgramCacheKey( parameters ) {

		const array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( hashString( parameters.fragmentShader ) );
			array.push( hashString( parameters.vertexShader ) );

		}

		if ( parameters.defines !== undefined ) {

			for ( const name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === false ) {

			for ( let i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( renderer.outputEncoding );
			array.push( renderer.gammaFactor );

		}

		array.push( parameters.customProgramCacheKey );

		return array.join();

	}

	function getUniforms( material ) {

		const shaderID = shaderIDs[ material.type ];
		let uniforms;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];
			uniforms = UniformsUtils.clone( shader.uniforms );

		} else {

			uniforms = material.uniforms;

		}

		return uniforms;

	}

	function acquireProgram( parameters, cacheKey ) {

		let program;

		// Check if code has been already compiled
		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			const preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
			programs.push( program );

		}

		return program;

	}

	function releaseProgram( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			const i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	}

	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs
	};

}

function WebGLProperties() {

	let properties = new WeakMap();

	function get( object ) {

		let map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.program !== b.program ) {

		return a.program.id - b.program.id;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList( properties ) {

	const renderItems = [];
	let renderItemsIndex = 0;

	const opaque = [];
	const transmissive = [];
	const transparent = [];

	const defaultProgram = { id: - 1 };

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transmissive.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		let renderItem = renderItems[ renderItemsIndex ];
		const materialProperties = properties.get( material );

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				program: materialProperties.program || defaultProgram,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.program = materialProperties.program || defaultProgram;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.push( renderItem );

		} else if ( material.transparent === true ) {

			transparent.push( renderItem );

		} else {

			opaque.push( renderItem );

		}

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.unshift( renderItem );

		} else if ( material.transparent === true ) {

			transparent.unshift( renderItem );

		} else {

			opaque.unshift( renderItem );

		}

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			const renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.program = null;
			renderItem.group = null;

		}

	}

	return {

		opaque: opaque,
		transmissive: transmissive,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists( properties ) {

	let lists = new WeakMap();

	function get( scene, renderCallDepth ) {

		let list;

		if ( lists.has( scene ) === false ) {

			list = new WebGLRenderList( properties );
			lists.set( scene, [ list ] );

		} else {

			if ( renderCallDepth >= lists.get( scene ).length ) {

				list = new WebGLRenderList( properties );
				lists.get( scene ).push( list );

			} else {

				list = lists.get( scene )[ renderCallDepth ];

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function UniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



let nextVersion = 0;

function shadowCastingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

}

function WebGLLights( extensions, capabilities ) {

	const cache = new UniformsCache();

	const shadowCache = ShadowUniformsCache();

	const state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadow: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: []

	};

	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();

	function setup( lights, physicallyCorrectLights ) {

		let r = 0, g = 0, b = 0;

		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;

		lights.sort( shadowCastingLightsFirst );

		// artist-friendly light intensity scaling factor
		const scaleFactor = ( physicallyCorrectLights !== true ) ? Math.PI : 1;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;

			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity * scaleFactor;
				g += color.g * intensity * scaleFactor;
				b += color.b * intensity * scaleFactor;

			} else if ( light.isLightProbe ) {

				for ( let j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

			} else if ( light.isDirectionalLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );

				uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
				uniforms.distance = distance;

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

					numSpotShadows ++;

				}

				state.spot[ spotLength ] = uniforms;

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = cache.get( light );

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = cache.get( light );

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		if ( rectAreaLength > 0 ) {

			if ( capabilities.isWebGL2 ) {

				// WebGL 2

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

			} else {

				// WebGL 1

				if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

				} else {

					console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

				}

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		const hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotShadowMatrix.length = numSpotShadows;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;

			state.version = nextVersion ++;

		}

	}

	function setupView( lights, camera ) {

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		const viewMatrix = camera.matrixWorldInverse;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			if ( light.isDirectionalLight ) {

				const uniforms = state.directional[ directionalLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = state.spot[ spotLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = state.rectArea[ rectAreaLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = state.point[ pointLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = state.hemi[ hemiLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				hemiLength ++;

			}

		}

	}

	return {
		setup: setup,
		setupView: setupView,
		state: state
	};

}

function WebGLRenderState( extensions, capabilities ) {

	const lights = new WebGLLights( extensions, capabilities );

	const lightsArray = [];
	const shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights( physicallyCorrectLights ) {

		lights.setup( lightsArray, physicallyCorrectLights );

	}

	function setupLightsView( camera ) {

		lights.setupView( lightsArray, camera );

	}

	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates( extensions, capabilities ) {

	let renderStates = new WeakMap();

	function get( scene, renderCallDepth = 0 ) {

		let renderState;

		if ( renderStates.has( scene ) === false ) {

			renderState = new WebGLRenderState( extensions, capabilities );
			renderStates.set( scene, [ renderState ] );

		} else {

			if ( renderCallDepth >= renderStates.get( scene ).length ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.get( scene ).push( renderState );

			} else {

				renderState = renderStates.get( scene )[ renderCallDepth ];

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

class MeshDepthMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.depthPacking = source.depthPacking;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	}

}

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

class MeshDistanceMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	}

}

MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

function WebGLShadowMap( _renderer, _objects, _capabilities ) {

	let _frustum = new Frustum();

	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
		_distanceMaterial = new MeshDistanceMaterial(),

		_materialCache = {},

		_maxTextureSize = _capabilities.maxTextureSize;

	const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

	const shadowMaterialVertical = new ShaderMaterial( {
		defines: {
			VSM_SAMPLES: 8
		},
		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vertex,
		fragmentShader: fragment

	} );

	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		'position',
		new BufferAttribute(
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	const scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		const currentRenderTarget = _renderer.getRenderTarget();
		const activeCubeFace = _renderer.getActiveCubeFace();
		const activeMipmapLevel = _renderer.getActiveMipmapLevel();

		const _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		for ( let i = 0, il = lights.length; i < il; i ++ ) {

			const light = lights[ i ];
			const shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			_shadowMapSize.copy( shadow.mapSize );

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

				if ( _shadowMapSize.x > _maxTextureSize ) {

					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > _maxTextureSize ) {

					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

				shadow.camera.updateProjectionMatrix();

			}

			if ( shadow.map === null ) {

				const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.camera.updateProjectionMatrix();

			}

			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();

			const viewportCount = shadow.getViewportCount();

			for ( let vp = 0; vp < viewportCount; vp ++ ) {

				const viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

			shadow.needsUpdate = false;

		}

		scope.needsUpdate = false;

		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		const geometry = _objects.update( fullScreenMesh );

		if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

			shadowMaterialVertical.needsUpdate = true;
			shadowMaterialHorizontal.needsUpdate = true;

		}

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.mapPass );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.map );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	}

	function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

		let result = null;

		const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

		if ( customMaterial !== undefined ) {

			result = customMaterial;

		} else {

			result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

		}

		if ( ( _renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 ) ||
			( material.displacementMap && material.displacementScale !== 0 ) ||
			( material.alphaMap && material.alphaTest > 0 ) ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			const keyA = result.uuid, keyB = material.uuid;

			let materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			let cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.alphaMap = material.alphaMap;
		result.alphaTest = material.alphaTest;

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.displacementMap = material.displacementMap;
		result.displacementScale = material.displacementScale;
		result.displacementBias = material.displacementBias;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				const geometry = _objects.update( object );
				const material = object.material;

				if ( Array.isArray( material ) ) {

					const groups = geometry.groups;

					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						const group = groups[ k ];
						const groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							const depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					const depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

}

function WebGLState( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function ColorBuffer() {

		let locked = false;

		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		let locked = false;

		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( 2929 );

				} else {

					disable( 2929 );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( 512 );
								break;

							case AlwaysDepth:

								gl.depthFunc( 519 );
								break;

							case LessDepth:

								gl.depthFunc( 513 );
								break;

							case LessEqualDepth:

								gl.depthFunc( 515 );
								break;

							case EqualDepth:

								gl.depthFunc( 514 );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( 518 );
								break;

							case GreaterDepth:

								gl.depthFunc( 516 );
								break;

							case NotEqualDepth:

								gl.depthFunc( 517 );
								break;

							default:

								gl.depthFunc( 515 );

						}

					} else {

						gl.depthFunc( 515 );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		let locked = false;

		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( 2960 );

					} else {

						disable( 2960 );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef !== stencilRef ||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail !== stencilFail ||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();

	let enabledCapabilities = {};

	let xrFramebuffer = null;
	let currentBoundFramebuffers = {};

	let currentProgram = null;

	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentPremultipledAlpha = false;

	let currentFlipSided = null;
	let currentCullFace = null;

	let currentLineWidth = null;

	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;

	const maxTextures = gl.getParameter( 35661 );

	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter( 7938 );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	let currentTextureSlot = null;
	let currentBoundTextures = {};

	const scissorParam = gl.getParameter( 3088 );
	const viewportParam = gl.getParameter( 2978 );

	const currentScissor = new Vector4().fromArray( scissorParam );
	const currentViewport = new Vector4().fromArray( viewportParam );

	function createTexture( type, target, count ) {

		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, 10241, 9728 );
		gl.texParameteri( type, 10240, 9728 );

		for ( let i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

		}

		return texture;

	}

	const emptyTextures = {};
	emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
	emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( 2929 );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( 2884 );

	setBlending( NoBlending );

	//

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function bindXRFramebuffer( framebuffer ) {

		if ( framebuffer !== xrFramebuffer ) {

			gl.bindFramebuffer( 36160, framebuffer );

			xrFramebuffer = framebuffer;

		}

	}

	function bindFramebuffer( target, framebuffer ) {

		if ( framebuffer === null && xrFramebuffer !== null ) framebuffer = xrFramebuffer; // use active XR framebuffer if available

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

			if ( isWebGL2 ) {

				// 36009 is equivalent to 36160

				if ( target === 36009 ) {

					currentBoundFramebuffers[ 36160 ] = framebuffer;

				}

				if ( target === 36160 ) {

					currentBoundFramebuffers[ 36009 ] = framebuffer;

				}

			}

			return true;

		}

		return false;

	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	const equationToGL = {
		[ AddEquation ]: 32774,
		[ SubtractEquation ]: 32778,
		[ ReverseSubtractEquation ]: 32779
	};

	if ( isWebGL2 ) {

		equationToGL[ MinEquation ] = 32775;
		equationToGL[ MaxEquation ] = 32776;

	} else {

		const extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			equationToGL[ MinEquation ] = extension.MIN_EXT;
			equationToGL[ MaxEquation ] = extension.MAX_EXT;

		}

	}

	const factorToGL = {
		[ ZeroFactor ]: 0,
		[ OneFactor ]: 1,
		[ SrcColorFactor ]: 768,
		[ SrcAlphaFactor ]: 770,
		[ SrcAlphaSaturateFactor ]: 776,
		[ DstColorFactor ]: 774,
		[ DstAlphaFactor ]: 772,
		[ OneMinusSrcColorFactor ]: 769,
		[ OneMinusSrcAlphaFactor ]: 771,
		[ OneMinusDstColorFactor ]: 775,
		[ OneMinusDstAlphaFactor ]: 773
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled === true ) {

				disable( 3042 );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( currentBlendingEnabled === false ) {

			enable( 3042 );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( 32774 );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 1, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 1, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 0, 769, 771 );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( 0, 768, 0, 770 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 770, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 770, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFunc( 0, 769 );
							break;

						case MultiplyBlending:
							gl.blendFunc( 0, 768 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = null;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( 2884 )
			: enable( 2884 );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true
			? enable( 32926 )
			: disable( 32926 );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( 2304 );

			} else {

				gl.frontFace( 2305 );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( 2884 );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( 1029 );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( 1028 );

				} else {

					gl.cullFace( 1032 );

				}

			}

		} else {

			disable( 2884 );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( 32823 );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( 32823 );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( 3089 );

		} else {

			disable( 3089 );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		let boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		// reset state

		gl.disable( 3042 );
		gl.disable( 2884 );
		gl.disable( 2929 );
		gl.disable( 32823 );
		gl.disable( 3089 );
		gl.disable( 2960 );
		gl.disable( 32926 );

		gl.blendEquation( 32774 );
		gl.blendFunc( 1, 0 );
		gl.blendFuncSeparate( 1, 0, 1, 0 );

		gl.colorMask( true, true, true, true );
		gl.clearColor( 0, 0, 0, 0 );

		gl.depthMask( true );
		gl.depthFunc( 513 );
		gl.clearDepth( 1 );

		gl.stencilMask( 0xffffffff );
		gl.stencilFunc( 519, 0, 0xffffffff );
		gl.stencilOp( 7680, 7680, 7680 );
		gl.clearStencil( 0 );

		gl.cullFace( 1029 );
		gl.frontFace( 2305 );

		gl.polygonOffset( 0, 0 );

		gl.activeTexture( 33984 );

		gl.bindFramebuffer( 36160, null );

		if ( isWebGL2 === true ) {

			gl.bindFramebuffer( 36009, null );
			gl.bindFramebuffer( 36008, null );

		}

		gl.useProgram( null );

		gl.lineWidth( 1 );

		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		// reset internals

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		xrFramebuffer = null;
		currentBoundFramebuffers = {};

		currentProgram = null;

		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentPremultipledAlpha = false;

		currentFlipSided = null;
		currentCullFace = null;

		currentLineWidth = null;

		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;

		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		enable: enable,
		disable: disable,

		bindFramebuffer: bindFramebuffer,
		bindXRFramebuffer: bindXRFramebuffer,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	const isWebGL2 = capabilities.isWebGL2;
	const maxTextures = capabilities.maxTextures;
	const maxCubemapSize = capabilities.maxCubemapSize;
	const maxTextureSize = capabilities.maxTextureSize;
	const maxSamples = capabilities.maxSamples;

	const _videoTextures = new WeakMap();
	let _canvas;

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

	}

	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		let scale = 1;

		// handle case if texture exceeds max size

		if ( image.width > maxSize || image.height > maxSize ) {

			scale = maxSize / Math.max( image.width, image.height );

		}

		// only perform resize if necessary

		if ( scale < 1 || needsPowerOfTwo === true ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;

				const width = floor( scale * image.width );
				const height = floor( scale * image.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function isPowerOfTwo$1( image ) {

		return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( isWebGL2 ) return false;

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		return texture.generateMipmaps && supportsMips &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target, texture, width, height, depth = 1 ) {

		_gl.generateMipmap( target );

		const textureProperties = properties.get( texture );

		textureProperties.__maxMipLevel = Math.log2( Math.max( width, height, depth ) );

	}

	function getInternalFormat( internalFormatName, glFormat, glType, encoding ) {

		if ( isWebGL2 === false ) return glFormat;

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === 6403 ) {

			if ( glType === 5126 ) internalFormat = 33326;
			if ( glType === 5131 ) internalFormat = 33325;
			if ( glType === 5121 ) internalFormat = 33321;

		}

		if ( glFormat === 6407 ) {

			if ( glType === 5126 ) internalFormat = 34837;
			if ( glType === 5131 ) internalFormat = 34843;
			if ( glType === 5121 ) internalFormat = 32849;

		}

		if ( glFormat === 6408 ) {

			if ( glType === 5126 ) internalFormat = 34836;
			if ( glType === 5131 ) internalFormat = 34842;
			if ( glType === 5121 ) internalFormat = ( encoding === sRGBEncoding ) ? 35907 : 32856;

		}

		if ( internalFormat === 33325 || internalFormat === 33326 ||
			internalFormat === 34842 || internalFormat === 34836 ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return 9728;

		}

		return 9729;

	}

	//

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

		info.memory.textures --;

	}

	function onRenderTargetDispose( event ) {

		const renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

	}

	//

	function deallocateTexture( texture ) {

		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		_gl.deleteTexture( textureProperties.__webglTexture );

		properties.remove( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

			info.memory.textures --;

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( let i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
			if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		if ( renderTarget.isWebGLMultipleRenderTargets ) {

			for ( let i = 0, il = texture.length; i < il; i ++ ) {

				const attachmentProperties = properties.get( texture[ i ] );

				if ( attachmentProperties.__webglTexture ) {

					_gl.deleteTexture( attachmentProperties.__webglTexture );

					info.memory.textures --;

				}

				properties.remove( texture[ i ] );

			}

		}

		properties.remove( texture );
		properties.remove( renderTarget );

	}

	//

	let textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		const textureUnit = textureUnits;

		if ( textureUnit >= maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	//

	function setTexture2D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			const image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 3553, textureProperties.__webglTexture );

	}

	function setTexture2DArray( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 35866, textureProperties.__webglTexture );

	}

	function setTexture3D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 32879, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadCubeTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

	}

	const wrappingToGL = {
		[ RepeatWrapping ]: 10497,
		[ ClampToEdgeWrapping ]: 33071,
		[ MirroredRepeatWrapping ]: 33648
	};

	const filterToGL = {
		[ NearestFilter ]: 9728,
		[ NearestMipmapNearestFilter ]: 9984,
		[ NearestMipmapLinearFilter ]: 9986,

		[ LinearFilter ]: 9729,
		[ LinearMipmapNearestFilter ]: 9985,
		[ LinearMipmapLinearFilter ]: 9987
	};

	function setTextureParameters( textureType, texture, supportsMips ) {

		if ( supportsMips ) {

			_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
			_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

			}

			_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
			_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

		} else {

			_gl.texParameteri( textureType, 10242, 33071 );
			_gl.texParameteri( textureType, 10243, 33071 );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, 33071 );

			}

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			}

			_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			}

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
			if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		let textureType = 3553;

		if ( texture.isDataTexture2DArray ) textureType = 35866;
		if ( texture.isDataTexture3D ) textureType = 32879;

		initTexture( textureProperties, texture );

		state.activeTexture( 33984 + slot );
		state.bindTexture( textureType, textureProperties.__webglTexture );

		_gl.pixelStorei( 37440, texture.flipY );
		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
		_gl.pixelStorei( 3317, texture.unpackAlignment );
		_gl.pixelStorei( 37443, 0 );

		const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
		const image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

		const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
			glFormat = utils.convert( texture.format );

		let glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );

		setTextureParameters( textureType, texture, supportsMips );

		let mipmap;
		const mipmaps = texture.mipmaps;

		if ( texture.isDepthTexture ) {

			// populate depth texture with dummy data

			glInternalFormat = 6402;

			if ( isWebGL2 ) {

				if ( texture.type === FloatType ) {

					glInternalFormat = 36012;

				} else if ( texture.type === UnsignedIntType ) {

					glInternalFormat = 33190;

				} else if ( texture.type === UnsignedInt248Type ) {

					glInternalFormat = 35056;

				} else {

					glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

				}

			} else {

				if ( texture.type === FloatType ) {

					console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

				}

			}

			// validation checks for WebGL 1

			if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					texture.type = UnsignedShortType;
					glType = utils.convert( texture.type );

				}

			}

			if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				glInternalFormat = 34041;

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedInt248Type ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					texture.type = UnsignedInt248Type;
					glType = utils.convert( texture.type );

				}

			}

			//

			state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture.isDataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			}

		} else if ( texture.isCompressedTexture ) {

			for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

					if ( glFormat !== null ) {

						state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

					}

				} else {

					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else if ( texture.isDataTexture2DArray ) {

			state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else if ( texture.isDataTexture3D ) {

			state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
				textureProperties.__maxMipLevel = 0;

			}

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			generateMipmap( textureType, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	function uploadCubeTexture( textureProperties, texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		initTexture( textureProperties, texture );

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

		_gl.pixelStorei( 37440, texture.flipY );
		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
		_gl.pixelStorei( 3317, texture.unpackAlignment );
		_gl.pixelStorei( 37443, 0 );

		const isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
		const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

		const cubeImage = [];

		for ( let i = 0; i < 6; i ++ ) {

			if ( ! isCompressed && ! isDataTexture ) {

				cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

			} else {

				cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

			}

		}

		const image = cubeImage[ 0 ],
			supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
			glFormat = utils.convert( texture.format ),
			glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );

		setTextureParameters( 34067, texture, supportsMips );

		let mipmaps;

		if ( isCompressed ) {

			for ( let i = 0; i < 6; i ++ ) {

				mipmaps = cubeImage[ i ].mipmaps;

				for ( let j = 0; j < mipmaps.length; j ++ ) {

					const mipmap = mipmaps[ j ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( glFormat !== null ) {

							state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

						}

					} else {

						state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else {

			mipmaps = texture.mipmaps;

			for ( let i = 0; i < 6; i ++ ) {

				if ( isDataTexture ) {

					state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];
						const mipmapImage = mipmap.image[ i ].image;

						state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

					}

				} else {

					state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

					}

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length;

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			// We assume images for cube map have the same size.
			generateMipmap( 34067, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {

		const glFormat = utils.convert( texture.format );
		const glType = utils.convert( texture.type );
		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );

		if ( textureTarget === 32879 || textureTarget === 35866 ) {

			state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

		} else {

			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

		}

		state.bindFramebuffer( 36160, framebuffer );
		_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );
		state.bindFramebuffer( 36160, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( 36161, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			let glInternalFormat = 33189;

			if ( isMultisample ) {

				const depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( depthTexture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					}

				}

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			if ( isMultisample ) {

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

		} else {

			// Use the first texture for MRT so far
			const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[ 0 ] : renderTarget.texture;

			const glFormat = utils.convert( texture.format );
			const glType = utils.convert( texture.type );
			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );

			if ( isMultisample ) {

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

		}

		_gl.bindRenderbuffer( 36161, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		state.bindFramebuffer( 36160, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		state.bindFramebuffer( 36160, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

			textureProperties.__webglTexture = _gl.createTexture();
			textureProperties.__version = texture.version;
			info.memory.textures ++;

		}

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
		const isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
		const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

		// Handles WebGL2 RGBFormat fallback - #18858

		if ( isWebGL2 && texture.format === RGBFormat && ( texture.type === FloatType || texture.type === HalfFloatType ) ) {

			texture.format = RGBAFormat;

			console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

		}

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( let i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if ( isMultipleRenderTargets ) {

				if ( capabilities.drawBuffers ) {

					const textures = renderTarget.texture;

					for ( let i = 0, il = textures.length; i < il; i ++ ) {

						const attachmentProperties = properties.get( textures[ i ] );

						if ( attachmentProperties.__webglTexture === undefined ) {

							attachmentProperties.__webglTexture = _gl.createTexture();

							info.memory.textures ++;

						}

					}

				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );

				}

			} else if ( isMultisample ) {

				if ( isWebGL2 ) {

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

					const glFormat = utils.convert( texture.format );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
					const samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
					_gl.bindRenderbuffer( 36161, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					state.bindFramebuffer( 36160, null );


				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( 34067, textureProperties.__webglTexture );
			setTextureParameters( 34067, texture, supportsMips );

			for ( let i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, 36064, 34069 + i );

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( 34067, texture, renderTarget.width, renderTarget.height );

			}

			state.unbindTexture();

		} else if ( isMultipleRenderTargets ) {

			const textures = renderTarget.texture;

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const attachment = textures[ i ];
				const attachmentProperties = properties.get( attachment );

				state.bindTexture( 3553, attachmentProperties.__webglTexture );
				setTextureParameters( 3553, attachment, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553 );

				if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

					generateMipmap( 3553, attachment, renderTarget.width, renderTarget.height );

				}

			}

			state.unbindTexture();

		} else {

			let glTextureType = 3553;

			if ( isRenderTarget3D ) {

				// Render targets containing layers, i.e: Texture 3D and 2d arrays

				if ( isWebGL2 ) {

					const isTexture3D = texture.isDataTexture3D;
					glTextureType = isTexture3D ? 32879 : 35866;

				} else {

					console.warn( 'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.' );

				}

			}

			state.bindTexture( glTextureType, textureProperties.__webglTexture );
			setTextureParameters( glTextureType, texture, supportsMips );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth );

			}

			state.unbindTexture();

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

		const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

		for ( let i = 0, il = textures.length; i < il; i ++ ) {

			const texture = textures[ i ];

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
				const webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				state.unbindTexture();

			}

		}

	}

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( renderTarget.isWebGLMultisampleRenderTarget ) {

			if ( isWebGL2 ) {

				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = 16384;

				if ( renderTarget.depthBuffer ) mask |= 256;
				if ( renderTarget.stencilBuffer ) mask |= 1024;

				const renderTargetProperties = properties.get( renderTarget );

				state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
				state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				state.bindFramebuffer( 36008, null );
				state.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );

			} else {

				console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

			}

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
			Math.min( maxSamples, renderTarget.samples ) : 0;

	}

	function updateVideoTexture( texture ) {

		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	// backwards compatibility

	let warnedTexture2D = false;
	let warnedTextureCube = false;

	function safeSetTexture2D( texture, slot ) {

		if ( texture && texture.isWebGLRenderTarget ) {

			if ( warnedTexture2D === false ) {

				console.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.' );
				warnedTexture2D = true;

			}

			texture = texture.texture;

		}

		setTexture2D( texture, slot );

	}

	function safeSetTextureCube( texture, slot ) {

		if ( texture && texture.isWebGLCubeRenderTarget ) {

			if ( warnedTextureCube === false ) {

				console.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.' );
				warnedTextureCube = true;

			}

			texture = texture.texture;

		}


		setTextureCube( texture, slot );

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

	this.safeSetTexture2D = safeSetTexture2D;
	this.safeSetTextureCube = safeSetTextureCube;

}

function WebGLUtils( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function convert( p ) {

		let extension;

		if ( p === UnsignedByteType ) return 5121;
		if ( p === UnsignedShort4444Type ) return 32819;
		if ( p === UnsignedShort5551Type ) return 32820;
		if ( p === UnsignedShort565Type ) return 33635;

		if ( p === ByteType ) return 5120;
		if ( p === ShortType ) return 5122;
		if ( p === UnsignedShortType ) return 5123;
		if ( p === IntType ) return 5124;
		if ( p === UnsignedIntType ) return 5125;
		if ( p === FloatType ) return 5126;

		if ( p === HalfFloatType ) {

			if ( isWebGL2 ) return 5131;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				return extension.HALF_FLOAT_OES;

			} else {

				return null;

			}

		}

		if ( p === AlphaFormat ) return 6406;
		if ( p === RGBFormat ) return 6407;
		if ( p === RGBAFormat ) return 6408;
		if ( p === LuminanceFormat ) return 6409;
		if ( p === LuminanceAlphaFormat ) return 6410;
		if ( p === DepthFormat ) return 6402;
		if ( p === DepthStencilFormat ) return 34041;
		if ( p === RedFormat ) return 6403;

		// WebGL2 formats.

		if ( p === RedIntegerFormat ) return 36244;
		if ( p === RGFormat ) return 33319;
		if ( p === RGIntegerFormat ) return 33320;
		if ( p === RGBIntegerFormat ) return 36248;
		if ( p === RGBAIntegerFormat ) return 36249;

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			} else {

				return null;

			}

		}

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) {

				return extension.COMPRESSED_RGB_ETC1_WEBGL;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

			}

		}

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
			p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
			p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
			p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
			p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
			p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === UnsignedInt248Type ) {

			if ( isWebGL2 ) return 34042;

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) {

				return extension.UNSIGNED_INT_24_8_WEBGL;

			} else {

				return null;

			}

		}

	}

	return { convert: convert };

}

class ArrayCamera extends PerspectiveCamera {

	constructor( array = [] ) {

		super();

		this.cameras = array;

	}

}

ArrayCamera.prototype.isArrayCamera = true;

class Group extends Object3D {

	constructor() {

		super();

		this.type = 'Group';

	}

}

Group.prototype.isGroup = true;

const _moveEvent = { type: 'move' };

class WebXRController {

	constructor() {

		this._targetRay = null;
		this._grip = null;
		this._hand = null;

	}

	getHandSpace() {

		if ( this._hand === null ) {

			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = {};
			this._hand.inputState = { pinching: false };

		}

		return this._hand;

	}

	getTargetRaySpace() {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;
			this._targetRay.hasLinearVelocity = false;
			this._targetRay.linearVelocity = new Vector3();
			this._targetRay.hasAngularVelocity = false;
			this._targetRay.angularVelocity = new Vector3();

		}

		return this._targetRay;

	}

	getGripSpace() {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;
			this._grip.hasLinearVelocity = false;
			this._grip.linearVelocity = new Vector3();
			this._grip.hasAngularVelocity = false;
			this._grip.angularVelocity = new Vector3();

		}

		return this._grip;

	}

	dispatchEvent( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	}

	disconnect( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	}

	update( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( targetRay !== null ) {

				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				if ( inputPose !== null ) {

					targetRay.matrix.fromArray( inputPose.transform.matrix );
					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

					if ( inputPose.linearVelocity ) {

						targetRay.hasLinearVelocity = true;
						targetRay.linearVelocity.copy( inputPose.linearVelocity );

					} else {

						targetRay.hasLinearVelocity = false;

					}

					if ( inputPose.angularVelocity ) {

						targetRay.hasAngularVelocity = true;
						targetRay.angularVelocity.copy( inputPose.angularVelocity );

					} else {

						targetRay.hasAngularVelocity = false;

					}

					this.dispatchEvent( _moveEvent );

				}

			}

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( const inputjoint of inputSource.hand.values() ) {

					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					if ( hand.joints[ inputjoint.jointName ] === undefined ) {

						// The transform of this joint will be updated with the joint pose on each frame
						const joint = new Group();
						joint.matrixAutoUpdate = false;
						joint.visible = false;
						hand.joints[ inputjoint.jointName ] = joint;
						// ??
						hand.add( joint );

					}

					const joint = hand.joints[ inputjoint.jointName ];

					if ( jointPose !== null ) {

						joint.matrix.fromArray( jointPose.transform.matrix );
						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						joint.jointRadius = jointPose.radius;

					}

					joint.visible = jointPose !== null;

				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints[ 'index-finger-tip' ];
				const thumbTip = hand.joints[ 'thumb-tip' ];
				const distance = indexTip.position.distanceTo( thumbTip.position );

				const distanceToPinch = 0.02;
				const threshold = 0.005;

				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					hand.inputState.pinching = false;
					this.dispatchEvent( {
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					} );

				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					hand.inputState.pinching = true;
					this.dispatchEvent( {
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					} );

				}

			} else {

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

						if ( gripPose.linearVelocity ) {

							grip.hasLinearVelocity = true;
							grip.linearVelocity.copy( gripPose.linearVelocity );

						} else {

							grip.hasLinearVelocity = false;

						}

						if ( gripPose.angularVelocity ) {

							grip.hasAngularVelocity = true;
							grip.angularVelocity.copy( gripPose.angularVelocity );

						} else {

							grip.hasAngularVelocity = false;

						}

					}

				}

			}

		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

}

class WebXRManager extends EventDispatcher {

	constructor( renderer, gl ) {

		super();

		const scope = this;
		const state = renderer.state;

		let session = null;
		let framebufferScaleFactor = 1.0;

		let referenceSpace = null;
		let referenceSpaceType = 'local-floor';

		let pose = null;
		let glBinding = null;
		let glFramebuffer = null;
		let glProjLayer = null;
		let glBaseLayer = null;
		let isMultisample = false;
		let glMultisampledFramebuffer = null;
		let glColorRenderbuffer = null;
		let glDepthRenderbuffer = null;
		let xrFrame = null;
		let depthStyle = null;
		let clearStyle = null;

		const controllers = [];
		const inputSourcesMap = new Map();

		//

		const cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		const cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		const cameras = [ cameraL, cameraR ];

		const cameraVR = new ArrayCamera();
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		let _currentDepthNear = null;
		let _currentDepthFar = null;

		//

		this.cameraAutoUpdate = true;
		this.enabled = false;

		this.isPresenting = false;

		this.getController = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getTargetRaySpace();

		};

		this.getControllerGrip = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getGripSpace();

		};

		this.getHand = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getHandSpace();

		};

		//

		function onSessionEvent( event ) {

			const controller = inputSourcesMap.get( event.inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			}

		}

		function onSessionEnd() {

			inputSourcesMap.forEach( function ( controller, inputSource ) {

				controller.disconnect( inputSource );

			} );

			inputSourcesMap.clear();

			_currentDepthNear = null;
			_currentDepthFar = null;

			// restore framebuffer/rendering state

			state.bindXRFramebuffer( null );
			renderer.setRenderTarget( renderer.getRenderTarget() );

			if ( glFramebuffer ) gl.deleteFramebuffer( glFramebuffer );
			if ( glMultisampledFramebuffer ) gl.deleteFramebuffer( glMultisampledFramebuffer );
			if ( glColorRenderbuffer ) gl.deleteRenderbuffer( glColorRenderbuffer );
			if ( glDepthRenderbuffer ) gl.deleteRenderbuffer( glDepthRenderbuffer );
			glFramebuffer = null;
			glMultisampledFramebuffer = null;
			glColorRenderbuffer = null;
			glDepthRenderbuffer = null;
			glBaseLayer = null;
			glProjLayer = null;
			glBinding = null;
			session = null;

			//

			animation.stop();

			scope.isPresenting = false;

			scope.dispatchEvent( { type: 'sessionend' } );

		}

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

			}

		};

		this.setReferenceSpaceType = function ( value ) {

			referenceSpaceType = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

			}

		};

		this.getReferenceSpace = function () {

			return referenceSpace;

		};

		this.getBaseLayer = function () {

			return glProjLayer !== null ? glProjLayer : glBaseLayer;

		};

		this.getBinding = function () {

			return glBinding;

		};

		this.getFrame = function () {

			return xrFrame;

		};

		this.getSession = function () {

			return session;

		};

		this.setSession = async function ( value ) {

			session = value;

			if ( session !== null ) {

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'squeeze', onSessionEvent );
				session.addEventListener( 'squeezestart', onSessionEvent );
				session.addEventListener( 'squeezeend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );
				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

				const attributes = gl.getContextAttributes();

				if ( attributes.xrCompatible !== true ) {

					await gl.makeXRCompatible();

				}

				if ( session.renderState.layers === undefined ) {

					const layerInit = {
						antialias: attributes.antialias,
						alpha: attributes.alpha,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};

					glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

					session.updateRenderState( { baseLayer: glBaseLayer } );

				} else if ( gl instanceof WebGLRenderingContext ) {

					// Use old style webgl layer because we can't use MSAA
					// WebGL2 support.

					const layerInit = {
						antialias: true,
						alpha: attributes.alpha,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};

					glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

					session.updateRenderState( { layers: [ glBaseLayer ] } );

				} else {

					isMultisample = attributes.antialias;
					let depthFormat = null;


					if ( attributes.depth ) {

						clearStyle = 256;

						if ( attributes.stencil ) clearStyle |= 1024;

						depthStyle = attributes.stencil ? 33306 : 36096;
						depthFormat = attributes.stencil ? 35056 : 33190;

					}

					const projectionlayerInit = {
						colorFormat: attributes.alpha ? 32856 : 32849,
						depthFormat: depthFormat,
						scaleFactor: framebufferScaleFactor
					};

					glBinding = new XRWebGLBinding( session, gl );

					glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

					glFramebuffer = gl.createFramebuffer();

					session.updateRenderState( { layers: [ glProjLayer ] } );

					if ( isMultisample ) {

						glMultisampledFramebuffer = gl.createFramebuffer();
						glColorRenderbuffer = gl.createRenderbuffer();
						gl.bindRenderbuffer( 36161, glColorRenderbuffer );
						gl.renderbufferStorageMultisample(
							36161,
							4,
							32856,
							glProjLayer.textureWidth,
							glProjLayer.textureHeight );
						state.bindFramebuffer( 36160, glMultisampledFramebuffer );
						gl.framebufferRenderbuffer( 36160, 36064, 36161, glColorRenderbuffer );
						gl.bindRenderbuffer( 36161, null );

						if ( depthFormat !== null ) {

							glDepthRenderbuffer = gl.createRenderbuffer();
							gl.bindRenderbuffer( 36161, glDepthRenderbuffer );
							gl.renderbufferStorageMultisample( 36161, 4, depthFormat, glProjLayer.textureWidth, glProjLayer.textureHeight );
							gl.framebufferRenderbuffer( 36160, depthStyle, 36161, glDepthRenderbuffer );
							gl.bindRenderbuffer( 36161, null );

						}

						state.bindFramebuffer( 36160, null );

					}

				}

				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

				animation.setContext( session );
				animation.start();

				scope.isPresenting = true;

				scope.dispatchEvent( { type: 'sessionstart' } );

			}

		};

		function onInputSourcesChange( event ) {

			const inputSources = session.inputSources;

			// Assign inputSources to available controllers

			for ( let i = 0; i < controllers.length; i ++ ) {

				inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

			}

			// Notify disconnected

			for ( let i = 0; i < event.removed.length; i ++ ) {

				const inputSource = event.removed[ i ];
				const controller = inputSourcesMap.get( inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
					inputSourcesMap.delete( inputSource );

				}

			}

			// Notify connected

			for ( let i = 0; i < event.added.length; i ++ ) {

				const inputSource = event.added[ i ];
				const controller = inputSourcesMap.get( inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: 'connected', data: inputSource } );

				}

			}

		}

		//

		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */
		function setProjectionFromUnion( camera, cameraL, cameraR ) {

			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			const ipd = cameraLPos.distanceTo( cameraRPos );

			const projL = cameraL.projectionMatrix.elements;
			const projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			const left = near * leftFov;
			const right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			const zOffset = ipd / ( - leftFov + rightFov );
			const xOffset = zOffset * - leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			camera.translateX( xOffset );
			camera.translateZ( zOffset );
			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			// Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.
			const near2 = near + zOffset;
			const far2 = far + zOffset;
			const left2 = left - xOffset;
			const right2 = right + ( ipd - xOffset );
			const top2 = topFov * far / far2 * near2;
			const bottom2 = bottomFov * far / far2 * near2;

			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

		}

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		}

		this.updateCamera = function ( camera ) {

			if ( session === null ) return;

			cameraVR.near = cameraR.near = cameraL.near = camera.near;
			cameraVR.far = cameraR.far = cameraL.far = camera.far;

			if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState( {
					depthNear: cameraVR.near,
					depthFar: cameraVR.far
				} );

				_currentDepthNear = cameraVR.near;
				_currentDepthFar = cameraVR.far;

			}

			const parent = camera.parent;
			const cameras = cameraVR.cameras;

			updateCamera( cameraVR, parent );

			for ( let i = 0; i < cameras.length; i ++ ) {

				updateCamera( cameras[ i ], parent );

			}

			cameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );

			// update user camera and its children

			camera.position.copy( cameraVR.position );
			camera.quaternion.copy( cameraVR.quaternion );
			camera.scale.copy( cameraVR.scale );
			camera.matrix.copy( cameraVR.matrix );
			camera.matrixWorld.copy( cameraVR.matrixWorld );

			const children = camera.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( true );

			}

			// update projection matrix for proper view frustum culling

			if ( cameras.length === 2 ) {

				setProjectionFromUnion( cameraVR, cameraL, cameraR );

			} else {

				// assume single camera setup (AR)

				cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			}

		};

		this.getCamera = function () {

			return cameraVR;

		};

		this.getFoveation = function () {

			if ( glProjLayer !== null ) {

				return glProjLayer.fixedFoveation;

			}

			if ( glBaseLayer !== null ) {

				return glBaseLayer.fixedFoveation;

			}

			return undefined;

		};

		this.setFoveation = function ( foveation ) {

			// 0 = no foveation = full resolution
			// 1 = maximum foveation = the edges render at lower resolution

			if ( glProjLayer !== null ) {

				glProjLayer.fixedFoveation = foveation;

			}

			if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

				glBaseLayer.fixedFoveation = foveation;

			}

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getViewerPose( referenceSpace );
			xrFrame = frame;

			if ( pose !== null ) {

				const views = pose.views;

				if ( glBaseLayer !== null ) {

					state.bindXRFramebuffer( glBaseLayer.framebuffer );

				}

				let cameraVRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraVR's camera list

				if ( views.length !== cameraVR.cameras.length ) {

					cameraVR.cameras.length = 0;

					cameraVRNeedsUpdate = true;

				}

				for ( let i = 0; i < views.length; i ++ ) {

					const view = views[ i ];

					let viewport = null;

					if ( glBaseLayer !== null ) {

						viewport = glBaseLayer.getViewport( view );

					} else {

						const glSubImage = glBinding.getViewSubImage( glProjLayer, view );

						state.bindXRFramebuffer( glFramebuffer );

						if ( glSubImage.depthStencilTexture !== undefined ) {

							gl.framebufferTexture2D( 36160, depthStyle, 3553, glSubImage.depthStencilTexture, 0 );

						}

						gl.framebufferTexture2D( 36160, 36064, 3553, glSubImage.colorTexture, 0 );

						viewport = glSubImage.viewport;

					}

					const camera = cameras[ i ];

					camera.matrix.fromArray( view.transform.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraVR.matrix.copy( camera.matrix );

					}

					if ( cameraVRNeedsUpdate === true ) {

						cameraVR.cameras.push( camera );

					}

				}

				if ( isMultisample ) {

					state.bindXRFramebuffer( glMultisampledFramebuffer );

					if ( clearStyle !== null ) gl.clear( clearStyle );

				}

			}

			//

			const inputSources = session.inputSources;

			for ( let i = 0; i < controllers.length; i ++ ) {

				const controller = controllers[ i ];
				const inputSource = inputSources[ i ];

				controller.update( inputSource, frame, referenceSpace );

			}

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

			if ( isMultisample ) {

				const width = glProjLayer.textureWidth;
				const height = glProjLayer.textureHeight;

				state.bindFramebuffer( 36008, glMultisampledFramebuffer );
				state.bindFramebuffer( 36009, glFramebuffer );
				// Invalidate the depth here to avoid flush of the depth data to main memory.
				gl.invalidateFramebuffer( 36008, [ depthStyle ] );
				gl.invalidateFramebuffer( 36009, [ depthStyle ] );
				gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, 16384, 9728 );
				// Invalidate the MSAA buffer because it's not needed anymore.
				gl.invalidateFramebuffer( 36008, [ 36064 ] );
				state.bindFramebuffer( 36008, null );
				state.bindFramebuffer( 36009, null );

				state.bindFramebuffer( 36160, glMultisampledFramebuffer );

			}

			xrFrame = null;

		}

		const animation = new WebGLAnimation();

		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

	}

}

function WebGLMaterials( properties ) {

	function refreshFogUniforms( uniforms, fog ) {

		uniforms.fogColor.value.copy( fog.color );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsLambert( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

			} else {

				refreshUniformsStandard( uniforms, material );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDepth( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsNormal( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.ior.value = material.ior;
			uniforms.refractionRatio.value = material.refractionRatio;

			const maxMipLevel = properties.get( envMap ).__maxMipLevel;

			if ( maxMipLevel !== undefined ) {

				uniforms.maxMipLevel.value = maxMipLevel;

			}

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. displacementMap map
		// 4. normal map
		// 5. bump map
		// 6. roughnessMap map
		// 7. metalnessMap map
		// 8. alphaMap map
		// 9. emissiveMap map
		// 10. clearcoat map
		// 11. clearcoat normal map
		// 12. clearcoat roughnessMap map
		// 13. specular intensity map
		// 14. specular tint map
		// 15. transmission map
		// 16. thickness map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		} else if ( material.clearcoatMap ) {

			uvScaleMap = material.clearcoatMap;

		} else if ( material.clearcoatNormalMap ) {

			uvScaleMap = material.clearcoatNormalMap;

		} else if ( material.clearcoatRoughnessMap ) {

			uvScaleMap = material.clearcoatRoughnessMap;

		} else if ( material.specularIntensityMap ) {

			uvScaleMap = material.specularIntensityMap;

		} else if ( material.specularColorMap ) {

			uvScaleMap = material.specularColorMap;

		} else if ( material.transmissionMap ) {

			uvScaleMap = material.transmissionMap;

		} else if ( material.thicknessMap ) {

			uvScaleMap = material.thicknessMap;

		} else if ( material.sheenColorMap ) {

			uvScaleMap = material.sheenColorMap;

		} else if ( material.sheenRoughnessMap ) {

			uvScaleMap = material.sheenRoughnessMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		let uv2ScaleMap;

		if ( material.aoMap ) {

			uv2ScaleMap = material.aoMap;

		} else if ( material.lightMap ) {

			uv2ScaleMap = material.lightMap;

		}

		if ( uv2ScaleMap !== undefined ) {

			// backwards compatibility
			if ( uv2ScaleMap.isWebGLRenderTarget ) {

				uv2ScaleMap = uv2ScaleMap.texture;

			}

			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				uv2ScaleMap.updateMatrix();

			}

			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsLambert( uniforms, material ) {

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsToon( uniforms, material ) {

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

		refreshUniformsStandard( uniforms, material );

		uniforms.ior.value = material.ior; // also part of uniforms common

		if ( material.sheen > 0 ) {

			uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

			uniforms.sheenRoughness.value = material.sheenRoughness;

			if ( material.sheenColorMap ) {

				uniforms.sheenColorMap.value = material.sheenColorMap;

			}

			if ( material.sheenRoughnessMap ) {

				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

			}

		}

		if ( material.clearcoat > 0 ) {

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

			if ( material.clearcoatMap ) {

				uniforms.clearcoatMap.value = material.clearcoatMap;

			}

			if ( material.clearcoatRoughnessMap ) {

				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

			}

			if ( material.clearcoatNormalMap ) {

				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				if ( material.side === BackSide ) {

					uniforms.clearcoatNormalScale.value.negate();

				}

			}

		}

		if ( material.transmission > 0 ) {

			uniforms.transmission.value = material.transmission;
			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

			if ( material.transmissionMap ) {

				uniforms.transmissionMap.value = material.transmissionMap;

			}

			uniforms.thickness.value = material.thickness;

			if ( material.thicknessMap ) {

				uniforms.thicknessMap.value = material.thicknessMap;

			}

			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationColor.value.copy( material.attenuationColor );

		}

		uniforms.specularIntensity.value = material.specularIntensity;
		uniforms.specularColor.value.copy( material.specularColor );

		if ( material.specularIntensityMap ) {

			uniforms.specularIntensityMap.value = material.specularIntensityMap;

		}

		if ( material.specularColorMap ) {

			uniforms.specularColorMap.value = material.specularColorMap;

		}

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDepth( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;

	}

	function refreshUniformsNormal( uniforms, material ) {

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}

function createCanvasElement() {

	const canvas = createElementNS( 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

function WebGLRenderer( parameters = {} ) {

	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
		_context = parameters.context !== undefined ? parameters.context : null,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	let currentRenderList = null;
	let currentRenderState = null;

	// render() can be called from within a callback triggered by another render.
	// We track this so that the nested render call gets its list and state isolated from the parent render call.

	const renderListStack = [];
	const renderStateStack = [];

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {

		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.outputEncoding = LinearEncoding;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = NoToneMapping;
	this.toneMappingExposure = 1.0;

	// internal properties

	const _this = this;

	let _isContextLost = false;

	// internal state cache

	let _currentActiveCubeFace = 0;
	let _currentActiveMipmapLevel = 0;
	let _currentRenderTarget = null;
	let _currentMaterialId = - 1;

	let _currentCamera = null;

	const _currentViewport = new Vector4();
	const _currentScissor = new Vector4();
	let _currentScissorTest = null;

	//

	let _width = _canvas.width;
	let _height = _canvas.height;

	let _pixelRatio = 1;
	let _opaqueSort = null;
	let _transparentSort = null;

	const _viewport = new Vector4( 0, 0, _width, _height );
	const _scissor = new Vector4( 0, 0, _width, _height );
	let _scissorTest = false;

	//

	const _currentDrawBuffers = [];

	// frustum

	const _frustum = new Frustum();

	// clipping

	let _clippingEnabled = false;
	let _localClippingEnabled = false;

	// transmission

	let _transmissionRenderTarget = null;

	// camera matrices cache

	const _projScreenMatrix = new Matrix4();

	const _vector3 = new Vector3();

	const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	// initialize

	let _gl = _context;

	function getContext( contextNames, contextAttributes ) {

		for ( let i = 0; i < contextNames.length; i ++ ) {

			const contextName = contextNames[ i ];
			const context = _canvas.getContext( contextName, contextAttributes );
			if ( context !== null ) return context;

		}

		return null;

	}

	try {

		const contextAttributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		};

		// event listeners must be registered before WebGL context is created, see #12753

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

		if ( _gl === null ) {

			const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

			if ( _this.isWebGL1Renderer === true ) {

				contextNames.shift();

			}

			_gl = getContext( contextNames, contextAttributes );

			if ( _gl === null ) {

				if ( getContext( contextNames ) ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error.message );
		throw error;

	}

	let extensions, capabilities, state, info;
	let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
	let programCache, materials, renderLists, renderStates, clipping, shadowMap;

	let background, morphtargets, bufferRenderer, indexedBufferRenderer;

	let utils, bindingStates;

	function initGLContext() {

		extensions = new WebGLExtensions( _gl );

		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

		extensions.init( capabilities );

		utils = new WebGLUtils( _gl, extensions, capabilities );

		state = new WebGLState( _gl, extensions, capabilities );

		_currentDrawBuffers[ 0 ] = 1029;

		info = new WebGLInfo( _gl );
		properties = new WebGLProperties();
		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
		cubemaps = new WebGLCubeMaps( _this );
		cubeuvmaps = new WebGLCubeUVMaps( _this );
		attributes = new WebGLAttributes( _gl, capabilities );
		bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
		geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
		objects = new WebGLObjects( _gl, geometries, attributes, info );
		morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
		clipping = new WebGLClipping( properties );
		programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
		materials = new WebGLMaterials( properties );
		renderLists = new WebGLRenderLists( properties );
		renderStates = new WebGLRenderStates( extensions, capabilities );
		background = new WebGLBackground( _this, cubemaps, state, objects, _premultipliedAlpha );
		shadowMap = new WebGLShadowMap( _this, objects, capabilities );

		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

		info.programs = programCache.programs;

		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.shadowMap = shadowMap;
		_this.state = state;
		_this.info = info;

	}

	initGLContext();

	// xr

	const xr = new WebXRManager( _this, _gl );

	this.xr = xr;

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();

	};

	this.forceContextRestore = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.restoreContext();

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function ( target ) {

		return target.set( _width, _height );

	};

	this.setSize = function ( width, height, updateStyle ) {

		if ( xr.isPresenting ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = Math.floor( width * _pixelRatio );
		_canvas.height = Math.floor( height * _pixelRatio );

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function ( target ) {

		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = Math.floor( width * pixelRatio );
		_canvas.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

	};

	this.getCurrentViewport = function ( target ) {

		return target.copy( _currentViewport );

	};

	this.getViewport = function ( target ) {

		return target.copy( _viewport );

	};

	this.setViewport = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_viewport.set( x.x, x.y, x.z, x.w );

		} else {

			_viewport.set( x, y, width, height );

		}

		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissor = function ( target ) {

		return target.copy( _scissor );

	};

	this.setScissor = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_scissor.set( x.x, x.y, x.z, x.w );

		} else {

			_scissor.set( x, y, width, height );

		}

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissorTest = function () {

		return _scissorTest;

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	this.setOpaqueSort = function ( method ) {

		_opaqueSort = method;

	};

	this.setTransparentSort = function ( method ) {

		_transparentSort = method;

	};

	// Clearing

	this.getClearColor = function ( target ) {

		return target.copy( background.getClearColor() );

	};

	this.setClearColor = function () {

		background.setClearColor.apply( background, arguments );

	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();

	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply( background, arguments );

	};

	this.clear = function ( color, depth, stencil ) {

		let bits = 0;

		if ( color === undefined || color ) bits |= 16384;
		if ( depth === undefined || depth ) bits |= 256;
		if ( stencil === undefined || stencil ) bits |= 1024;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	//

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		cubemaps.dispose();
		cubeuvmaps.dispose();
		objects.dispose();
		bindingStates.dispose();

		xr.dispose();

		xr.removeEventListener( 'sessionstart', onXRSessionStart );
		xr.removeEventListener( 'sessionend', onXRSessionEnd );

		if ( _transmissionRenderTarget ) {

			_transmissionRenderTarget.dispose();
			_transmissionRenderTarget = null;

		}

		animation.stop();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		console.log( 'THREE.WebGLRenderer: Context Lost.' );

		_isContextLost = true;

	}

	function onContextRestore( /* event */ ) {

		console.log( 'THREE.WebGLRenderer: Context Restored.' );

		_isContextLost = false;

		const infoAutoReset = info.autoReset;
		const shadowMapEnabled = shadowMap.enabled;
		const shadowMapAutoUpdate = shadowMap.autoUpdate;
		const shadowMapNeedsUpdate = shadowMap.needsUpdate;
		const shadowMapType = shadowMap.type;

		initGLContext();

		info.autoReset = infoAutoReset;
		shadowMap.enabled = shadowMapEnabled;
		shadowMap.autoUpdate = shadowMapAutoUpdate;
		shadowMap.needsUpdate = shadowMapNeedsUpdate;
		shadowMap.type = shadowMapType;

	}

	function onMaterialDispose( event ) {

		const material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReferences( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReferences( material ) {

		const programs = properties.get( material ).programs;

		if ( programs !== undefined ) {

			programs.forEach( function ( program ) {

				programCache.releaseProgram( program );

			} );

		}

	}

	// Buffer rendering

	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		const program = setProgram( camera, scene, geometry, material, object );

		state.setMaterial( material, frontFaceCW );

		//

		let index = geometry.index;
		const position = geometry.attributes.position;

		//

		if ( index === null ) {

			if ( position === undefined || position.count === 0 ) return;

		} else if ( index.count === 0 ) {

			return;

		}

		//

		let rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		bindingStates.setup( object, material, program, geometry, index );

		let attribute;
		let renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		//

		const dataCount = ( index !== null ) ? index.count : position.count;

		const rangeStart = geometry.drawRange.start * rangeFactor;
		const rangeCount = geometry.drawRange.count * rangeFactor;

		const groupStart = group !== null ? group.start * rangeFactor : 0;
		const groupCount = group !== null ? group.count * rangeFactor : Infinity;

		const drawStart = Math.max( rangeStart, groupStart );
		const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( 1 );

			} else {

				renderer.setMode( 4 );

			}

		} else if ( object.isLine ) {

			let lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( 1 );

			} else if ( object.isLineLoop ) {

				renderer.setMode( 2 );

			} else {

				renderer.setMode( 3 );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( 0 );

		} else if ( object.isSprite ) {

			renderer.setMode( 4 );

		}

		if ( object.isInstancedMesh ) {

			renderer.renderInstances( drawStart, drawCount, object.count );

		} else if ( geometry.isInstancedBufferGeometry ) {

			const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

			renderer.renderInstances( drawStart, drawCount, instanceCount );

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	// Compile

	this.compile = function ( scene, camera ) {

		currentRenderState = renderStates.get( scene );
		currentRenderState.init();

		renderStateStack.push( currentRenderState );

		scene.traverseVisible( function ( object ) {

			if ( object.isLight && object.layers.test( camera.layers ) ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			}

		} );

		currentRenderState.setupLights( _this.physicallyCorrectLights );

		scene.traverse( function ( object ) {

			const material = object.material;

			if ( material ) {

				if ( Array.isArray( material ) ) {

					for ( let i = 0; i < material.length; i ++ ) {

						const material2 = material[ i ];

						getProgram( material2, scene, object );

					}

				} else {

					getProgram( material, scene, object );

				}

			}

		} );

		renderStateStack.pop();
		currentRenderState = null;

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time ) {

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	}

	function onXRSessionStart() {

		animation.stop();

	}

	function onXRSessionEnd() {

		animation.start();

	}

	const animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	if ( typeof window !== 'undefined' ) animation.setContext( window );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;
		xr.setAnimationLoop( callback );

		( callback === null ) ? animation.stop() : animation.start();

	};

	xr.addEventListener( 'sessionstart', onXRSessionStart );
	xr.addEventListener( 'sessionend', onXRSessionEnd );

	// Rendering

	this.render = function ( scene, camera ) {

		if ( camera !== undefined && camera.isCamera !== true ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( _isContextLost === true ) return;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		if ( xr.enabled === true && xr.isPresenting === true ) {

			if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

			camera = xr.getCamera(); // use XR camera for rendering

		}

		//
		if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

		currentRenderState = renderStates.get( scene, renderStateStack.length );
		currentRenderState.init();

		renderStateStack.push( currentRenderState );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix );

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		currentRenderList = renderLists.get( scene, renderListStack.length );
		currentRenderList.init();

		renderListStack.push( currentRenderList );

		projectObject( scene, camera, 0, _this.sortObjects );

		currentRenderList.finish();

		if ( _this.sortObjects === true ) {

			currentRenderList.sort( _opaqueSort, _transparentSort );

		}

		//

		if ( _clippingEnabled === true ) clipping.beginShadows();

		const shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render( shadowsArray, scene, camera );

		if ( _clippingEnabled === true ) clipping.endShadows();

		//

		if ( this.info.autoReset === true ) this.info.reset();

		//

		background.render( currentRenderList, scene );

		// render scene

		currentRenderState.setupLights( _this.physicallyCorrectLights );

		if ( camera.isArrayCamera ) {

			const cameras = camera.cameras;

			for ( let i = 0, l = cameras.length; i < l; i ++ ) {

				const camera2 = cameras[ i ];

				renderScene( currentRenderList, scene, camera2, camera2.viewport );

			}

		} else {

			renderScene( currentRenderList, scene, camera );

		}

		//

		if ( _currentRenderTarget !== null ) {

			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget( _currentRenderTarget );

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap( _currentRenderTarget );

		}

		//

		if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		state.setPolygonOffset( false );

		// _gl.finish();

		bindingStates.resetDefaultState();
		_currentMaterialId = - 1;
		_currentCamera = null;

		renderStateStack.pop();

		if ( renderStateStack.length > 0 ) {

			currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

		} else {

			currentRenderState = null;

		}

		renderListStack.pop();

		if ( renderListStack.length > 0 ) {

			currentRenderList = renderListStack[ renderListStack.length - 1 ];

		} else {

			currentRenderList = null;

		}

	};

	function projectObject( object, camera, groupOrder, sortObjects ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					// update skeleton only once in a frame

					if ( object.skeleton.frame !== info.render.frame ) {

						object.skeleton.update();
						object.skeleton.frame = info.render.frame;

					}

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let i = 0, l = groups.length; i < l; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, groupOrder, sortObjects );

		}

	}

	function renderScene( currentRenderList, scene, camera, viewport ) {

		const opaqueObjects = currentRenderList.opaque;
		const transmissiveObjects = currentRenderList.transmissive;
		const transparentObjects = currentRenderList.transparent;

		currentRenderState.setupLightsView( camera );

		if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, scene, camera );

		if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

		if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
		if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
		if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

	}

	function renderTransmissionPass( opaqueObjects, scene, camera ) {

		if ( _transmissionRenderTarget === null ) {

			const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
			const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;

			_transmissionRenderTarget = new renderTargetType( 1024, 1024, {
				generateMipmaps: true,
				type: utils.convert( HalfFloatType ) !== null ? HalfFloatType : UnsignedByteType,
				minFilter: LinearMipmapLinearFilter,
				magFilter: NearestFilter,
				wrapS: ClampToEdgeWrapping,
				wrapT: ClampToEdgeWrapping
			} );

		}

		const currentRenderTarget = _this.getRenderTarget();
		_this.setRenderTarget( _transmissionRenderTarget );
		_this.clear();

		// Turn off the features which can affect the frag color for opaque objects pass.
		// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
		const currentToneMapping = _this.toneMapping;
		_this.toneMapping = NoToneMapping;

		renderObjects( opaqueObjects, scene, camera );

		_this.toneMapping = currentToneMapping;

		textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
		textures.updateRenderTargetMipmap( _transmissionRenderTarget );

		_this.setRenderTarget( currentRenderTarget );

	}

	function renderObjects( renderList, scene, camera ) {

		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

		for ( let i = 0, l = renderList.length; i < l; i ++ ) {

			const renderItem = renderList[ i ];

			const object = renderItem.object;
			const geometry = renderItem.geometry;
			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			const group = renderItem.group;

			if ( object.layers.test( camera.layers ) ) {

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.onBeforeRender( _this, scene, camera, geometry, material, group );

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		material.onBeforeRender( _this, scene, camera, geometry, object, group );

		if ( material.transparent === true && material.side === DoubleSide ) {

			material.side = BackSide;
			material.needsUpdate = true;
			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			material.side = FrontSide;
			material.needsUpdate = true;
			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			material.side = DoubleSide;

		} else {

			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );

	}

	function getProgram( material, scene, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		const materialProperties = properties.get( material );

		const lights = currentRenderState.state.lights;
		const shadowsArray = currentRenderState.state.shadowsArray;

		const lightsStateVersion = lights.state.version;

		const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
		const programCacheKey = programCache.getProgramCacheKey( parameters );

		let programs = materialProperties.programs;

		// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		materialProperties.fog = scene.fog;
		materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );

		if ( programs === undefined ) {

			// new material

			material.addEventListener( 'dispose', onMaterialDispose );

			programs = new Map();
			materialProperties.programs = programs;

		}

		let program = programs.get( programCacheKey );

		if ( program !== undefined ) {

			// early out if program and light state is identical

			if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

				updateCommonMaterialProperties( material, parameters );

				return program;

			}

		} else {

			parameters.uniforms = programCache.getUniforms( material );

			material.onBuild( object, parameters, _this );

			material.onBeforeCompile( parameters, _this );

			program = programCache.acquireProgram( parameters, programCacheKey );
			programs.set( programCacheKey, program );

			materialProperties.uniforms = parameters.uniforms;

		}

		const uniforms = materialProperties.uniforms;

		if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

			uniforms.clippingPlanes = clipping.uniform;

		}

		updateCommonMaterialProperties( material, parameters );

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights( material );
		materialProperties.lightsStateVersion = lightsStateVersion;

		if ( materialProperties.needsLights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		const progUniforms = program.getUniforms();
		const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.currentProgram = program;
		materialProperties.uniformsList = uniformsList;

		return program;

	}

	function updateCommonMaterialProperties( material, parameters ) {

		const materialProperties = properties.get( material );

		materialProperties.outputEncoding = parameters.outputEncoding;
		materialProperties.instancing = parameters.instancing;
		materialProperties.skinning = parameters.skinning;
		materialProperties.morphTargets = parameters.morphTargets;
		materialProperties.morphNormals = parameters.morphNormals;
		materialProperties.morphTargetsCount = parameters.morphTargetsCount;
		materialProperties.numClippingPlanes = parameters.numClippingPlanes;
		materialProperties.numIntersection = parameters.numClipIntersection;
		materialProperties.vertexAlphas = parameters.vertexAlphas;
		materialProperties.vertexTangents = parameters.vertexTangents;

	}

	function setProgram( camera, scene, geometry, material, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		textures.resetTextureUnits();

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
		const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
		const vertexTangents = !! material.normalMap && !! geometry.attributes.tangent;
		const morphTargets = !! geometry.morphAttributes.position;
		const morphNormals = !! geometry.morphAttributes.normal;
		const morphTargetsCount = !! geometry.morphAttributes.position ? geometry.morphAttributes.position.length : 0;

		const materialProperties = properties.get( material );
		const lights = currentRenderState.state.lights;

		if ( _clippingEnabled === true ) {

			if ( _localClippingEnabled === true || camera !== _currentCamera ) {

				const useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				clipping.setState( material, camera, useCache );

			}

		}

		//

		let needsProgramChange = false;

		if ( material.version === materialProperties.__version ) {

			if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.outputEncoding !== encoding ) {

				needsProgramChange = true;

			} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

				needsProgramChange = true;

			} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

				needsProgramChange = true;

			} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

				needsProgramChange = true;

			} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

				needsProgramChange = true;

			} else if ( materialProperties.envMap !== envMap ) {

				needsProgramChange = true;

			} else if ( material.fog && materialProperties.fog !== fog ) {

				needsProgramChange = true;

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== clipping.numPlanes ||
				materialProperties.numIntersection !== clipping.numIntersection ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

				needsProgramChange = true;

			} else if ( materialProperties.vertexTangents !== vertexTangents ) {

				needsProgramChange = true;

			} else if ( materialProperties.morphTargets !== morphTargets ) {

				needsProgramChange = true;

			} else if ( materialProperties.morphNormals !== morphNormals ) {

				needsProgramChange = true;

			} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {

				needsProgramChange = true;

			}

		} else {

			needsProgramChange = true;
			materialProperties.__version = material.version;

		}

		//

		let program = materialProperties.currentProgram;

		if ( needsProgramChange === true ) {

			program = getProgram( material, scene, object );

		}

		let refreshProgram = false;
		let refreshMaterial = false;
		let refreshLights = false;

		const p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;

		if ( state.useProgram( program.program ) ) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || _currentCamera !== camera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( _currentCamera !== camera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				const uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ) {

				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.isShadowMaterial ||
				object.isSkinnedMesh ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning and morph target uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone and morph texture must go before other textures
		// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

		if ( object.isSkinnedMesh ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			const skeleton = object.skeleton;

			if ( skeleton ) {

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( !! geometry && ( geometry.morphAttributes.position !== undefined || geometry.morphAttributes.normal !== undefined ) ) {

			morphtargets.update( object, geometry, material, program );

		}


		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

			if ( materialProperties.needsLights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				materials.refreshFogUniforms( m_uniforms, fog );

			}

			materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

		}

		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			material.uniformsNeedUpdate = false;

		}

		if ( material.isSpriteMaterial ) {

			p_uniforms.setValue( _gl, 'center', object.center );

		}

		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	function materialNeedsLights( material ) {

		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			material.isMeshStandardMaterial || material.isShadowMaterial ||
			( material.isShaderMaterial && material.lights === true );

	}

	this.getActiveCubeFace = function () {

		return _currentActiveCubeFace;

	};

	this.getActiveMipmapLevel = function () {

		return _currentActiveMipmapLevel;

	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		let framebuffer = null;
		let isCube = false;
		let isRenderTarget3D = false;

		if ( renderTarget ) {

			const texture = renderTarget.texture;

			if ( texture.isDataTexture3D || texture.isDataTexture2DArray ) {

				isRenderTarget3D = true;

			}

			const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				framebuffer = __webglFramebuffer[ activeCubeFace ];
				isCube = true;

			} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			} else {

				framebuffer = __webglFramebuffer;

			}

			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

		} else {

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			_currentScissorTest = _scissorTest;

		}

		const framebufferBound = state.bindFramebuffer( 36160, framebuffer );

		if ( framebufferBound && capabilities.drawBuffers ) {

			let needsUpdate = false;

			if ( renderTarget ) {

				if ( renderTarget.isWebGLMultipleRenderTargets ) {

					const textures = renderTarget.texture;

					if ( _currentDrawBuffers.length !== textures.length || _currentDrawBuffers[ 0 ] !== 36064 ) {

						for ( let i = 0, il = textures.length; i < il; i ++ ) {

							_currentDrawBuffers[ i ] = 36064 + i;

						}

						_currentDrawBuffers.length = textures.length;

						needsUpdate = true;

					}

				} else {

					if ( _currentDrawBuffers.length !== 1 || _currentDrawBuffers[ 0 ] !== 36064 ) {

						_currentDrawBuffers[ 0 ] = 36064;
						_currentDrawBuffers.length = 1;

						needsUpdate = true;

					}

				}

			} else {

				if ( _currentDrawBuffers.length !== 1 || _currentDrawBuffers[ 0 ] !== 1029 ) {

					_currentDrawBuffers[ 0 ] = 1029;
					_currentDrawBuffers.length = 1;

					needsUpdate = true;

				}

			}

			if ( needsUpdate ) {

				if ( capabilities.isWebGL2 ) {

					_gl.drawBuffers( _currentDrawBuffers );

				} else {

					extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( _currentDrawBuffers );

				}

			}

		}

		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		if ( isCube ) {

			const textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

		} else if ( isRenderTarget3D ) {

			const textureProperties = properties.get( renderTarget.texture );
			const layer = activeCubeFace || 0;
			_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

		}

		_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			framebuffer = framebuffer[ activeCubeFaceIndex ];

		}

		if ( framebuffer ) {

			state.bindFramebuffer( 36160, framebuffer );

			try {

				const texture = renderTarget.texture;
				const textureFormat = texture.format;
				const textureType = texture.type;

				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! halfFloatSupportedByExt ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				// restore framebuffer of current render target if necessary

				const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
				state.bindFramebuffer( 36160, framebuffer );

			}

		}

	};

	this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

		const levelScale = Math.pow( 2, - level );
		const width = Math.floor( texture.image.width * levelScale );
		const height = Math.floor( texture.image.height * levelScale );

		let glFormat = utils.convert( texture.format );

		if ( capabilities.isWebGL2 ) {

			// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
			// Not needed in Chrome 93+

			if ( glFormat === 6407 ) glFormat = 32849;
			if ( glFormat === 6408 ) glFormat = 32856;

		}

		textures.setTexture2D( texture, 0 );

		_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

		state.unbindTexture();

	};

	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

		const width = srcTexture.image.width;
		const height = srcTexture.image.height;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );

		textures.setTexture2D( dstTexture, 0 );

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		if ( srcTexture.isDataTexture ) {

			_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

			} else {

				_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		}

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

		state.unbindTexture();

	};

	this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

		if ( _this.isWebGL1Renderer ) {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
			return;

		}

		const width = sourceBox.max.x - sourceBox.min.x + 1;
		const height = sourceBox.max.y - sourceBox.min.y + 1;
		const depth = sourceBox.max.z - sourceBox.min.z + 1;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );
		let glTarget;

		if ( dstTexture.isDataTexture3D ) {

			textures.setTexture3D( dstTexture, 0 );
			glTarget = 32879;

		} else if ( dstTexture.isDataTexture2DArray ) {

			textures.setTexture2DArray( dstTexture, 0 );
			glTarget = 35866;

		} else {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
			return;

		}

		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		const unpackRowLen = _gl.getParameter( 3314 );
		const unpackImageHeight = _gl.getParameter( 32878 );
		const unpackSkipPixels = _gl.getParameter( 3316 );
		const unpackSkipRows = _gl.getParameter( 3315 );
		const unpackSkipImages = _gl.getParameter( 32877 );

		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;

		_gl.pixelStorei( 3314, image.width );
		_gl.pixelStorei( 32878, image.height );
		_gl.pixelStorei( 3316, sourceBox.min.x );
		_gl.pixelStorei( 3315, sourceBox.min.y );
		_gl.pixelStorei( 32877, sourceBox.min.z );

		if ( srcTexture.isDataTexture || srcTexture.isDataTexture3D ) {

			_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );
				_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

			} else {

				_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

			}

		}

		_gl.pixelStorei( 3314, unpackRowLen );
		_gl.pixelStorei( 32878, unpackImageHeight );
		_gl.pixelStorei( 3316, unpackSkipPixels );
		_gl.pixelStorei( 3315, unpackSkipRows );
		_gl.pixelStorei( 32877, unpackSkipImages );

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

		state.unbindTexture();

	};

	this.initTexture = function ( texture ) {

		textures.setTexture2D( texture, 0 );

		state.unbindTexture();

	};

	this.resetState = function () {

		_currentActiveCubeFace = 0;
		_currentActiveMipmapLevel = 0;
		_currentRenderTarget = null;

		state.reset();
		bindingStates.reset();

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

	}

}

WebGLRenderer.prototype.isWebGLRenderer = true;

class WebGL1Renderer extends WebGLRenderer {}

WebGL1Renderer.prototype.isWebGL1Renderer = true;

class FogExp2 {

	constructor( color, density = 0.00025 ) {

		this.name = '';

		this.color = new Color( color );
		this.density = density;

	}

	clone() {

		return new FogExp2( this.color, this.density );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	}

}

FogExp2.prototype.isFogExp2 = true;

class Fog {

	constructor( color, near = 1, far = 1000 ) {

		this.name = '';

		this.color = new Color( color );

		this.near = near;
		this.far = far;

	}

	clone() {

		return new Fog( this.color, this.near, this.far );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

}

Fog.prototype.isFog = true;

class Scene extends Object3D {

	constructor() {

		super();

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		return data;

	}

}

Scene.prototype.isScene = true;

class InterleavedBuffer {

	constructor( array, stride ) {

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

		this.uuid = generateUUID();

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	copy( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	clone( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new this.constructor( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	toJSON( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

}

InterleavedBuffer.prototype.isInterleavedBuffer = true;

const _vector$6 = /*@__PURE__*/ new Vector3();

class InterleavedBufferAttribute {

	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		this.name = '';

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	get count() {

		return this.data.count;

	}

	get array() {

		return this.data.array;

	}

	set needsUpdate( value ) {

		this.data.needsUpdate = value;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.x = this.getX( i );
			_vector$6.y = this.getY( i );
			_vector$6.z = this.getZ( i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.x = this.getX( i );
			_vector$6.y = this.getY( i );
			_vector$6.z = this.getZ( i );

			_vector$6.applyNormalMatrix( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.x = this.getX( i );
			_vector$6.y = this.getY( i );
			_vector$6.z = this.getZ( i );

			_vector$6.transformDirection( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	setX( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	}

	setY( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	}

	setZ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	}

	setW( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	}

	getX( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	}

	getY( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	}

	getZ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	}

	getW( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	}

	setXY( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

	clone( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	}

	toJSON( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// deinterleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interlaved attribtue

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

}

InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;

/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

class SpriteMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.transparent = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	}

}

SpriteMaterial.prototype.isSpriteMaterial = true;

let _geometry;

const _intersectPoint = /*@__PURE__*/ new Vector3();
const _worldScale = /*@__PURE__*/ new Vector3();
const _mvPosition = /*@__PURE__*/ new Vector3();

const _alignedPosition = /*@__PURE__*/ new Vector2();
const _rotatedPosition = /*@__PURE__*/ new Vector2();
const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

const _vA = /*@__PURE__*/ new Vector3();
const _vB = /*@__PURE__*/ new Vector3();
const _vC = /*@__PURE__*/ new Vector3();

const _uvA = /*@__PURE__*/ new Vector2();
const _uvB = /*@__PURE__*/ new Vector2();
const _uvC = /*@__PURE__*/ new Vector2();

class Sprite extends Object3D {

	constructor( material ) {

		super();

		this.type = 'Sprite';

		if ( _geometry === undefined ) {

			_geometry = new BufferGeometry();

			const float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );

			const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		this.geometry = _geometry;
		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		this.center = new Vector2( 0.5, 0.5 );

	}

	raycast( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		const rotation = this.material.rotation;
		let sin, cos;

		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		const center = this.center;

		transformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA.set( 0, 0 );
		_uvB.set( 1, 0 );
		_uvC.set( 1, 1 );

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getUV( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),
			face: null,
			object: this

		} );

	}

	copy( source ) {

		super.copy( source );

		if ( source.center !== undefined ) this.center.copy( source.center );

		this.material = source.material;

		return this;

	}

}

Sprite.prototype.isSprite = true;

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

const _v1$2 = /*@__PURE__*/ new Vector3();
const _v2$1 = /*@__PURE__*/ new Vector3();

class LOD extends Object3D {

	constructor() {

		super();

		this._currentLevel = 0;

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			isLOD: {
				value: true,
			}
		} );

		this.autoUpdate = true;

	}

	copy( source ) {

		super.copy( source, false );

		const levels = source.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	}

	addLevel( object, distance = 0 ) {

		distance = Math.abs( distance );

		const levels = this.levels;

		let l;

		for ( l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

		return this;

	}

	getCurrentLevel() {

		return this._currentLevel;

	}

	getObjectForDistance( distance ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	}

	raycast( raycaster, intersects ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			_v1$2.setFromMatrixPosition( this.matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( _v1$2 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	}

	update( camera ) {

		const levels = this.levels;

		if ( levels.length > 1 ) {

			_v1$2.setFromMatrixPosition( camera.matrixWorld );
			_v2$1.setFromMatrixPosition( this.matrixWorld );

			const distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		const levels = this.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

}

const _basePosition = /*@__PURE__*/ new Vector3();

const _skinIndex = /*@__PURE__*/ new Vector4();
const _skinWeight = /*@__PURE__*/ new Vector4();

const _vector$5 = /*@__PURE__*/ new Vector3();
const _matrix = /*@__PURE__*/ new Matrix4();

class SkinnedMesh extends Mesh {

	constructor( geometry, material ) {

		super( geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

	}

	copy( source ) {

		super.copy( source );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		return this;

	}

	bind( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	}

	pose() {

		this.skeleton.pose();

	}

	normalizeSkinWeights() {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.x = skinWeight.getX( i );
			vector.y = skinWeight.getY( i );
			vector.z = skinWeight.getZ( i );
			vector.w = skinWeight.getW( i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	}

	boneTransform( index, target ) {

		const skeleton = this.skeleton;
		const geometry = this.geometry;

		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		_basePosition.copy( target ).applyMatrix4( this.bindMatrix );

		target.set( 0, 0, 0 );

		for ( let i = 0; i < 4; i ++ ) {

			const weight = _skinWeight.getComponent( i );

			if ( weight !== 0 ) {

				const boneIndex = _skinIndex.getComponent( i );

				_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				target.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );

			}

		}

		return target.applyMatrix4( this.bindMatrixInverse );

	}

}

SkinnedMesh.prototype.isSkinnedMesh = true;

class Bone extends Object3D {

	constructor() {

		super();

		this.type = 'Bone';

	}

}

Bone.prototype.isBone = true;

class DataTexture extends Texture {

	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data, width: width, height: height };

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

		this.needsUpdate = true;

	}

}

DataTexture.prototype.isDataTexture = true;

const _offsetMatrix = /*@__PURE__*/ new Matrix4();
const _identityMatrix = /*@__PURE__*/ new Matrix4();

class Skeleton {

	constructor( bones = [], boneInverses = [] ) {

		this.uuid = generateUUID();

		this.bones = bones.slice( 0 );
		this.boneInverses = boneInverses;
		this.boneMatrices = null;

		this.boneTexture = null;
		this.boneTextureSize = 0;

		this.frame = - 1;

		this.init();

	}

	init() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	calculateInverses() {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	}

	pose() {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	}

	update() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	}

	clone() {

		return new Skeleton( this.bones, this.boneInverses );

	}

	computeBoneTexture() {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = ceilPowerOfTwo( size );
		size = Math.max( size, 4 );

		const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		boneMatrices.set( this.boneMatrices ); // copy current values

		const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

		this.boneMatrices = boneMatrices;
		this.boneTexture = boneTexture;
		this.boneTextureSize = size;

		return this;

	}

	getBoneByName( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	}

	dispose( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	}

	fromJSON( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

}

class InstancedBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

		if ( typeof normalized === 'number' ) {

			meshPerAttribute = normalized;

			normalized = false;

			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

		}

		super( array, itemSize, normalized );

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

}

InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

const _instanceIntersects = [];

const _mesh = /*@__PURE__*/ new Mesh();

class InstancedMesh extends Mesh {

	constructor( geometry, material, count ) {

		super( geometry, material );

		this.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );
		this.instanceColor = null;

		this.count = count;

		this.frustumCulled = false;

	}

	copy( source ) {

		super.copy( source );

		this.instanceMatrix.copy( source.instanceMatrix );

		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		this.count = source.count;

		return this;

	}

	getColorAt( index, color ) {

		color.fromArray( this.instanceColor.array, index * 3 );

	}

	getMatrixAt( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	}

	raycast( raycaster, intersects ) {

		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;

		_mesh.geometry = this.geometry;
		_mesh.material = this.material;

		if ( _mesh.material === undefined ) return;

		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;

			_mesh.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				const intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	}

	setColorAt( index, color ) {

		if ( this.instanceColor === null ) {

			this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );

		}

		color.toArray( this.instanceColor.array, index * 3 );

	}

	setMatrixAt( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	}

	updateMorphTargets() {

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

InstancedMesh.prototype.isInstancedMesh = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

class LineBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		return this;

	}

}

LineBasicMaterial.prototype.isLineBasicMaterial = true;

const _start$1 = /*@__PURE__*/ new Vector3();
const _end$1 = /*@__PURE__*/ new Vector3();
const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
const _ray$1 = /*@__PURE__*/ new Ray();
const _sphere$1 = /*@__PURE__*/ new Sphere();

class Line extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		super();

		this.type = 'Line';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source ) {

		super.copy( source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	computeLineDistances() {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [ 0 ];

				for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

					_start$1.fromBufferAttribute( positionAttribute, i - 1 );
					_end$1.fromBufferAttribute( positionAttribute, i );

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += _start$1.distanceTo( _end$1 );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere );
		_sphere$1.applyMatrix4( matrixWorld );
		_sphere$1.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const vStart = new Vector3();
		const vEnd = new Vector3();
		const interSegment = new Vector3();
		const interRay = new Vector3();
		const step = this.isLineSegments ? 2 : 1;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );

					vStart.fromBufferAttribute( positionAttribute, a );
					vEnd.fromBufferAttribute( positionAttribute, b );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					vStart.fromBufferAttribute( positionAttribute, i );
					vEnd.fromBufferAttribute( positionAttribute, i + 1 );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

}

Line.prototype.isLine = true;

const _start = /*@__PURE__*/ new Vector3();
const _end = /*@__PURE__*/ new Vector3();

class LineSegments extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.type = 'LineSegments';

	}

	computeLineDistances() {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [];

				for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					_start.fromBufferAttribute( positionAttribute, i );
					_end.fromBufferAttribute( positionAttribute, i + 1 );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		return this;

	}

}

LineSegments.prototype.isLineSegments = true;

class LineLoop extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.type = 'LineLoop';

	}

}

LineLoop.prototype.isLineLoop = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 * }
 */

class PointsMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	}

}

PointsMaterial.prototype.isPointsMaterial = true;

const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray = /*@__PURE__*/ new Ray();
const _sphere = /*@__PURE__*/ new Sphere();
const _position$2 = /*@__PURE__*/ new Vector3();

class Points extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		super();

		this.type = 'Points';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source ) {

		super.copy( source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i ++ ) {

					const a = index.getX( i );

					_position$2.fromBufferAttribute( positionAttribute, a );

					testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end; i < l; i ++ ) {

					_position$2.fromBufferAttribute( positionAttribute, i );

					testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			}

		} else {

			console.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

}

Points.prototype.isPoints = true;

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

class VideoTexture extends Texture {

	constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.format = format !== undefined ? format : RGBFormat;

		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

		this.generateMipmaps = false;

		const scope = this;

		function updateVideo() {

			scope.needsUpdate = true;
			video.requestVideoFrameCallback( updateVideo );

		}

		if ( 'requestVideoFrameCallback' in video ) {

			video.requestVideoFrameCallback( updateVideo );

		}

	}

	clone() {

		return new this.constructor( this.image ).copy( this );

	}

	update() {

		const video = this.image;
		const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

}

VideoTexture.prototype.isVideoTexture = true;

class CompressedTexture extends Texture {

	constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

}

CompressedTexture.prototype.isCompressedTexture = true;

class CanvasTexture extends Texture {

	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

}

CanvasTexture.prototype.isCanvasTexture = true;

class DepthTexture extends Texture {

	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;

	}


}

DepthTexture.prototype.isDepthTexture = true;

class CircleGeometry extends BufferGeometry {

	constructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );

	}

}

class CylinderGeometry extends BufferGeometry {

	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();
		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			const normal = new Vector3();
			const vertex = new Vector3();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new Vector2();
			const vertex = new Vector3();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : - 1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	static fromJSON( data ) {

		return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class ConeGeometry extends CylinderGeometry {

	constructor( radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	static fromJSON( data ) {

		return new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class PolyhedronGeometry extends BufferGeometry {

	constructor( vertices = [], indices = [], radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	static fromJSON( data ) {

		return new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );

	}

}

class DodecahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
		const r = 1 / t;

		const vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		super( vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new DodecahedronGeometry( data.radius, data.detail );

	}

}

const _v0 = new Vector3();
const _v1$1 = new Vector3();
const _normal = new Vector3();
const _triangle = new Triangle();

class EdgesGeometry extends BufferGeometry {

	constructor( geometry = null, thresholdAngle = 1 ) {

		super();
		this.type = 'EdgesGeometry';

		this.parameters = {
			geometry: geometry,
			thresholdAngle: thresholdAngle
		};

		if ( geometry !== null ) {

			const precisionPoints = 4;
			const precision = Math.pow( 10, precisionPoints );
			const thresholdDot = Math.cos( DEG2RAD * thresholdAngle );

			const indexAttr = geometry.getIndex();
			const positionAttr = geometry.getAttribute( 'position' );
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

			const indexArr = [ 0, 0, 0 ];
			const vertKeys = [ 'a', 'b', 'c' ];
			const hashes = new Array( 3 );

			const edgeData = {};
			const vertices = [];
			for ( let i = 0; i < indexCount; i += 3 ) {

				if ( indexAttr ) {

					indexArr[ 0 ] = indexAttr.getX( i );
					indexArr[ 1 ] = indexAttr.getX( i + 1 );
					indexArr[ 2 ] = indexAttr.getX( i + 2 );

				} else {

					indexArr[ 0 ] = i;
					indexArr[ 1 ] = i + 1;
					indexArr[ 2 ] = i + 2;

				}

				const { a, b, c } = _triangle;
				a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
				b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
				c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
				_triangle.getNormal( _normal );

				// create hashes for the edge from the vertices
				hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
				hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
				hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

				// skip degenerate triangles
				if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

					continue;

				}

				// iterate over every edge
				for ( let j = 0; j < 3; j ++ ) {

					// get the first and next vertex making up the edge
					const jNext = ( j + 1 ) % 3;
					const vecHash0 = hashes[ j ];
					const vecHash1 = hashes[ jNext ];
					const v0 = _triangle[ vertKeys[ j ] ];
					const v1 = _triangle[ vertKeys[ jNext ] ];

					const hash = `${ vecHash0 }_${ vecHash1 }`;
					const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

					if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

							vertices.push( v0.x, v0.y, v0.z );
							vertices.push( v1.x, v1.y, v1.z );

						}

						edgeData[ reverseHash ] = null;

					} else if ( ! ( hash in edgeData ) ) {

						// if we've already got an edge here then skip adding a new one
						edgeData[ hash ] = {

							index0: indexArr[ j ],
							index1: indexArr[ jNext ],
							normal: _normal.clone(),

						};

					}

				}

			}

			// iterate over all remaining, unmatched edges and add them to the vertex array
			for ( const key in edgeData ) {

				if ( edgeData[ key ] ) {

					const { index0, index1 } = edgeData[ key ];
					_v0.fromBufferAttribute( positionAttr, index0 );
					_v1$1.fromBufferAttribute( positionAttr, index1 );

					vertices.push( _v0.x, _v0.y, _v0.z );
					vertices.push( _v1$1.x, _v1$1.y, _v1$1.z );

				}

			}

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

}

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

class Curve {

	constructor() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	}

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	}

	// Get sequence of points using getPoint( t )

	getPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	}

	// Get sequence of points using getPointAt( u )

	getSpacedPoints( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	}

	// Get total curve arc length

	getLength() {

		const lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	}

	// Get list of cumulative segment lengths

	getLengths( divisions = this.arcLengthDivisions ) {

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		const cache = [];
		let current, last = this.getPoint( 0 );
		let sum = 0;

		cache.push( 0 );

		for ( let p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	}

	updateArcLengths() {

		this.needsUpdate = true;
		this.getLengths();

	}

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping( u, distance ) {

		const arcLengths = this.getLengths();

		let i = 0;
		const il = arcLengths.length;

		let targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[ i ];
		const lengthAfter = arcLengths[ i + 1 ];

		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		const t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	}

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent( t, optionalTarget ) {

		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		const pt1 = this.getPoint( t1 );
		const pt2 = this.getPoint( t2 );

		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	}

	getTangentAt( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	}

	computeFrenetFrames( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3();

		const tangents = [];
		const normals = [];
		const binormals = [];

		const vec = new Vector3();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for ( let i = 0; i <= segments; i ++ ) {

			const u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new Vector3() );

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		let min = Number.MAX_VALUE;
		const tx = Math.abs( tangents[ 0 ].x );
		const ty = Math.abs( tangents[ 0 ].y );
		const tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( let i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( let i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	}

	fromJSON( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

}

class EllipseCurve extends Curve {

	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		super();

		this.type = 'EllipseCurve';

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

		this.aRotation = aRotation;

	}

	getPoint( t, optionalTarget ) {

		const point = optionalTarget || new Vector2();

		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos( angle );
		let y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			const cos = Math.cos( this.aRotation );
			const sin = Math.sin( this.aRotation );

			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	}

	copy( source ) {

		super.copy( source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	}

}

EllipseCurve.prototype.isEllipseCurve = true;

class ArcCurve extends EllipseCurve {

	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

}

ArcCurve.prototype.isArcCurve = true;

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

const tmp = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

class CatmullRomCurve3 extends Curve {

	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		super();

		this.type = 'CatmullRomCurve3';

		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const points = this.points;
		const l = points.length;

		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		let intPoint = Math.floor( p );
		let weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		let p0, p3; // 4 points (p1 & p2 defined below)

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		const p1 = points[ intPoint % l ];
		const p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	}

}

CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	const v0 = ( p2 - p0 ) * 0.5;
	const v1 = ( p3 - p1 ) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	const k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

class CubicBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

		super();

		this.type = 'CubicBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

CubicBezierCurve.prototype.isCubicBezierCurve = true;

class CubicBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

		super();

		this.type = 'CubicBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

class LineCurve extends Curve {

	constructor( v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.type = 'LineCurve';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget ) {

		const tangent = optionalTarget || new Vector2();

		tangent.copy( this.v2 ).sub( this.v1 ).normalize();

		return tangent;

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

LineCurve.prototype.isLineCurve = true;

class LineCurve3 extends Curve {

	constructor( v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.type = 'LineCurve3';
		this.isLineCurve3 = true;

		this.v1 = v1;
		this.v2 = v2;

	}
	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}
	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}
	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}
	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}
	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

class QuadraticBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

class SplineCurve extends Curve {

	constructor( points = [] ) {

		super();

		this.type = 'SplineCurve';

		this.points = points;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const points = this.points;
		const p = ( points.length - 1 ) * t;

		const intPoint = Math.floor( p );
		const weight = p - intPoint;

		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		const p1 = points[ intPoint ];
		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	}

}

SplineCurve.prototype.isSplineCurve = true;

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends Curve {

	constructor() {

		super();

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	add( curve ) {

		this.curves.push( curve );

	}

	closePath() {

		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[ 0 ].getPoint( 0 );
		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new LineCurve( endPoint, startPoint ) );

		}

	}

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint( t, optionalTarget ) {

		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				const diff = curveLengths[ i ] - d;
				const curve = this.curves[ i ];

				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u, optionalTarget );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	}

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength() {

		const lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	}

	// cacheLengths must be recalculated.
	updateArcLengths() {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	}

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	}

	getSpacedPoints( divisions = 40 ) {

		const points = [];

		for ( let i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	getPoints( divisions = 12 ) {

		const points = [];
		let last;

		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			const curve = curves[ i ];
			const resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
				: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
					: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
						: divisions;

			const pts = curve.getPoints( resolution );

			for ( let j = 0; j < pts.length; j ++ ) {

				const point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	copy( source ) {

		super.copy( source );

		this.curves = [];

		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			const curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			const curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			const curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

}

class Path extends CurvePath {

	constructor( points ) {

		super();
		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	setFromPoints( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( let i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	}

	moveTo( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	}

	lineTo( x, y ) {

		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		const curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		const curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	splineThru( pts /*Array of Vector*/ ) {

		const npts = [ this.currentPoint.clone() ].concat( pts );

		const curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	}

	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	}

	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		const lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	}

	copy( source ) {

		super.copy( source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.currentPoint = this.currentPoint.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

}

class Shape extends Path {

	constructor( points ) {

		super( points );

		this.uuid = generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	getPointsHoles( divisions ) {

		const holesPts = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	}

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	}

	copy( source ) {

		super.copy( source );

		this.holes = [];

		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			const hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.uuid = this.uuid;
		data.holes = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			const hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			const hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */

const Earcut = {

	triangulate: function ( data, holeIndices, dim = 2 ) {

		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		let outerNode = linkedList( data, 0, outerLen, dim, true );
		const triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		let minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( let i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 1 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	let i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	let p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	let stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim );
			triangles.push( ear.i / dim );
			triangles.push( next.i / dim );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	let p = ear.next.next;

	while ( p !== ear.prev ) {

		if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// triangle bbox; min & max are calculated like this for speed
	const minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
		minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
		maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
		maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

	// z-order range for the current triangle bbox;
	const minZ = zOrder( minTX, minTY, minX, minY, invSize ),
		maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	let p = start;
	do {

		const a = p.prev,
			b = p.next.next;

		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim );
			triangles.push( p.i / dim );
			triangles.push( b.i / dim );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return filterPoints( p );

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {

		let b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				let c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize );
				earcutLinked( c, triangles, dim, minX, minY, invSize );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	const queue = [];
	let i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		eliminateHole( queue[ i ], outerNode );
		outerNode = filterPoints( outerNode, outerNode.next );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole( hole, outerNode ) {

	outerNode = findHoleBridge( hole, outerNode );
	if ( outerNode ) {

		const b = splitPolygon( outerNode, hole );

		// filter collinear points around the cuts
		filterPoints( outerNode, outerNode.next );
		filterPoints( b, b.next );

	}

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	let p = outerNode;
	const hx = hole.x;
	const hy = hole.y;
	let qx = - Infinity, m;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				if ( x === hx ) {

					if ( hy === p.y ) return p;
					if ( hy === p.next.y ) return p.next;

				}

				m = p.x < p.next.x ? p : p.next;

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity, tan;

	p = m;

	do {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	} while ( p !== stop );

	return m;

}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector( m, p ) {

	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	let p = start;
	do {

		if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	let i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = 32767 * ( x - minX ) * invSize;
	y = 32767 * ( y - minY ) * invSize;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	let p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
			( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
			( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
		( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
		( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
		equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	const o1 = sign( area( p1, q1, p2 ) );
	const o2 = sign( area( p1, q1, q2 ) );
	const o3 = sign( area( p2, q2, p1 ) );
	const o4 = sign( area( p2, q2, q1 ) );

	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;

}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment( p, q, r ) {

	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

}

function sign( num ) {

	return num > 0 ? 1 : num < 0 ? - 1 : 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	let p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	let p = a,
		inside = false;
	const px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
				( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	const a2 = new Node( a.i, a.x, a.y ),
		b2 = new Node( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	const p = new Node( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = null;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	let sum = 0;
	for ( let i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}

class ShapeUtils {

	// calculate area of the contour polygon

	static area( contour ) {

		const n = contour.length;
		let a = 0.0;

		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	}

	static isClockWise( pts ) {

		return ShapeUtils.area( pts ) < 0;

	}

	static triangulateShape( contour, holes ) {

		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		let holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( let i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		const triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( let i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

}

function removeDupEndPts( points ) {

	const l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( let i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

class ExtrudeGeometry extends BufferGeometry {

	constructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {

		super();

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		const scope = this;

		const verticesArray = [];
		const uvArray = [];

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			let depth = options.depth !== undefined ? options.depth : 1;

			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			const extrudePath = options.extrudePath;

			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			// deprecated options

			if ( options.amount !== undefined ) {

				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;

			}

			//

			let extrudePts, extrudeByPath = false;
			let splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;

			}

			// Variables initialization

			const shapePoints = shape.extractPoints( curveSegments );

			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;

			const reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			const faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			const vlen = vertices.length, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt( v_prev_lensq );
					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			const contourMovements = [];

			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			const holesMovements = [];
			let oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				oneHoleMovements = [];

				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( let b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for ( let i = 0; i < vlen; i ++ ) {

				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			for ( let s = 1; s <= steps; s ++ ) {

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				const start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				let i = contour.length;

				while ( -- i >= 0 ) {

					const j = i;
					let k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						const slen1 = vlen * s;
						const slen2 = vlen * ( s + 1 );

						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;
		const options = this.parameters.options;

		return toJSON$1( shapes, options, data );

	}

	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		const extrudePath = data.options.extrudePath;

		if ( extrudePath !== undefined ) {

			data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

		}

		return new ExtrudeGeometry( geometryShapes, data.options );

	}

}

const WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const a_z = vertices[ indexA * 3 + 2 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const b_z = vertices[ indexB * 3 + 2 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];
		const c_z = vertices[ indexC * 3 + 2 ];
		const d_x = vertices[ indexD * 3 ];
		const d_y = vertices[ indexD * 3 + 1 ];
		const d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}

};

function toJSON$1( shapes, options, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

class IcosahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new IcosahedronGeometry( data.radius, data.detail );

	}

}

class LatheGeometry extends BufferGeometry {

	constructor( points = [ new Vector2( 0, 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, - 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

		super();

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments );

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = clamp( phiLength, 0, Math.PI * 2 );

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices and uvs

		for ( let i = 0; i <= segments; i ++ ) {

			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin( phi );
			const cos = Math.cos( phi );

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );


			}

		}

		// indices

		for ( let i = 0; i < segments; i ++ ) {

			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

				const base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if ( phiLength === Math.PI * 2 ) {

			const normals = this.attributes.normal.array;
			const n1 = new Vector3();
			const n2 = new Vector3();
			const n = new Vector3();

			// this is the buffer offset for the last line of vertices

			const base = segments * points.length * 3;

			for ( let i = 0, j = 0; i < points.length; i ++, j += 3 ) {

				// select the normal of the vertex in the first line

				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];

				// select the normal of the vertex in the last line

				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];

				// average normals

				n.addVectors( n1, n2 ).normalize();

				// assign the new values to both normals

				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

			}

		}

	}

	static fromJSON( data ) {

		return new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );

	}

}

class OctahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new OctahedronGeometry( data.radius, data.detail );

	}

}

class RingGeometry extends BufferGeometry {

	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );

	}

}

class ShapeGeometry extends BufferGeometry {

	constructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {

		super();
		this.type = 'ShapeGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( let i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints( curveSegments );

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				const vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				const a = face[ 0 ] + indexOffset;
				const b = face[ 1 ] + indexOffset;
				const c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	toJSON() {

		const data = super.toJSON();

		const shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	}

	static fromJSON( data, shapes ) {

		const geometryShapes = [];

		for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

			const shape = shapes[ data.shapes[ j ] ];

			geometryShapes.push( shape );

		}

		return new ShapeGeometry( geometryShapes, data.curveSegments );

	}

}

function toJSON( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

class SphereGeometry extends BufferGeometry {

	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();
		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy == 0 && thetaStart == 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

				uOffset = - 0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

	}

}

class TetrahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		const indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new TetrahedronGeometry( data.radius, data.detail );

	}

}

class TorusGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2 ) {

		super();
		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );

	}

}

class TorusKnotGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();
		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();

		const P1 = new Vector3();
		const P2 = new Vector3();

		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	static fromJSON( data ) {

		return new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );

	}

}

class TubeGeometry extends BufferGeometry {

	constructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

		super();
		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		const frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const uv = new Vector2();
		let P = new Vector3();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( let i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			const N = frames.normals[ i ];
			const B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( let j = 0; j <= radialSegments; j ++ ) {

				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin( v );
				const cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				for ( let j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	toJSON() {

		const data = super.toJSON();

		data.path = this.parameters.path.toJSON();

		return data;

	}

	static fromJSON( data ) {

		// This only works for built-in curves (e.g. CatmullRomCurve3).
		// User defined curves or instances of CurvePath will not be deserialized.
		return new TubeGeometry(
			new Curves[ data.path.type ]().fromJSON( data.path ),
			data.tubularSegments,
			data.radius,
			data.radialSegments,
			data.closed
		);

	}

}

class WireframeGeometry extends BufferGeometry {

	constructor( geometry = null ) {

		super();
		this.type = 'WireframeGeometry';

		this.parameters = {
			geometry: geometry
		};

		if ( geometry !== null ) {

			// buffer

			const vertices = [];
			const edges = new Set();

			// helper variables

			const start = new Vector3();
			const end = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all eges without duplicates

				for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

					const group = groups[ o ];

					const groupStart = group.start;
					const groupCount = group.count;

					for ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {

						for ( let j = 0; j < 3; j ++ ) {

							const index1 = indices.getX( i + j );
							const index2 = indices.getX( i + ( j + 1 ) % 3 );

							start.fromBufferAttribute( position, index1 );
							end.fromBufferAttribute( position, index2 );

							if ( isUniqueEdge( start, end, edges ) === true ) {

								vertices.push( start.x, start.y, start.z );
								vertices.push( end.x, end.y, end.z );

							}

						}

					}

				}

			} else {

				// non-indexed BufferGeometry

				const position = geometry.attributes.position;

				for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( let j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j;
						const index2 = 3 * i + ( ( j + 1 ) % 3 );

						start.fromBufferAttribute( position, index1 );
						end.fromBufferAttribute( position, index2 );

						if ( isUniqueEdge( start, end, edges ) === true ) {

							vertices.push( start.x, start.y, start.z );
							vertices.push( end.x, end.y, end.z );

						}

					}

				}

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

}

function isUniqueEdge( start, end, edges ) {

	const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
	const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

	if ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {

		return false;

	} else {

		edges.add( hash1, hash2 );
		return true;

	}

}

var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BoxGeometry: BoxGeometry,
	BoxBufferGeometry: BoxGeometry,
	CircleGeometry: CircleGeometry,
	CircleBufferGeometry: CircleGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronGeometry,
	EdgesGeometry: EdgesGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	ExtrudeBufferGeometry: ExtrudeGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronGeometry,
	PlaneGeometry: PlaneGeometry,
	PlaneBufferGeometry: PlaneGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingGeometry,
	ShapeGeometry: ShapeGeometry,
	ShapeBufferGeometry: ShapeGeometry,
	SphereGeometry: SphereGeometry,
	SphereBufferGeometry: SphereGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeGeometry,
	WireframeGeometry: WireframeGeometry
});

/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

class ShadowMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.transparent = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		return this;

	}

}

ShadowMaterial.prototype.isShadowMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  flatShading: <bool>
 * }
 */

class MeshStandardMaterial extends Material {

	constructor( parameters ) {

		super();

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 1.0;
		this.metalness = 0.0;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  ior: <float>,
 *  reflectivity: <float>,
 *
 *  sheen: <float>,
 *  sheenColor: <Color>,
 *  sheenColorMap: new THREE.Texture( <Image> ),
 *  sheenRoughness: <float>,
 *  sheenRoughnessMap: new THREE.Texture( <Image> ),
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> ),
 *
 *  thickness: <float>,
 *  thicknessMap: new THREE.Texture( <Image> ),
 *  attenuationDistance: <float>,
 *  attenuationColor: <Color>,
 *
 *  specularIntensity: <float>,
 *  specularIntensityMap: new THREE.Texture( <Image> ),
 *  specularColor: <Color>,
 *  specularColorMap: new THREE.Texture( <Image> )
 * }
 */

class MeshPhysicalMaterial extends MeshStandardMaterial {

	constructor( parameters ) {

		super();

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2( 1, 1 );
		this.clearcoatNormalMap = null;

		this.ior = 1.5;

		Object.defineProperty( this, 'reflectivity', {
			get: function () {

				return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

			},
			set: function ( reflectivity ) {

				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

			}
		} );

		this.sheenColor = new Color( 0x000000 );
		this.sheenColorMap = null;
		this.sheenRoughness = 1.0;
		this.sheenRoughnessMap = null;

		this.transmissionMap = null;

		this.thickness = 0.01;
		this.thicknessMap = null;
		this.attenuationDistance = 0.0;
		this.attenuationColor = new Color( 1, 1, 1 );

		this.specularIntensity = 1.0;
		this.specularIntensityMap = null;
		this.specularColor = new Color( 1, 1, 1 );
		this.specularColorMap = null;

		this._sheen = 0.0;
		this._clearcoat = 0;
		this._transmission = 0;

		this.setValues( parameters );

	}

	get sheen() {

		return this._sheen;

	}

	set sheen( value ) {

		if ( this._sheen > 0 !== value > 0 ) {

			this.version ++;

		}

		this._sheen = value;

	}

	get clearcoat() {

		return this._clearcoat;

	}

	set clearcoat( value ) {

		if ( this._clearcoat > 0 !== value > 0 ) {

			this.version ++;

		}

		this._clearcoat = value;

	}

	get transmission() {

		return this._transmission;

	}

	set transmission( value ) {

		if ( this._transmission > 0 !== value > 0 ) {

			this.version ++;

		}

		this._transmission = value;

	}

	copy( source ) {

		super.copy( source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.ior = source.ior;

		this.sheen = source.sheen;
		this.sheenColor.copy( source.sheenColor );
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy( source.attenuationColor );

		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy( source.specularColor );
		this.specularColorMap = source.specularColorMap;

		return this;

	}

}

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  flatShading: <bool>
 * }
 */

class MeshPhongMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 * }
 */

class MeshToonMaterial extends Material {

	constructor( parameters ) {

		super();

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;
		this.gradientMap = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;
		this.gradientMap = source.gradientMap;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		return this;

	}

}

MeshToonMaterial.prototype.isMeshToonMaterial = true;

/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  flatShading: <bool>
 * }
 */

class MeshNormalMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 * }
 */

class MeshLambertMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		return this;

	}

}

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  flatShading: <bool>
 * }
 */

class MeshMatcapMaterial extends Material {

	constructor( parameters ) {

		super();

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.flatShading = false;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

class LineDashedMaterial extends LineBasicMaterial {

	constructor( parameters ) {

		super();

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	}

}

LineDashedMaterial.prototype.isLineDashedMaterial = true;

var Materials = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ShadowMaterial: ShadowMaterial,
	SpriteMaterial: SpriteMaterial,
	RawShaderMaterial: RawShaderMaterial,
	ShaderMaterial: ShaderMaterial,
	PointsMaterial: PointsMaterial,
	MeshPhysicalMaterial: MeshPhysicalMaterial,
	MeshStandardMaterial: MeshStandardMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshToonMaterial: MeshToonMaterial,
	MeshNormalMaterial: MeshNormalMaterial,
	MeshLambertMaterial: MeshLambertMaterial,
	MeshDepthMaterial: MeshDepthMaterial,
	MeshDistanceMaterial: MeshDistanceMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	MeshMatcapMaterial: MeshMatcapMaterial,
	LineDashedMaterial: LineDashedMaterial,
	LineBasicMaterial: LineBasicMaterial,
	Material: Material
});

const AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function ( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function ( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
			! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function ( object ) {

		return ArrayBuffer.isView( object ) &&
			! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function ( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		const n = times.length;
		const result = new Array( n );
		for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function ( values, stride, order ) {

		const nValues = values.length;
		const result = new values.constructor( nValues );

		for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			const srcOffset = order[ i ] * stride;

			for ( let j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		let i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		let value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	},

	subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

		const clip = sourceClip.clone();

		clip.name = name;

		const tracks = [];

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			const track = clip.tracks[ i ];
			const valueSize = track.getValueSize();

			const times = [];
			const values = [];

			for ( let j = 0; j < track.times.length; ++ j ) {

				const frame = track.times[ j ] * fps;

				if ( frame < startFrame || frame >= endFrame ) continue;

				times.push( track.times[ j ] );

				for ( let k = 0; k < valueSize; ++ k ) {

					values.push( track.values[ j * valueSize + k ] );

				}

			}

			if ( times.length === 0 ) continue;

			track.times = AnimationUtils.convertArray( times, track.times.constructor );
			track.values = AnimationUtils.convertArray( values, track.values.constructor );

			tracks.push( track );

		}

		clip.tracks = tracks;

		// find minimum .times value across all tracks in the trimmed clip

		let minStartTime = Infinity;

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				minStartTime = clip.tracks[ i ].times[ 0 ];

			}

		}

		// shift all tracks such that clip begins at t=0

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			clip.tracks[ i ].shift( - 1 * minStartTime );

		}

		clip.resetDuration();

		return clip;

	},

	makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

		if ( fps <= 0 ) fps = 30;

		const numTracks = referenceClip.tracks.length;
		const referenceTime = referenceFrame / fps;

		// Make each track's values relative to the values at the reference frame
		for ( let i = 0; i < numTracks; ++ i ) {

			const referenceTrack = referenceClip.tracks[ i ];
			const referenceTrackType = referenceTrack.ValueTypeName;

			// Skip this track if it's non-numeric
			if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			// Find the track in the target clip whose name and type matches the reference track
			const targetTrack = targetClip.tracks.find( function ( track ) {

				return track.name === referenceTrack.name
					&& track.ValueTypeName === referenceTrackType;

			} );

			if ( targetTrack === undefined ) continue;

			let referenceOffset = 0;
			const referenceValueSize = referenceTrack.getValueSize();

			if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				referenceOffset = referenceValueSize / 3;

			}

			let targetOffset = 0;
			const targetValueSize = targetTrack.getValueSize();

			if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				targetOffset = targetValueSize / 3;

			}

			const lastIndex = referenceTrack.times.length - 1;
			let referenceValue;

			// Find the value to subtract out of the track
			if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				// Reference frame is earlier than the first keyframe, so just use the first keyframe
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				// Reference frame is after the last keyframe, so just use the last keyframe
				const startIndex = lastIndex * referenceValueSize + referenceOffset;
				const endIndex = startIndex + referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else {

				// Interpolate to the reference value
				const interpolant = referenceTrack.createInterpolant();
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				interpolant.evaluate( referenceTime );
				referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

			}

			// Conjugate the quaternion
			if ( referenceTrackType === 'quaternion' ) {

				const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
				referenceQuat.toArray( referenceValue );

			}

			// Subtract the reference value from all of the track values

			const numTimes = targetTrack.times.length;
			for ( let j = 0; j < numTimes; ++ j ) {

				const valueStart = j * targetValueSize + targetOffset;

				if ( referenceTrackType === 'quaternion' ) {

					// Multiply the conjugate for quaternion track types
					Quaternion.multiplyQuaternionsFlat(
						targetTrack.values,
						valueStart,
						referenceValue,
						0,
						targetTrack.values,
						valueStart
					);

				} else {

					const valueEnd = targetValueSize - targetOffset * 2;

					// Subtract each value for all other numeric track types
					for ( let k = 0; k < valueEnd; ++ k ) {

						targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					}

				}

			}

		}

		targetClip.blendMode = AdditiveAnimationBlendMode;

		return targetClip;

	}

};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

class Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

		this.settings = null;
		this.DefaultSettings_ = {};

	}

	evaluate( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	}

	getSettings_() {

		return this.settings || this.DefaultSettings_;

	}

	copySampleValue_( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	// Template methods for derived classes:

	interpolate_( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	}

	intervalChanged_( /* i1, t0, t1 */ ) {

		// empty

	}

}

// ALIAS DEFINITIONS

Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

class CubicInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

		this.DefaultSettings_ = {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		};

	}

	intervalChanged_( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

}

class LinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

}

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */

class DiscreteInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

}

class KeyframeTrack {

	constructor( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	static toJSON( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

	InterpolantFactoryMethodDiscrete( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodLinear( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodSmooth( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	setInterpolation( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	}

	getInterpolation() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	}

	getValueSize() {

		return this.values.length / this.times.length;

	}

	// move all keyframes either forwards or backwards in time
	shift( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	}

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	}

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	}

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate() {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	}

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize() {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = AnimationUtils.arraySlice( this.times ),
			values = AnimationUtils.arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	}

	clone() {

		const times = AnimationUtils.arraySlice( this.times, 0 );
		const values = AnimationUtils.arraySlice( this.values, 0 );

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

}

KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A Track of Boolean keyframe values.
 */
class BooleanKeyframeTrack extends KeyframeTrack {}

BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of keyframe values that represent color.
 */
class ColorKeyframeTrack extends KeyframeTrack {}

ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A Track of numeric keyframe values.
 */
class NumberKeyframeTrack extends KeyframeTrack {}

NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 */

class QuaternionLinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

}

/**
 * A Track of quaternion keyframe values.
 */
class QuaternionKeyframeTrack extends KeyframeTrack {

	InterpolantFactoryMethodLinear( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

}

QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track that interpolates Strings
 */
class StringKeyframeTrack extends KeyframeTrack {}

StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of vectored keyframe values.
 */
class VectorKeyframeTrack extends KeyframeTrack {}

VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

class AnimationClip {

	constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;

		this.uuid = generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}


	static parse( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	}

	static toJSON( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	}

	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, - 1, tracks );

	}

	static findByName( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	}

	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	}

	// parse the animation.hierarchy format
	static parseAnimation( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	}

	resetDuration() {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	}

	trim() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	}

	validate() {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	}

	optimize() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

	clone() {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	}

	toJSON() {

		return this.constructor.toJSON( this );

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

const Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

class LoadingManager {

	constructor( onLoad, onProgress, onError ) {

		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		this.removeHandler = function ( regex ) {

			const index = handlers.indexOf( regex );

			if ( index !== - 1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		this.getHandler = function ( file ) {

			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				const regex = handlers[ i ];
				const loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

}

const DefaultLoadingManager = new LoadingManager();

class Loader {

	constructor( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};

	}

	load( /* url, onLoad, onProgress, onError */ ) {}

	loadAsync( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	}

	parse( /* data */ ) {}

	setCrossOrigin( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	}

	setWithCredentials( value ) {

		this.withCredentials = value;
		return this;

	}

	setPath( path ) {

		this.path = path;
		return this;

	}

	setResourcePath( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	}

	setRequestHeader( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

}

const loading = {};

class FileLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			this.manager.itemStart( url );

			setTimeout( () => {

				if ( onLoad ) onLoad( cached );

				this.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Initialise array for duplicate requests
		loading[ url ] = [];

		loading[ url ].push( {
			onLoad: onLoad,
			onProgress: onProgress,
			onError: onError,
		} );

		// create request
		const req = new Request( url, {
			headers: new Headers( this.requestHeader ),
			credentials: this.withCredentials ? 'include' : 'same-origin',
			// An abort controller could be added within a future PR
		} );

		// start the fetch
		fetch( req )
			.then( response => {

				if ( response.status === 200 || response.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( response.status === 0 ) {

						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					}

					const callbacks = loading[ url ];
					const reader = response.body.getReader();
					const contentLength = response.headers.get( 'Content-Length' );
					const total = contentLength ? parseInt( contentLength ) : 0;
					const lengthComputable = total !== 0;
					let loaded = 0;

					// periodically read data into the new stream tracking while download progress
					return new ReadableStream( {
						start( controller ) {

							readData();

							function readData() {

								reader.read().then( ( { done, value } ) => {

									if ( done ) {

										controller.close();

									} else {

										loaded += value.byteLength;

										const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
										for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

											const callback = callbacks[ i ];
											if ( callback.onProgress ) callback.onProgress( event );

										}

										controller.enqueue( value );
										readData();

									}

								} );

							}

						}

					} );

				} else {

					throw Error( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}` );

				}

			} )
			.then( stream => {

				const response = new Response( stream );

				switch ( this.responseType ) {

					case 'arraybuffer':

						return response.arrayBuffer();

					case 'blob':

						return response.blob();

					case 'document':

						return response.text()
							.then( text => {

								const parser = new DOMParser();
								return parser.parseFromString( text, this.mimeType );

							} );

					case 'json':

						return response.json();

					default:

						return response.text();

				}

			} )
			.then( data => {

				// Add to cache only on HTTP success, so that we do not cache
				// error response bodies as proper responses to requests.
				Cache.add( url, data );

				const callbacks = loading[ url ];
				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onLoad ) callback.onLoad( data );

				}

				this.manager.itemEnd( url );

			} )
			.catch( err => {

				// Abort errors and other errors are handled the same

				const callbacks = loading[ url ];
				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( err );

				}

				this.manager.itemError( url );
				this.manager.itemEnd( url );

			} );

		this.manager.itemStart( url );

	}

	setResponseType( value ) {

		this.responseType = value;
		return this;

	}

	setMimeType( value ) {

		this.mimeType = value;
		return this;

	}

}

class AnimationLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const animations = [];

		for ( let i = 0; i < json.length; i ++ ) {

			const clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

}

/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class CompressedTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const images = [];

		const texture = new CompressedTexture();

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;

					texture.image = images;
					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			for ( let i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( let f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

					texture.image = images;

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

}

class ImageLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = createElementNS( 'img' );

		function onImageLoad() {

			removeEventListeners();

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			removeEventListeners();

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		function removeEventListeners() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.substr( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}

class CubeTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( urls, onLoad, onProgress, onError ) {

		const texture = new CubeTexture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( let i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

}

/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

class DataTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const texture = new DataTexture();

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setPath( this.path );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			const texData = scope.parse( buffer );

			if ( ! texData ) return;

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.encoding !== undefined ) {

				texture.encoding = texData.encoding;

			}

			if ( texData.flipY !== undefined ) {

				texture.flipY = texData.flipY;

			}

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			if ( texData.generateMipmaps !== undefined ) {

				texture.generateMipmaps = texData.generateMipmaps;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

}

class TextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

}

class Light extends Object3D {

	constructor( color, intensity = 1 ) {

		super();

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity;

	}

	dispose() {

		// Empty here in base class; some subclasses override.

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

}

Light.prototype.isLight = true;

class HemisphereLight extends Light {

	constructor( skyColor, groundColor, intensity ) {

		super( skyColor, intensity );

		this.type = 'HemisphereLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	copy( source ) {

		Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

}

HemisphereLight.prototype.isHemisphereLight = true;

const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();

class LightShadow {

	constructor( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;
		this.blurSamples = 8;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	getViewportCount() {

		return this._viewportCount;

	}

	getFrustum() {

		return this._frustum;

	}

	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( shadowCamera.projectionMatrix );
		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	}

	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	getFrameExtents() {

		return this._frameExtents;

	}

	dispose() {

		if ( this.map ) {

			this.map.dispose();

		}

		if ( this.mapPass ) {

			this.mapPass.dispose();

		}

	}

	copy( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

class SpotLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

	copy( source ) {

		super.copy( source );

		this.focus = source.focus;

		return this;

	}

}

SpotLightShadow.prototype.isSpotLightShadow = true;

class SpotLight extends Light {

	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

		super( color, intensity );

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / Math.PI;

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

SpotLight.prototype.isSpotLight = true;

const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

class PointLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		this._cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

	}

	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

	}

}

PointLightShadow.prototype.isPointLightShadow = true;

class PointLight extends Light {

	constructor( color, intensity, distance = 0, decay = 1 ) {

		super( color, intensity );

		this.type = 'PointLight';

		this.distance = distance;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new PointLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / ( 4 * Math.PI );

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

PointLight.prototype.isPointLight = true;

class DirectionalLightShadow extends LightShadow {

	constructor() {

		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

}

DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

class DirectionalLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

DirectionalLight.prototype.isDirectionalLight = true;

class AmbientLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.type = 'AmbientLight';

	}

}

AmbientLight.prototype.isAmbientLight = true;

class RectAreaLight extends Light {

	constructor( color, intensity, width = 10, height = 10 ) {

		super( color, intensity );

		this.type = 'RectAreaLight';

		this.width = width;
		this.height = height;

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in nits)
		return this.intensity * this.width * this.height * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in nits) from the desired luminous power (in lumens)
		this.intensity = power / ( this.width * this.height * Math.PI );

	}

	copy( source ) {

		super.copy( source );

		this.width = source.width;
		this.height = source.height;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

}

RectAreaLight.prototype.isRectAreaLight = true;

/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {

	constructor() {

		this.coefficients = [];

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients.push( new Vector3() );

		}

	}

	set( coefficients ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	}

	zero() {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	}

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	}

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

		return target;

	}

	add( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	}

	addScaledSH( sh, s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	}

	scale( s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	}

	lerp( sh, alpha ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	}

	equals( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	}

	copy( sh ) {

		return this.set( sh.coefficients );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	fromArray( array, offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	static getBasisAt( normal, shBasis ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

}

SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

class LightProbe extends Light {

	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

		super( undefined, intensity );

		this.sh = sh;

	}

	copy( source ) {

		super.copy( source );

		this.sh.copy( source.sh );

		return this;

	}

	fromJSON( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

}

LightProbe.prototype.isLightProbe = true;

class MaterialLoader extends Loader {

	constructor( manager ) {

		super( manager );
		this.textures = {};

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = new Materials[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = json.sheen;
		if ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );
		if ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;
		if ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.thickness !== undefined ) material.thickness = json.thickness;
		if ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;
		if ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.format !== undefined ) material.format = json.format;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;
		if ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		// Deprecated

		if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
		if ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );
		if ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );
		if ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );

		if ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );
		if ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );

		return material;

	}

	setTextures( value ) {

		this.textures = value;
		return this;

	}

}

class LoaderUtils {

	static decodeText( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';

		for ( let i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	}

	static extractUrlBase( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.substr( 0, index + 1 );

	}

	static resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' ) return '';

		// Host Relative URL
		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

		}

		// Absolute URL http://,https://,//
		if ( /^(https?:)?\/\//i.test( url ) ) return url;

		// Data URI
		if ( /^data:.*,.*$/i.test( url ) ) return url;

		// Blob URL
		if ( /^blob:.*$/i.test( url ) ) return url;

		// Relative URL
		return path + url;

	}

}

class InstancedBufferGeometry extends BufferGeometry {

	constructor() {

		super();

		this.type = 'InstancedBufferGeometry';
		this.instanceCount = Infinity;

	}

	copy( source ) {

		super.copy( source );

		this.instanceCount = source.instanceCount;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const data = super.toJSON( this );

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

}

InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

class BufferGeometryLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const interleavedBufferMap = {};
		const arrayBufferMap = {};

		function getInterleavedBuffer( json, uuid ) {

			if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

			const interleavedBuffers = json.interleavedBuffers;
			const interleavedBuffer = interleavedBuffers[ uuid ];

			const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

			const array = getTypedArray( interleavedBuffer.type, buffer );
			const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
			ib.uuid = interleavedBuffer.uuid;

			interleavedBufferMap[ uuid ] = ib;

			return ib;

		}

		function getArrayBuffer( json, uuid ) {

			if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

			const arrayBuffers = json.arrayBuffers;
			const arrayBuffer = arrayBuffers[ uuid ];

			const ab = new Uint32Array( arrayBuffer ).buffer;

			arrayBufferMap[ uuid ] = ab;

			return ab;

		}

		const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

		const index = json.data.index;

		if ( index !== undefined ) {

			const typedArray = getTypedArray( index.type, index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		const attributes = json.data.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];
			let bufferAttribute;

			if ( attribute.isInterleavedBufferAttribute ) {

				const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
				bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

			} else {

				const typedArray = getTypedArray( attribute.type, attribute.array );
				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
				bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

			}

			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			if ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );

			if ( attribute.updateRange !== undefined ) {

				bufferAttribute.updateRange.offset = attribute.updateRange.offset;
				bufferAttribute.updateRange.count = attribute.updateRange.count;

			}

			geometry.setAttribute( key, bufferAttribute );

		}

		const morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( const key in morphAttributes ) {

				const attributeArray = morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];
					let bufferAttribute;

					if ( attribute.isInterleavedBufferAttribute ) {

						const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
						bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

					} else {

						const typedArray = getTypedArray( attribute.type, attribute.array );
						bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

					}

					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		const morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( let i = 0, n = groups.length; i !== n; ++ i ) {

				const group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		const boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			const center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

}

class ObjectLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			let json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			const metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	}

	async loadAsync( url, onProgress ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		const text = await loader.loadAsync( url, onProgress );

		const json = JSON.parse( text );

		const metadata = json.metadata;

		if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

			throw new Error( 'THREE.ObjectLoader: Can\'t load ' + url );

		}

		return await scope.parseAsync( json );

	}

	parse( json, onLoad ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		//

		if ( onLoad !== undefined ) {

			let hasImages = false;

			for ( const uuid in images ) {

				if ( images[ uuid ] instanceof HTMLImageElement ) {

					hasImages = true;
					break;

				}

			}

			if ( hasImages === false ) onLoad( object );

		}

		return object;

	}

	async parseAsync( json ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = await this.parseImagesAsync( json.images );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, textures, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		return object;

	}

	parseShapes( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}

	parseSkeletons( json, object ) {

		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse( function ( child ) {

			if ( child.isBone ) bones[ child.uuid ] = child;

		} );

		// create skeletons

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const skeleton = new Skeleton().fromJSON( json[ i ], bones );

				skeletons[ skeleton.uuid ] = skeleton;

			}

		}

		return skeletons;

	}

	parseGeometries( json, shapes ) {

		const geometries = {};

		if ( json !== undefined ) {

			const bufferGeometryLoader = new BufferGeometryLoader();

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				let geometry;
				const data = json[ i ];

				switch ( data.type ) {

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						console.error( 'THREE.ObjectLoader: The legacy Geometry type is no longer supported.' );

						break;

					default:

						if ( data.type in Geometries ) {

							geometry = Geometries[ data.type ].fromJSON( data, shapes );

						} else {

							console.warn( `THREE.ObjectLoader: Unsupported geometry type "${ data.type }"` );

						}

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	}

	parseMaterials( json, textures ) {

		const cache = {}; // MultiMaterial
		const materials = {};

		if ( json !== undefined ) {

			const loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.type === 'MultiMaterial' ) {

					// Deprecated

					const array = [];

					for ( let j = 0; j < data.materials.length; j ++ ) {

						const material = data.materials[ j ];

						if ( cache[ material.uuid ] === undefined ) {

							cache[ material.uuid ] = loader.parse( material );

						}

						array.push( cache[ material.uuid ] );

					}

					materials[ data.uuid ] = array;

				} else {

					if ( cache[ data.uuid ] === undefined ) {

						cache[ data.uuid ] = loader.parse( data );

					}

					materials[ data.uuid ] = cache[ data.uuid ];

				}

			}

		}

		return materials;

	}

	parseAnimations( json ) {

		const animations = {};

		if ( json !== undefined ) {

			for ( let i = 0; i < json.length; i ++ ) {

				const data = json[ i ];

				const clip = AnimationClip.parse( data );

				animations[ clip.uuid ] = clip;

			}

		}

		return animations;

	}

	parseImages( json, onLoad ) {

		const scope = this;
		const images = {};

		let loader;

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return loadImage( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			const manager = new LoadingManager( onLoad );

			loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					images[ image.uuid ] = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								images[ image.uuid ].push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								images[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

				} else {

					// load single image

					const deserializedImage = deserializeImage( image.url );

					if ( deserializedImage !== null ) {

						images[ image.uuid ] = deserializedImage;

					}

				}

			}

		}

		return images;

	}

	async parseImagesAsync( json ) {

		const scope = this;
		const images = {};

		let loader;

		async function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return await loader.loadAsync( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					images[ image.uuid ] = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = await deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								images[ image.uuid ].push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								images[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

				} else {

					// load single image

					const deserializedImage = await deserializeImage( image.url );

					if ( deserializedImage !== null ) {

						images[ image.uuid ] = deserializedImage;

					}

				}

			}

		}

		return images;

	}

	parseTextures( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		const textures = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				let texture;
				const image = images[ data.image ];

				if ( Array.isArray( image ) ) {

					texture = new CubeTexture( image );

					if ( image.length === 6 ) texture.needsUpdate = true;

				} else {

					if ( image && image.data ) {

						texture = new DataTexture( image.data, image.width, image.height );

					} else {

						texture = new Texture( image );

					}

					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

				}

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

				if ( data.userData !== undefined ) texture.userData = data.userData;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	}

	parseObject( data, geometries, materials, textures, animations ) {

		let object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				const array = [];

				for ( let i = 0, l = name.length; i < l; i ++ ) {

					const uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		function getTexture( uuid ) {

			if ( textures[ uuid ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined texture', uuid );

			}

			return textures[ uuid ];

		}

		let geometry, material;

		switch ( data.type ) {

			case 'Scene':

				object = new Scene();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new Color( data.background );

					} else {

						object.background = getTexture( data.background );

					}

				}

				if ( data.environment !== undefined ) {

					object.environment = getTexture( data.environment );

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new FogExp2( data.fog.color, data.fog.density );

					}

				}

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new AmbientLight( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new DirectionalLight( data.color, data.intensity );

				break;

			case 'PointLight':

				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

				break;

			case 'HemisphereLight':

				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

				break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

			case 'SkinnedMesh':

				geometry = getGeometry( data.geometry );
			 	material = getMaterial( data.material );

				object = new SkinnedMesh( geometry, material );

				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

				break;

			case 'Mesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new Mesh( geometry, material );

				break;

			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;
				const instanceColor = data.instanceColor;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );
				if ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineLoop':

				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new Sprite( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new Group();

				break;

			case 'Bone':

				object = new Bone();

				break;

			default:

				object = new Object3D();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );

			}

		}

		if ( data.animations !== undefined ) {

			const objectAnimations = data.animations;

			for ( let i = 0; i < objectAnimations.length; i ++ ) {

				const uuid = objectAnimations[ i ];

				object.animations.push( animations[ uuid ] );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			const levels = data.levels;

			for ( let l = 0; l < levels.length; l ++ ) {

				const level = levels[ l ];
				const child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance );

				}

			}

		}

		return object;

	}

	bindSkeletons( object, skeletons ) {

		if ( Object.keys( skeletons ).length === 0 ) return;

		object.traverse( function ( child ) {

			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

				const skeleton = skeletons[ child.skeleton ];

				if ( skeleton === undefined ) {

					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

				} else {

					child.bind( skeleton, child.bindMatrix );

				}

			}

		} );

	}

	/* DEPRECATED */

	setTexturePath( value ) {

		console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
		return this.setResourcePath( value );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping,
	CubeUVRefractionMapping: CubeUVRefractionMapping
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

class ImageBitmapLoader extends Loader {

	constructor( manager ) {

		super( manager );

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.options = { premultiplyAlpha: 'none' };

	}

	setOptions( options ) {

		this.options = options;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;

		fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		scope.manager.itemStart( url );

	}

}

ImageBitmapLoader.prototype.isImageBitmapLoader = true;

let _context;

const AudioContext = {

	getContext: function () {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	},

	setContext: function ( value ) {

		_context = value;

	}

};

class AudioLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( buffer ) {

			try {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice( 0 );

				const context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

}

class HemisphereLightProbe extends LightProbe {

	constructor( skyColor, groundColor, intensity = 1 ) {

		super( undefined, intensity );

		const color1 = new Color().set( skyColor );
		const color2 = new Color().set( groundColor );

		const sky = new Vector3( color1.r, color1.g, color1.b );
		const ground = new Vector3( color2.r, color2.g, color2.b );

		// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
		const c0 = Math.sqrt( Math.PI );
		const c1 = c0 * Math.sqrt( 0.75 );

		this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
		this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

	}

}

HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

class AmbientLightProbe extends LightProbe {

	constructor( color, intensity = 1 ) {

		super( undefined, intensity );

		const color1 = new Color().set( color );

		// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
		this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

	}

}

AmbientLightProbe.prototype.isAmbientLightProbe = true;

const _eyeRight = /*@__PURE__*/ new Matrix4();
const _eyeLeft = /*@__PURE__*/ new Matrix4();

class StereoCamera {

	constructor() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};

	}

	update( camera ) {

		const cache = this._cache;

		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			const projectionMatrix = camera.projectionMatrix.clone();
			const eyeSepHalf = cache.eyeSep / 2;
			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			const ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			let xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

}

class Clock {

	constructor( autoStart = true ) {

		this.autoStart = autoStart;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	start() {

		this.startTime = now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

function now() {

	return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

}

const _position$1 = /*@__PURE__*/ new Vector3();
const _quaternion$1 = /*@__PURE__*/ new Quaternion();
const _scale$1 = /*@__PURE__*/ new Vector3();
const _orientation$1 = /*@__PURE__*/ new Vector3();

class AudioListener extends Object3D {

	constructor() {

		super();

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

		// private

		this._clock = new Clock();

	}

	getInput() {

		return this.gain;

	}

	removeFilter() {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	}

	getFilter() {

		return this.filter;

	}

	setFilter( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	}

	getMasterVolume() {

		return this.gain.gain.value;

	}

	setMasterVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		const listener = this.context.listener;
		const up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );

		_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			const endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position$1.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position$1.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position$1.x, _position$1.y, _position$1.z );
			listener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );

		}

	}

}

class Audio extends Object3D {

	constructor( listener ) {

		super();

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.loopStart = 0;
		this.loopEnd = 0;
		this.offset = 0;
		this.duration = undefined;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.source = null;
		this.sourceType = 'empty';

		this._startedAt = 0;
		this._progress = 0;
		this._connected = false;

		this.filters = [];

	}

	getOutput() {

		return this.gain;

	}

	setNodeSource( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	}

	setMediaElementSource( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	}

	setMediaStreamSource( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	}

	setBuffer( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	}

	play( delay = 0 ) {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		const source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._progress + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	}

	pause() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			// update current progress

			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			if ( this.loop === true ) {

				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % ( this.duration || this.buffer.duration );

			}

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	}

	stop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._progress = 0;

		this.source.stop();
		this.source.onended = null;
		this.isPlaying = false;

		return this;

	}

	connect() {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		this._connected = true;

		return this;

	}

	disconnect() {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		this._connected = false;

		return this;

	}

	getFilters() {

		return this.filters;

	}

	setFilters( value ) {

		if ( ! value ) value = [];

		if ( this._connected === true ) {

			this.disconnect();
			this.filters = value.slice();
			this.connect();

		} else {

			this.filters = value.slice();

		}

		return this;

	}

	setDetune( value ) {

		this.detune = value;

		if ( this.source.detune === undefined ) return; // only set detune when available

		if ( this.isPlaying === true ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getDetune() {

		return this.detune;

	}

	getFilter() {

		return this.getFilters()[ 0 ];

	}

	setFilter( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	}

	setPlaybackRate( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getPlaybackRate() {

		return this.playbackRate;

	}

	onEnded() {

		this.isPlaying = false;

	}

	getLoop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	}

	setLoop( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	}

	setLoopStart( value ) {

		this.loopStart = value;

		return this;

	}

	setLoopEnd( value ) {

		this.loopEnd = value;

		return this;

	}

	getVolume() {

		return this.gain.gain.value;

	}

	setVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

}

const _position = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();
const _scale = /*@__PURE__*/ new Vector3();
const _orientation = /*@__PURE__*/ new Vector3();

class PositionalAudio extends Audio {

	constructor( listener ) {

		super( listener );

		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect( this.gain );

	}

	getOutput() {

		return this.panner;

	}

	getRefDistance() {

		return this.panner.refDistance;

	}

	setRefDistance( value ) {

		this.panner.refDistance = value;

		return this;

	}

	getRolloffFactor() {

		return this.panner.rolloffFactor;

	}

	setRolloffFactor( value ) {

		this.panner.rolloffFactor = value;

		return this;

	}

	getDistanceModel() {

		return this.panner.distanceModel;

	}

	setDistanceModel( value ) {

		this.panner.distanceModel = value;

		return this;

	}

	getMaxDistance() {

		return this.panner.maxDistance;

	}

	setMaxDistance( value ) {

		this.panner.maxDistance = value;

		return this;

	}

	setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position, _quaternion, _scale );

		_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );

		const panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			const endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );

		} else {

			panner.setPosition( _position.x, _position.y, _position.z );
			panner.setOrientation( _orientation.x, _orientation.y, _orientation.z );

		}

	}

}

class AudioAnalyser {

	constructor( audio, fftSize = 2048 ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}


	getFrequencyData() {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	}

	getAverageFrequency() {

		let value = 0;
		const data = this.getFrequencyData();

		for ( let i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

}

class PropertyMixer {

	constructor( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		let mixFunction,
			mixFunctionAdditive,
			setIdentity;

		// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
		//
		// 'add' is used for additive cumulative results
		//
		// 'work' is optional and is only present for quaternion types. It is used
		// to store intermediate quaternion multiplication results

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				mixFunctionAdditive = this._slerpAdditive;
				setIdentity = this._setAdditiveIdentityQuaternion;

				this.buffer = new Float64Array( valueSize * 6 );
				this._workIndex = 5;
				break;

			case 'string':
			case 'bool':
				mixFunction = this._select;

				// Use the regular mix function and for additive on these types,
				// additive is not relevant for non-numeric types
				mixFunctionAdditive = this._select;

				setIdentity = this._setAdditiveIdentityOther;

				this.buffer = new Array( valueSize * 5 );
				break;

			default:
				mixFunction = this._lerp;
				mixFunctionAdditive = this._lerpAdditive;
				setIdentity = this._setAdditiveIdentityNumeric;

				this.buffer = new Float64Array( valueSize * 5 );

		}

		this._mixBufferRegion = mixFunction;
		this._mixBufferRegionAdditive = mixFunctionAdditive;
		this._setIdentity = setIdentity;
		this._origIndex = 3;
		this._addIndex = 4;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;

		let currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	}

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive( weight ) {

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	}

	// apply the state of 'accu<i>' to the binding when accus differ
	apply( accuIndex ) {

		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	}

	// remember the state of the bound property and copy it to both accus
	saveOriginalState() {

		const binding = this.binding;

		const buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	}

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState() {

		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	}

	_setAdditiveIdentityNumeric() {

		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;

		for ( let i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	}

	_setAdditiveIdentityQuaternion() {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	}

	_setAdditiveIdentityOther() {

		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;

		for ( let i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	}


	// mix functions

	_select( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	}

	_slerp( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	}

	_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	}

	_lerp( buffer, dstOffset, srcOffset, t, stride ) {

		const s = 1 - t;

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

	_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

}

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

class Composite {

	constructor( targetGroup, path, optionalParsedPath ) {

		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	getValue( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	}

	setValue( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	}

	bind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	}

	unbind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

}

// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class PropertyBinding {

	constructor( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

		// initial state of these methods that calls 'bind'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}


	static create( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	}

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	static sanitizeNodeName( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	}

	static parseTrackName( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( ! matches ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	}

	static findNode( root, nodeName ) {

		if ( ! nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

	// these are used to "bind" a nonexistent property
	_getValue_unavailable() {}
	_setValue_unavailable() {}

	// Getters

	_getValue_direct( buffer, offset ) {

		buffer[ offset ] = this.targetObject[ this.propertyName ];

	}

	_getValue_array( buffer, offset ) {

		const source = this.resolvedProperty;

		for ( let i = 0, n = source.length; i !== n; ++ i ) {

			buffer[ offset ++ ] = source[ i ];

		}

	}

	_getValue_arrayElement( buffer, offset ) {

		buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

	}

	_getValue_toArray( buffer, offset ) {

		this.resolvedProperty.toArray( buffer, offset );

	}

	// Direct

	_setValue_direct( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];

	}

	_setValue_direct_setNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// EntireArray

	_setValue_array( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

	}

	_setValue_array_setNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.needsUpdate = true;

	}

	_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// ArrayElement

	_setValue_arrayElement( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

	}

	_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// HasToFromArray

	_setValue_fromArray( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );

	}

	_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.needsUpdate = true;

	}

	_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	_getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

	}

	_setValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	}

	// create getter / setter pair for a property in the scene graph
	bind() {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === 'morphTargetInfluences' ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( targetObject.geometry.isBufferGeometry ) {

					if ( ! targetObject.geometry.morphAttributes ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;

					}

					if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

						propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

					}


				} else {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
					return;

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	}

	unbind() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

}

PropertyBinding.Composite = Composite;

PropertyBinding.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};

PropertyBinding.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};

PropertyBinding.prototype.GetterByBindingType = [

	PropertyBinding.prototype._getValue_direct,
	PropertyBinding.prototype._getValue_array,
	PropertyBinding.prototype._getValue_arrayElement,
	PropertyBinding.prototype._getValue_toArray,

];

PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

	[
		// Direct
		PropertyBinding.prototype._setValue_direct,
		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

	], [

		// EntireArray

		PropertyBinding.prototype._setValue_array,
		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

	], [

		// ArrayElement
		PropertyBinding.prototype._setValue_arrayElement,
		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

	], [

		// HasToFromArray
		PropertyBinding.prototype._setValue_fromArray,
		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

	]

];

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

class AnimationObjectGroup {

	constructor() {

		this.uuid = generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		const indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		const scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	add() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		let knownObject = undefined,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid;
			let index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				const firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ];

					let binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	remove() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				const lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// remove & forget
	uncache() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_,
			nObjects = objects.length;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					const lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					if ( lastIndex > 0 ) {

						indicesByUUID[ lastObject.uuid ] = index;

					}

					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		const indicesByPath = this._bindingsIndicesByPath;
		let index = indicesByPath[ path ];
		const bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		const paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			const object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	}

	unsubscribe_( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		const indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

}

AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

class AnimationAction {

	constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot;
		this.blendMode = blendMode;

		const tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		const interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( let i = 0; i !== nTracks; ++ i ) {

			const interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end

	}

	// State & Scheduling

	play() {

		this._mixer._activateAction( this );

		return this;

	}

	stop() {

		this._mixer._deactivateAction( this );

		return this.reset();

	}

	reset() {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = - 1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	}

	isRunning() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	}

	// return true when play has been called
	isScheduled() {

		return this._mixer._isActiveAction( this );

	}

	startAt( time ) {

		this._startTime = time;

		return this;

	}

	setLoop( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	}

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	}

	// return the weight considering fading and .enabled
	getEffectiveWeight() {

		return this._effectiveWeight;

	}

	fadeIn( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	}

	fadeOut( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	}

	crossFadeFrom( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp ) {

			const fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	}

	crossFadeTo( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	}

	stopFading() {

		const weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	}

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	}

	// return the time scale considering warping and .paused
	getEffectiveTimeScale() {

		return this._effectiveTimeScale;

	}

	setDuration( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	}

	syncWith( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	}

	halt( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	}

	warp( startTimeScale, endTimeScale, duration ) {

		const mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale;

		let interpolant = this._timeScaleInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	}

	stopWarping() {

		const timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	}

	// Object Accessors

	getMixer() {

		return this._mixer;

	}

	getClip() {

		return this._clip;

	}

	getRoot() {

		return this._localRoot || this._mixer._root;

	}

	// Interna

	_update( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		const startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			const timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		const clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		const weight = this._updateWeight( time );

		if ( weight > 0 ) {

			const interpolants = this._interpolants;
			const propertyMixers = this._propertyBindings;

			switch ( this.blendMode ) {

				case AdditiveAnimationBlendMode:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulateAdditive( weight );

					}

					break;

				case NormalAnimationBlendMode:
				default:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

			}

		}

	}

	_updateWeight( time ) {

		let weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			const interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	}

	_updateTimeScale( time ) {

		let timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			const interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	}

	_updateTime( deltaTime ) {

		const duration = this._clip.duration;
		const loop = this.loop;

		let time = this.time + deltaTime;
		let loopCount = this._loopCount;

		const pingPong = ( loop === LoopPingPong );

		if ( deltaTime === 0 ) {

			if ( loopCount === - 1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === LoopOnce ) {

			if ( loopCount === - 1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === - 1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				const loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				const pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						const atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	}

	_setEndings( atStart, atEnd, pingPong ) {

		const settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	}

	_scheduleFading( duration, weightNow, weightThen ) {

		const mixer = this._mixer, now = mixer.time;
		let interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

}

class AnimationMixer extends EventDispatcher {

	constructor( root ) {

		super();

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
		this.time = 0;
		this.timeScale = 1.0;

	}

	_bindAction( action, prototypeAction ) {

		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;

		let bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( let i = 0; i !== nTracks; ++ i ) {

			const track = tracks[ i ],
				trackName = track.name;

			let binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				const path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	}

	_activateAction( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	}

	_deactivateAction( action ) {

		if ( this._isActiveAction( action ) ) {

			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	}

	// Memory manager

	_initMemoryManager() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		const scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	}

	// Memory management for AnimationAction objects

	_isActiveAction( action ) {

		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	}

	_addInactiveAction( action, clipUuid, rootUuid ) {

		const actions = this._actions,
			actionsByClip = this._actionsByClip;

		let actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			const knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	}

	_removeInactiveAction( action ) {

		const actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	}

	_removeInactiveBindingsForAction( action ) {

		const bindings = action._propertyBindings;

		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			const binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	}

	_lendAction( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	}

	_takeBackAction( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	}

	// Memory management for PropertyMixer objects

	_addInactiveBinding( binding, rootUuid, trackName ) {

		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;

		let bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	}

	_removeInactiveBinding( binding ) {

		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	}

	_lendBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	}

	_takeBackBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	}


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant() {

		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++;

		let interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	}

	_takeBackControlInterpolant( interpolant ) {

		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	}

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction( clip, optionalRoot, blendMode ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid;

		let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		const actionsForClip = this._actionsByClip[ clipUuid ];
		let prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = NormalAnimationBlendMode;

			}

		}

		if ( actionsForClip !== undefined ) {

			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	}

	// get an existing action
	existingAction( clip, optionalRoot ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	}

	// deactivates all previously scheduled actions
	stopAllAction() {

		const actions = this._actions,
			nActions = this._nActiveActions;

		for ( let i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	}

	// advance the time and update apply the animation
	update( deltaTime ) {

		deltaTime *= this.timeScale;

		const actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( let i = 0; i !== nActions; ++ i ) {

			const action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( let i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	}

	// Allows you to seek to a specific time in an animation.
	setTime( timeInSeconds ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( let i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	}

	// return this mixer's root target object
	getRoot() {

		return this._root;

	}

	// free all resources specific to a particular clip
	uncacheClip( clip ) {

		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;

			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				const action = actionsToRemove[ i ];

				this._deactivateAction( action );

				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	}

	// free all resources specific to a particular root target object
	uncacheRoot( root ) {

		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( const clipUuid in actionsByClip ) {

			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( const trackName in bindingByName ) {

				const binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	}

	// remove a targeted clip from the cache
	uncacheAction( clip, optionalRoot ) {

		const action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

}

AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );

class Uniform {

	constructor( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	clone() {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	}

}

class InstancedInterleavedBuffer extends InterleavedBuffer {

	constructor( array, stride, meshPerAttribute = 1 ) {

		super( array, stride );

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	clone( data ) {

		const ib = super.clone( data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	}

	toJSON( data ) {

		const json = super.toJSON( data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

}

InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

class GLBufferAttribute {

	constructor( buffer, type, itemSize, elementSize, count ) {

		this.buffer = buffer;
		this.type = type;
		this.itemSize = itemSize;
		this.elementSize = elementSize;
		this.count = count;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setBuffer( buffer ) {

		this.buffer = buffer;

		return this;

	}

	setType( type, elementSize ) {

		this.type = type;
		this.elementSize = elementSize;

		return this;

	}

	setItemSize( itemSize ) {

		this.itemSize = itemSize;

		return this;

	}

	setCount( count ) {

		this.count = count;

		return this;

	}

}

GLBufferAttribute.prototype.isGLBufferAttribute = true;

class Raycaster {

	constructor( origin, direction, near = 0, far = Infinity ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near;
		this.far = far;
		this.camera = null;
		this.layers = new Layers();

		this.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

	}

	set( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	}

	setFromCamera( coords, camera ) {

		if ( camera && camera.isPerspectiveCamera ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( camera && camera.isOrthographicCamera ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

		}

	}

	intersectObject( object, recursive = true, intersects = [] ) {

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	}

	intersectObjects( objects, recursive = true, intersects = [] ) {

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

class Spherical {

	constructor( radius = 1, phi = 0, theta = 0 ) {

		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;

	}

	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe() {

		const EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */

class Cylindrical {

	constructor( radius = 1, theta = 0, y = 0 ) {

		this.radius = radius; // distance from the origin to a point in the x-z plane
		this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = y; // height above the x-z plane

		return this;

	}

	set( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$4 = /*@__PURE__*/ new Vector2();

class Box2 {

	constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	}

	intersectsBox( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$4.copy( point ).clamp( this.min, this.max );
		return clampedPoint.sub( point ).length();

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

Box2.prototype.isBox2 = true;

const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();

class Line3 {

	constructor( start = new Vector3(), end = new Vector3() ) {

		this.start = start;
		this.end = end;

	}

	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	getCenter( target ) {

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	delta( target ) {

		return target.subVectors( this.end, this.start );

	}

	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	distance() {

		return this.start.distanceTo( this.end );

	}

	at( t, target ) {

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = clamp( t, 0, 1 );

		}

		return t;

	}

	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$3 = /*@__PURE__*/ new Vector3();

class SpotLightHelper extends Object3D {

	constructor( light, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new BufferGeometry();

		const positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			const p1 = ( i / l ) * Math.PI * 2;
			const p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	dispose() {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

	update() {

		this.light.updateMatrixWorld();

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector$3 );

		if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}

	}

}

const _vector$2 = /*@__PURE__*/ new Vector3();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


class SkeletonHelper extends LineSegments {

	constructor( object ) {

		const bones = getBoneList( object );

		const geometry = new BufferGeometry();

		const vertices = [];
		const colors = [];

		const color1 = new Color( 0, 0, 1 );
		const color2 = new Color( 0, 1, 0 );

		for ( let i = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		super( geometry, material );

		this.type = 'SkeletonHelper';
		this.isSkeletonHelper = true;

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	updateMatrixWorld( force ) {

		const bones = this.bones;

		const geometry = this.geometry;
		const position = geometry.getAttribute( 'position' );

		_matrixWorldInv.copy( this.root.matrixWorld ).invert();

		for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

		super.updateMatrixWorld( force );

	}

}


function getBoneList( object ) {

	const boneList = [];

	if ( object && object.isBone ) {

		boneList.push( object );

	}

	for ( let i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

class PointLightHelper extends Mesh {

	constructor( light, sphereSize, color ) {

		const geometry = new SphereGeometry( sphereSize, 4, 2 );
		const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

		super( geometry, material );

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		this.type = 'PointLightHelper';

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

	update() {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	}

}

const _vector$1 = /*@__PURE__*/ new Vector3();
const _color1 = /*@__PURE__*/ new Color();
const _color2 = /*@__PURE__*/ new Color();

class HemisphereLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new OctahedronGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
		if ( this.color === undefined ) this.material.vertexColors = true;

		const position = geometry.getAttribute( 'position' );
		const colors = new Float32Array( position.count * 3 );

		geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	dispose() {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

	update() {

		const mesh = this.children[ 0 ];

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			const colors = mesh.geometry.getAttribute( 'color' );

			_color1.copy( this.light.color );
			_color2.copy( this.light.groundColor );

			for ( let i = 0, l = colors.count; i < l; i ++ ) {

				const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

				colors.setXYZ( i, color.r, color.g, color.b );

			}

			colors.needsUpdate = true;

		}

		mesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );

	}

}

class GridHelper extends LineSegments {

	constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;

		const vertices = [], colors = [];

		for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			const color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'GridHelper';

	}

}

class PolarGridHelper extends LineSegments {

	constructor( radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const vertices = [];
		const colors = [];

		// create the radials

		for ( let i = 0; i <= radials; i ++ ) {

			const v = ( i / radials ) * ( Math.PI * 2 );

			const x = Math.sin( v ) * radius;
			const z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			const color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( let i = 0; i <= circles; i ++ ) {

			const color = ( i & 1 ) ? color1 : color2;

			const r = radius - ( radius / circles * i );

			for ( let j = 0; j < divisions; j ++ ) {

				// first vertex

				let v = ( j / divisions ) * ( Math.PI * 2 );

				let x = Math.sin( v ) * r;
				let z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'PolarGridHelper';

	}

}

const _v1 = /*@__PURE__*/ new Vector3();
const _v2 = /*@__PURE__*/ new Vector3();
const _v3 = /*@__PURE__*/ new Vector3();

class DirectionalLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		let geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	dispose() {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	}

	update() {

		_v1.setFromMatrixPosition( this.light.matrixWorld );
		_v2.setFromMatrixPosition( this.light.target.matrixWorld );
		_v3.subVectors( _v2, _v1 );

		this.lightPlane.lookAt( _v2 );

		if ( this.color !== undefined ) {

			this.lightPlane.material.color.set( this.color );
			this.targetLine.material.color.set( this.color );

		} else {

			this.lightPlane.material.color.copy( this.light.color );
			this.targetLine.material.color.copy( this.light.color );

		}

		this.targetLine.lookAt( _v2 );
		this.targetLine.scale.z = _v3.length();

	}

}

const _vector = /*@__PURE__*/ new Vector3();
const _camera = /*@__PURE__*/ new Camera();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

class CameraHelper extends LineSegments {

	constructor( camera ) {

		const geometry = new BufferGeometry();
		const material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

		const vertices = [];
		const colors = [];

		const pointMap = {};

		// colors

		const colorFrustum = new Color( 0xffaa00 );
		const colorCone = new Color( 0xff0000 );
		const colorUp = new Color( 0x00aaff );
		const colorTarget = new Color( 0xffffff );
		const colorCross = new Color( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		super( geometry, material );

		this.type = 'CameraHelper';

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	update() {

		const geometry = this.geometry;
		const pointMap = this.pointMap;

		const w = 1, h = 1;

		// we need just camera projection matrix inverse
		// world matrix must be identity

		_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

		// center / target

		setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
		setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

		// near

		setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
		setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
		setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
		setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

		// far

		setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
		setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
		setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
		setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

		// up

		setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
		setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
		setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

		// cross

		setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
		setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
		setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
		setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

		setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
		setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
		setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
		setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}


function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector.set( x, y, z ).unproject( camera );

	const points = pointMap[ point ];

	if ( points !== undefined ) {

		const position = geometry.getAttribute( 'position' );

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );

		}

	}

}

const _box = /*@__PURE__*/ new Box3();

class BoxHelper extends LineSegments {

	constructor( object, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		const positions = new Float32Array( 8 * 3 );

		const geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.object = object;
		this.type = 'BoxHelper';

		this.matrixAutoUpdate = false;

		this.update();

	}

	update( object ) {

		if ( object !== undefined ) {

			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

		}

		if ( this.object !== undefined ) {

			_box.setFromObject( this.object );

		}

		if ( _box.isEmpty() ) return;

		const min = _box.min;
		const max = _box.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;

		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();


	}

	setFromObject( object ) {

		this.object = object;
		this.update();

		return this;

	}

	copy( source ) {

		LineSegments.prototype.copy.call( this, source );

		this.object = source.object;

		return this;

	}

}

class Box3Helper extends LineSegments {

	constructor( box, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		const geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.box = box;

		this.type = 'Box3Helper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

}

class PlaneHelper extends Line {

	constructor( plane, size = 1, hex = 0xffff00 ) {

		const color = hex;

		const positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = size;

		const positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		const geometry2 = new BufferGeometry();
		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

	}

	updateMatrixWorld( force ) {

		let scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

		this.lookAt( this.plane.normal );

		super.updateMatrixWorld( force );

	}

}

const _axis = /*@__PURE__*/ new Vector3();
let _lineGeometry, _coneGeometry;

class ArrowHelper extends Object3D {

	// dir is assumed to be normalized

	constructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		super();

		this.type = 'ArrowHelper';

		if ( _lineGeometry === undefined ) {

			_lineGeometry = new BufferGeometry();
			_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );
			_coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			_axis.set( dir.z, 0, - dir.x ).normalize();

			const radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( _axis, radians );

		}

	}

	setLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	}

	setColor( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	}

	copy( source ) {

		super.copy( source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	}

}

class AxesHelper extends LineSegments {

	constructor( size = 1 ) {

		const vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		const colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'AxesHelper';

	}

	setColors( xAxisColor, yAxisColor, zAxisColor ) {

		const color = new Color();
		const array = this.geometry.attributes.color.array;

		color.set( xAxisColor );
		color.toArray( array, 0 );
		color.toArray( array, 3 );

		color.set( yAxisColor );
		color.toArray( array, 6 );
		color.toArray( array, 9 );

		color.set( zAxisColor );
		color.toArray( array, 12 );
		color.toArray( array, 15 );

		this.geometry.attributes.color.needsUpdate = true;

		return this;

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

}

class ShapePath {

	constructor() {

		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;

	}

	moveTo( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	}

	lineTo( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	}

	splineThru( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	}

	toShapes( isCCW, noHoles ) {

		function toShapesNoHoles( inSubpaths ) {

			const shapes = [];

			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

				const tmpPath = inSubpaths[ i ];

				const tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				let edgeLowPt = inPolygon[ p ];
				let edgeHighPt = inPolygon[ q ];

				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}

					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		const isClockWise = ShapeUtils.isClockWise;

		const subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		let solid, tmpPath, tmpShape;
		const shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			let ambiguous = false;
			const toChange = [];

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				const sho = newShapeHoles[ sIdx ];

				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					const ho = sho[ hIdx ];
					let hole_unassigned = true;

					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}

					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);

			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		let tmpHoles;

		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

}

const _floatView = new Float32Array( 1 );
const _int32View = new Int32Array( _floatView.buffer );

class DataUtils {

	// Converts float32 to float16 (stored as uint16 value).

	static toHalfFloat( val ) {

		if ( val > 65504 ) {

			console.warn( 'THREE.DataUtils.toHalfFloat(): value exceeds 65504.' );

			val = 65504; // maximum representable value in float16

		}

		// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

		/* This method is faster than the OpenEXR implementation (very often
		* used, eg. in Ogre), with the additional benefit of rounding, inspired
		* by James Tursa?s half-precision code. */

		_floatView[ 0 ] = val;
		const x = _int32View[ 0 ];

		let bits = ( x >> 16 ) & 0x8000; /* Get the sign */
		let m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */
		const e = ( x >> 23 ) & 0xff; /* Using int is faster here */

		/* If zero, or denormal, or exponent underflows too much for a denormal
			* half, return signed zero. */
		if ( e < 103 ) return bits;

		/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
		if ( e > 142 ) {

			bits |= 0x7c00;
			/* If exponent was 0xff and one mantissa bit was set, it means NaN,
						* not Inf, so make sure we set one mantissa bit too. */
			bits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );
			return bits;

		}

		/* If exponent underflows but not too much, return a denormal */
		if ( e < 113 ) {

			m |= 0x0800;
			/* Extra rounding may overflow and set mantissa to 0 and exponent
				* to 1, which is OK. */
			bits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );
			return bits;

		}

		bits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );
		/* Extra rounding. An overflow will set mantissa to 0 and increment
			* the exponent, which is OK. */
		bits += m & 1;
		return bits;

	}

}

const LineStrip = 0;
const LinePieces = 1;
const NoColors = 0;
const FaceColors = 1;
const VertexColors = 2;

function MeshFaceMaterial( materials ) {

	console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
	return materials;

}

function MultiMaterial( materials = [] ) {

	console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
	materials.isMultiMaterial = true;
	materials.materials = materials;
	materials.clone = function () {

		return materials.slice();

	};

	return materials;

}

function PointCloud( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function Particle( material ) {

	console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
	return new Sprite( material );

}

function ParticleSystem( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function PointCloudMaterial( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleBasicMaterial( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleSystemMaterial( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function Vertex( x, y, z ) {

	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
	return new Vector3( x, y, z );

}

//

function DynamicBufferAttribute( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );
	return new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );

}

function Int8Attribute( array, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
	return new Int8BufferAttribute( array, itemSize );

}

function Uint8Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
	return new Uint8BufferAttribute( array, itemSize );

}

function Uint8ClampedAttribute( array, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
	return new Uint8ClampedBufferAttribute( array, itemSize );

}

function Int16Attribute( array, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
	return new Int16BufferAttribute( array, itemSize );

}

function Uint16Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
	return new Uint16BufferAttribute( array, itemSize );

}

function Int32Attribute( array, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
	return new Int32BufferAttribute( array, itemSize );

}

function Uint32Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
	return new Uint32BufferAttribute( array, itemSize );

}

function Float32Attribute( array, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
	return new Float32BufferAttribute( array, itemSize );

}

function Float64Attribute( array, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
	return new Float64BufferAttribute( array, itemSize );

}

//

Curve.create = function ( construct, getPoint ) {

	console.log( 'THREE.Curve.create() has been deprecated' );

	construct.prototype = Object.create( Curve.prototype );
	construct.prototype.constructor = construct;
	construct.prototype.getPoint = getPoint;

	return construct;

};

//

Path.prototype.fromPoints = function ( points ) {

	console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
	return this.setFromPoints( points );

};

//

function AxisHelper( size ) {

	console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
	return new AxesHelper( size );

}

function BoundingBoxHelper( object, color ) {

	console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
	return new BoxHelper( object, color );

}

function EdgesHelper( object, hex ) {

	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

SkeletonHelper.prototype.update = function () {

	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

};

function WireframeHelper( object, hex ) {

	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

//

Loader.prototype.extractUrlBase = function ( url ) {

	console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
	return LoaderUtils.extractUrlBase( url );

};

Loader.Handlers = {

	add: function ( /* regex, loader */ ) {

		console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

	},

	get: function ( /* file */ ) {

		console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

	}

};

function XHRLoader( manager ) {

	console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
	return new FileLoader( manager );

}

function BinaryTextureLoader( manager ) {

	console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
	return new DataTextureLoader( manager );

}

//

Box2.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

Box2.prototype.empty = function () {

	console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

Box2.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Box2.prototype.size = function ( optionalTarget ) {

	console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
	return this.getSize( optionalTarget );

};

//

Box3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

Box3.prototype.empty = function () {

	console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

Box3.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Box3.prototype.isIntersectionSphere = function ( sphere ) {

	console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	return this.intersectsSphere( sphere );

};

Box3.prototype.size = function ( optionalTarget ) {

	console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
	return this.getSize( optionalTarget );

};

//

Sphere.prototype.empty = function () {

	console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

//

Frustum.prototype.setFromMatrix = function ( m ) {

	console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
	return this.setFromProjectionMatrix( m );

};

//

Line3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

//

Matrix3.prototype.flattenToArrayOffset = function ( array, offset ) {

	console.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	return this.toArray( array, offset );

};

Matrix3.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
	return vector.applyMatrix3( this );

};

Matrix3.prototype.multiplyVector3Array = function ( /* a */ ) {

	console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

};

Matrix3.prototype.applyToBufferAttribute = function ( attribute ) {

	console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
	return attribute.applyMatrix3( this );

};

Matrix3.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

};

Matrix3.prototype.getInverse = function ( matrix ) {

	console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	return this.copy( matrix ).invert();

};

//

Matrix4.prototype.extractPosition = function ( m ) {

	console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
	return this.copyPosition( m );

};

Matrix4.prototype.flattenToArrayOffset = function ( array, offset ) {

	console.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	return this.toArray( array, offset );

};

Matrix4.prototype.getPosition = function () {

	console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	return new Vector3().setFromMatrixColumn( this, 3 );

};

Matrix4.prototype.setRotationFromQuaternion = function ( q ) {

	console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
	return this.makeRotationFromQuaternion( q );

};

Matrix4.prototype.multiplyToArray = function () {

	console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

};

Matrix4.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.multiplyVector4 = function ( vector ) {

	console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.multiplyVector3Array = function ( /* a */ ) {

	console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

};

Matrix4.prototype.rotateAxis = function ( v ) {

	console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
	v.transformDirection( this );

};

Matrix4.prototype.crossVector = function ( vector ) {

	console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.translate = function () {

	console.error( 'THREE.Matrix4: .translate() has been removed.' );

};

Matrix4.prototype.rotateX = function () {

	console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

};

Matrix4.prototype.rotateY = function () {

	console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

};

Matrix4.prototype.rotateZ = function () {

	console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

};

Matrix4.prototype.rotateByAxis = function () {

	console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

};

Matrix4.prototype.applyToBufferAttribute = function ( attribute ) {

	console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
	return attribute.applyMatrix4( this );

};

Matrix4.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

};

Matrix4.prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {

	console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
	return this.makePerspective( left, right, top, bottom, near, far );

};

Matrix4.prototype.getInverse = function ( matrix ) {

	console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	return this.copy( matrix ).invert();

};

//

Plane.prototype.isIntersectionLine = function ( line ) {

	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );

};

//

Quaternion.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	return vector.applyQuaternion( this );

};

Quaternion.prototype.inverse = function ( ) {

	console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );
	return this.invert();

};

//

Ray.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Ray.prototype.isIntersectionPlane = function ( plane ) {

	console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
	return this.intersectsPlane( plane );

};

Ray.prototype.isIntersectionSphere = function ( sphere ) {

	console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	return this.intersectsSphere( sphere );

};

//

Triangle.prototype.area = function () {

	console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
	return this.getArea();

};

Triangle.prototype.barycoordFromPoint = function ( point, target ) {

	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	return this.getBarycoord( point, target );

};

Triangle.prototype.midpoint = function ( target ) {

	console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
	return this.getMidpoint( target );

};

Triangle.prototypenormal = function ( target ) {

	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	return this.getNormal( target );

};

Triangle.prototype.plane = function ( target ) {

	console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
	return this.getPlane( target );

};

Triangle.barycoordFromPoint = function ( point, a, b, c, target ) {

	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	return Triangle.getBarycoord( point, a, b, c, target );

};

Triangle.normal = function ( a, b, c, target ) {

	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	return Triangle.getNormal( a, b, c, target );

};

//

Shape.prototype.extractAllPoints = function ( divisions ) {

	console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
	return this.extractPoints( divisions );

};

Shape.prototype.extrude = function ( options ) {

	console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
	return new ExtrudeGeometry( this, options );

};

Shape.prototype.makeGeometry = function ( options ) {

	console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
	return new ShapeGeometry( this, options );

};

//

Vector2.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector2.prototype.distanceToManhattan = function ( v ) {

	console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	return this.manhattanDistanceTo( v );

};

Vector2.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Vector3.prototype.setEulerFromRotationMatrix = function () {

	console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

};

Vector3.prototype.setEulerFromQuaternion = function () {

	console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

};

Vector3.prototype.getPositionFromMatrix = function ( m ) {

	console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
	return this.setFromMatrixPosition( m );

};

Vector3.prototype.getScaleFromMatrix = function ( m ) {

	console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
	return this.setFromMatrixScale( m );

};

Vector3.prototype.getColumnFromMatrix = function ( index, matrix ) {

	console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
	return this.setFromMatrixColumn( matrix, index );

};

Vector3.prototype.applyProjection = function ( m ) {

	console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
	return this.applyMatrix4( m );

};

Vector3.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector3.prototype.distanceToManhattan = function ( v ) {

	console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	return this.manhattanDistanceTo( v );

};

Vector3.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Vector4.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector4.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Object3D.prototype.getChildByName = function ( name ) {

	console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
	return this.getObjectByName( name );

};

Object3D.prototype.renderDepth = function () {

	console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

};

Object3D.prototype.translate = function ( distance, axis ) {

	console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
	return this.translateOnAxis( axis, distance );

};

Object3D.prototype.getWorldRotation = function () {

	console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

};

Object3D.prototype.applyMatrix = function ( matrix ) {

	console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
	return this.applyMatrix4( matrix );

};

Object.defineProperties( Object3D.prototype, {

	eulerOrder: {
		get: function () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;

		},
		set: function ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;

		}
	},
	useQuaternion: {
		get: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},
		set: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		}
	}

} );

Mesh.prototype.setDrawMode = function () {

	console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

};

Object.defineProperties( Mesh.prototype, {

	drawMode: {
		get: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
			return TrianglesDrawMode;

		},
		set: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

		}
	}

} );

SkinnedMesh.prototype.initBones = function () {

	console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

};

//

PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +
			'Use .setFocalLength and .filmGauge for a photographic setup.' );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( Light.prototype, {
	onlyShadow: {
		set: function () {

			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		}
	},
	shadowCameraFov: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;

		}
	},
	shadowCameraLeft: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;

		}
	},
	shadowCameraRight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;

		}
	},
	shadowCameraTop: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;

		}
	},
	shadowCameraBottom: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;

		}
	},
	shadowCameraNear: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;

		}
	},
	shadowCameraFar: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;

		}
	},
	shadowCameraVisible: {
		set: function () {

			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		}
	},
	shadowBias: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;

		}
	},
	shadowDarkness: {
		set: function () {

			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		}
	},
	shadowMapWidth: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;

		}
	},
	shadowMapHeight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;

		}
	}
} );

//

Object.defineProperties( BufferAttribute.prototype, {

	length: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;

		}
	},
	dynamic: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			this.setUsage( DynamicDrawUsage );

		}
	}

} );

BufferAttribute.prototype.setDynamic = function ( value ) {

	console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
	return this;

};

BufferAttribute.prototype.copyIndicesArray = function ( /* indices */ ) {

	console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

},

BufferAttribute.prototype.setArray = function ( /* array */ ) {

	console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

};

//

BufferGeometry.prototype.addIndex = function ( index ) {

	console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
	this.setIndex( index );

};

BufferGeometry.prototype.addAttribute = function ( name, attribute ) {

	console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

	if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

		console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

		return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

	}

	if ( name === 'index' ) {

		console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
		this.setIndex( attribute );

		return this;

	}

	return this.setAttribute( name, attribute );

};

BufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset ) {

	if ( indexOffset !== undefined ) {

		console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

	}

	console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
	this.addGroup( start, count );

};

BufferGeometry.prototype.clearDrawCalls = function () {

	console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
	this.clearGroups();

};

BufferGeometry.prototype.computeOffsets = function () {

	console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

};

BufferGeometry.prototype.removeAttribute = function ( name ) {

	console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

	return this.deleteAttribute( name );

};

BufferGeometry.prototype.applyMatrix = function ( matrix ) {

	console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
	return this.applyMatrix4( matrix );

};

Object.defineProperties( BufferGeometry.prototype, {

	drawcalls: {
		get: function () {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		}
	},
	offsets: {
		get: function () {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		}
	}

} );

InterleavedBuffer.prototype.setDynamic = function ( value ) {

	console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
	return this;

};

InterleavedBuffer.prototype.setArray = function ( /* array */ ) {

	console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

};

//

ExtrudeGeometry.prototype.getArrays = function () {

	console.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );

};

ExtrudeGeometry.prototype.addShapeList = function () {

	console.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );

};

ExtrudeGeometry.prototype.addShape = function () {

	console.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );

};

//

Scene.prototype.dispose = function () {

	console.error( 'THREE.Scene: .dispose() has been removed.' );

};

//

Uniform.prototype.onUpdate = function () {

	console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
	return this;

};

//

Object.defineProperties( Material.prototype, {

	wrapAround: {
		get: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		}
	},

	overdraw: {
		get: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		}
	},

	wrapRGB: {
		get: function () {

			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			return new Color();

		}
	},

	shading: {
		get: function () {

			console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
			this.flatShading = ( value === FlatShading );

		}
	},

	stencilMask: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			return this.stencilFuncMask;

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			this.stencilFuncMask = value;

		}
	},

	vertexTangents: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .vertexTangents has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.' + this.type + ': .vertexTangents has been removed.' );

		}
	},

} );

Object.defineProperties( ShaderMaterial.prototype, {

	derivatives: {
		get: function () {

			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;

		},
		set: function ( value ) {

			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;

		}
	}

} );

//

WebGLRenderer.prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {

	console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
	this.setRenderTarget( renderTarget );
	this.clear( color, depth, stencil );

};

WebGLRenderer.prototype.animate = function ( callback ) {

	console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
	this.setAnimationLoop( callback );

};

WebGLRenderer.prototype.getCurrentRenderTarget = function () {

	console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
	return this.getRenderTarget();

};

WebGLRenderer.prototype.getMaxAnisotropy = function () {

	console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
	return this.capabilities.getMaxAnisotropy();

};

WebGLRenderer.prototype.getPrecision = function () {

	console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
	return this.capabilities.precision;

};

WebGLRenderer.prototype.resetGLState = function () {

	console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
	return this.state.reset();

};

WebGLRenderer.prototype.supportsFloatTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
	return this.extensions.get( 'OES_texture_float' );

};

WebGLRenderer.prototype.supportsHalfFloatTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
	return this.extensions.get( 'OES_texture_half_float' );

};

WebGLRenderer.prototype.supportsStandardDerivatives = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
	return this.extensions.get( 'OES_standard_derivatives' );

};

WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
	return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

};

WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
	return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

};

WebGLRenderer.prototype.supportsBlendMinMax = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
	return this.extensions.get( 'EXT_blend_minmax' );

};

WebGLRenderer.prototype.supportsVertexTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
	return this.capabilities.vertexTextures;

};

WebGLRenderer.prototype.supportsInstancedArrays = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
	return this.extensions.get( 'ANGLE_instanced_arrays' );

};

WebGLRenderer.prototype.enableScissorTest = function ( boolean ) {

	console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
	this.setScissorTest( boolean );

};

WebGLRenderer.prototype.initMaterial = function () {

	console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

};

WebGLRenderer.prototype.addPrePlugin = function () {

	console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

};

WebGLRenderer.prototype.addPostPlugin = function () {

	console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

};

WebGLRenderer.prototype.updateShadowMap = function () {

	console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

};

WebGLRenderer.prototype.setFaceCulling = function () {

	console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

};

WebGLRenderer.prototype.allocTextureUnit = function () {

	console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

};

WebGLRenderer.prototype.setTexture = function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

};

WebGLRenderer.prototype.setTexture2D = function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

};

WebGLRenderer.prototype.setTextureCube = function () {

	console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

};

WebGLRenderer.prototype.getActiveMipMapLevel = function () {

	console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
	return this.getActiveMipmapLevel();

};

Object.defineProperties( WebGLRenderer.prototype, {

	shadowMapEnabled: {
		get: function () {

			return this.shadowMap.enabled;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;

		}
	},
	shadowMapType: {
		get: function () {

			return this.shadowMap.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;

		}
	},
	shadowMapCullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	context: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
			return this.getContext();

		}
	},
	vr: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
			return this.xr;

		}
	},
	gammaInput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

		}
	},
	gammaOutput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			return false;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

		}
	},
	toneMappingWhitePoint: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );
			return 1.0;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

		}
	},

} );

Object.defineProperties( WebGLShadowMap.prototype, {

	cullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* cullFace */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderReverseSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderSingleSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

		}
	}

} );

function WebGLRenderTargetCube( width, height, options ) {

	console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );
	return new WebGLCubeRenderTarget( width, options );

}

//

Object.defineProperties( WebGLRenderTarget.prototype, {

	wrapS: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;

		}
	},
	wrapT: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;

		}
	},
	magFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;

		}
	},
	minFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;

		}
	},
	anisotropy: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;

		}
	},
	offset: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;

		}
	},
	repeat: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;

		}
	},
	format: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;

		}
	},
	type: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;

		}
	},
	generateMipmaps: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;

		}
	}

} );

//

Audio.prototype.load = function ( file ) {

	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
	const scope = this;
	const audioLoader = new AudioLoader();
	audioLoader.load( file, function ( buffer ) {

		scope.setBuffer( buffer );

	} );
	return this;

};


AudioAnalyser.prototype.getData = function () {

	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();

};

//

CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

	console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
	return this.update( renderer, scene );

};

CubeCamera.prototype.clear = function ( renderer, color, depth, stencil ) {

	console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );
	return this.renderTarget.clear( renderer, color, depth, stencil );

};

ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

	const loader = new TextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( url, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

	const loader = new CubeTextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( urls, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadCompressedTexture = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

};

ImageUtils.loadCompressedTextureCube = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

};

//

function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been removed' );

}

//

function JSONLoader() {

	console.error( 'THREE.JSONLoader has been removed.' );

}

//

const SceneUtils = {

	createMultiMaterialObject: function ( /* geometry, materials */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	detach: function ( /* child, parent, scene */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	attach: function ( /* child, scene, parent */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	}

};

//

function LensFlare() {

	console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );

}

//

function ParametricGeometry() {

	console.error( 'THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js' );
	return new BufferGeometry();

}

function TextGeometry() {

	console.error( 'THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js' );
	return new BufferGeometry();

}

function FontLoader() {

	console.error( 'THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js' );

}

function Font() {

	console.error( 'THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js' );

}

function ImmediateRenderObject() {

	console.error( 'THREE.ImmediateRenderObject has been removed.' );

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	/* eslint-disable no-undef */
	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );
	/* eslint-enable no-undef */

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}




/***/ }),

/***/ "./src/core/renderer/devices/three/shaders.js":
/*!****************************************************!*\
  !*** ./src/core/renderer/devices/three/shaders.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const ThreeShaders = {};

ThreeShaders.tileVertexShader =

    '#ifdef onlyFog\n'+
        'varying float vFogFactor;\n'+
    '#endif\n'+

    '#ifdef clip4\n'+
        'varying vec2 vClipCoord;\n'+
    '#endif\n'+

    '#ifdef clip8\n'+
        'varying vec3 vClipCoord;\n'+

        'uniform mat4 uParams;\n'+  //[zfactor, fogDensity, scale.xy][camVec.xyzw][transform.xyzw][scale.z, trans.xyz]
        'uniform mat4 uParamsC8;\n'+  //c,x,y,z

        'float getLinePointParametricDist(vec3 c, vec3 v, vec3 p) {\n'+
            'vec3 w = p - c;\n'+
            'float c1 = dot(w,v);\n'+
            'if (c1 <= 0.0) return 0.0;\n'+
            'float c2 = dot(v,v);\n'+
            'if (c2 <= c1) return 1.0;\n'+
            'return c1 / c2;\n'+
        '}\n'+

    '#endif\n'+

    '#ifdef depth\n'+
        'varying float vDepth;\n'+
    '#endif\n'+

    '#ifdef flatShadeVar\n'+
        'varying vec3 vBarycentric;\n'+
    '#endif\n'+

    '#ifndef depth\n'+
        'uniform vec4 uvTrans;\n'+
        'varying vec2 vUv;\n'+
    '#endif\n'+

    '#ifdef uvs\n'+
        'attribute vec2 uv2;\n'+
    '#endif\n'+

                             //0-3                            4-7          8-11            12-15
    //'uniform mat4 uParams;\n'+  //[zfactor, fogDensity, scale.xy][camVec.xyzw][transform.xyzw][scale.z, trans.xyz]

    '#ifdef applySE\n'+
        'uniform mat4 uParamsSE;\n'+
    '#endif\n'+

    'void main() {\n'+

        '#ifdef applySE\n'+
            'vec3 geoPos2 = position*vec3(uParamsSE[0][3],uParamsSE[1][0],uParamsSE[1][1]);\n'+
            'vec3 geoPos = geoPos2+vec3(uParamsSE[0][0],uParamsSE[0][1],uParamsSE[0][2]);\n'+
            'geoPos.z *= uParamsSE[3][3];\n'+
            'float ll = length(geoPos);\n'+
            'vec3 v = geoPos * (1.0/(ll+0.0001));\n'+
            'float h = ll - uParamsSE[3][2];\n'+
            'float h2 = clamp(h, uParamsSE[2][1], uParamsSE[2][3]);\n'+
            'float h3 = h;\n'+
            'h *= (uParamsSE[2][2] + ((h2 - uParamsSE[2][1]) * uParamsSE[3][0]) * uParamsSE[3][1]);\n'+
            'geoPos2.xyz += v * (h - h3);\n'+
            'vec4 camSpacePos = uMV * vec4(geoPos2, 1.0);\n'+
            'float l = dot(v, vec3(uParams[1][0],uParams[1][1],uParams[1][2]));\n'+
        '#else\n'+
            'vec4 camSpacePos = modelViewMatrix * vec4(position, 1.0);\n'+
            /*
            'vec3 worldPos = vec3(position.x * uParams[0][2] + uParams[3][1], position.y * uParams[0][3] + uParams[3][2], position.z * uParams[3][0] + uParams[3][3]);\n'+
            'float l = dot(normalize(worldPos.xyz), vec3(uParams[1][0],uParams[1][1],uParams[1][2]));\n'+
            */
        '#endif\n'+

        'gl_Position = projectionMatrix * camSpacePos;\n'+

        '#ifdef depth\n'+
            'float camDist = length(camSpacePos.xyz);\n'+
            'vDepth = camDist;\n'+
        '#endif\n'+

        '#ifdef flatShadeVar\n'+
            'vBarycentric = camSpacePos.xyz;\n'+
        '#endif\n'+

        /*
        'float fogFactor = 1.0-exp(uParams[0][1] * camDist);\n'+
        'fogFactor = clamp((1.0-abs(l))*uParams[1][3] + fogFactor, 0.0, 1.0);\n'+

        '#ifdef onlyFog\n'+
            'vFogFactor = fogFactor;\n'+
        '#else\n'+
            'vTexCoord.z = fogFactor;\n'+

            '#ifdef externalTex\n'+
                'vTexCoord.xy = vec2(uParams[2][0] * aTexCoord2[0] + uParams[2][2], uParams[2][1] * aTexCoord2[1] + uParams[2][3]);\n'+
            '#else\n'+
                'vTexCoord.xy = aTexCoord;\n'+
            '#endif\n'+

        '#endif\n'+
        */

        //'vUv = uv;\n'+

        '#ifndef depth\n'+
            'vUv = vec2(uv.x * uvTrans.x + uvTrans.z, uv.y * uvTrans.y + uvTrans.w);\n' +
        '#endif\n'+

        '#ifdef clip4\n'+
            '#ifdef uvs\n'+
                'vClipCoord.xy = uv2.xy;\n'+
            '#else\n'+
                'vClipCoord.xy = uv.xy;\n'+
            '#endif\n'+
        '#endif\n'+

        '#ifdef clip8\n'+
            'vec3 worldPos2 = vec3(position.x * uParams[0][2] + uParamsC8[0][3], position.y * uParams[0][3] + uParamsC8[1][3], position.z * uParams[3][0] + uParamsC8[2][3]);\n'+
            'vClipCoord.x = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[1][0],uParamsC8[1][1],uParamsC8[1][2]), worldPos2.xyz);\n'+
            'vClipCoord.y = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[2][0],uParamsC8[2][1],uParamsC8[2][2]), worldPos2.xyz);\n'+
            'vClipCoord.z = 1.0-getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[3][0],uParamsC8[3][1],uParamsC8[3][2]), worldPos2.xyz);\n'+
        '#endif\n'+
    '}';

ThreeShaders.tileFragmentShader = 'precision mediump float;\n'+

    '#ifdef clip4\n'+
        'uniform float uClip[4];\n'+
        'varying vec2 vClipCoord;\n'+
    '#endif\n'+

    '#ifdef clip8\n'+
        'uniform float uClip[8];\n'+
        'varying vec3 vClipCoord;\n'+
    '#endif\n'+


    '#ifdef onlyFog\n'+
        'varying float vFogFactor;\n'+
    '#else\n'+

        '#ifdef mask\n'+
            'uniform sampler2D uSampler2;\n'+
        '#endif\n'+

    '#endif\n'+

    '#ifdef depth\n'+
        'varying float vDepth;\n'+
    '#endif\n'+

    '#ifdef flatShadeVar\n'+
        'varying vec3 vBarycentric;\n'+

        '#ifdef fogAndColor\n'+
            'uniform vec4 uColor;\n'+
        '#endif\n'+

    '#endif\n'+

    '#ifndef depth\n'+
        'varying vec2 vUv;\n'+
    '#endif\n'+

    'uniform sampler2D map;\n'+

    /*'uniform vec4 uParams2;\n'+*/

    'void main() {\n'+

        '#ifdef clip4_nomargin\n'+
            'if (vClipCoord.y > 0.5){\n'+
                'if (vClipCoord.x > 0.5){\n'+
                    'if (uClip[3] == 0.0) discard;\n'+
                '} else {\n'+
                    'if (uClip[2] == 0.0) discard;\n'+
                '}\n'+
            '} else {\n'+
                'if (vClipCoord.x > 0.5){\n'+
                    'if (uClip[1] == 0.0) discard;\n'+
                '} else {\n'+
                    'if (uClip[0] == 0.0) discard;\n'+
                '}\n'+
            '}\n'+
        '#endif\n'+

        '#ifdef clip4\n'+
            'if (vClipCoord.y > 0.5){\n'+
                'if (vClipCoord.x > 0.5){\n'+
                    'if (uClip[3] == 0.0 && !(vClipCoord.x < TMAX && uClip[2] != 0.0) && !(vClipCoord.y < TMAX && uClip[1] != 0.0)) discard;\n'+
                '} else {\n'+
                    'if (uClip[2] == 0.0 && !(vClipCoord.x > TMIN && uClip[3] != 0.0) && !(vClipCoord.y < TMAX && uClip[0] != 0.0)) discard;\n'+
                '}\n'+
            '} else {\n'+
                'if (vClipCoord.x > 0.5){\n'+
                    'if (uClip[1] == 0.0 && !(vClipCoord.x < TMAX && uClip[0] != 0.0) && !(vClipCoord.y > TMIN && uClip[3] != 0.0)) discard;\n'+
                '} else {\n'+
                    'if (uClip[0] == 0.0 && !(vClipCoord.x > TMIN && uClip[1] != 0.0) && !(vClipCoord.y > TMIN && uClip[2] != 0.0)) discard;\n'+
                '}\n'+
            '}\n'+
        '#endif\n'+

        '#ifdef clip8\n'+
            'if (vClipCoord.z <= 0.5){\n'+
                'if (vClipCoord.y <= 0.5){\n'+
                    'if (vClipCoord.x > 0.5){\n'+
                        'if (uClip[5] == 0.0) discard;\n'+
                    '} else {\n'+
                        'if (uClip[4] == 0.0) discard;\n'+
                    '}\n'+
                '} else {\n'+
                    'if (vClipCoord.x > 0.5){\n'+
                        'if (uClip[7] == 0.0) discard;\n'+
                    '} else {\n'+
                        'if (uClip[6] == 0.0) discard;\n'+
                    '}\n'+
                '}\n'+
            '} else {\n'+
                'if (vClipCoord.y <= 0.5){\n'+
                    'if (vClipCoord.x > 0.5){\n'+
                        'if (uClip[1] == 0.0) discard;\n'+
                    '} else {\n'+
                        'if (uClip[0] == 0.0) discard;\n'+
                    '}\n'+
                '} else {\n'+
                    'if (vClipCoord.x > 0.5){\n'+
                        'if (uClip[3] == 0.0) discard;\n'+
                    '} else {\n'+
                        'if (uClip[2] == 0.0) discard;\n'+
                    '}\n'+
                '}\n'+
            '}\n'+
        '#endif\n'+

        '#ifdef flatShadeVar\n'+

            '#ifdef flatShadeVarFallback\n'+
                'vec4 flatShadeData = vec4(1.0);\n'+
            '#else\n'+
                //clip8'#ifdef GL_OES_standard_derivatives\n'+
                    'vec3 nx = dFdx(vBarycentric);\n'+
                    'vec3 ny = dFdy(vBarycentric);\n'+
                    'vec3 normal=normalize(cross(nx,ny));\n'+
                    'vec4 flatShadeData = vec4(vec3(max(0.0,normal.z*(204.0/255.0))+(32.0/255.0)),1.0);\n'+
                //'#else\n'+
                //    'vec4 flatShadeData = vec4(1.0);\n'+
                //'#endif\n'+
            '#endif\n'+

        '#endif\n'+

        '#ifdef flatShade\n'+

            '#ifdef flatShadeInner\n'+
               // 'gl_FragColor = vec4(mix(uColor.xyz * flatShadeData.xyz, uParams2.xyz, vTexCoord.z), uColor.w);\n'+
                //'gl_FragColor = vec4(uColor.xyz * flatShadeData.xyz, uColor.w);\n'+
                'gl_FragColor.xyz = texture2D(map, vUv.xy).xyz * flatShadeData.xyz;\n'+
                'gl_FragColor.w = 1.0;\n'+
            '#else\n'+
                'gl_FragColor = vec4(flatShadeData.xyz, 1.0);\n'+
            '#endif\n'+

        '#else\n'+

            '#ifdef depth\n'+
                'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\n'+
            '#else\n'+
                'gl_FragColor = texture2D(map, vUv.xy);\n'+
                //'gl_FragColor = vec4(vUv.x,vUv.y,1.0,1.0);\n'+
                'gl_FragColor.w = 1.0;\n'+
            '#endif\n'+


            /*
            'vec4 fogColor = vec4(uParams2.xyz, 1.0);\n'+

            '#ifdef onlyFog\n'+
                'gl_FragColor = vec4(fogColor.xyz, vFogFactor);\n'+
            '#else\n'+

                '#ifdef depth\n'+
                    'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\n'+
                '#else\n'+

                    '#ifdef externalTex\n'+
                        'vec4 c = texture2D(uSampler, vTexCoord.xy);\n'+'__FILTER__' +
                        'vec4 cc = mix(c, fogColor, vTexCoord.z);\n'+
                        '#ifdef mask\n'+
                            'vec4 c2 = texture2D(uSampler2, vTexCoord.xy);\n'+
                            'cc.w = c.w * uParams2.w * c2.x;\n'+
                        '#else\n'+
                            'cc.w = c.w * uParams2.w;\n'+
                        '#endif\n'+

                        'gl_FragColor = cc;\n'+
                    '#else\n'+
                        'gl_FragColor = mix(texture2D(uSampler, vTexCoord.xy), fogColor, vTexCoord.z);\n'+
                    '#endif\n'+

                '#endif\n'+

            '#endif\n'+
            */

        '#endif\n'+
    '}';


    ThreeShaders.bbox2VertexShader =
        //'attribute float position;\n'+
        'uniform float uPoints[8*3];\n'+
        'void main(){ \n'+
            'int index = int(position) * 3; \n'+
            'gl_Position =  projectionMatrix * modelViewMatrix * vec4(uPoints[index], uPoints[index+1], uPoints[index+2], 1.0);\n'+
        '}';


    ThreeShaders.bboxFragmentShader = 'precision mediump float;\n'+
        'void main() {\n'+
            'gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n'+
        '}';


    ThreeShaders.textVertexShader =
        'uniform mat4 uProj;\n'+
        'attribute vec3 color;\n'+
        //'attribute vec2 uv;\n'+
        'varying vec3 vColor;\n'+
        'varying vec2 vUv;\n'+
        'void main(){ \n'+
            'vColor = color;\n'+
            'vUv = uv;\n'+
            'gl_Position =  uProj * vec4(position.x, position.y, position.z, 1.0);\n'+
        '}';


    ThreeShaders.textFragmentShader = 'precision mediump float;\n'+
        'uniform sampler2D map;\n'+
        'varying vec3 vColor;\n'+
        'varying vec2 vUv;\n'+
        'void main() {\n'+
            'gl_FragColor.xyz = vColor * texture2D(map, vUv.xy * vec2(1.0/256.0, 1.0/128.0)).xyz;\n'+
            'gl_FragColor.w = 1.0;\n'+
        '}';


/* harmony default export */ __webpack_exports__["default"] = (ThreeShaders);


/***/ }),

/***/ "./src/core/renderer/devices/webgl/bbox.js":
/*!*************************************************!*\
  !*** ./src/core/renderer/devices/webgl/bbox.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


const WebGLBBox = function(gpu, free) {
    this.gl = gpu.gl;

    const gl = this.gl;

    if (gl == null)
        return;

    this.free = free;
    this.vertexPositionBuffer = null;

    //create vertex buffer
    this.vertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);

    let vertices;

    if (free) {
        vertices = [0,0,0, 0,0,1,
            0,0,1, 0,0,2,
            0,0,2, 0,0,3,
            0,0,3, 0,0,0,

            0,0,4, 0,0,5,
            0,0,5, 0,0,6,
            0,0,6, 0,0,7,
            0,0,7, 0,0,4,

            0,0,0, 0,0,4,
            0,0,1, 0,0,5,
            0,0,2, 0,0,6,
            0,0,3, 0,0,7 ];
    } else {
        vertices = [0,0,0, 1,0,0,
            1,0,0, 1,1,0,
            1,1,0, 0,1,0,
            0,1,0, 0,0,0,

            0,0,1, 1,0,1,
            1,0,1, 1,1,1,
            1,1,1, 0,1,1,
            0,1,1, 0,0,1,

            0,0,0, 0,0,1,
            1,0,0, 1,0,1,
            1,1,0, 1,1,1,
            0,1,0, 0,1,1 ];
    }

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    this.vertexPositionBuffer.itemSize = 3;
    this.vertexPositionBuffer.numItems = vertices.length / 3;

    this.size = 4 + 4 * 8;
    this.lines = this.vertexPositionBuffer.numItems / 3;
};

//destructor
WebGLBBox.prototype.kill = function() {
    this.gl.deleteBuffer(this.vertexPositionBuffer);
};

// Draws the mesh, given the two vertex shader attributes locations.
WebGLBBox.prototype.draw = function(program, attrPosition) {
    const gl = this.gl;
    if (gl == null)
        return;

    const vertexPositionAttribute = program.getAttribute(attrPosition);

    //bind vetex positions
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
    gl.vertexAttribPointer(vertexPositionAttribute, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    //draw lines
    gl.drawArrays(gl.LINES, 0, this.vertexPositionBuffer.numItems);

};


/* harmony default export */ __webpack_exports__["default"] = (WebGLBBox);


/***/ }),

/***/ "./src/core/renderer/devices/webgl/device.js":
/*!***************************************************!*\
  !*** ./src/core/renderer/devices/webgl/device.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ "./src/core/renderer/devices/webgl/init.js");
/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./draw */ "./src/core/renderer/devices/webgl/draw.js");
/* harmony import */ var _program__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./program */ "./src/core/renderer/devices/webgl/program.js");
/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders */ "./src/core/renderer/devices/webgl/shaders.js");
/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./group */ "./src/core/renderer/devices/webgl/group.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./texture */ "./src/core/renderer/devices/webgl/texture.js");
/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mesh */ "./src/core/renderer/devices/webgl/mesh.js");









//get rid of compiler mess
const mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
const WebGLProgram = _program__WEBPACK_IMPORTED_MODULE_3__["default"];
const WebGLShaders = _shaders__WEBPACK_IMPORTED_MODULE_4__["default"];
const WebGLInit = _init__WEBPACK_IMPORTED_MODULE_1__["default"];
const WebGLDraw = _draw__WEBPACK_IMPORTED_MODULE_2__["default"];
const WebGLGroup = _group__WEBPACK_IMPORTED_MODULE_5__["default"];
const WebGLTexture = _texture__WEBPACK_IMPORTED_MODULE_6__["default"];
const WebGLMesh = _mesh__WEBPACK_IMPORTED_MODULE_7__["default"];

const WebGLDevice = function(renderer, div, size, keepFrameBuffer, antialias, aniso) {
    this.renderer = renderer;
    this.div = div;
    this.config = renderer.config;
    this.canvas =  null;
    this.curSize = size;
    this.currentProgram = null;
    this.maxAttributesCount = 8;
    this.newAttributes = new Uint8Array(this.maxAttributesCount);
    this.enabledAttributes = new Uint8Array(this.maxAttributesCount);
    this.noTextures = false;
    this.barycentricBuffer = null;
    this.progTile = null;
    this.progHeightmap = null;
    this.progSkydome = null;
    this.progWireframeTile = null;
    this.progWireframeTile2 = null;
    this.progText = null;
    this.progMap = [];

    //state of device when first initialized
    this.defaultState = this.createState({blend:false, stencil:false, zequal: false, ztest:false, zwrite: false, culling:false});
    this.currentState = this.defaultState;
    this.currentOffset = 0; //used fot direct offset

    this.keepFrameBuffer = (keepFrameBuffer == null) ? false : keepFrameBuffer;
    this.antialias = antialias ? true : false;
    this.anisoLevel = aniso;

    this.mBuffer = new Float32Array(16);
    this.mBuffer2 = new Float32Array(16);
    this.vBuffer = new Float32Array(4);
};


WebGLDevice.prototype.init = function() {
    const canvas = document.createElement('canvas');

    if (canvas == null) {
        //canvas not supported
        return;
    }

    this.canvas = canvas;

    canvas.width = this.curSize[0];
    canvas.height = this.curSize[1];
    canvas.style.display = 'block';
    canvas.style.width = '100%';
    canvas.style.height = '100%';

    if (canvas.getContext == null) {
        //canvas not supported
        return;
    }

    canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), false);
    canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), false);

    let gl;

    try {
        gl = canvas.getContext('webgl', {preserveDrawingBuffer: this.keepFrameBuffer, antialias: this.antialias, stencil: true}) || canvas.getContext('experimental-webgl', {preserveDrawingBuffer: this.keepFrameBuffer});
    } catch(e) {
        //webgl not supported
    }

    if (!gl) {
        //webgl not supported
        return;
    }

    this.gl = gl;

    //if (!
        gl.getExtension('OES_standard_derivatives');
    //){}

    this.anisoExt = (
      gl.getExtension('EXT_texture_filter_anisotropic') ||
      gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
      gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
    );

    if (this.anisoExt) {
        this.maxAniso = gl.getParameter(this.anisoExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);

        if (this.anisoLevel) {
            if (this.anisoLevel == -1) {
                this.anisoLevel = this.maxAniso;
            } else {
                this.anisoLevel = Math.min(this.anisoLevel, this.maxAniso);
            }
        }
    } else {
        this.maxAniso = 0;
        this.anisoLevel = 0;
    }

    this.div.appendChild(canvas);

    gl.viewportWidth = canvas.width;
    gl.viewportHeight = canvas.height;

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    //gl.enable(gl.DEPTH_TEST);

    //initial state
    gl.disable(gl.BLEND);

    gl.disable(gl.STENCIL_TEST);
    gl.depthMask(false);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.disable(gl.CULL_FACE);

    //clear screen
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    this.init = new WebGLInit(this);
    this.draw = new WebGLDraw(this);

};


WebGLDevice.prototype.kill = function() {

    if (this.heightmapMesh) this.heightmapMesh.kill();
    if (this.heightmapTexture) this.heightmapTexture.kill();
    if (this.skydomeMesh) this.skydomeMesh.kill();
    if (this.skydomeTexture) this.skydomeTexture.kill();
    if (this.hitmapTexture) this.hitmapTexture.kill();
    if (this.geoHitmapTexture) this.geoHitmapTexture.kill();
    if (this.redTexture) this.redTexture.kill();
    if (this.whiteTexture) this.whiteTexture.kill();
    if (this.blackTexture) this.blackTexture.kill();
    if (this.lineTexture) this.lineTexture.kill();
    if (this.textTexture2) this.textTexture2.kill();
    if (this.atmoMesh) this.atmoMesh.kill();
    if (this.bboxMesh) this.bboxMesh.kill();
    if (this.font) this.font.kill();
    if (this.plines) this.plines.kill();
    if (this.plineJoints) this.plineJoints.kill();

    this.div.removeChild(this.canvas);
    delete this.canvas;
    this.canvas = null;
};


WebGLDevice.prototype.contextLost = function(event) {
    event.preventDefault();
    this.renderer.core.contextLost = true;
    this.renderer.core.callListener('gpu-context-lost', {});
};


WebGLDevice.prototype.contextRestored = function() {
    this.renderer.core.callListener('gpu-context-restored', {});
};


WebGLDevice.prototype.resize = function(size, skipCanvas) {
    this.curSize = size;
    const canvas = this.canvas, gl = this.gl;

    if (canvas != null && skipCanvas !== true) {
        canvas.width = this.curSize[0];
        canvas.height = this.curSize[1];
    }

    if (gl != null) {
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
    }
};


WebGLDevice.prototype.setAniso = function(aniso) {
    if (this.anisoExt) {
        if (this.anisoLevel) {
            if (aniso == -1) {
                this.anisoLevel = this.maxAniso;
            } else {
                this.anisoLevel = Math.min(aniso, this.maxAniso);
            }
        }
    }
};


WebGLDevice.prototype.getCanvas = function() {
    return this.canvas;
};


WebGLDevice.prototype.setViewport = function() {
    this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);
};


WebGLDevice.prototype.clear = function(clearDepth, clearColor, color) {
    if (color != null) {
        this.gl.clearColor(color[0]/255, color[1]/255, color[2]/255, color[3]/255);
    }

    this.gl.clear((clearColor ? this.gl.COLOR_BUFFER_BIT : 0) |
                  (clearDepth ? this.gl.DEPTH_BUFFER_BIT : 0) );
};


WebGLDevice.prototype.useProgram = function(program, attributes, nextSampler) {
    if (this.currentProgram != program) {
        this.gl.useProgram(program.program);
        this.currentProgram = program;

        program.setSampler('uSampler', 0);

        if (nextSampler) {
            program.setSampler('uSampler2', 1);
        }

        const newAttributes = this.newAttributes;
        const enabledAttributes = this.enabledAttributes;

        //reset new attributes list
        for (let i = 0, li = newAttributes.length; i < li; i++){
            newAttributes[i] = 0;
        }

        for (let i = 0, li = attributes.length; i < li; i++){
            const index = program.getAttribute(attributes[i]);

            if (index != -1){
                newAttributes[index] = 1;
            }
        }

        //enable or disable current attributes according to new attributes list
        for (let i = 0, li = newAttributes.length; i < li; i++){
            if (enabledAttributes[i] != newAttributes[i]) {
                if (newAttributes[i]) {
                    this.gl.enableVertexAttribArray(i);
                    enabledAttributes[i] = 1;
                } else {
                    this.gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }
        }
    }
};


WebGLDevice.prototype.bindTexture = function(texture, id) {
    if (!texture.loaded) {
        return;
    }

    this.gl.activeTexture(id ? this.gl.TEXTURE1 : this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texture);
};


WebGLDevice.prototype.setFramebuffer = function(texture) {
    if (texture != null) {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.framebuffer);
    } else {
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    }
};


WebGLDevice.prototype.createState = function(state) {
    if (state.blend == null) { state.blend = false; }
    if (state.stencil == null) { state.stencil = false; }
    if (state.zwrite == null) { state.zwrite = true; }
    if (state.ztest == null) { state.ztest = true; }
    if (state.zequal == null) { state.zequal = false; }
    if (state.culling == null) { state.culling = true; }

    return state;
};


WebGLDevice.prototype.setState = function(state) {
    if (!state) {
        return;
    }

    const gl = this.gl;
    const currentState = this.currentState;

    if (currentState.blend != state.blend) {
        if (state.blend) {
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);
        } else {
            gl.disable(gl.BLEND);
        }
    }

    if (currentState.stencil != state.stencil) {
        if (state.stencil) {
            gl.enable(gl.STENCIL_TEST);
        } else {
            gl.disable(gl.STENCIL_TEST);
        }
    }

    if (currentState.zwrite != state.zwrite) {
        if (state.zwrite) {
            gl.depthMask(true);
        } else {
            gl.depthMask(false);
        }
    }

    if (currentState.ztest != state.ztest) {
        if (state.ztest != 0) {
            gl.enable(gl.DEPTH_TEST);
        } else {
            gl.disable(gl.DEPTH_TEST);
        }
    }

    if (currentState.zequal != state.zequal) {
        if (state.zequal != 0) {
            gl.depthFunc(gl.LEQUAL);
        } else {
            gl.depthFunc(gl.LESS);
        }
    }

    if (currentState.culling != state.culling) {
        if (state.culling) {
            gl.enable(gl.CULL_FACE);
        } else {
            gl.disable(gl.CULL_FACE);
        }
    }

    this.currentState = state;
};


WebGLDevice.prototype.setSize = function(width, height) {
    this.resize(this.curSize /*, skipCanvas*/);

    //if (skipPaint !== true) { //remove this??
       // this.draw.paintGL();
    //}
};

WebGLDevice.prototype.generateTileShader = function (progs, v, useSuperElevation, splitMask) {
    let str = '';
    if (splitMask) {
        if (!this.config.mapSplitMargin) {
            if (splitMask.length == 4){ str += '#define clip4_nomargin\n' } else { str += '#define clip8\n' }
        } else {
            if (splitMask.length == 4){ str += '#define clip4\n' } else { str += '#define clip8\n' }
            str += '#define TMIN ' + (0.5-this.config.mapSplitMargin) + '\n' + '#define TMAX ' + (0.5+this.config.mapSplitMargin) + '\n';
        }
    }

    if (v & 8) {
        str +=  '#extension GL_OES_standard_derivatives : enable\n';
        str += '#define flatShade\n';
        str += '#define flatShadeVar\n';
        str += '#define flatShadeInner\n';
    }

    if (useSuperElevation) str += '#define applySE\n';
    const prog = (new WebGLProgram(this, progs[0].vertex.replace('#define variants\n', str), progs[0].fragment.replace('#define variants\n', str)));
    progs[v] = prog;
    return prog;
};


WebGLDevice.prototype.generateTileShaderWithFilter = function (progs, v, useSuperElevation, splitMask, gpuMask, flatShade, filter) {
    const map = this.renderer.core.map;
    let pixelShader, variations = '';

    if (splitMask) {
        if (!map.config.mapSplitMargin) {
            variations += '#define clip4_nomargin\n';
        } else {
            variations += '#define clip4\n';
            variations += '#define TMIN ' + (0.5-map.config.mapSplitMargin) + '\n' + '#define TMAX ' + (0.5+map.config.mapSplitMargin) + '\n';
        }
    }

    let vertexShader = '#define externalTex\n' + variations + ((useSuperElevation) ? '#define applySE\n' : '') + WebGLShaders.tileVertexShader;

    if (gpuMask) {
        pixelShader = '#define externalTex\n#define mask\n' + variations + WebGLShaders.tileFragmentShader;
    } else {
        pixelShader = '#define externalTex\n' + variations + WebGLShaders.tileFragmentShader;
    }

    if (flatShade) {
        pixelShader =  '#extension GL_OES_standard_derivatives : enable\n#define flatShadeVar\n' + pixelShader;
        vertexShader = '#define flatShadeVar\n' + vertexShader;

        //if (map.mobile) {
            //pixelShader = '#define flatShadeVarFallback\n' + pixelShader;
            pixelShader = pixelShader.replace('mediump', 'highp');
        //}
    }

    const program = new WebGLProgram(this, vertexShader, pixelShader.replace('__FILTER__', filter));
    progs[v] = program;
    return program;
};


WebGLDevice.prototype.createRenderGroup = function(id, bbox, origin) {
    return new WebGLGroup(id, bbox, origin, this, this.renderer);
};


WebGLDevice.prototype.drawTileSubmesh = function (cameraPos, index, texture, type, alpha, layer, surface, splitMask, splitSpace, submesh, gpuSubmesh) {

    const renderer = this.renderer;
    const map = this.renderer.core.map;
    const draw = map.draw;
    const stats = map.stats;
    let program = null;
    let gpuMask = null;

    let texcoordsAttr = null;
    let texcoords2Attr = null;
    const drawWireframe = draw.debug.drawWireframe;
    const useSuperElevation = renderer.useSuperElevation;
    let attributes = ['aPosition'];
    let vbits = (useSuperElevation) ? 4 : 0;

    if (drawWireframe == 2) {
        type = 2;
    }

    if (splitMask) {
        vbits |= 1;

        if (type != 6 && type != 5) {
            texcoords2Attr = 'aTexCoord2';
            attributes.push('aTexCoord2');
        }
    }

    if (texture && draw.debug.meshStats) {
        if (!submesh.uvAreaComputed) {
            submesh.computeUVArea(texture.getGpuTexture());
        }

        stats.meshesUVArea += submesh.uvArea;
        stats.meshesFaces += submesh.faces;
    }

    if (type == 1) {
        program = this.progDepthTile[vbits];

        if (!program) {
            program = this.generateTileShader(this.progDepthTile, vbits, useSuperElevation, splitMask);
        }

    } else if (type == 2) {
        program = this.progFlatShadeTile[vbits];

        if (!program) {
            program = this.generateTileShader(this.progFlatShadeTile, vbits, useSuperElevation, splitMask);
        }

    } else {
        if (drawWireframe > 0 && type == 3) {
            return;
        }

        if (drawWireframe == 1 || drawWireframe == 3) {
            program = this.progFlatShadeTile[vbits];

            if (!program) {
                program = this.generateTileShader(this.progFlatShadeTile, vbits, useSuperElevation, splitMask);
            }

        } else {
            switch(type) {
            case 4:
            case 5:

                texcoordsAttr = 'aTexCoord';
                attributes.push('aTexCoord');

                if (surface && surface.flatShade) {
                    vbits |= 8;
                }

                program = this.progTile[vbits];

                if (!program) {
                    program = this.generateTileShader(this.progTile, vbits, useSuperElevation, splitMask);
                }

                break;

            case 6:
            case 7:
                {
                    let prog = this.progTile2;

                    if (texture) {
                        gpuMask = texture.getGpuMaskTexture();
                        if (gpuMask) {
                            prog = this.progTile3;
                        }
                    }

                    program = prog[vbits];

                    if (!program) {
                        program = this.generateTileShader(prog, vbits, useSuperElevation, splitMask);
                    }


                    if (layer && (layer.shaderFilters || layer.shaderFilter)) {
                        let filter, flatShade;

                        if (surface && layer.shaderFilters) {
                            filter = layer.shaderFilters[surface.id];

                            if (filter) {
                                if (filter.varFlatShade) {
                                    flatShade = true;
                                }

                                filter = filter.filter;
                            }
                        }

                        if (!filter) {
                            filter = layer.shaderFilter;
                        }

                        if (filter) {
                            let id = (gpuMask) ? 'progTile3' : 'progTile2';

                            if (useSuperElevation) {
                                id += 'se';
                            }

                            if (flatShade) {
                                id += 'fs';
                            }

                            if (splitMask) {
                                id += 'c4';
                            }

                            id += filter;

                            program = this.progMap[id];

                            if (!program) {
                                program = this.generateTileShaderWithFilter(this.progMap, id, useSuperElevation, splitMask, gpuMask, flatShade, filter);
                            }
                        }
                    }

                    texcoords2Attr = 'aTexCoord2';
                    attributes.push('aTexCoord2');
                }
                break;

            case 3:
                program = this.progFogTile[vbits];

                if (!program) {
                    program = this.generateTileShader(this.progFogTile, vbits, useSuperElevation, splitMask);
                }

                break;
            }
        }
    }

    if (!program || !program.isReady()) {
        return;
    }

    this.useProgram(program, attributes, gpuMask);

    let gpuTexture;

    if (texture) {

        if (!(draw.config.mapNoTextures || drawWireframe)) {
            gpuTexture = texture.getGpuTexture();

            if (gpuTexture) {
                if (texture.statsCoutner != stats.counter) {
                    texture.statsCoutner = stats.counter;
                    stats.gpuRenderUsed += gpuTexture.getSize();
                }

                this.bindTexture(gpuTexture);

                if (gpuMask) {
                    this.bindTexture(gpuMask, 1);
                }

            } else {
                return;
            }
        }

    } else if (type != 3 && type != 1 && type != 2) {
        return;
    }

    let mv = this.mBuffer, m = this.mBuffer2, v = this.vBuffer;

    if (useSuperElevation) {

        m = this.mBuffer;
        const se = renderer.superElevation;

        m[0] = submesh.bbox.min[0];
        m[1] = submesh.bbox.min[1];
        m[2] = submesh.bbox.min[2];

        m[3] = submesh.bbox.side(0);
        m[4] = submesh.bbox.side(1);
        m[5] = submesh.bbox.side(2);

        //m[6] = 0;
        //m[7] = 0;
        //m[8] = 0;

        m[9] = se[0]; // h1
        m[10] = se[1]; // f1
        m[11] = se[2]; // h2
        m[12] = se[6]; // inv dh
        m[13] = se[5]; // df

        m[14] = renderer.earthRadius;
        m[15] = renderer.earthERatio;

        program.setMat4('uParamsSE', m);

        //mv = renderer.camera.getModelviewFMatrix();
        mat4.multiply(renderer.camera.getModelviewFMatrix(), submesh.getWorldMatrixSE(cameraPos, m), mv);

    } else {
        mat4.multiply(renderer.camera.getModelviewFMatrix(), submesh.getWorldMatrix(cameraPos, m), mv);
    }


    let proj = renderer.camera.getProjectionFMatrix();

    program.setMat4('uMV', mv);

    if (draw.zbufferOffset) {
        program.setMat4('uProj', proj, renderer.getZoffsetFactor(draw.zbufferOffset));
    } else {
        program.setMat4('uProj', proj);
    }

    if (splitMask) {
        program.setFloatArray('uClip', splitMask);

        //const fx = this.getLinePointParametricDist(points[0], points[1], point);
        //const fy = this.getLinePointParametricDist(points[1], points[2], point);
        //const fz = this.getLinePointParametricDist(points[4], points[0], point);

        let p = map.camera.position;
        let s = splitSpace;
        //const c = [s[0][0] - p[0], s[0][1] - p[1], s[0][2] - p[2]];
        //const px = [s[1][0] - p[0], s[1][1] - p[1], s[1][2] - p[2]];
        //const py = [s[2][0] - p[0], s[2][1] - p[1], s[2][2] - p[2]];
        //const pz = [s[4][0] - p[0], s[4][1] - p[1], s[4][2] - p[2]];

        if (splitSpace) {
            m[0] = s[0][0] - p[0]; m[1] = s[0][1] - p[1]; m[2] = s[0][2] - p[2];
            m[4] = s[1][0] - s[0][0]; m[5] = s[1][1] - s[0][1]; m[6] = s[1][2] - s[0][2];
            m[8] = s[2][0] - s[1][0]; m[9] = s[2][1] - s[1][1]; m[10] = s[2][2] - s[1][2];
            //m[12] = s[0][0] - s[4][0]; m[13] = s[0][1] - s[4][1]; m[14] = s[0][2] - s[4][2];
            m[12] = s[4][0] - s[0][0]; m[13] = s[4][1] - s[0][1]; m[14] = s[4][2] - s[0][2];

            let bmin = submesh.bbox.min;// bmax = submesh.bbox.max;

            m[3] = bmin[0] - p[0];
            m[7] = bmin[1] - p[1];
            m[11] = bmin[2] - p[2];

            program.setMat4('uParamsC8', m);
        }
    }

    if (drawWireframe == 0) {
        let cv = map.camera.vector2, c = draw.atmoColor, t, bmin = submesh.bbox.min, bmax = submesh.bbox.max;

        switch(type) {
        case 4:
        case 3:
        case 5:

            m[0] = draw.zFactor, m[1] = (type == 5) ? 0 : draw.fogDensity;
            m[2] = bmax[0] - bmin[0], m[3] = bmax[1] - bmin[1],
            m[4] = cv[0], m[5] = cv[1], m[6] = cv[2], m[7] = cv[3],
            m[12] = bmax[2] - bmin[2], m[13] = bmin[0], m[14] = bmin[1], m[15] = bmin[2];

            program.setMat4('uParams', m);

            v[0] = c[0], v[1] = c[1], v[2] = c[2];
            program.setVec4('uParams2', v);

            break;

        case 6:
        case 7:

            t = texture.getTransform();

            m[0] = draw.zFactor, m[1] = (type == 6) ? draw.fogDensity : 0;
            m[2] = bmax[0] - bmin[0], m[3] = bmax[1] - bmin[1],
            m[4] = cv[0], m[5] = cv[1], m[6] = cv[2], m[7] = cv[3],
            m[8] = t[0], m[9] = t[1], m[10] = t[2], m[11] = t[3],
            m[12] = bmax[2] - bmin[2], m[13] = bmin[0], m[14] = bmin[1], m[15] = bmin[2];

            program.setMat4('uParams', m);

            v[0] = c[0], v[1] = c[1], v[2] = c[2]; v[3] = (type == 6) ? 1 : alpha;
            program.setVec4('uParams2', v);

            break;
        }
    }

    if (submesh.statsCoutner != stats.counter) {
        submesh.statsCoutner = stats.counter;
        stats.gpuRenderUsed += gpuSubmesh.getSize();
    }

    gpuSubmesh.draw(program, 'aPosition', texcoordsAttr, texcoords2Attr, drawWireframe != 0 ? 'aBarycentric' : null, (drawWireframe == 2));


    if (drawWireframe == 1 || drawWireframe == 2) { //very slow debug only
        program = this.progWireFrameBasic[vbits];

        if (!program) {
            program = this.generateTileShader(this.progWireFrameBasic, vbits, useSuperElevation, splitMask);
            this.progWireFrameBasic[vbits] = program;
        }

        this.useProgram(program, attributes, gpuMask);

        if (useSuperElevation) {
            program.setMat4('uParamsSE', m);
        }

        program.setMat4('uMV', mv);
        program.setVec4('uColor', [0,0,0,1]);

        program.setMat4('uProj', proj, renderer.getZoffsetFactor([-0.001,0,0]));

        if (splitMask) {
            program.setFloatArray('uClip', splitMask);
        }

        const gl = gpuSubmesh.gl;

        if (gpuSubmesh.indexBuffer) {
            for (let i = 0, li = gpuSubmesh.indexBuffer.numItems*2; i < li; i+=3) {
                gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i);
            }
        }  else {
            for (let i = 0, li = gpuSubmesh.vertexBuffer.numItems*2; i < li; i+=3) {
                gl.drawArrays(gl.LINE_LOOP, i, 3);
            }
        }
    }

    stats.drawnFaces += submesh.faces;
    stats.drawCalls ++;
};


WebGLDevice.prototype.createShader = function(options) {

    return new WebGLProgram(this, options.vertexShader, options.fragmentShader);

};


WebGLDevice.prototype.createTexture = function(options) {

    const texture = new WebGLTexture(this, null, this.renderer.core, null, null, options.tiled, options.filter);

    if (options.data) {
        texture.createFromData(options.width, options.height, options.data, options.filter, options.repeat);

        if (options.framebuffer) {
            texture.createFramebuffer(options.width, options.height);
        }

    } else if (options.path) {
        texture.load(options.path, options.onLoaded, options.onError, options.direct, options.keepImage);
    } else if (options.image) {
        texture.createFromImage(options.image, options.filter, options.repeat, options.aniso);
    }

    return texture;

};


WebGLDevice.prototype.createMesh = function(options) {

    //(gpu, meshData, fileSize, core, direct, use16bit, verticesUnnormalized) {

    return new WebGLMesh(this, options, 1, this.renderer.core, options.direct, options.use16bit); // true, this.use16bit);

}



/* harmony default export */ __webpack_exports__["default"] = (WebGLDevice);


/***/ }),

/***/ "./src/core/renderer/devices/webgl/draw.js":
/*!*************************************************!*\
  !*** ./src/core/renderer/devices/webgl/draw.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var _gmap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../gmap */ "./src/core/renderer/gmap.js");





//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"], mat3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"], mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_1__["math"];
const processGMap = _gmap__WEBPACK_IMPORTED_MODULE_2__["processGMap"];
const processGMap4 = _gmap__WEBPACK_IMPORTED_MODULE_2__["processGMap4"];
const processGMap5 = _gmap__WEBPACK_IMPORTED_MODULE_2__["processGMap5"];
const processGMap6 = _gmap__WEBPACK_IMPORTED_MODULE_2__["processGMap6"];
const processGMap7 = _gmap__WEBPACK_IMPORTED_MODULE_2__["processGMap7"];
const radixDepthSortFeatures = _gmap__WEBPACK_IMPORTED_MODULE_2__["radixDepthSortFeatures"];


const WebGLDraw = function(gpu) {
    this.gpu = gpu;
    this.renderer = gpu.renderer;
    this.core = gpu.renderer.core;
    this.gl = gpu.gl;

    this.rmap = gpu.renderer.rmap;
    this.mBuffer = new Float32Array(16);
    this.mBuffer2 = new Float32Array(16);
    this.vBuffer = new Float32Array(4);
};


WebGLDraw.prototype.drawSkydome = function(texture, shader) {
    if (!texture) {
        return;
    }

    const gpu = this.gpu;
    const gl = this.gl;
    const renderer = this.renderer;

    const lower = 400; // put the dome a bit lower
    const normMat = mat4.create();
    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);

    const domeMat = mat4.create();

    const pos = renderer.camera.getPosition();
    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2] - lower), math.scaleMatrixf(Math.min(renderer.camera.getFar()*0.9,600000)), domeMat);

    const mvp = mat4.create();
    mat4.multiply(renderer.camera.getMvpMatrix(), domeMat, mvp);
    mat4.multiply(mvp, normMat, mvp);


    gpu.useProgram(shader, ['aPosition', 'aTexCoord']);
    gpu.bindTexture(texture);

    shader.setSampler('uSampler', 0);
    shader.setMat4('uMVP', mvp);

    gl.depthMask(false);

    gpu.skydomeMesh.draw(shader, 'aPosition', 'aTexCoord');

    gl.depthMask(true);
    gl.enable(gl.CULL_FACE);

    renderer.renderedPolygons += gpu.skydomeMesh.getPolygons();
};


WebGLDraw.prototype.drawTBall = function(position, size, shader, texture, size2, nocull) {
    const gpu = this.gpu;
    //const gl = this.gl;
    const renderer = this.renderer;

    if (nocull) {
        //gl.disable(gl.CULL_FACE);
    }

    const normMat = mat4.create();
    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);

    const pos = [position[0], position[1], position[2] ];

    size = (size != null) ? size : 1.5;

    const domeMat = mat4.create();
    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrix(size, size, size2 || size), domeMat);

    const mvp = mat4.create();
    mat4.multiply(renderer.camera.getMvpMatrix(), domeMat, mvp);
    mat4.multiply(mvp, normMat, mvp);

    gpu.useProgram(shader, ['aPosition', 'aTexCoord']);
    gpu.bindTexture(texture || gpu.redTexture);

    shader.setSampler('uSampler', 0);
    shader.setMat4('uMVP', mvp);

    gpu.skydomeMesh.draw(shader, 'aPosition', 'aTexCoord');

    renderer.renderedPolygons += gpu.skydomeMesh.getPolygons();

    if (nocull) {
        //gl.enable(gl.CULL_FACE);
    }
};


WebGLDraw.prototype.drawBall = function(position, size, size2, shader, params, params2, params3, color, color2, normals) {
    const gpu = this.gpu;
    const gl = this.gl;
    const renderer = this.renderer;

    const normMat = mat4.create();
    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);

    const pos = [position[0], position[1], position[2] ];

    const domeMat = mat4.create();
    size = size || 1.5;
    size2 = size2 || 1.5;
    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrix(size, size, size2), domeMat);

    const mv = mat4.create();
    mat4.multiply(renderer.camera.getModelviewMatrix(), domeMat, mv);
    mat4.multiply(mv, normMat, mv);
    const proj = renderer.camera.getProjectionMatrix();

    const norm = [0,0,0, 0,0,0, 0,0,0];
    mat4.toInverseMat3(mv, norm);
    mat3.transpose(norm);

    gpu.useProgram(shader, ['aPosition']);
    //gpu.bindTexture(gpu.redTexture);

    //shader.setSampler('uSampler', 0);
    shader.setMat4('uProj', proj);
    shader.setMat4('uMV', mv);

    if (normals) {
        shader.setMat3('uNorm', norm);
        gl.cullFace(gl.FRONT);
        //gl.disable(gl.DEPTH_TEST);
    }

    if (params) {
        shader.setVec4('uParams', params);
    }

    if (params2) {
        shader.setVec4('uParams2', params2);
    }

    if (params2) {
        shader.setVec4('uParams3', params3);
    }

    if (color) {
        shader.setVec4('uFogColor', color);
    }

    if (color2) {
        shader.setVec4('uFogColor2', color2);
    }

    gpu.atmoMesh.draw(shader, 'aPosition', null /*"aTexCoord"*/);

    renderer.renderedPolygons += gpu.skydomeMesh.getPolygons();

    if (normals) {
        gl.cullFace(gl.BACK);
    }
};


WebGLDraw.prototype.drawBall2 = function(position, size, shader, nfactor, dir, radius2) {
    const gpu = this.gpu;
    const renderer = this.renderer;

    const normMat = mat4.create();
    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);

    const pos = [position[0], position[1], position[2] ];

    const domeMat = mat4.create();
    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrixf(size != null ? size : 1.5), domeMat);

    const mv = mat4.create();
    mat4.multiply(renderer.camera.getModelviewMatrix(), domeMat, mv);
    mat4.multiply(mv, normMat, mv);
    const proj = renderer.camera.getProjectionMatrix();

    const norm = [0,0,0, 0,0,0, 0,0,0];
    mat4.toInverseMat3(mv, norm);
    mat3.transpose(norm);

    gpu.useProgram(shader, ['aPosition']);
    gpu.bindTexture(gpu.redTexture);

    shader.setSampler('uSampler', 0);
    shader.setMat4('uProj', proj);
    shader.setMat4('uMV', mv);
    shader.setMat3('uNorm', norm);
    shader.setFloat('uNFactor', nfactor);
    shader.setVec3('uCenter', position);
    shader.setVec2('uRadius', [size, radius2]);

    gpu.atmoMesh.draw(shader, 'aPosition', null /*"aTexCoord"*/);
    renderer.renderedPolygons += gpu.skydomeMesh.getPolygons();
};


WebGLDraw.prototype.drawLineString = function(points, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState) {
    const gpu = this.gpu;
    //const gl = this.gl;
    const renderer = this.renderer;
    let index = 0, p, i;

    const totalPoints = points.length;

    if (totalPoints > 32) {
        for (i = 0; i < totalPoints; i += 31) {
            p = points.slice(i, i + 32);
            this.drawLineString(p, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState);
        }
        return;
    }

    const plineBuffer = gpu.plineBuffer;

    if (screenSpace) {

        //fill points
        for (i = 0; i < totalPoints; i++) {
            p = points[i];
            plineBuffer[index] = p[0];
            plineBuffer[index+1] = p[1];
            plineBuffer[index+2] = p[2] || 0;
            index += 3;
        }

    } else { //covert points from physical space

        //const mvp = renderer.camera.getMvpMatrix();
        //const curSize = renderer.curSize;
        const cameraPos = renderer.cameraPosition;

        for (i = 0; i < totalPoints; i++) {
            p = points[i];

            plineBuffer[index] = p[0] - cameraPos[0];
            plineBuffer[index+1] = p[1] - cameraPos[1];
            plineBuffer[index+2] = p[2] - cameraPos[2];

            index += 3;
        }
    }

    let tmpState;

    if (useState !== true) {
        tmpState = gpu.currentState;

        gpu.setState({
            ztest: !(depthTest !== true),
            blend: (transparent === true),
            zwrite: !(writeDepth === false),
            stencil: false,
            culling: false,
            zequal: false
        });
    }

    const prog = (!screenSpace) ? gpu.progLine5 : gpu.progLine4;

    gpu.useProgram(prog, ['aPosition']);

    if (screenSpace) {
        prog.setMat4('uMVP', renderer.imageProjectionMatrix, depthOffset ? renderer.getZoffsetFactor(depthOffset) : null);
    } else {
        prog.setMat4('uMV', renderer.camera.getModelviewFMatrix(), null); //depthOffset ? renderer.getZoffsetFactor(depthOffset) : null);
        prog.setMat4('uProj', renderer.camera.getProjectionFMatrix(), null);
    }

    prog.setVec3('uScale', [(2 / renderer.curSize[0]), (2 / renderer.curSize[1]), size*0.5]);
    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));
    prog.setVec3('uPoints', plineBuffer);

    gpu.plines.draw(prog, 'aPosition', totalPoints);

    if (useState !== true) {
        gpu.setState(tmpState);
    }
};


//draw 2d circle - used for debuging
WebGLDraw.prototype.drawCircle = function(point, radius, lineWidth, color, depthOffset, depthTest, transparent, writeDepth, useState) {
    const points = [];
    const circleSides = 16, step = (2.0*Math.PI) / circleSides;
    let angle = 0;

    for (let i = 0; i < circleSides; i++) {
        points[i] = [-Math.sin(angle)*radius+point[0], Math.cos(angle)*radius+point[1], point[2]];
        angle += step;
    }

    points[circleSides] = [point[0], radius+point[1], point[2]];

    this.drawLineString(points, true, lineWidth, color, depthOffset, depthTest, transparent, writeDepth, useState);
};


//draw 2d image - used for debuging
WebGLDraw.prototype.drawImage = function(x, y, lx, ly, texture, color, depth, depthOffset, depthTest, transparent, writeDepth, useState) {
    const gpu = this.gpu;
    const gl = this.gl;
    const renderer = this.renderer;

    if (texture == null || renderer.imageProjectionMatrix == null) {
        return;
    }

    let tmpState;

    if (useState !== true) {
        tmpState = gpu.currentState;

        gpu.setState({
            ztest: !(depthTest !== true),
            blend: (transparent === true),
            zwrite: !(writeDepth === false),
            stencil: false,
            culling: false,
            zequal: false
        });
    }

    const prog = gpu.progImage;

    gpu.useProgram(prog, ['aPosition']);
    gpu.bindTexture(texture);

    const vertices = gpu.rectVerticesBuffer;
    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

    const indices = gpu.rectIndicesBuffer;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);

    prog.setMat4('uData', [
        x, y,  0, 0,
        x + lx, y,  1, 0,
        x + lx, y + ly, 1, 1,
        x,  y + ly,  0, 1  ]);

    if (depthOffset) {
        depth = depth * (1 + renderer.getZoffsetFactor(depthOffset) * 2);
    }

    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));
    prog.setFloat('uDepth', depth);

    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);

    if (useState !== true) {
        gpu.setState(tmpState);
    }
};


WebGLDraw.prototype.drawBillboard = function(mvp, texture, color, depthOffset, depthTest, transparent, writeDepth, useState) {
    const gpu = this.gpu;
    const gl = this.gl;
    const renderer = this.renderer;
    let tmpState;

    if (useState !== true) {
        tmpState = gpu.currentState;

        gpu.setState({
            ztest: !(depthTest !== true),
            blend: (transparent === true),
            zwrite: !(writeDepth === false),
            stencil: false,
            culling: false,
            zequal: false
        });
    }

    const prog = gpu.progImage;

    gpu.useProgram(prog, ['aPosition', 'aTexCoord']);
    gpu.bindTexture(texture);
    prog.setSampler('uSampler', 0);

    const vertices = gpu.rectVerticesBuffer;
    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

    const indices = gpu.rectIndicesBuffer;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

    prog.setMat4('uProjectionMatrix', mvp, depthOffset ? renderer.getZoffsetFactor(depthOffset) : null);

    const x = 0, y = 0, lx = 1, ly = 1;

    prog.setMat4('uData', [
        x, y,  0, 0,
        x + lx, y,  1, 0,
        x + lx, y + ly, 1, 1,
        x,  y + ly,  0, 1  ]);

    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));
    prog.setFloat('uDepth', 0);

    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);

    if (useState !== true) {
        gpu.setState(tmpState);
    }
};


//draw flat 2d image - used for debuging
// eslint-disable-next-line
WebGLDraw.prototype.drawFlatImage = function(x, y, lx, ly, texture, color, depth, depthOffset) {
    const gpu = this.gpu;
    const gl = this.gl;
    const renderer = this.renderer;

    if (texture == null || renderer.imageProjectionMatrix == null) {
        return;
    }

    const prog = gpu.progImage;

    gpu.useProgram(prog, ['aPosition']);
    gpu.bindTexture(texture);

    const vertices = gpu.rectVerticesBuffer;
    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

    const indices = gpu.rectIndicesBuffer;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);

    prog.setMat4('uData', [
        x, y,  0, 0,
        x + lx, y,  1, 0,
        x + lx, y + ly, 1, 1,
        x,  y + ly,  0, 1  ]);

    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));
    prog.setFloat('uDepth', depth != null ? depth : 0);

    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);
};


//draw 2d text - used for debuging
WebGLDraw.prototype.drawText = function(x, y, size, text, color, depth, useState) {
    const gpu = this.gpu;
    const gl = this.gl;
    const renderer = this.renderer;
    let tmpState;

    if (renderer.imageProjectionMatrix == null) {
        return;
    }

    if (useState !== true) {
        tmpState = gpu.currentState;

        gpu.setState({
          ztest: !(depth == null),
          blend: false,
          zwrite: !(depth == null),
          stencil: false,
          culling: false,
          zequal: !(depth == null)
        });
    }

    const prog = gpu.progImage;

    gpu.useProgram(prog, ['aPosition']);
    gpu.bindTexture(gpu.textTexture2);

    const vertices = gpu.rectVerticesBuffer;
    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

    const indices = gpu.rectIndicesBuffer;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);
    prog.setVec4('uColor', color);
    prog.setFloat('uDepth', depth != null ? depth : 0);

    const sizeX = size - 1;
    const sizeY = size;

    const sizeX2 = Math.round(size*0.5);

    const texelX = 1 / 256;
    const texelY = 1 / 128;

    const lx = this.getTextSize(size, text) + 2;

    //draw black line before text
    let char = 0;
    let charPosX = (char & 15) << 4;
    let charPosY = (char >> 4) << 4;

    prog.setMat4('uData', [
        x-2, y-2,  (charPosX * texelX), (charPosY * texelY),
        x-2 + lx, y-2,  ((charPosX+15) * texelX), (charPosY * texelY),
        x-2 + lx, y + sizeY+1, ((charPosX + 15) * texelX), ((charPosY+15) * texelY),
        x-2,  y + sizeY+1,  (charPosX * texelX), ((charPosY+15) * texelY) ]);

    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);


    for (let i = 0, li = text.length; i < li; i++) {
        char = text.charCodeAt(i) - 32;
        charPosX = (char & 15) << 4;
        charPosY = (char >> 4) << 4;

        switch(char) {
        case 12:
        case 14:
        case 27: //:
        case 28: //;
        case 64: //'
        case 73: //i
        case 76: //l
        case 84: //t

            prog.setMat4('uData', [
                x, y,  (charPosX * texelX), (charPosY * texelY),
                x + sizeX2, y,  ((charPosX+8) * texelX), (charPosY * texelY),
                x + sizeX2, y + sizeY, ((charPosX + 8) * texelX), ((charPosY+16) * texelY),
                x,  y + sizeY,  (charPosX * texelX), ((charPosY+16) * texelY) ]);

            x += sizeX2;
            break;

        default:

            prog.setMat4('uData', [
                x, y,  (charPosX * texelX), (charPosY * texelY),
                x + sizeX, y,  ((charPosX+15) * texelX), (charPosY * texelY),
                x + sizeX, y + sizeY, ((charPosX + 15) * texelX), ((charPosY+16) * texelY),
                x,  y + sizeY,  (charPosX * texelX), ((charPosY+16) * texelY) ]);

            x += sizeX;

            break;
        }

        gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);

    }

    if (useState !== true) {
        gpu.setState(tmpState);
    }
};


WebGLDraw.prototype.getTextSize = function(size, text) {

    const sizeX = size - 1;
    const sizeX2 = Math.round(size*0.5);
    let x = 0;

    for (let i = 0, li = text.length; i < li; i++) {
        const char = text.charCodeAt(i) - 32;

        switch(char) {
        case 12:
        case 14:
        case 27: //:
        case 28: //;7
        case 64: //'
        case 73: //i
        case 76: //l
        case 84: //t
            x += sizeX2;
            break;

        default:
            x += sizeX;
            break;
        }
    }

    return x;
};


WebGLDraw.prototype.drawGpuJobs = function() {
    const gpu = this.gpu;
    const gl = this.gl;
    const renderer = this.renderer;
    const sortHysteresis = renderer.config.mapSortHysteresis;
    const timerWait = renderer.config.mapHysteresisWait;

    renderer.geoRenderCounter++;
    renderer.totalJobs = 0;
    renderer.drawnJobs = 0;
    renderer.jobsTimer4 = 0;
    renderer.jobsTimer3 = 0;
    renderer.jobsTimer2 = 0;
    renderer.jobsTimer1 = performance.now();

    //setup stencil
    gl.stencilMask(0xFF);
    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilFunc(gl.EQUAL, 0, 0xFF);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);

    const screenPixelSize = [1.0/renderer.curSize[0], 1.0/renderer.curSize[1]];
    const rmap = this.rmap;
    const clearStencilPasses = renderer.clearStencilPasses;
    const jobZBuffer = renderer.jobZBuffer;
    const jobZBufferSize = renderer.jobZBufferSize;
    const jobZBuffer2 = renderer.jobZBuffer2;
    const jobZBuffer2Size = renderer.jobZBuffer2Size;
    const onlyHitLayers = renderer.onlyHitLayers;
    const onlyAdvancedHitLayers = renderer.onlyAdvancedHitLayers;
    const geoRenderCounter = renderer.geoRenderCounter;
    const hitmapRender = renderer.onlyHitLayers;
    let job, job2, key, clearPass = 513, clearPassIndex = 0;

    const hsortBuff = renderer.jobHSortBuffer;
    let hsortBuffSize = 0;

    if (clearStencilPasses.length > 0) {
        clearPass = clearStencilPasses[0];
        clearPassIndex++;
    }

    if (this.rmap.counter != this.renderer.geoRenderCounter) {
        this.rmap.clear();
    }

    renderer.gmapIndex = 0;
    renderer.gmapUseVersion = 1;

    let forceUpdate = false;
    let frameTime = renderer.frameTime; // sortHbuffer = false;

    //console.log("" + frameTime);

    //draw job buffer and also clean buffer
    for (let i = 0, li = jobZBuffer.length; i < li; i++) {
        let j, lj = jobZBufferSize[i], lj2 = jobZBuffer2Size[i];
        const buffer = jobZBuffer[i];
        const buffer2 = jobZBuffer2[i];
        renderer.jobHBuffer = {};

        renderer.totalJobs += lj;

        if (lj > 0 && i >= clearPass) {
            gl.clear(gl.STENCIL_BUFFER_BIT);

            if (clearStencilPasses.length > clearPassIndex) {
                clearPass = clearStencilPasses[clearPassIndex];
                clearPassIndex++;
            } else {
                clearPass = 513;
            }
        }

        if (onlyHitLayers) {
            if (onlyAdvancedHitLayers) {
                for (j = 0; j < lj; j++) {
                    if (buffer[j].advancedHit) {
                        this.drawGpuJob(gpu, gl, renderer, buffer[j], screenPixelSize, true);
                    }
                }
            } else {
                for (j = 0; j < lj; j++) {
                    const job = buffer[j];
                    if (job.hitable) {
                        this.drawGpuJob(gpu, gl, renderer, job, screenPixelSize);
                        if (job.advancedHit) {
                            renderer.advancedPassNeeded = true;
                        }
                    }
                }
            }
        } else {

            for (j = 0; j < lj; j++) {

                job = buffer[j];
                this.drawGpuJob(gpu, gl, renderer, job, screenPixelSize);
            }

            /*if (logDebugInfo) {
                for (j = 0; j < lj; j++) {
                    job = buffer[j];
                    console.log('' + j + ' ' + job.id);
                }
            }*/
        }

        renderer.jobsTimer3 = performance.now();

        if (renderer.gmapIndex > 0) {
            switch(renderer.gmapUseVersion) {
                case 1: //scr-count4
                    processGMap(gpu, gl, renderer, screenPixelSize, this);
                    break;
                case 2:  //scr-count5
                    processGMap4(gpu, gl, renderer, screenPixelSize, this);
                    break;
                case 3: //scr-count6
                    processGMap5(gpu, gl, renderer, screenPixelSize, this);
                    break;
                case 4: //scr-count7
                    processGMap6(gpu, gl, renderer, screenPixelSize, this);
                    break;
                case 5: //scr-count8
                    processGMap7(gpu, gl, renderer, screenPixelSize, this);
                    break;
            }
            renderer.gmapIndex = 0;
        }

        if (rmap.rectanglesCount > 0 || rmap.rectangles2Count > 0) {
            rmap.processRectangles(gpu, gl, renderer, screenPixelSize);
        }

        renderer.jobsTimer4 += performance.now() - renderer.jobsTimer3;

        //lj2 = jobZBuffer2Size[i]; //probably no op

        lj2 = false;
        const hbuffer = renderer.jobHBuffer;

        for (key in hbuffer) {
            lj2 = true;
            break;
        }

        for (key in buffer2) {
            lj2 = true;
            break;
        }

        if (lj2) {

            if (!hitmapRender) {

                for (key in hbuffer) {
                    job = hbuffer[key];

                     if (job.hysteresis && job.id) {
                        job2 = buffer2[job.id];

                        if (!job2) {
                            job.timerShow = 0;
                            job.timerHide = 0;
                            job.draw = false;
                            job.hysteresisCounter = renderer.geoRenderCounter;
                            buffer2[job.id] = job;
                            jobZBuffer2Size[i]++;
                            forceUpdate = true;
                        } else {

                            if (job == job2) {
                                job2.hysteresisCounter = renderer.geoRenderCounter;
                            } else {
                                job2.hysteresisBackup = job;
                            }

                        }

                            //sortHbuffer = true;
                    }
                }
            }

            for (key in buffer2) {
                job = buffer2[key];
                job2 = hbuffer[key];

                renderer.drawnJobs++;

                if (!hitmapRender) {
                    if (job2) {
                        if (isNaN(job.timerShow)) {
                            job.timerShow = 0;
                            job.timerHide = 0;
                            job.draw = false;
                        }

                        if (!job.draw) {
                            job.timerShow += frameTime;

                            if ((job.timerShow - timerWait) > (job.hysteresis[0])) {
                                job.draw = true;
                                job.timerShow = 0;
                            } else {
                                forceUpdate = true;
                            }
                        } else if (job.timerHide) {
                            job.draw = false;
                            job.timerShow = timerWait + (job.hysteresis[0]) * (1.0-(job.timerHide / (job.hysteresis[1])));
                        }

                        job.timerHide = 0;

                    } else {
                        //job = buffer2[key];

                        if (job.draw) {
                            job.timerHide += frameTime;

                            if (job.timerHide > (job.hysteresis[1])) {
                                delete buffer2[key];
                                jobZBuffer2Size[i]--;
                                job.draw = false;
                                job.timerHide = 0;
                            } else {
                                forceUpdate = true;
                            }
                        } else if (job.timerShow) {
                            job.draw = true;
                            job.timerHide = (job.hysteresis[1]) * (1.0-((job.timerShow-timerWait) / (job.hysteresis[0])));
                        }

                        job.timerShow = 0;
                    }
                }

                let draw = job.draw, fade = null;

                if (!hitmapRender && job.hysteresis[3] === true) {

                    if (draw) {
                        if (job.timerHide != 0) {
                            fade = job.timerHide / (job.hysteresis[1]+1);
                            fade = 1.0 - Math.min(1.0, fade);
                        }
                    } else {
                        if (job.timerShow != 0 && (job.timerShow-timerWait) > 0) {
                            fade = (job.timerShow -timerWait) / (job.hysteresis[0]+1);
                            fade = Math.min(1.0, fade);
                            draw = true;
                        }
                    }
                }


                if (draw) {

                    if (job.hysteresisCounter != renderer.geoRenderCounter && job.hysteresisBackup) {
                        const job3 = job.hysteresisBackup;
                        buffer2[key] = job3;

                        job3.timerShow = job.timerShow;
                        job3.timerHide = job.timerHide;
                        job3.draw = job.draw;

                        job = job3;
                    }

                    // update job matricies
                    if (job.renderCounter[0][0] !== geoRenderCounter && job.renderCounter[0][0] !== null) {
                        job.updatePos = true;

                        const renderCounter = job.renderCounter[0];

                        const mvp = mat4.create();
                        const mv = mat4.create();
                        const group = renderCounter[3];
                        const bbox = group.bbox;
                        const geoPos = renderer.cameraPosition;

                        const m = math.translationMatrix(bbox.min[0] - geoPos[0], bbox.min[1] - geoPos[1], bbox.min[2] - geoPos[2]);
                        mat4.multiply(renderer.camera.getModelviewMatrix(), m, mv);

                        const proj = renderer.camera.getProjectionMatrix();
                        mat4.multiply(proj, mv, mvp);

                        job.mv = mv;
                        job.mvp = mvp;
                    }

                    if (sortHysteresis) {

                        job.fade = fade;

                        hsortBuff[hsortBuffSize] = job;
                        hsortBuffSize++;

                    } else {

                        switch(job.type) {
                            case 10:
                                {
                                    //const viewExtent = renderer.viewExtent;
                                    let slayers = job.vswitch[job.vswitchIndex];

                                    if (slayers) {
                                        slayers = slayers[1];

                                        for (let k = 0, lk = slayers.length; k < lk; k++) {
                                            const sjob = slayers[k];
                                            sjob.updatePos = job.updatePos;
                                            sjob.mvp = job.mvp;
                                            sjob.mv = job.mv;
                                            this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, sjob.lastSubJob, fade);
                                        }
                                    }
                                }
                                break;

                            case 6:
                                this.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, fade);
                                break;

                            default:
                                this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, fade);
                                break;
                        }

                        job.updatePos = false;
                    }
                }

                job.hysteresisBackup = null;
            }
        }
    }

    if (sortHysteresis && hsortBuffSize) {

        radixDepthSortFeatures(renderer, hsortBuff, hsortBuffSize, renderer.gmap2);

        for (let i = 0; i < hsortBuffSize; i++) {
            job = hsortBuff[i];

            switch(job.type) {
                case 10:
                    {
                        //const viewExtent = renderer.viewExtent;
                        let slayers = job.vswitch[job.vswitchIndex];

                        if (slayers) {
                            slayers = slayers[1];

                            for (let k = 0, lk = slayers.length; k < lk; k++) {
                                const sjob = slayers[k];
                                sjob.updatePos = job.updatePos;
                                sjob.mvp = job.mvp;
                                sjob.mv = job.mv;
                                this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, sjob.lastSubJob, job.fade);
                            }
                        }
                    }
                break;

                case 6:
                    this.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, job.fade);
                    break;

                default:
                    this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, job.fade);
                    break;
            }

            job.updatePos = false;
        }

    }

    if (forceUpdate) {
        this.core.markDirty();
    }

    renderer.jobsTimer2 = performance.now();
};


WebGLDraw.prototype.clearJobBuffer = function() {
    const renderer = this.renderer;
    const jobZBuffer = renderer.jobZBuffer;
    const jobZBufferSize = renderer.jobZBufferSize;

    //clean job buffer
    for (let i = 0, li = jobZBuffer.length; i < li; i++) {
        const lj = jobZBufferSize[i];
        const buffer = jobZBuffer[i];

        for (let j = 0; j < lj; j++) {
            buffer[j] = null;
        }

        jobZBufferSize[i] = 0;
    }
};


WebGLDraw.prototype.clearJobHBuffer = function() {
    const renderer = this.renderer;
    const jobZBuffer2 = renderer.jobZBuffer2;
    const jobZBuffer2Size = renderer.jobZBuffer2Size;

    //clean job hbuffer
    for (let i = 0, li = jobZBuffer2.length; i < li; i++) {
        jobZBuffer2[i] = {};
        jobZBuffer2Size[i] = 0;
    }
};


WebGLDraw.prototype.paintGL = function() {   //remove this??
    const renderer = this.renderer;

    this.gpu.clear(true, false);

    if (!renderer.onlyLayers) {
        if (!renderer.onlyDepth && !renderer.onlyHitLayers) {
            this.drawSkydome();
        }
    }
};


WebGLDraw.prototype.processNoOverlap = function(renderer, job, pp, p1, p2, camVec, l, stickShift, texture, files, color) {
    const res = {
        exit: true
    };

    const reduce78 = (job.reduce && (job.reduce[0] >= 7 && job.reduce[0] <= 11));

    if (!renderer.drawAllLabels && job.noOverlap) {
        if (!pp) {
            //if (job.type == VTS_JOB_LINE_LABEL) {
              //  pp = renderer.project2(job.center2, job.mvp, [0,0,0]);
            //} else {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition, true);
            //}
        }

        res.pp = pp;
        const o = job.noOverlap;
        let depth = pp[2];

        if (depth < 0 || depth > 1.0) {
            return res;
        }

        if (job.type == 6) {
            if (renderer.benevolentMargins) {
                if (!renderer.rmap.checkRectangle(pp[0]-200, pp[1]-200, pp[0]+200, pp[1]+200, 0)) {
                    return res;
                }
            } else{
                if (!renderer.rmap.checkRectangle(pp[0], pp[1], pp[0], pp[1], 0)) {
                    return res;
                }
            }
        } else {
            if (!renderer.rmap.checkRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], stickShift)) {
                return res;
            }
        }

        if (o[4] !== null) {
            if (o[4] === 0) {
                depth = o[5];
            } else {
                if (l === null) {
                    p2 = job.center2;
                    p1 = renderer.cameraPosition;
                    camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                    l = vec3.length(camVec) + 0.0001;
                }

                if (!job.reduce || (job.reduce && !(job.reduce[0] >= 8 && job.reduce[0] <= 11))) {  //not overlap code not used for reduce==8
                    depth = o[5] / l;
                }
            }
        }

        job.lastSubJob = [job, stickShift, texture, files, color, pp, true, depth, o];

        if (reduce78) {
            renderer.gmapUseVersion = (job.reduce[0] >= 8 && job.reduce[0] <= 11) ? (job.reduce[0] - 6) : 1;
            renderer.gmap[renderer.gmapIndex] = job.lastSubJob;
            renderer.gmapIndex++;

            if (renderer.config.mapFeaturesReduceFactor >= 1) { // prom / dists
                if (l === null) {
                    p2 = job.center2;
                    p1 = renderer.cameraPosition;
                    camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                    l = vec3.length(camVec) + 0.0001;
                }

                if (l > renderer.fmaxDist) renderer.fmaxDist = l;
                if (l < renderer.fminDist) renderer.fminDist = l;

                job.reduce[1] = job.reduce[2];
                job.reduce[4] = l;
            }
            return res;
        }

        if (job.type == 6) {
            if (!renderer.rmap.addLineLabel(job.lastSubJob)) {
                //renderer.rmap.storeRemovedLineLabel(job.lastSubJob);
                return res;
            }
        } else {
            if (!renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], depth, job.lastSubJob)) {
                renderer.rmap.storeRemovedRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], depth, job.lastSubJob);
                return res;
            }
        }

        return res; //draw all labe from same z-index together
    } else {
        if (reduce78) {
            if (!pp) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition, true);
            }

            job.lastSubJob = [job, stickShift, texture, files, color, pp, false];

            renderer.gmapUseVersion = (job.reduce[0] >= 8 && job.reduce[0] <= 11) ? (job.reduce[0] - 6) : 1;
            renderer.gmap[renderer.gmapIndex] = job.lastSubJob;
            renderer.gmapIndex++;

            if (renderer.config.mapFeaturesReduceFactor >= 1) { // prom / dists
                if (l === null) {
                    p2 = job.center2;
                    p1 = renderer.cameraPosition;
                    camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                    l = vec3.length(camVec) + 0.0001;
                }

                if (l > renderer.fmaxDist) renderer.fmaxDist = l;
                if (l < renderer.fminDist) renderer.fminDist = l;

                job.reduce[1] = job.reduce[2];
                job.reduce[4] = l;
            }

            res.pp = pp;
            return res;
        }
    }

    if (job.hysteresis && job.id) {
        if (!pp) {
            pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition, true);
        }

        job.lastSubJob = [job, stickShift, texture, files, color, pp];
        renderer.jobHBuffer[job.id] = job;
        res.pp = pp;
        return res;
     } else {
        res.pp = pp;
     }

    res.exit = false;

    return res;
}

WebGLDraw.prototype.drawGpuJob = function(gpu, gl, renderer, job, screenPixelSize, advancedHitPass, ignoreFilters) {
    if (!job.ready) {
        return;
    }

    //if (!(job.tile.id[0] == 14 && job.tile.id[1] == 4383 && job.tile.id[2] == 2863)) {
      //  return;
    //}

    if (!job.eventInfo) {
        return;
    }

    const state = job.state & 0xff;
    const id = job.eventInfo['#id'];

    if (id != null) {

        if (job.state & (2 << 8)) { //has selection layers?

            if (renderer.geodataSelection.indexOf(id) != -1) {  // is selected

                if (job.state & (3 << 8)) { //has hover layers?

                    if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {
                        if (state != 3) {
                            return;
                        }
                    } else {
                        if (state != 2) {
                            return;
                        }
                    }
                }
            } else if (job.state & (1 << 8)) { //has hover layers?

                if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {
                    if (state != 1) {
                        return;
                    }
                } else {
                    if (state != 0) {
                        return;
                    }
                }

            } else {
                if (state != 0) {
                    return;
                }
            }

        } else if (job.state & (1 << 8)) { //has hover layers?

            if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {
                if (state != 1) {
                    return;
                }
            } else {
                if (state != 0) {
                    return;
                }
            }

        } else {
            if (state != 0) {
                return;
            }
        }

    } else {
        if (state != 0) {
            return;
        }
    }

    const mvp = job.mvp;
    let  prog, texture, res;
    let vertexPositionAttribute, vertexTexcoordAttribute,
        vertexNormalAttribute, vertexOriginAttribute, vertexElementAttribute;

    let hitmapRender = job.hitable && renderer.onlyHitLayers;
    let screenPixelSize2, color = job.color, files;
    const useSuperElevation = renderer.useSuperElevation;

    if (hitmapRender) {
        const c = renderer.hoverFeatureCounter;
        //color = [(c&255)/255, ((c>>8)&255)/255, ((c>>16)&255)/255, 1];
        color = [(c&255)/255, ((c>>8)&255)/255, 0, 0];
        renderer.hoverFeatureList[c] = [job.eventInfo, job.center, job.clickEvent, job.hoverEvent, job.enterEvent, job.leaveEvent, advancedHitPass];
        renderer.hoverFeatureCounter++;
    }

    switch(job.type) {
    case 1:
    case 11:
        {
            if (job.type == 11) {
                if (hitmapRender) {
                    if (job.stencil) {
                        gpu.setState(job.culling ? gpu.polygonB0S1C1tate : gpu.polygonB0S1C0tate);
                    } else {
                        gpu.setState(job.culling ? gpu.polygonB0S0C1tate : gpu.polygonB0S0C0tate);
                    }
                } else {
                    if (job.stencil) {
                        gpu.setState(job.culling ? gpu.polygonB1S1C1tate : gpu.polygonB1S1C0tate);
                    } else {
                        gpu.setState(job.culling ? gpu.polygonB1S0C1tate : gpu.polygonB1S0C0tate);
                    }
                }
            } else {
                gpu.setState(hitmapRender ? gpu.stencilLineHitState : gpu.stencilLineState);
            }

            const debugWires = (gpu === 0); //just generate false value to avoid compiler warnings;

            if (useSuperElevation) {
                prog = advancedHitPass ? job.program2 : gpu.progLineSE;
            } else {
                prog = advancedHitPass ? job.program2 : debugWires ? gpu.progLineWireframe : job.program;
            }

            const flatShade = (!advancedHitPass && job.type == 11 && job.style == 1);

            if (flatShade) {
                prog = useSuperElevation ? gpu.progCFlatShadeTileSE : gpu.progCFlatShadeTile;
            }

            gpu.useProgram(prog, advancedHitPass ? ['aPosition', 'aElement'] : debugWires ? ['aPosition', 'aBarycentric'] : ['aPosition']);

            const m = this.mBuffer;

            if (useSuperElevation) {
                const se = renderer.superElevation;

                m[0] = job.bbox.min[0];
                m[1] = job.bbox.min[1];
                m[2] = job.bbox.min[2];

                m[3] = 1;
                m[4] = 1;
                m[5] = 1;

                m[9] = se[0]; // h1
                m[10] = se[1]; // f1
                m[11] = se[2]; // h2
                m[12] = se[6]; // inv dh
                m[13] = se[5]; // df

                m[14] = renderer.earthRadius;
                m[15] = renderer.earthERatio;

                prog.setMat4('uParamsSE', m);
            }

            if (flatShade) {
                prog.setMat4('uMV', job.mv);
                prog.setMat4('uProj', renderer.camera.getProjectionFMatrix(), renderer.getZoffsetFactor(job.zbufferOffset));
                prog.setVec4('uColor', color);
            } else {
                prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));
                prog.setVec4('uColor', color);
            }

            vertexPositionAttribute = prog.getAttribute('aPosition');

            //bind vetex positions
            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
            gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            if (advancedHitPass) {
                vertexElementAttribute = prog.getAttribute('aElement');
                gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);
                gl.vertexAttribPointer(vertexElementAttribute, job.vertexElementBuffer.itemSize, gl.FLOAT, false, 0, 0);
            }

            if (debugWires) {
                const barycentericAttribute = prog.getAttribute('aBarycentric');
                gl.bindBuffer(gl.ARRAY_BUFFER, gpu.barycentricBuffer);
                gl.vertexAttribPointer(barycentericAttribute, gpu.barycentricBuffer.itemSize, gl.FLOAT, false, 0, 0);
            }

            //draw polygons
            gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);

            const drawDebugLines = renderer.debug.drawPolyWires;// false;//true;

            if (drawDebugLines) {

                const program = useSuperElevation ? gpu.progWireFrameBasicSE : gpu.progWireFrameBasic;
                renderer.gpu.useProgram(program, ['aPosition']);

                if (useSuperElevation) {
                    program.setMat4('uParamsSE', m);
                }

                program.setMat4('uMV', job.mv);
                program.setVec4('uColor', [0,0,0,1]);

                program.setMat4('uProj', renderer.camera.getProjectionFMatrix(), renderer.getZoffsetFactor(job.zbufferOffset));

                for (let i = 0, li = job.vertexPositionBuffer.numItems*2; i < li; i+=3) {
                    gl.drawArrays(gl.LINE_LOOP, i, 3);
                }


            }
        }
        break;

    case 2:
    case 3:
    case 4:
    case 5:
        {
            gpu.setState(hitmapRender ? gpu.stencilLineHitState : gpu.stencilLineState);

            prog = advancedHitPass ? job.program2 : job.program;
            texture = null;
            let textureParams = [0,0,0,0];
            screenPixelSize2 = screenPixelSize;

            if (hitmapRender) {
                if (job.type == 5) {
                    if (job.widthByRatio) {
                        screenPixelSize2 = [ screenPixelSize[0] * renderer.curSize[1], screenPixelSize[1] * renderer.curSize[1]];
                    }
                    prog = advancedHitPass ? this.gpu.progELine3 : this.gpu.progLine3;
                    if (!prog.isReady()) {
                        return;
                    }
                }
            }

            if (job.type != 4) {

                if (job.type == 2) {
                    textureParams = [0, 0, 0, job.widthByRatio ? renderer.cameraViewExtent : 1];
                } else {
                    if (hitmapRender) {
                        texture = gpu.whiteTexture;

                        if (job.type == 3 || job.type == 2) {
                            textureParams = [0, 0, 0, job.widthByRatio ? renderer.cameraViewExtent : 1];
                        }

                    } else {
                        const t = job.texture;
                        if (t == null || t[0] == null) {
                            return;
                        }

                        texture = t[0];
                        textureParams = [0, t[1]/t[0].height, (t[1]+t[2])/t[0].height, job.widthByRatio ? renderer.cameraViewExtent : 1];

                        if (job.type == 3 || job.type == 2) {
                            if (job.widthByRatio) {
                                textureParams[0] = 1/(renderer.cameraViewExtent2*job.lineWidth)/(texture.width/t[2]);
                            } else {
                                textureParams[0] = 1/job.lineWidth/(texture.width/t[2]);
                            }
                        } else {
                            if (job.widthByRatio) {
                                textureParams[0] = 1/(renderer.cameraViewExtent2/renderer.curSize[1])/(texture.width/t[2]);
                                textureParams[0] /= (renderer.curSize[1]*job.lineWidth*0.5);
                                //textureParams[3] = renderer.curSize[1]*(1.0/job.lineWidth)*0.5;
                                textureParams[3] = renderer.curSize[1];
                            } else {
                                textureParams[0] = 1/(renderer.cameraViewExtent2/renderer.curSize[1])/(texture.width/t[2]);
                                textureParams[0] /= (job.lineWidth*0.5);
                                textureParams[3] = 1;
                            }
                        }
                    }

                    if (!texture.loaded) {
                        return;
                    }

                    gpu.bindTexture(texture);
                }

            } else if (job.widthByRatio) {
                screenPixelSize2 = [ screenPixelSize[0] * renderer.curSize[1], screenPixelSize[1] * renderer.curSize[1]];
            }

            if (useSuperElevation) {
                prog = advancedHitPass ? job.program2 : gpu.progLine3SE;

                const m = this.mBuffer;
                const se = renderer.superElevation;

                m[0] = job.bbox.min[0];
                m[1] = job.bbox.min[1];
                m[2] = job.bbox.min[2];

                m[3] = 1;
                m[4] = 1;
                m[5] = 1;

                m[9] = se[0]; // h1
                m[10] = se[1]; // f1
                m[11] = se[2]; // h2
                m[12] = se[6]; // inv dh
                m[13] = se[5]; // df

                m[14] = renderer.earthRadius;
                m[15] = renderer.earthERatio;

                gpu.useProgram(prog, advancedHitPass ? ['aPosition','aNormal','aElement'] : ['aPosition','aNormal']);
                prog.setMat4('uParamsSE', m);

            } else {
                gpu.useProgram(prog, advancedHitPass ? ['aPosition','aNormal','aElement'] : ['aPosition','aNormal']);
            }

            prog.setVec4('uColor', color);
            prog.setVec2('uScale', screenPixelSize2);
            prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));

            if (job.type != 4) {
                if (job.background != null) {
                    prog.setVec4('uColor2', hitmapRender ? [0,0,0,0] : job.background);
                }
                prog.setVec4('uParams', textureParams);
                prog.setSampler('uSampler', 0);
            }

            vertexPositionAttribute = prog.getAttribute('aPosition');
            vertexNormalAttribute = prog.getAttribute('aNormal');

            //bind vetex positions
            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
            gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            //bind vetex normals
            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexNormalBuffer);
            gl.vertexAttribPointer(vertexNormalAttribute, job.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            if (advancedHitPass) {
                vertexElementAttribute = prog.getAttribute('aElement');
                gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);
                gl.vertexAttribPointer(vertexElementAttribute, job.vertexElementBuffer.itemSize, gl.FLOAT, false, 0, 0);
            }

            //draw polygons
            gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);

        }
        break;

    case 6:
        {
            const files = job.files;

            if (files.length > 0) {
                for (let i = 0, li = files.length; i < li; i++) {
                    if (files[i].length > 0) {
                        const font = job.fonts[i];
                        if (font && !font.areTexturesReady(files[i])) {
                            return;
                        }
                    }
                }

            } else {
                if (!hitmapRender) {
                    return;
                }

                texture = gpu.whiteTexture;
            }

            if (renderer.useSuperElevation) {
                if (job.seCounter != renderer.seCounter) {
                    job.seCounter = renderer.seCounter;
                    job.labelPointsBuffer.id = -1;
                    job.center2 = renderer.transformPointBySE(job.center);
                }
            } else {
                job.center2 = job.center;
            }

            const gamma = job.outline[2] * 1.4142 / 20;
            const gamma2 = job.outline[3] * 1.4142 / 20;

            if (job.singleBuffer) {

                let p1, p2, camVec, ll, l = null, localTilt;

                if (job.culling != 180) {
                    p2 = job.center2;
                    p1 = renderer.cameraPosition;
                    camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];

                    if (job.visibility) {
                        l = vec3.length(camVec);

                        switch(job.visibility.length) {
                            case 1:
                                if (l > job.visibility[0]) {
                                    return;
                                }
                                break;

                            case 2:
                                ll = l * renderer.localViewExtentFactor;
                                if (ll < job.visibility[0] || ll > job.visibility[1]) {
                                    return;
                                }

                                break;

                            case 4:
                                {
                                    ll = l * renderer.localViewExtentFactor;
                                    const diameter = job.visibility[0] * job.visibility[1];
                                    if (diameter < (job.visibility[2] * ll) || diameter > (job.visibility[3] * ll)) {
                                        return;
                                    }
                                }

                                break;
                        }

                        l = 1/l;
                        camVec[0] *= l;
                        camVec[1] *= l;
                        camVec[2] *= l;
                    } else {
                        vec3.normalize(camVec);
                    }

                    job.normal = [0,0,0];
                    vec3.normalize(job.center2, job.normal);

                    localTilt = -vec3.dot(camVec, job.normal);

                    if (localTilt < Math.cos(math.radians(job.culling))) {
                        return;
                    }

                } else if (job.visibility) {

                    p2 = job.center2;
                    p1 = renderer.cameraPosition;
                    camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                    l = vec3.length(camVec);

                    switch(job.visibility.length) {
                        case 1:
                            if (l > job.visibility[0]) {
                                return;
                            }
                            break;

                        case 2:
                            l *= renderer.localViewExtentFactor;
                            if (l < job.visibility[0] || l > job.visibility[1]) {
                                return;
                            }

                            break;

                        case 4:
                            {
                                l *= renderer.localViewExtentFactor;

                                const diameter = job.visibility[0] * job.visibility[1];
                                if (diameter < (job.visibility[2] * l) || diameter > (job.visibility[3] * l)) {
                                    return;
                                }
                            }
                            break;
                    }
                }

                res = this.processNoOverlap(renderer, job, null /*pp*/, p1, p2, camVec, l, null /*stickShift*/, texture, files, color); //, pointsIndex);

                if (res.exit) {
                    return;
                } else {
                    //pp = res.pp;
                    //p1 = res.p1;
                    //p2 = res.p2;
                    //camVec = res.camVec;
                    //l = res.l;
                }

                this.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, [job,0,texture,files,color,null/*pp*/]);

                /*
                if (bl > 384) { vbuff = gpu.textQuads128; prog = gpu.progLineLabel128; } else
                if (bl > 256) { vbuff = gpu.textQuads96; prog = gpu.progLineLabel96; } else
                if (bl > 192) { vbuff = gpu.textQuads64; prog = gpu.progLineLabel64; } else
                if (bl > 128) { vbuff = gpu.textQuads48; prog = gpu.progLineLabel48; } else
                if (bl > 64) { vbuff = gpu.textQuads32; prog = gpu.progLineLabel32; }
                else { vbuff = gpu.textQuads16; prog = gpu.progLineLabel16; }

                gpu.useProgram(prog, ['aPosition']);
                prog.setSampler('uSampler', 0);
                prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));

                prog.setVec4('uColor', hitmapRender ? color : job.color2);
                prog.setVec2('uParams', [job.outline[0], gamma2]);
                lj = hitmapRender ? 1 : 2;

                const vertexPositionAttribute = prog.getAttribute('aPosition');

                prog.setVec4('uData', b);

                //bind vetex positions
                gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);
                gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);

                //draw polygons
                for(let j = 0; j < (hitmapRender ? 1 : 2); j++) {
                    if (j == 1) {
                        prog.setVec4('uColor', color);
                        prog.setVec2('uParams', [job.outline[1], gamma]);
                    }

                    for (let i = 0, li = files.length; i < li; i++) {
                        const fontFiles = files[i];

                        for (let k = 0, lk = fontFiles.length; k < lk; k++) {
                            const file = fontFiles[k];
                            prog.setFloat('uFile', Math.round(file+i*1000));
                            gpu.bindTexture(job.fonts[i].getTexture(file));
                            gl.drawArrays(gl.TRIANGLES, 0, vitems / 3); //TODO: demystify vitems
                        }
                    }
                }

                if (renderer.drawLabelBoxes) {
                    if (job.labelPoints.length > 0) {
                        const points = job.labelPoints[0][pointsIndex];

                        for(j = 0; j < points.length; j++) {
                            pp = renderer.project2(points[j], mvp, [0,0,0], true);
                            this.drawCircle(pp, points[j][3] *renderer.camera.scaleFactor2(pp[3])*0.5*renderer.curSize[1]*(renderer.curSize[0]/renderer.curSize[1]), 1, [255, 0, 255, 255], null, null, null, null, null);
                        }
                    }
                }*/

                return;
            }

            gpu.setState(hitmapRender ? gpu.lineLabelHitState : gpu.lineLabelState);

            prog = renderer.useSuperElevation ? gpu.progText2SE : job.program;
            gpu.useProgram(prog, ['aPosition', 'aTexCoord']);

            if (useSuperElevation) {
                const m = this.mBuffer;
                const se = renderer.superElevation;

                m[0] = job.bbox.min[0];
                m[1] = job.bbox.min[1];
                m[2] = job.bbox.min[2];

                m[3] = 1;
                m[4] = 1;
                m[5] = 1;

                m[9] = se[0]; // h1
                m[10] = se[1]; // f1
                m[11] = se[2]; // h2
                m[12] = se[6]; // inv dh
                m[13] = se[5]; // df

                m[14] = renderer.earthRadius;
                m[15] = renderer.earthERatio;

                prog.setMat4('uParamsSE', m);
            }

            prog.setSampler('uSampler', 0);
            prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));
            prog.setVec4('uVec', renderer.labelVector);

            prog.setVec4('uColor', (hitmapRender ? color : job.color2));
            prog.setVec2('uParams', [job.outline[0], gamma2]);

            vertexPositionAttribute = prog.getAttribute('aPosition');
            vertexTexcoordAttribute = prog.getAttribute('aTexCoord');

            //bind vetex positions
            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
            gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            //bind vetex texcoords
            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
            gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            //draw polygons
            for(let j = 0; j < (hitmapRender ? 1 : 2); j++) {
                if (j == 1) {
                    prog.setVec4('uColor', color);
                    prog.setVec2('uParams', [job.outline[1], gamma]);
                }

                if (files.length > 0) {
                    for (let i = 0, li = files.length; i < li; i++) {
                        const fontFiles = files[i];

                        for (let k = 0, lk = fontFiles.length; k < lk; k++) {
                            const file = fontFiles[k];
                            prog.setFloat('uFile', Math.round(file+i*1000));
                            gpu.bindTexture(job.fonts[i].getTexture(file));
                            gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
                        }
                    }

                } else {
                    gpu.bindTexture(texture);
                    gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
                }
            }
        }
        break;

    case 7:
    case 8:
    case 9:
    case 10:
        {
            if (job.reduce && !(job.reduce[0] >= 7 && job.reduce[0] <= 11)) {
                let a;
                const r = job.reduce;

                if (r[0] > 4) {

                    if (r[0] == 4) {
                        a = Math.max(r[1], Math.floor(r[2] / Math.max(1, renderer.drawnGeodataTiles)));

                        if (job.index >= a) {
                            return;
                        }
                        r[5] = a; //for debug
                    } else {
                        a = Math.pow(job.texelSize * job.tiltAngle, 0.5);
                        a = Math.max(r[1], Math.round(r[2] * (a / Math.max(0.00001, this.renderer.drawnGeodataTilesFactor))));

                        if (job.index >= a) {
                            return;
                        }
                        r[5] = a; //for debug
                    }

                } else {
                    a = job.tiltAngle;

                    if (r[0] == 1) {
                        a = 1.0 - (Math.acos(a) * (1.0/(Math.PI*0.5)));
                    } else if (r[0] == 3) {
                        a = (Math.cos(Math.acos(a) * 2) + 1.0) * 0.5;
                    }

                    const indexLimit = (Math.round(r[1] + (a*r[2]))-1);

                    if (job.index > indexLimit) {
                        return;
                    }
                    r[5] = indexLimit; //for debug
                }
            }

            //const files = job.files;

            if (job.type != 10) {
                if (job.type == 9) {

                    let notready = false;

                    for (let j = 0, lj = job.subjobs.length; j < lj; j++) {
                        const subjob = job.subjobs[j];

                        files = subjob.files;

                        if (files.length > 0) {
                            for (let i = 0, li = files.length; i < li; i++) {
                                if (files[i].length > 0) {
                                    const font = subjob.fonts[i];
                                    if (font && !font.areTexturesReady(files[i])) {
                                        notready = true;
                                    }
                                }
                            }

                        } else {
                            texture = hitmapRender ? gpu.whiteTexture : subjob.texture;
                            if (!texture.loaded) {
                                notready = true;
                            }
                        }
                    }

                    if (notready) {
                        return;
                    }

                } else {
                    files = job.files;

                    if (files.length > 0) {
                        for (let i = 0, li = files.length; i < li; i++) {
                            if (files[i].length > 0) {
                                const font = job.fonts[i];
                                if (font && !font.areTexturesReady(files[i])) {
                                    return;
                                }
                            }
                        }

                    } else {
                        texture = hitmapRender ? gpu.whiteTexture : job.texture;
                        if (!texture.loaded) {
                            return;
                        }
                    }
                }
            }

            let p1, p2, camVec, ll, l = null, localTilt;

            if (renderer.useSuperElevation) {
                if (job.seCounter != renderer.seCounter) {
                    job.seCounter = renderer.seCounter;
                    job.center2 = renderer.transformPointBySE(job.center);
                }
            } else {
                job.center2 = job.center;
            }

            if (job.culling != 180) {
                p2 = job.center2;
                p1 = renderer.cameraPosition;
                camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];

                if (job.visibility) {
                    l = vec3.length(camVec);

                    switch(job.visibility.length) {
                        case 1:
                            if (l > job.visibility[0]) {
                                return;
                            }
                            break;

                        case 2:
                            ll = l * renderer.localViewExtentFactor;
                            if (ll < job.visibility[0] || ll > job.visibility[1]) {
                                return;
                            }

                            break;

                        case 4:
                            {
                                ll = l * renderer.localViewExtentFactor;
                                const diameter = job.visibility[0] * job.visibility[1];
                                if (diameter < (job.visibility[2] * ll) || diameter > (job.visibility[3] * ll)) {
                                    return;
                                }
                            }
                            break;
                    }

                    l = 1/l;
                    camVec[0] *= l;
                    camVec[1] *= l;
                    camVec[2] *= l;
                } else {
                    vec3.normalize(camVec);
                }

                job.normal = [0,0,0];
                vec3.normalize(job.center2, job.normal);

                localTilt = -vec3.dot(camVec, job.normal);

                if (localTilt < Math.cos(math.radians(job.culling))) {
                    return;
                }

            } else if (job.visibility) {

                p2 = job.center2;
                p1 = renderer.cameraPosition;
                camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                l = vec3.length(camVec);

                switch(job.visibility.length) {
                    case 1:
                        if (l > job.visibility[0]) {
                            return;
                        }
                        break;

                    case 2:
                        l *= renderer.localViewExtentFactor;
                        if (l < job.visibility[0] || l > job.visibility[1]) {
                            return;
                        }

                        break;

                    case 4:
                        {
                            l *= renderer.localViewExtentFactor;

                            const diameter = job.visibility[0] * job.visibility[1];
                            if (diameter < (job.visibility[2] * l) || diameter > (job.visibility[3] * l)) {
                                return;
                            }
                        }
                        break;
                }
            }

            if (job.type == 10) {
                //TODO: solve switch an call render
                const viewExtent = renderer.viewExtent;
                let vswitch = job.vswitch; //lastViewExtent = 0
                job.vswitchIndex = 0;

                for (let i = 0, li = vswitch.length; i < li; i++) {
                    if (viewExtent <= vswitch[i][0] || i == (li-1)) {
                        job.vswitchIndex = i;
                        let slayers = job.vswitch[i];

                        if (slayers) {
                            slayers = slayers[1];

                            for (j = 0, lj = slayers.length; j < lj; j++) {
                                const sjob = slayers[j];
                                sjob.mv = job.mv;
                                sjob.mvp = job.mvp;
                                sjob.updatePos = job.updatePos;
                                sjob.hysteresis = job.hysteresis;
                                sjob.vswitchIndex = i;
                                sjob.renderCounter = job.renderCounter;
                                sjob.localTilt = localTilt;
                                sjob.id = job.id;
                                this.drawGpuJob(gpu, gl, renderer, sjob, screenPixelSize, advancedHitPass, ignoreFilters);
                            }
                        }

                        return;
                    }
                }

                return;
            }

            const s = job.stick;
            let stickShift = 0, pp, o, stickMode, stickHeight;

            if (s[0] != 0) {
                stickMode = renderer.config.mapFeatureStickMode;
                stickHeight = s[0];

                if (stickMode[0]) {
                    if (!localTilt) {
                        localTilt = job.localTilt;

                        if (!localTilt) {
                            p2 = job.center2;
                            p1 = renderer.cameraPosition;
                            camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                            vec3.normalize(camVec);
                            job.normal = [0,0,0];
                            vec3.normalize(job.center2, job.normal);

                            localTilt = -vec3.dot(camVec, job.normal);
                        }
                    }

                    if (stickMode[0] == 2) {

                        let hdelta = renderer.gridHmax - renderer.gridHmin;

                        if (hdelta < 0) {
                            hdelta = 0;
                        }

                        if (hdelta < stickHeight) {
                            stickHeight = hdelta;
                        }
                    }

                    if (localTilt < 0) {
                        localTilt = 0;
                    }

                    stickShift = Math.pow(1-localTilt,stickMode[1]) * stickHeight * renderer.cameraTiltFator;

                } else {
                    stickShift = renderer.cameraTiltFator * s[0];
                }

                if (stickShift < s[1]) {
                    stickShift = 0;
                }

                if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {
                    stickShift += s[7];
                }

                //else if (s[2] != 0) {
                    pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                    pp[0] = Math.round(pp[0]);
                    pp[1] -= stickShift;
                //}
            }

            res = this.processNoOverlap(renderer, job, pp, p1, p2, camVec, l, stickShift, texture, files, color);

            if (res.exit) {
                return;
            } else {
                pp = res.pp;
                p1 = res.p1;
                p2 = res.p2;
                camVec = res.camVec;
                l = res.l;
            }

            if (job.type == 9) {
                return;
            }

            if (renderer.drawLabelBoxes) {
                o = job.noOverlap;

                if (o) {
                    if (!pp) {
                        pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                    }

                    gpu.setState(hitmapRender ? gpu.lineLabelHitState : gpu.lineLabelState);
                    this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],
                                         [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);

                    if (job.reduce) {
                        if (job.reduce[0] >= 10) {
                            this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.reduce[7].toFixed(0), [1,0,0,1], 0.5);
                        } else {
                            this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);
                        }
                    }
                }
            }

            gpu.setState(hitmapRender ? gpu.lineLabelHitState : gpu.labelState);

            if (s[0] != 0 && s[2] != 0) {
                if (!pp) {
                    pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                }

                this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], s[6]], null, null, null, null, true);
            }

            /*if (dinfo) { //debug only
                if (!pp) {
                    pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                }

                const stmp = "" + dinfo[0].toFixed(0) + " " + dinfo[1].toFixed(0) + " " + dinfo[2].toFixed(0) + " " + dinfo[3].toFixed(0) + " " + dinfo[4].toFixed(0);
                this.drawText(Math.round(pp[0]-this.getTextSize(10,stmp)*0.5), Math.round(pp[1]), 10, stmp, [1,1,1,1], 0);
            }*/

            prog = job.program; //renderer.gpu.progIcon;

            if (job.singleBuffer) {
                if (!pp) {
                    pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                }

                if (prog == gpu.progIcon) {
                    const b = job.singleBuffer;
                    prog = gpu.progImage;

                    if (!job.singleBuffer2) {
                        job.singleBuffer2 = new Float32Array(b);

                        const tx = 1 / texture.width, ty = 1 / texture.height;
                        b[2] *= tx; b[3] *= ty;
                        b[6] *= tx; b[7] *= ty;
                        b[10] *= tx; b[11] *= ty;
                        b[14] *= tx; b[15] *= ty;
                    }

                    if (job.updatePos) {
                        pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                        pp[1] -= stickShift;
                    }

                    const b2 = job.singleBuffer2;

                    b[0] = pp[0] + b2[0];
                    b[1] = pp[1] + b2[1];

                    b[4] = pp[0] + b2[4];
                    b[5] = pp[1] + b2[5];

                    b[8] = pp[0] + b2[8];
                    b[9] = pp[1] + b2[9];

                    b[12] = pp[0] + b2[12];
                    b[13] = pp[1] + b2[13];

                    gpu.useProgram(prog, ['aPosition']);
                    gpu.bindTexture(texture);

                    const vertices = gpu.rectVerticesBuffer;
                    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
                    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

                    const indices = gpu.rectIndicesBuffer;
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

                    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);
                    prog.setMat4('uData', job.singleBuffer );
                    prog.setVec4('uColor', color);
                    prog.setFloat('uDepth', pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2));

                    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);

                } else {

                    const b = job.singleBuffer, bl = b.length, vitems = (b.length / 4) * 6, color2 = job.color2;
                    let j = 0, vbuff;

                    if (bl > 384) { vbuff = gpu.textQuads128; prog = gpu.progLabel128; } else
                    if (bl > 256) { vbuff = gpu.textQuads96; prog = gpu.progLabel96; } else
                    if (bl > 192) { vbuff = gpu.textQuads64; prog = gpu.progLabel64; } else
                    if (bl > 128) { vbuff = gpu.textQuads48; prog = gpu.progLabel48; } else
                    if (bl > 64) { vbuff = gpu.textQuads32; prog = gpu.progLabel32; }
                    else { vbuff = gpu.textQuads16; prog = gpu.progLabel16; }

                    if (job.updatePos) {
                        pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                        pp[1] -= stickShift;
                    }

                    gpu.useProgram(prog, ['aPosition']);
                    prog.setSampler('uSampler', 0);
                    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);

                    prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], 1, stickShift*2]);
                    prog.setVec3('uOrigin', [pp[0],pp[1],pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2)]);
                    prog.setVec4('uColor', hitmapRender ? color : color2);
                    prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);
                    lj = hitmapRender ? 1 : 2;

                    const vertexPositionAttribute = prog.getAttribute('aPosition');

                    prog.setVec4('uData', b);

                    //bind vetex positions
                    gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);
                    gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);

                    //draw polygons
                    for(;j<lj;j++) {
                        if (j == 1) {
                            prog.setVec4('uColor', color);
                            prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);
                        }

                        for (let i = 0, li = files.length; i < li; i++) {
                            const fontFiles = files[i];

                            for (let k = 0, lk = fontFiles.length; k < lk; k++) {
                                const file = fontFiles[k];
                                prog.setFloat('uFile', Math.round(file+i*1000));
                                gpu.bindTexture(job.fonts[i].getTexture(file));
                                gl.drawArrays(gl.TRIANGLES, 0, vitems);
                            }
                        }
                    }

                }

                return;
            }

            gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aOrigin']);
            prog.setSampler('uSampler', 0);
            prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));
            prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], (job.type == 8 ? 1.0 : 1.0 / texture.width), stickShift*2]);

            let j = 0, lj = 1;

            if (prog != gpu.progIcon) {
                prog.setVec4('uColor', hitmapRender ? color : job.color2);
                prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);
                lj = hitmapRender ? 1 : 2;
            } else {
                prog.setVec4('uColor', color);
            }

            vertexPositionAttribute = prog.getAttribute('aPosition');
            vertexTexcoordAttribute = prog.getAttribute('aTexCoord');
            vertexOriginAttribute = prog.getAttribute('aOrigin');

            //bind vetex positions
            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
            gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            //bind vetex texcoordds
            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
            gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            //bind vetex origin
            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);
            gl.vertexAttribPointer(vertexOriginAttribute, job.vertexOriginBuffer.itemSize, gl.FLOAT, false, 0, 0);

            //draw polygons
            for(;j<lj;j++) {
                if (j == 1) {
                    prog.setVec4('uColor', color);
                    prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);
                }

                if (files.length > 0) {
                    for (let i = 0, li = files.length; i < li; i++) {
                        const fontFiles = files[i];

                        for (let k = 0, lk = fontFiles.length; k < lk; k++) {
                            const file = fontFiles[k];
                            prog.setFloat('uFile', Math.round(file+i*1000));
                            gpu.bindTexture(job.fonts[i].getTexture(file));
                            gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
                        }
                    }

                } else {
                    gpu.bindTexture(texture);
                    gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
                }
            }
        }
        break;
    }

    return;
};

WebGLDraw.prototype.drawGpuSubJob = function(gpu, gl, renderer, screenPixelSize, subjob, fade) {
    if (!subjob) {
        return;
    }

    const job = subjob[0], s = job.stick;
    let localTilt, p2, p1, camVec, pp = subjob[5], stickShift = subjob[1], o = job.noOverlap,
        texture = subjob[2], files = subjob[3], color = subjob[4];

    if (renderer.useSuperElevation) {
        if (job.seCounter != renderer.seCounter) {
            job.seCounter = renderer.seCounter;
            job.center2 = renderer.transformPointBySE(job.center);
        }
    } else {
        job.center2 = job.center;
    }

    if (job.hysteresis && job.id) {

        /*
        if (job.culling != 180) {
            p2 = job.center2;
            p1 = renderer.cameraPosition;
            const camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
            vec3.normalize(camVec);

            job.normal = [0,0,0];
            vec3.normalize(job.center2, job.normal);

            localTilt = -vec3.dot(camVec, job.normal);
            if (localTilt < Math.cos(math.radians(job.culling))) {
                return;
            }
        }

        //if (o) {
            //const x1 = pp[0]+o[0], y1 = pp[1]+o[1],
              //  x2 = pp[0]+o[2], y2 = pp[1]+o[3]+stickShift;

            /*
            if (s[0] != 0) {
                stickShift = renderer.cameraTiltFator * s[0];

                if (stickShift < s[1]) {
                    stickShift = 0;
                }
            }*/

            /*
            const rmap = renderer.rmap;

            //screen including credits
            if (x1 < 0 || x2 > rmap.slx || y1 < 0 || y2 > rmap.sly) {
                return false;
            }

            //compass
            if (x1 < rmap.clx && x2 > 0 && y1 <= rmap.sly && y2 > (rmap.sly - rmap.cly)) {
                return false;
            }

            //serach bar
            if (x1 < rmap.blx && x2 > 0 && y1 <= rmap.bly && y2 > 0) {
                return false;
            }*/
        //}

        if (s[0] != 0) {
            const stickMode = renderer.config.mapFeatureStickMode;
            let stickHeight = s[0];

            if (stickMode[0]) {
                if (!localTilt) {
                    localTilt = job.localTilt;

                    if (!localTilt) {
                        p2 = job.center2;
                        p1 = renderer.cameraPosition;
                        camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                        vec3.normalize(camVec);
                        job.normal = [0,0,0];
                        vec3.normalize(job.center2, job.normal);

                        localTilt = -vec3.dot(camVec, job.normal);
                    }
                }

                if (stickMode[0] == 2) {

                    let hdelta = renderer.gridHmax - renderer.gridHmin;

                    if (hdelta < 0) {
                        hdelta = 0;
                    }

                    if (hdelta < stickHeight) {
                        stickHeight = hdelta;
                    }
                }

                if (localTilt < 0) {
                    localTilt = 0;
                }

                stickShift = Math.pow(1-localTilt,stickMode[1]) * stickHeight * renderer.cameraTiltFator;

            } else {
                stickShift = renderer.cameraTiltFator * s[0];
            }

            if (stickShift < s[1]) {
                stickShift = 0;
            }

            if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {
                stickShift += s[7];
            }


             //else if (s[2] != 0) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                pp[0] = Math.round(pp[0]);
                pp[1] -= stickShift;
            //}

        }

    }

    const hitmapRender = job.hitable && renderer.onlyHitLayers;

    if (job.type == 9) {
        if (renderer.drawLabelBoxes && o) {
            gpu.setState(hitmapRender ? gpu.lineLabelHitState : gpu.lineLabelState);
            this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],
                                 [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);

            if (job.reduce) {
                if (job.reduce[0] >= 10) {
                    this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.reduce[7].toFixed(0), [1,0,0,1], 0.5);
                } else {
                    this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);
                }
            }
        }

        gpu.setState(hitmapRender ? gpu.lineLabelHitState : gpu.labelState);

        if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {
            this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], ((fade !== null) ? s[6] * fade : s[6]) ], null, null, null, null, true);
            //stickShift += s[7];
        }

        for (let i = 0, li = job.subjobs.length; i < li; i++) {
            const subjob2 = job.subjobs[i];
            //let job2;
            subjob2.mvp = job.mvp;
            subjob2.updatePos = job.updatePos;

            const depth = subjob[7];

            o = null;
            files = subjob2.files;

            if (hitmapRender) {
                color = subjob[4];
                texture = gpu.whiteTexture;
            } else {
                color = subjob2.color;
                texture = subjob2.texture;
            }

            this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, [subjob2, stickShift, texture, files, color, pp, true, depth, o], fade);
        }

        return;
    }


    if (renderer.drawLabelBoxes && o) {
        gpu.setState(hitmapRender ? gpu.lineLabelHitState : gpu.lineLabelState);
        this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],
                             [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);

        if (job.reduce) {
            if (job.reduce[0] >= 10) {
                this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.reduce[7].toFixed(0), [1,0,0,1], 0.5);
                //this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.fade, [1,0,0,1], 0.5);
            } else {
                this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);
            }
        }
    }

    gpu.setState(hitmapRender ? gpu.lineLabelHitState : gpu.labelState);

    let j = 0, lj = 1, color2 = job.color2;

    if (fade !== null) {
        color = [color[0], color[1], color[2], color[3] * fade];

        if (color2) {
            color2 = [color2[0], color2[1], color2[2], color2[3] * fade];
        }
    }

    if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {
        this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], ((fade !== null) ? s[6] * fade : s[6]) ], null, null, null, null, true);
    }

    let prog = job.program; //gpu.progIcon;

    if (job.singleBuffer) {

        if (prog == gpu.progIcon) {
            const b = job.singleBuffer;
            prog = gpu.progImage;

            if (!job.singleBuffer2) {
                job.singleBuffer2 = new Float32Array(b);

                const tx = 1 / texture.width, ty = 1 / texture.height;
                b[2] *= tx; b[3] *= ty;
                b[6] *= tx; b[7] *= ty;
                b[10] *= tx; b[11] *= ty;
                b[14] *= tx; b[15] *= ty;
            }

            if (job.updatePos) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                pp[1] -= stickShift;
            }

            const b2 = job.singleBuffer2;

            b[0] = pp[0] + b2[0];
            b[1] = pp[1] + b2[1];

            b[4] = pp[0] + b2[4];
            b[5] = pp[1] + b2[5];

            b[8] = pp[0] + b2[8];
            b[9] = pp[1] + b2[9];

            b[12] = pp[0] + b2[12];
            b[13] = pp[1] + b2[13];

            gpu.useProgram(prog, ['aPosition']);
            gpu.bindTexture(texture);

            const vertices = gpu.rectVerticesBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
            gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

            const indices = gpu.rectIndicesBuffer;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

            prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);
            prog.setMat4('uData', job.singleBuffer );
            prog.setVec4('uColor', color);
            prog.setFloat('uDepth', pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2));

            gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);

        } else {

            const b = job.singleBuffer, bl = b.length, vitems = (b.length / 4) * 6;
            let  vbuff;

            if (bl > 384) { vbuff = gpu.textQuads128; prog = gpu.progLabel128; } else
            if (bl > 256) { vbuff = gpu.textQuads96; prog = gpu.progLabel96; } else
            if (bl > 192) { vbuff = gpu.textQuads64; prog = gpu.progLabel64; } else
            if (bl > 128) { vbuff = gpu.textQuads48; prog = gpu.progLabel48; } else
            if (bl > 64) { vbuff = gpu.textQuads32; prog = gpu.progLabel32; }
            else { vbuff = gpu.textQuads16; prog = gpu.progLabel16; }

            if (job.updatePos) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                pp[1] -= stickShift;
            }

            gpu.useProgram(prog, ['aPosition']);
            prog.setSampler('uSampler', 0);
            prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);

            prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], 1, stickShift*2]);
            prog.setVec3('uOrigin', [pp[0],pp[1],pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2)]);
            prog.setVec4('uColor', hitmapRender ? color : color2);
            prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);
            lj = hitmapRender ? 1 : 2;

            const vertexPositionAttribute = prog.getAttribute('aPosition');

            prog.setVec4('uData', b);

            //bind vetex positions
            gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);
            gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);

            //draw polygons
            for(;j<lj;j++) {
                if (j == 1) {
                    prog.setVec4('uColor', color);
                    prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);
                }

                for (let i = 0, li = files.length; i < li; i++) {
                    const fontFiles = files[i];

                    for (let k = 0, lk = fontFiles.length; k < lk; k++) {
                        const file = fontFiles[k];
                        prog.setFloat('uFile', Math.round(file+i*1000));
                        gpu.bindTexture(job.fonts[i].getTexture(file));
                        gl.drawArrays(gl.TRIANGLES, 0, vitems);
                    }
                }
            }

        }

        return;
    }

    gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aOrigin']);
    prog.setSampler('uSampler', 0);
    prog.setMat4('uMVP', job.mvp, renderer.getZoffsetFactor(job.zbufferOffset));
    prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], (job.type == 8 ? 1.0 : 1.0 / texture.width), stickShift*2]);

    if (prog != gpu.progIcon) {
        prog.setVec4('uColor', hitmapRender ? color : color2);
        prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);
        lj = hitmapRender ? 1 : 2;
    } else {
        prog.setVec4('uColor', color);
    }

    const vertexPositionAttribute = prog.getAttribute('aPosition');
    const vertexTexcoordAttribute = prog.getAttribute('aTexCoord');
    const vertexOriginAttribute = prog.getAttribute('aOrigin');

    //bind vetex positions
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
    gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    //bind vetex texcoordds
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
    gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    //bind vetex origin
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);
    gl.vertexAttribPointer(vertexOriginAttribute, job.vertexOriginBuffer.itemSize, gl.FLOAT, false, 0, 0);

    //draw polygons
    for(;j<lj;j++) {
        if (j == 1) {
            prog.setVec4('uColor', color);
            prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);
        }

        if (files.length > 0) {
            for (let i = 0, li = files.length; i < li; i++) {
                const fontFiles = files[i];

                for (let k = 0, lk = fontFiles.length; k < lk; k++) {
                    const file = fontFiles[k];
                    prog.setFloat('uFile', Math.round(file+i*1000));
                    gpu.bindTexture(job.fonts[i].getTexture(file));
                    gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
                }
            }

        } else {
            gpu.bindTexture(texture);
            gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
        }
    }
};


function q4Slerp(a, b, t, out) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  const ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  let omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if ( cosom < 0.0 ) {
    cosom = -cosom;
    bx = - bx;
    by = - by;
    bz = - bz;
    bw = - bw;
  }
  // calculate coefficients
  if ( (1.0 - cosom) > 0.000001) {
    // standard case (slerp)
    omega  = Math.acos(cosom);
    sinom  = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

WebGLDraw.prototype.drawGpuSubJobLineLabel = function(gpu, gl, renderer, screenPixelSize, subjob, fade) {
    if (!subjob) {
        return;
    }

    const job = subjob[0], //texture = subjob[2],
        files = subjob[3],
        o = job.noOverlap, useSE = renderer.useSuperElevation;
    let p2, prog, pp = subjob[5], color = subjob[4];

    if (useSE) {
        if (job.seCounter != renderer.seCounter) {
            job.seCounter = renderer.seCounter;
            job.labelPointsBuffer.id = -1;
            job.center2 = renderer.transformPointBySE(job.center);
        }
    } else {
        job.center2 = job.center;
    }

    const hitmapRender = job.hitable && renderer.onlyHitLayers;
    let j, p;

    const gamma = job.outline[2] * 1.4142 / 20;
    const gamma2 = job.outline[3] * 1.4142 / 20;

    if (job.singleBuffer) {

        gpu.setState(hitmapRender ? gpu.lineLabelHitState : gpu.lineLabelState);

        //if (job.labelPoints.length < 1) return;

        pp = subjob[5];

        if (!pp || job.updatePos) {
            pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition, true);
        }

        const targetSize = job.labelSize * 0.5;
        const sizeFactor = renderer.camera.scaleFactor2(pp[3])*0.5*renderer.curSize[1]*(renderer.curSize[0]/renderer.curSize[1]);
        const labelPoints = job.labelPoints;
        let labelIndex = job.labelIndex;
        let labelMorph = 0;

        lj = labelPoints.length;

        if (lj <= 1 || labelPoints[lj -1][0]*sizeFactor < targetSize) {
            return;
        }

        lj--;

        for (j = 0; j < lj; j++) {
            const s2 = labelPoints[j+1][0] * sizeFactor;

            if (s2 > targetSize) {
                const s1 = labelPoints[j][0] * sizeFactor;

                labelIndex = j;
                labelMorph = (targetSize - s1) / (s2 - s1);
                break;
            }
        }

        let pointsIndex = (vec3.dot(labelPoints[labelIndex][1], renderer.labelVector) >= 0) ? 3 : 2;

        const b = (pointsIndex == 3) ? job.singleBuffer2 : job.singleBuffer, bl = b.length, vitems = (b.length / 4) * 6;

        let points = labelPoints[labelIndex][pointsIndex], vbuff;
        let points2 = (labelPoints[labelIndex+1]) ? labelPoints[labelIndex+1][pointsIndex] : points;
        let q = [0,0,0,0], buffer, index = 0;

        if (useSE) {
            buffer = job.labelPointsBuffer;

            if (buffer.id != (labelIndex * 1024 + pointsIndex)) {
                buffer.id = (labelIndex * 1024 + pointsIndex);
                if (buffer.points.length != points.length) {
                    buffer.points = new Array(points.length);
                    buffer.points2 = new Array(points.length);
                }

                const sePoints = buffer.points;
                const sePoints2 = buffer.points2;

                for(j = 0, lj = points.length; j < lj; j++) {
                    sePoints[j] = renderer.transformPointBySE2(points[j]);
                    sePoints2[j] = renderer.transformPointBySE2(points2[j]);
                }

                points = sePoints;
                points2 = sePoints2;

            } else {
                points = buffer.points;
                points2 = buffer.points2;
            }
        }

        if (!points.length || !points2.length) {
            return;
        }

        for(j = 0, lj = points.length; j < lj; j++) {
            p = points[j];
            p2 = points2[j];

            if (useSE) {
                b[index] = (p[4]+p[13]) + ((p2[4]+p2[13]) - (p[4]+p[13])) * labelMorph;
                b[index+1] = (p[5]+p[14]) + ((p2[5]+p2[14]) - (p[5]+p[14])) * labelMorph;
                b[index+2] = (p[6]+p[15]) + ((p2[6]+p2[15]) - (p[6]+p[15])) * labelMorph;
            } else {
                b[index] = p[4] + (p2[4] - p[4]) * labelMorph;
                b[index+1] = p[5] + (p2[5] - p[5]) * labelMorph;
                b[index+2] = p[6] + (p2[6] - p[6]) * labelMorph;
            }

            q4Slerp([p[7],p[8],p[9],p[10]], [p2[7],p2[8],p2[9],p2[10]], labelMorph, q);

            b[index+3] = q[0];
            b[index+4] = q[1];
            b[index+5] = q[2];
            b[index+6] = q[3];

            b[index+7] = p[11] + (p2[11] - p[11]) * labelMorph;
            b[index+8] = p[12] + (p2[12] - p[12]) * labelMorph;

            index += 12;
        }

        if (bl > 384) { vbuff = gpu.textQuads128; prog = gpu.progLineLabel128; } else
        if (bl > 256) { vbuff = gpu.textQuads96; prog = gpu.progLineLabel96; } else
        if (bl > 192) { vbuff = gpu.textQuads64; prog = gpu.progLineLabel64; } else
        if (bl > 128) { vbuff = gpu.textQuads48; prog = gpu.progLineLabel48; } else
        if (bl > 64) { vbuff = gpu.textQuads32; prog = gpu.progLineLabel32; }
        else { vbuff = gpu.textQuads16; prog = gpu.progLineLabel16; }

        let color2 = job.color2;

        if (fade !== null) {
            color = [color[0], color[1], color[2], color[3] * fade];

            if (color2) {
                color2 = [color2[0], color2[1], color2[2], color2[3] * fade];
            }
        }

        gpu.useProgram(prog, ['aPosition']);
        prog.setSampler('uSampler', 0);
        prog.setMat4('uMVP', job.mvp, renderer.getZoffsetFactor(job.zbufferOffset));

        prog.setVec4('uColor', hitmapRender ? color : color2);
        prog.setVec2('uParams', [job.outline[0], gamma2]);
        let lj = hitmapRender ? 1 : 2;

        const vertexPositionAttribute = prog.getAttribute('aPosition');

        prog.setVec4('uData', b);

        //bind vetex positions
        gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);
        gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);

        //draw polygons
        for(j = 0, lj = (hitmapRender ? 1 : 2); j < lj; j++) {
            if (j == 1) {
                prog.setVec4('uColor', color);
                prog.setVec2('uParams', [job.outline[1], gamma]);
            }

            for (let i = 0, li = files.length; i < li; i++) {
                const fontFiles = files[i];

                for (let k = 0, lk = fontFiles.length; k < lk; k++) {
                    const file = fontFiles[k];
                    prog.setFloat('uFile', Math.round(file+i*1000));
                    gpu.bindTexture(job.fonts[i].getTexture(file));
                    gl.drawArrays(gl.TRIANGLES, 0, vitems / 3); //TODO: demystify vitems
                }
            }
        }

        if (renderer.drawLabelBoxes) {
            const margin = o ? o[0] : 1;
            let pp = [0,0,0], r;

            for(j = 0, lj = points.length; j < lj; j++) {
                p = points[j];
                p2 = points2[j];

                pp[0] = p[0] + (p2[0] - p[0]) * labelMorph;
                pp[1] = p[1] + (p2[1] - p[1]) * labelMorph;
                pp[2] = p[2] + (p2[2] - p[2]) * labelMorph;
                r = p[3] + (p2[3] - p[3]) * labelMorph;

                pp = renderer.project2(pp, renderer.camera.mvp, renderer.cameraPosition, true);
                this.drawCircle(pp, r*sizeFactor*margin, 1, [255, 0, 255, 255], null, null, null, null, null);
            }

            pp = subjob[5];

            if (!pp) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition, true);
            }

            this.drawCircle(pp, 8, 1, [255, 255, 0, 255], null, null, null, null, null);

            if (job.reduce) {
                if (job.reduce[0] >= 10) {
                    this.drawText(pp[0], pp[1]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.reduce[7].toFixed(0), [1,0,0,1], 0.5);
                } else {
                    this.drawText(pp[0], pp[1]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);
                }
            }
        }

        return;
    }

};

/* harmony default export */ __webpack_exports__["default"] = (WebGLDraw);


/***/ }),

/***/ "./src/core/renderer/devices/webgl/group.js":
/*!**************************************************!*\
  !*** ./src/core/renderer/devices/webgl/group.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../bbox */ "./src/core/renderer/bbox.js");
/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/math */ "./src/core/utils/math.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/utils */ "./src/core/utils/utils.js");
/* harmony import */ var _map_resource_node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../map/resource-node */ "./src/core/map/resource-node.js");







//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"], mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
const BBox = _bbox__WEBPACK_IMPORTED_MODULE_1__["default"];
const math = _utils_math__WEBPACK_IMPORTED_MODULE_2__["math"];
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_3__["utils"];
const MapResourceNode = _map_resource_node__WEBPACK_IMPORTED_MODULE_4__["default"];

const WebGLGroup = function(id, bbox, origin, gpu, renderer) {
    this.id = id;
    this.bbox = null;
    this.origin = origin || [0,0,0];
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.renderer = renderer;
    this.jobs = [];
    this.reduced = 0;
    this.geometries = {};
    this.subjob = null;
    this.mv = new Float32Array(16);
    this.mvp = new Float32Array(16);
    this.loadMode = 0;
    //this.geFactor = 1/38;
    this.geFactor = 1/16;
    this.geFactor2 = 0.5;
    this.geNormalized = false;

    if (bbox != null && bbox[0] != null && bbox[1] != null) {
        this.bbox = new BBox(bbox[0][0], bbox[0][1], bbox[0][2], bbox[1][0], bbox[1][1], bbox[1][2]);
    }

    this.binFiles = [];

    this.size = 0;
    this.polygons = 0;
};

//destructor
WebGLGroup.prototype.kill = function() {
    for (let i = 0, li = this.jobs.length; i < li; i++) {
        const job = this.jobs[i];

        switch(job.type) {
        case 1:
        case 11:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;

        case 3:
        case 2:
        case 4:
        case 5:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexNormalBuffer) this.gl.deleteBuffer(job.vertexNormalBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;

        case 6:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexTexcoordBuffer) this.gl.deleteBuffer(job.vertexTexcoordBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;

        case 7:
        case 8:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexTexcoordBuffer) this.gl.deleteBuffer(job.vertexTexcoordBuffer);
            if (job.vertexOriginBuffer) this.gl.deleteBuffer(job.vertexOriginBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;
        }
    }

    //remove geometries
    for (let key in this.geometries) {
        const geometries = this.geometries[key];
        const globalGeometry = this.renderer.geometries[key];
        this.geometries[key] = null;

        //remove geometry from glbal stack
        for (let i = 0, li = geometries.length; i < li; i++) {
            if (geometries[i] == globalGeometry) {
                this.renderer.geometries[key] = null;
            }
        }
    }

    if (this.octreeParser) {
        this.octreeParser.kill();
        this.octreeParser = null;
    }

};


WebGLGroup.prototype.getSize = function() {
    return this.size;
};


WebGLGroup.prototype.getZbufferOffset = function() {
    return this.size;
};

WebGLGroup.prototype.addGeometry = function(data) {
    const id = data['id'];

    if (!this.geometries[id]) {
        this.geometries[id] = [data];
    } else {
        this.geometries[id].push(data);
    }

    this.renderer.geometries[id] = data;
};

WebGLGroup.prototype.convertColor = function(c) {
    const f = 1.0/255;
    return [c[0]*f, c[1]*f, c[2]*f, c[3]*f];
};

WebGLGroup.prototype.addLineJob = function(data) {
    const gl = this.gl;

    const vertices = data.vertexBuffer;

    const job = {};

    if (data.type == 13) {
        job.type = 11;
    } else {
        job.type = 1;
    }

    job.program = this.gpu.progLine;
    job.color = this.convertColor(data['color']);
    job.zIndex = data['z-index'] + 256;
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.advancedHit = data['advancedHit'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.style = data['style'] || 0;
    job.stencil = (data['stencil'] === false) ? false : true;
    job.culling = data['culling'] || 0;
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.lineWidth = data['line-width'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.reduced = false;
    job.ready = true;
    job.bbox = this.bbox;

    if (!job.program.isReady()) {
        return;
    }

    if (job.advancedHit) {
        job.program2 = this.gpu.progELine;

        if (!job.program2.isReady()) {
            return;
        }
    }

    //create vertex buffer
    job.vertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    job.vertexPositionBuffer.itemSize = 3;
    job.vertexPositionBuffer.numItems = vertices.length / 3;

    if (job.advancedHit) {
        job.program = this.gpu.progLine;

        const elements = data.elementBuffer;

        job.vertexElementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, elements, gl.STATIC_DRAW);
        job.vertexElementBuffer.itemSize = 1;
        job.vertexElementBuffer.numItems = elements.length;
    }

    this.jobs.push(job);

    this.size += vertices.length * 4;
    this.polygons += vertices.length / (3 * 3);
};


WebGLGroup.prototype.addExtentedLineJob = function(data) {
    const gl = this.gl;

    const vertices = data.vertexBuffer;
    const normals = data.normalBuffer;

    const job = {};
    job.type = data['type'];


    switch(job.type) {
    case 6:  job.type = 3;  break;
    case 7:  job.type = 2;  break;
    case 9:  job.type = 4;  break;
    case 10: job.type = 5; break;
    }

    job.color = this.convertColor(data['color']);
    job.zIndex = data['z-index'] + 256;
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.advancedHit = data['advancedHit'];
    job.widthByRatio = data['width-units'] == 'ratio',
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.lineWidth = data['line-width'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.reduced = false;
    job.ready = true;
    job.bbox = this.bbox;

    let background;

    if (data['texture'] != null) {
        const texture = data['texture'];
        const bitmap = texture[0];
        job.texture = [this.renderer.getBitmap(bitmap['url'], bitmap['filter'] || 'linear', bitmap['tiled'] || false),
            texture[1], texture[2], texture[3], texture[4]];
        background = this.convertColor(data['background']);

        if (background[3] != 0) {
            job.background = background;
        }
    }

    switch(job.type) {
    case 3:   job.program = (background[3] != 0) ? this.gpu.progTBLine : this.gpu.progTLine;  break;
    case 2:   job.program = this.gpu.progRLine;  break;
    case 4:   job.program = this.gpu.progLine3;  break;
    case 5:  job.program = (background[3] != 0) ? this.gpu.progTPBLine : this.gpu.progTPLine; break;
    }

    if (!job.program.isReady()) {
        return;
    }

    if (job.advancedHit) {
        switch(job.type) {
        case 3:   job.program2 = this.gpu.progETLine;  break;
        case 2:   job.program2 = this.gpu.progERLine;  break;
        case 4:   job.program2 = this.gpu.progELine3;  break;
        case 5:  job.program2 = this.gpu.progETPLine; break;
        }

        if (!job.program2.isReady()) {
            return;
        }
    }

    //create vertex buffer
    job.vertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    job.vertexPositionBuffer.itemSize = 4;
    job.vertexPositionBuffer.numItems = vertices.length / 4;

    //create normal buffer
    job.vertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
    job.vertexNormalBuffer.itemSize = 4;
    job.vertexNormalBuffer.numItems = normals.length / 4;

    if (job.advancedHit) {
        const elements = data.elementBuffer;

        job.vertexElementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, elements, gl.STATIC_DRAW);
        job.vertexElementBuffer.itemSize = 1;
        job.vertexElementBuffer.numItems = elements.length;
    }

    this.jobs.push(job);

    this.size += vertices.length * 4 + normals.length * 4;
    this.polygons += vertices.length / (4 * 3);
};


WebGLGroup.prototype.processReduce = function(job) {
    if (job.reduce) {
        switch(job.reduce[0]) {
            case 'tilt':       job.reduce[0] = 1; break;
            case 'tilt-cos':   job.reduce[0] = 2; break;
            case 'tilt-cos2':  job.reduce[0] = 3; break;
            case 'scr-count':  job.reduce[0] = 4; break;
            case 'scr-count2': job.reduce[0] = 5; this.renderer.drawnGeodataTilesUsed = true; break;
            case 'scr-count3': job.reduce[0] = 6; this.renderer.drawnGeodataTilesUsed = true; break;
            case 'scr-count4': job.reduce[0] = 7; break;
            case 'scr-count5': job.reduce[0] = 8; break;
            case 'scr-count6': job.reduce[0] = 9; break;
            case 'scr-count7': job.reduce[0] = 10; break;
            case 'scr-count8': job.reduce[0] = 11; break;
        }

        job.reduce[5] = 0; //zero debug value
        job.reduce[6] = 0;
        job.reduce[7] = 0;

        if (job.reduce[0] >= 7 && job.reduce[0] <= 11) {

            if (job.reduce[0] == 10 || job.reduce[0] == 11) {
                job.reduce[1] = Math.abs(job.reduce[1]);
                job.reduce[3] = job.reduce[1] * job.reduce[2];
                job.reduce[2] = job.reduce[1];
                job.reduce[4] = 0;
            } else {
                job.reduce[2] = Math.abs(job.reduce[1]); //copy prominence for prom / dist support

                if (this.renderer.config.mapFeaturesReduceFactor >= 1) { // prom / dists
                    job.reduce[1] = job.reduce[2];
                } else {
                    if (job.reduce[0] == 9) {
                        job.reduce[1] = job.reduce[2];
                    } else {
                        job.reduce[1] = Math.floor((Math.log(job.reduce[2] * 500) / Math.log(1.0017)) + 5000);
                    }
                }
            }
        }
    }
};


WebGLGroup.prototype.addLineLabelJob = function(data) {
    const gl = this.gl;
    let singleBuffer;
    let singleBuffer2;
    let vertices;
    let texcoords;

    if (data.singleBuffer) {
        singleBuffer = data.singleBuffer;
        singleBuffer2 = data.singleBuffer2;
    } else {
        vertices = data.vertexBuffer;
        texcoords = data.texcoordsBuffer;
    }

    const job = {};
    job.type = 6;
    job.program = this.gpu.progText;
    job.color = this.convertColor(data['color']);
    job.color2 = this.convertColor(data['color2']);
    job.outline = data['outline'];
    job.zIndex = data['z-index'] + 256;
    job.visibility = data['visibility'];
    job.culling = data['culling'];
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.labelPoints = data['labelPoints'];
    job.labelIndex = data['labelIndex'];
    job.labelSize = data['labelSize'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.hysteresis = data['hysteresis'];
    job.noOverlap = data['noOverlap'];
    job.labelPointsBuffer = { id: -1, points: [], points2: [] },
    job.id = job.hysteresis ? job.hysteresis[2] : null;
    job.reduced = false;
    job.ready = true;
    job.bbox = this.bbox;
    job.reduce = data['reduce'];

    this.processReduce(job);

    job.files = data['files'] || [];
    const fonts = data['fonts'] || ['#default'];
    job.fonts = fonts;

    for (let i = 0, li = fonts.length; i < li; i++) {
        fonts[i] = this.renderer.fonts[fonts[i]];
    }

    job.program = this.gpu.progText2;

    if (!job.program.isReady()) {
        return;
    }

    if (singleBuffer) {

        job.singleBuffer = singleBuffer;
        job.singleBuffer2 = singleBuffer2;
        job.textVector = data['textVector'];
        this.polygons += (singleBuffer.length / 12) * 2;

    } else {
        //create vertex buffer
        job.vertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        job.vertexPositionBuffer.itemSize = 4;
        job.vertexPositionBuffer.numItems = vertices.length / 4;

        //create normal buffer
        job.vertexTexcoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);
        job.vertexTexcoordBuffer.itemSize = 4;
        job.vertexTexcoordBuffer.numItems = texcoords.length / 4;

        this.size += vertices.length * 4 + texcoords.length * 4;
        this.polygons += vertices.length / (4 * 3);
    }

    this.jobs.push(job);
};


WebGLGroup.prototype.addIconJob = function(data, label, tile) {
    const gl = this.gl;

    const vertices = data.vertexBuffer;
    const texcoords = data.texcoordsBuffer;
    const origins = data.originBuffer;
    const singleBuffer = data.singleBuffer;
    const s = data['stick'];
    const f = 1.0/255;

    const job = { tile: tile };
    job.type = label ? 8 : 7;
    job.program = this.gpu.progIcon;
    job.color = this.convertColor(data['color']);
    job.zIndex = data['z-index'] + 256;
    job.visibility = data['visibility'];
    job.culling = data['culling'];
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.state = data['state'];
    job.center = data['center'];
    job.stick = [s[0], s[1], s[2], s[3]*f, s[4]*f, s[5]*f, s[6]*f, s[7]];
    job.lod = data['lod'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.hysteresis = data['hysteresis'];
    job.noOverlap = data['noOverlap'];
    job.id = job.hysteresis ? job.hysteresis[2] : null;
    job.reduced = false;
    job.ready = true;
    job.reduce = data['reduce'];

    this.processReduce(job);

    if (!job.program.isReady()) {
        return;
    }

    if (label !== true) {
        const icon = data['icon'];
        job.texture = this.renderer.getBitmap(null, icon['filter'] || 'linear', icon['tiled'] || false, icon['hash'], true);
        job.files = [];
    } else {
        job.color2 = this.convertColor(data['color2']);
        job.outline = data['outline'];
        job.size = data['size'];
        job.origin = data['origin'];
        job.files = data['files'] || [];
        job.index = data['index'] || 0;
        const fonts = data['fonts'] || ['#default'];
        job.fonts = fonts;
        job.gamma = [job.outline[2] * 1.4142 / job.size, job.outline[3] * 1.4142 / job.size];

        if (job.origin) {
            job.origin = new Float32Array(job.origin);
        }

        for (let i = 0, li = fonts.length; i < li; i++) {
            fonts[i] = this.renderer.fonts[fonts[i]];
        }

        job.program = this.gpu.progIcon2;
    }

    if (job.visibility != null && !Array.isArray(job.visibility)) {
        job.visibility = [job.visibility];
    }

    if (singleBuffer) {
        job.singleBuffer = singleBuffer;
        this.polygons += 2;

    } else {
        //create vertex buffer
        job.vertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        job.vertexPositionBuffer.itemSize = 4;
        job.vertexPositionBuffer.numItems = vertices.length / 4;

        //create normal buffer
        job.vertexTexcoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);
        job.vertexTexcoordBuffer.itemSize = 4;
        job.vertexTexcoordBuffer.numItems = texcoords.length / 4;

        //create origin buffer
        job.vertexOriginBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, origins, gl.STATIC_DRAW);
        job.vertexOriginBuffer.itemSize = 3;
        job.vertexOriginBuffer.numItems = origins.length / 3;

        this.size += job.vertexPositionBuffer.numItems * 4 +
                      job.vertexOriginBuffer.numItems * 4 +
                      job.vertexTexcoordBuffer.numItems * 4;
        this.polygons += job.vertexPositionBuffer.numItems / (4 * 3);
    }


    if (this.subjobs) {
        this.subjobs.push(job);
    } else {
        if (this.vsjobs) {
            this.vsjobs.push(job);
        } else {
            this.jobs.push(job);
        }
    }

};


WebGLGroup.prototype.addPack = function() {
    if (!this.subjobs.length) {
        this.subjobs = null;
        return;
    }

    const job = {
        type : 9,
        subjobs: this.subjobs,
        culling : 180,
        zIndex : 0,
        ready : true
    };

    //extract no overlap, remove it form subjobs
    for (let i = 0, li = job.subjobs.length; i < li; i++) {
        const subjob = job.subjobs[i];

        if (subjob.noOverlap) {

            if (!job.noOverlap) {
                job.noOverlap = subjob.noOverlap;
            } else {
                const o = job.noOverlap;
                const o2 = subjob.noOverlap;

                if (o2[0] < o[0]) o[0] = o2[0];
                if (o2[1] < o[1]) o[1] = o2[1];
                if (o2[2] > o[2]) o[2] = o2[2];
                if (o2[3] > o[3]) o[3] = o2[3];
            }

            subjob.noOverlap = null;
        }

        if (subjob.culling <= job.culling) {
            job.culling = subjob.culling;
            subjob.culling = 180;
        }

        if (subjob.visibility) {
            job.visibility = subjob.visibility;
            subjob.visibility = null;
        }

        if (subjob.stick) {
            job.stick = subjob.stick;
            subjob.stick = [0,0,0,255,255,255,255,0];
        }

        if (subjob.zIndex > job.zIndex) {
            job.zIndex = subjob.zIndex;
        }

        if (subjob.center) {
            job.center = subjob.center;
        }

        job.eventInfo = subjob.eventInfo;
        job.reduce = subjob.reduce;

        job.hysteresis = subjob.hysteresis;
        job.id = subjob.id;
    }

    if (this.vsjobs) {
        this.vsjobs.push(job);
    } else {
        this.jobs.push(job);
    }

    this.subjobs = null;
};


WebGLGroup.prototype.addVSPoint = function(data, tile){
    const job = { tile: tile };
    job.type = 10;
    job.zIndex = data['z-index'] + 256;
    job.visibility = data['visibility'];
    job.culling = data['culling'];
    job.hitable = false;
    job.eventInfo = data['eventInfo'];
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.hysteresis = data['hysteresis'];
    job.id = job.hysteresis ? job.hysteresis[2] : null;
    job.reduced = false;
    job.ready = true;
    job.reduce = data['reduce'];
    job.vswitch = [];

    this.vsjob = job;
};


WebGLGroup.prototype.storeVSJobs = function(data){
    this.vsjob.vswitch.push([data.viewExtent, this.vsjobs]);
    this.vsjobs = [];
};


WebGLGroup.prototype.addVSwitch = function(){
    if (this.vsjob) {
        this.jobs.push(this.vsjob);
    }

    this.vsjobs = null;
};

WebGLGroup.prototype.addMeshJob = function(data) {
    const job = {};

    job.type = 12;
    job.path = data['path'];

    job.textures = [];

    job.resources = new MapResourceNode(this.renderer.core.map, null, null);

    if (job.path) {
        const stmp = job.path.split(".");
        if (stmp.length > 1) {
            stmp.pop();
            job.texturePath = stmp.join('.');
        }

        job.mesh = job.resources.getMesh(job.path, null);
    }

    this.jobs.push(job);
};


WebGLGroup.prototype.copyBuffer = function(buffer, source, index) {
    const tmp = new Uint8Array(buffer.buffer);
    tmp.set(new Uint8Array(source.buffer, index, buffer.byteLength));
    return buffer;
};


WebGLGroup.prototype.addRenderJob2 = function(buffer, index, tile, direct) {
    let data, str, length, type, view;

    if (direct) {
        type = direct.type;
        data = direct.data;
    } else {
        view = new DataView(buffer.buffer);
        type = buffer[index]; index += 1;

        if (type != 15 && type != 16 &&
            type != 17 && type != 19 && type != 18) {

            length = view.getUint32(index); index += 4;
            str = utils.unint8ArrayToString(new Uint8Array(buffer.buffer, index, length)); index+= length;
            data = JSON.parse(str);
        }
    }

    switch(type) {
        case 13:
        case 6:
            data.type = type;
            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;

            if (data['advancedHit']) {
                length = view.getUint32(index); index += 4;
                data.elementBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.elementBuffer.byteLength;
            }

            this.addLineJob(data);
            break;

        case 8:
        case 7:
        case 9:
        case 10:
            data.type = type;
            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.normalBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.normalBuffer.byteLength;

            if (data['advancedHit']) {
                length = view.getUint32(index); index += 4;
                data.elementBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.elementBuffer.byteLength;
            }

            this.addExtentedLineJob(data);
            break;

        case 11:

            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.texcoordsBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.texcoordsBuffer.byteLength;
            this.addLineLabelJob(data);
            break;

        case 12:

            length = view.getUint32(index); index += 4;
            data.singleBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.singleBuffer2 = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer2.byteLength;
            this.addLineLabelJob(data);
            break;

        case 3:
        case 1:

            length = view.getUint32(index); index += 4;
            data.singleBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer.byteLength;
            this.addIconJob(data, (type == 1), tile);
            break;

        case 4:
        case 2:

            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.originBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.originBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.texcoordsBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.texcoordsBuffer.byteLength;
            this.addIconJob(data, (type == 2), tile);
            break;

        case 5:
        case 14:

            length = view.getUint32(index); index += 4;
            data.geometryBuffer = this.copyBuffer(new Float64Array(length), buffer, index); index += data.originBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.indicesBuffer = this.copyBuffer(new Uint32Array(length), buffer, index); index += data.indicesBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            this.addGeometry(data);
            break;

        case 15:
            this.subjobs = []; index += 4;
            break;

        case 16:
            this.addPack(); index += 4;
            break;

        case 20:
            this.addVSPoint(data, tile);
            break;

        case 17:
            this.vsjobs = []; this.vsjob = null; index += 4;
            break;

        case 19:
            this.addVSwitch(); index += 4;
            break;

        case 18:
            data = { viewExtent: view.getUint32(index) }; index += 4;
            this.storeVSJobs(data);
            break;

        case 21:
            {
                const node = data;
                node.nodes = [];
                node.jobs = [];
                node.parent = this.currentNode;

                if (node.volume) {
                    const p = node.volume.points;
                    const points = [
                        p[0][0],p[0][1],p[0][2],
                        p[1][0],p[1][1],p[1][2],
                        p[2][0],p[2][1],p[2][2],
                        p[3][0],p[3][1],p[3][2],
                        p[4][0],p[4][1],p[4][2],
                        p[5][0],p[5][1],p[5][2],
                        p[6][0],p[6][1],p[6][2],
                        p[7][0],p[7][1],p[7][2]
                    ];

                    node.volume.points2 = points;
                }

                if (this.rootNode) {
                    this.currentNode.nodes.push(node);
                    this.currentNode = node;
                } else {
                    this.rootNode = node;
                    this.currentNode = node;

                    this.oldJobs = this.jobs;
                }

                this.jobs = node.jobs;
            }
            break;

        case 22:

            if (this.currentNode.parent) {
                this.currentNode = this.currentNode.parent;
                this.jobs = this.currentNode.jobs;
            } else {
                this.currentNode = this.currentNode.parent;
                this.jobs = this.oldJobs;
            }

            break;

        case 23:
            this.addMeshJob(data, tile);
            break;

        case 24:
            if(this.currentNode) {
                this.currentNode.path = data['path'];
            }
            break;

    }

    return index;
};


WebGLGroup.prototype.addRenderJob = function(data, tile) {
    switch(data['type']) {
    case 'polygon':
    case 'flat-line':     this.addLineJob(data); break;
    case 'flat-tline':
    case 'flat-rline':
    case 'pixel-line':
    case 'pixel-tline':    this.addExtentedLineJob(data); break;
    case 'line-label':     this.addLineLabelJob(data); break;
    case 'icon':           this.addIconJob(data); break;
    case 'label':          this.addIconJob(data, true, tile); break;
    case 'point-geometry': this.addGeometry(data); break;
    case 'line-geometry':  this.addGeometry(data); break;
    case 'pack-begin':     this.subjobs = []; break;
    case 'pack-end':       this.addPack(); break;
    case 'vspoint':        this.addVSPoint(data, tile); break;
    case 'vswitch-begin':  this.vsjobs = []; this.vsjob = null; break;
    case 'vswitch-store':  this.storeVSJobs(data); break;
    case 'vswitch-end':    this.addVSwitch(); break;
    case 'node-begin':     this.nodeBegin(); break;
    case 'node-end':       this.nodeEnd(); break;
    case 'mesh':           this.addMesh(); break;
    }
};

/*
function drawLineString(options, renderer) {
    if (options == null || typeof options !== 'object') {
        return this;
    }

    if (options['points'] == null) {
        return this;
    }

    const points = options['points'];
    const depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;
    const size = options['size'] || 2;
    const screenSpace = (options['screenSpace'] != null) ? options['screenSpace'] : true;
    const depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;
    const blend = (options['blend'] != null) ? options['blend'] : false;
    const writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;
    const useState = (options['useState'] != null) ? options['useState'] : false;
    let color = options['color'] || [255,255,255,255];

    color = [ color[0] * (1.0/255), color[1] * (1.0/255), color[2] * (1.0/255), color[3] * (1.0/255) ];

    renderer.gpu.draw.drawLineString(points, screenSpace, size, color, depthOffset, depthTest, blend, writeDepth, useState);
    return this;
}
*/

WebGLGroup.prototype.draw = function(mv, mvp, applyOrigin, tiltAngle, texelSize) {
    if (this.id != null) {
        if (this.renderer.layerGroupVisible[this.id] === false) {
            return;
        }
    }

    const renderer = this.renderer;
    const renderCounter = [[renderer.geoRenderCounter, mv, mvp, this]];
    const map = renderer.core.map;
    this.map = map;

    if (this.binPath) {
        if (this.octreeParser) {
            this.octreeParser.draw(mv, mvp, applyOrigin, tiltAngle, texelSize);
        }
    }

    if (applyOrigin) {
        const mvp2 = mat4.create();
        const mv2 = mat4.create();
        const pos = this.renderer.position;

        /*
        const transform = this.renderer.layerGroupTransform[this.id];

        if (transform != null) {
            origin = transform[1];
            origin = [origin[0] - pos[0], origin[1] - pos[1], origin[2]];
            mat4.multiply(math.translationMatrix(origin[0], origin[1], origin[2]), transform[0], mv2);
            mat4.multiply(mv, mv2, mv2);
        } else {*/
            let origin = this.origin;
            origin = [origin[0] - pos[0], origin[1] - pos[1], origin[2]];
            mat4.multiply(mv, math.translationMatrix(origin[0], origin[1], origin[2]), mv2);
        /*}*/

        mat4.multiply(mvp, mv2, mvp2);
        mv = mv2;
        mvp = mvp2;
    }

    const cameraPos = renderer.cameraPosition;
    const jobZBuffer = renderer.jobZBuffer;
    const jobZBufferSize = renderer.jobZBufferSize;
    //const jobZBuffer2 = renderer.jobZBuffer2;
    //const jobZBuffer2Size = renderer.jobZBuffer2Size;

    const onlyHitable = renderer.onlyHitLayers;

    for (let i = 0, li = this.jobs.length; i < li; i++) {
        const job = this.jobs[i];

        if ((job.type == 7 || job.type == 8) && job.visibility > 0) {
            const center = job.center;
            if (vec3.length([center[0]-cameraPos[0],
                center[1]-cameraPos[1],
                center[2]-cameraPos[2]]) > job.visibility) {
                continue;
            }
        }

        if (onlyHitable && !job.hitable) {
            continue;
        }

        job.mv = mv;
        job.mvp = mvp;
        job.renderCounter = renderCounter;
        job.tiltAngle = tiltAngle;
        job.texelSize = texelSize;

        const zIndex = job.zIndex;

        jobZBuffer[zIndex][jobZBufferSize[zIndex]] = job;
        jobZBufferSize[zIndex]++;
    }
};


/* harmony default export */ __webpack_exports__["default"] = (WebGLGroup);


/***/ }),

/***/ "./src/core/renderer/devices/webgl/init.js":
/*!*************************************************!*\
  !*** ./src/core/renderer/devices/webgl/init.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ "./src/core/renderer/geometry.js");
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bbox */ "./src/core/renderer/devices/webgl/bbox.js");
/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh */ "./src/core/renderer/devices/webgl/mesh.js");
/* harmony import */ var _pixel_line3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pixel-line3 */ "./src/core/renderer/devices/webgl/pixel-line3.js");
/* harmony import */ var _program__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./program */ "./src/core/renderer/devices/webgl/program.js");
/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shaders */ "./src/core/renderer/devices/webgl/shaders.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./texture */ "./src/core/renderer/devices/webgl/texture.js");









//get rid of compiler mess
const RendererGeometry = _geometry__WEBPACK_IMPORTED_MODULE_0__["default"];
const WebGLBBox = _bbox__WEBPACK_IMPORTED_MODULE_1__["default"];
const WebGLMesh = _mesh__WEBPACK_IMPORTED_MODULE_2__["default"];
const WebGLPixelLine3 = _pixel_line3__WEBPACK_IMPORTED_MODULE_3__["default"];
const WebGLProgram = _program__WEBPACK_IMPORTED_MODULE_4__["default"];
const WebGLShaders = _shaders__WEBPACK_IMPORTED_MODULE_5__["default"];
const WebGLTexture = _texture__WEBPACK_IMPORTED_MODULE_6__["default"];


const WebGLInit = function(gpu) {
    this.gpu = gpu;
    this.renderer = gpu.renderer;
    this.core = gpu.renderer.core;

    this.initShaders();
    this.initHeightmap();
    this.initSkydome();
    this.initHitmap();
    this.initTextMap();
    this.initImage();
    this.initTestMap();
    this.initBBox();
    this.initLines();
    this.initBaricentricBuffer();
};


WebGLInit.prototype.initShaders = function() {
    const shaders = WebGLShaders;
    //const renderer = this.renderer;
    const gpu = this.gpu;

    gpu.progTile = [new WebGLProgram(gpu, '#define variants\n' +shaders.tileVertexShader, '#define variants\n' + shaders.tileFragmentShader)];
    gpu.progTile2 = [new WebGLProgram(gpu, '#define variants\n#define externalTex\n' + shaders.tileVertexShader, '#define variants\n#define externalTex\n' + shaders.tileFragmentShader.replace('__FILTER__', ''))];
    gpu.progTile3 = [new WebGLProgram(gpu, '#define variants\n#define externalTex\n' + shaders.tileVertexShader, '#define variants\n#define externalTex\n#define mask\n' + shaders.tileFragmentShader.replace('__FILTER__', ''))];

    gpu.progFogTile = [new WebGLProgram(gpu, '#define variants\n#define onlyFog\n' + shaders.tileVertexShader, '#define variants\n#define onlyFog\n' + shaders.tileFragmentShader)];

    const sdExt = '#extension GL_OES_standard_derivatives : enable\n';

    gpu.progFlatShadeTile = [new WebGLProgram(gpu, '#define variants\n#define flatShadeVar\n' + shaders.tileVertexShader, sdExt+'#define variants\n#define flatShadeVar\n#define flatShade\n' + shaders.tileFragmentShader)];
    gpu.progFlatShadeTileSE = [new WebGLProgram(gpu, '#define variants\n#define applySE\n#define flatShadeVar\n' + shaders.tileVertexShader, sdExt+'#define variants\n#define flatShadeVar\n#define flatShade\n' + shaders.tileFragmentShader)];
    gpu.progCFlatShadeTile = new WebGLProgram(gpu, '#define flatShadeVar\n' + shaders.tileVertexShader, (sdExt+'#define flatShadeVar\n#define flatShade\n#define fogAndColor\n' + shaders.tileFragmentShader).replace('mediump', 'highp'));
    gpu.progCFlatShadeTileSE = new WebGLProgram(gpu, '#define applySE\n#define flatShadeVar\n' + shaders.tileVertexShader, (sdExt+'#define flatShadeVar\n#define flatShade\n#define fogAndColor\n' + shaders.tileFragmentShader).replace('mediump', 'highp'));

    gpu.progDepthTile = [new WebGLProgram(gpu, '#define variants\n#define depth\n' + shaders.tileVertexShader, ('#define variants\n#define depth\n' + shaders.tileFragmentShader).replace('mediump', 'highp'))];
    gpu.progDepthHeightmap = new WebGLProgram(gpu, shaders.heightmapDepthVertexShader, (shaders.heightmapDepthFragmentShader).replace('mediump', 'highp'));

    gpu.progWireFrameBasic = [new WebGLProgram(gpu, '#define variants\n' + shaders.tileVertexShader, '#define variants\n' + shaders.tileWireFrameBasicShader)];

    gpu.progShadedTile = new WebGLProgram(gpu, shaders.shadedMeshVertexShader, shaders.shadedMeshFragmentShader);
    gpu.progTShadedTile = new WebGLProgram(gpu, shaders.shadedMeshVertexShader, '#define textured\n' + shaders.shadedMeshFragmentShader);

    gpu.progHeightmap = new WebGLProgram(gpu, shaders.heightmapVertexShader, shaders.heightmapFragmentShader);
    gpu.progPlane = new WebGLProgram(gpu, '#define flat\n' + shaders.planeVertexShader, shaders.planeFragmentShader); //flat
    gpu.progPlane2 = new WebGLProgram(gpu, '#define poles\n' + shaders.planeVertexShader, '#define poles\n' + shaders.planeFragmentShader); //poles
    gpu.progPlane3 = new WebGLProgram(gpu, shaders.planeVertexShader, shaders.planeFragmentShader); // grid
    gpu.progPlaneD = new WebGLProgram(gpu, '#define depth\n#define flat\n' + shaders.planeVertexShader, '#define depth\n' + shaders.planeFragmentShader); //flat
    gpu.progPlane2D = new WebGLProgram(gpu, '#define depth\n#define poles\n' + shaders.planeVertexShader, '#define depth\n#define poles\n' + shaders.planeFragmentShader); //poles
    gpu.progPlane3D = new WebGLProgram(gpu, '#define depth\n' + shaders.planeVertexShader, '#define depth\n' + shaders.planeFragmentShader); // grid

    gpu.progSkydome = new WebGLProgram(gpu, shaders.skydomeVertexShader, shaders.skydomeFragmentShader);
    gpu.progStardome = new WebGLProgram(gpu, shaders.skydomeVertexShader, shaders.stardomeFragmentShader);

    gpu.progAtmo2 = new WebGLProgram(gpu, shaders.atmoVertexShader, shaders.atmoFragmentShader);
    gpu.progAtmo = new WebGLProgram(gpu, shaders.atmoVertexShader3, shaders.atmoFragmentShader3);

    gpu.progPCloud = new WebGLProgram(gpu, shaders.pointsVertexShader, shaders.pointsFragmentShader);

    gpu.progBBox = new WebGLProgram(gpu, shaders.bboxVertexShader, shaders.bboxFragmentShader);
    gpu.progBBox2 = new WebGLProgram(gpu, shaders.bbox2VertexShader, shaders.bboxFragmentShader);

    gpu.progLine = new WebGLProgram(gpu, shaders.lineVertexShader, shaders.lineFragmentShader); //line
    gpu.progLineSE = new WebGLProgram(gpu, '#define applySE\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //line SE
    gpu.progELine = new WebGLProgram(gpu, '#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //line elements
    gpu.progELineSE = new WebGLProgram(gpu, '#define applySE\n#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //line SE elements
    gpu.progLine3 = new WebGLProgram(gpu, '#define pixelLine\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //pixel line
    gpu.progELine3 = new WebGLProgram(gpu, '#define pixelLine\n#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //pixel line elements
    gpu.progLine3SE = new WebGLProgram(gpu, '#define applySE\n#define pixelLine\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //pixel line SE
    gpu.progELine3SE = new WebGLProgram(gpu, '#define applySE\n#define pixelLine\n#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //pixel line SE elements
    gpu.progLine4 = new WebGLProgram(gpu, '#define pixelLine\n#define dataPoints\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //direct linestring pixel line
    gpu.progLine5 = new WebGLProgram(gpu, '#define pixelLine\n#define dataPoints\n#define dataPoints2\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //clipped direct linestring pixel line, physical coords
    gpu.progRLine = new WebGLProgram(gpu, '#define dynamicWidth\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //dynamic width line
    gpu.progRLineSE = new WebGLProgram(gpu, '#define applySE\n#define dynamicWidth\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //dynamic width line
    gpu.progERLine = new WebGLProgram(gpu, '#define dynamicWidth\n#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //dynamic width line elements
    gpu.progERLineSE = new WebGLProgram(gpu, '#define applySE\n#define dynamicWidth\n#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //dynamic width line elements

    gpu.progTLine = new WebGLProgram(gpu, shaders.tlineVertexShader, shaders.tlineFragmentShader); //textured line
    gpu.progTPLine = new WebGLProgram(gpu, shaders.tplineVertexShader, shaders.tlineFragmentShader); //textured pixed line
    gpu.progTBLine = new WebGLProgram(gpu, shaders.tlineVertexShader, shaders.tblineFragmentShader); //textured line with background color
    gpu.progTPBLine = new WebGLProgram(gpu, shaders.tplineVertexShader, shaders.tblineFragmentShader); //textured pixel line with background color
    gpu.progETLine = new WebGLProgram(gpu, shaders.etlineVertexShader, shaders.elineFragmentShader); //textured line elements
    gpu.progETPLine = new WebGLProgram(gpu, shaders.etplineVertexShader, shaders.elineFragmentShader); //textured pixed line elements
    //gpu.progLineWireframe = new WebGLProgram(gpu, shaders.lineWireframeVertexShader, shaders.lineWireframeFragmentShader); //line with wireframe for debugging

    gpu.progText2 = new WebGLProgram(gpu, '#define lineLabel\n' + shaders.lineVertexShader, shaders.text2FragmentShader); //line label
    gpu.progText2SE = new WebGLProgram(gpu, '#define applySE\n#define lineLabel\n' + shaders.lineVertexShader, shaders.text2FragmentShader); //line label

    gpu.progLineLabel16 = new WebGLProgram(gpu, '#define DSIZE 16\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader);
    gpu.progLineLabel32 = new WebGLProgram(gpu, '#define DSIZE 32\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader);
    gpu.progLineLabel48 = new WebGLProgram(gpu, '#define DSIZE 48\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader);
    gpu.progLineLabel64 = new WebGLProgram(gpu, '#define DSIZE 64\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader);
    gpu.progLineLabel96 = new WebGLProgram(gpu, '#define DSIZE 96\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader);
    gpu.progLineLabel128 = new WebGLProgram(gpu, '#define DSIZE 128\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader);

    gpu.progPolygon = new WebGLProgram(gpu, shaders.polygonVertexShader, shaders.polygonFragmentShader);
    gpu.progImage = new WebGLProgram(gpu, shaders.imageVertexShader, shaders.imageFragmentShader);
    gpu.progIcon = new WebGLProgram(gpu, shaders.iconVertexShader, shaders.textFragmentShader); //label or icon
    gpu.progIcon2 = new WebGLProgram(gpu, shaders.icon2VertexShader, shaders.text2FragmentShader); //label

    gpu.progLabel16 = new WebGLProgram(gpu, '#define DSIZE 16\n' + shaders.icon3VertexShader, shaders.text2FragmentShader); //label with singleBuffer
    gpu.progLabel32 = new WebGLProgram(gpu, '#define DSIZE 32\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);
    gpu.progLabel48 = new WebGLProgram(gpu, '#define DSIZE 48\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);
    gpu.progLabel64 = new WebGLProgram(gpu, '#define DSIZE 64\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);
    gpu.progLabel96 = new WebGLProgram(gpu, '#define DSIZE 96\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);
    gpu.progLabel128 = new WebGLProgram(gpu, '#define DSIZE 128\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);
};

WebGLInit.prototype.initProceduralShaders = function() {
    const shaders = WebGLShaders;
    const gpu = this.gpu;
    gpu.progHmapPlane = new WebGLProgram(gpu, shaders.planeVertex4Shader, shaders.planeFragmentShader2);
    gpu.progHmapPlane2 = new WebGLProgram(gpu, shaders.planeVertex4Shader, '#define grid\n' + shaders.planeFragmentShader2);
    gpu.progHmapPlane3 = new WebGLProgram(gpu, shaders.planeVertex4Shader, '#define exmap\n' + shaders.planeFragmentShader2);
    gpu.progHmapPlane4 = new WebGLProgram(gpu, shaders.planeVertex4Shader, '#define flat\n' + shaders.planeFragmentShader2);
    gpu.progHmapPlane5 = new WebGLProgram(gpu, shaders.planeVertex4Shader, '#define normals\n' + shaders.planeFragmentShader2);
    gpu.progHmapPlane6 = new WebGLProgram(gpu, shaders.planeVertex4Shader, '#define nmix\n#define normals\n' + shaders.planeFragmentShader2);
    gpu.progHmapPlane7 = new WebGLProgram(gpu, shaders.planeVertex4Shader, '#define nmix\n' + shaders.planeFragmentShader2);
    gpu.progHmapPlane8 = new WebGLProgram(gpu, shaders.planeVertex4Shader, '#define exmap\n#define classmap\n' + shaders.planeFragmentShader2);
}

WebGLInit.prototype.initHeightmap = function() {
    const use16Bit = this.renderer.core.config.map16bitMeshes;
    const gpu = this.gpu;

    // initialize heightmap geometry
    let meshData = RendererGeometry.buildHeightmap(5, true);
    //gpu.heightmapMesh = new WebGLMesh(gpu, meshData, null, this.core, true, use16Bit);

    meshData = RendererGeometry.buildPlane(16, true);
    gpu.planeMesh = new WebGLMesh(gpu, meshData, null, this.core, true, use16Bit, true);

    meshData = RendererGeometry.buildPlane(128, true);
    gpu.planeMesh2 = new WebGLMesh(gpu, meshData, null, this.core, true, use16Bit, true);

    // create heightmap texture
    const size = 64;
    const halfLineWidth = 1;
    const data = new Uint8Array( size * size * 4 );

    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {

            const index = (i*size+j)*4;

            if (i < halfLineWidth || i >= size-halfLineWidth || j < halfLineWidth || j >= size-halfLineWidth) {
                data[index] = 255;
                data[index + 1] = 255;
                data[index + 2] = 255;
            } else {
                data[index] = 32;
                data[index + 1] = 32;
                data[index + 2] = 32;
            }

            data[index + 3] = 255;
        }
    }


    gpu.heightmapTexture = new WebGLTexture(gpu);
    gpu.heightmapTexture.createFromData(size, size, data, 'trilinear', true);
};


WebGLInit.prototype.initHitmap = function() {
    const gpu = this.gpu;
    const renderer = this.renderer
    const size = renderer.hitmapSize;
    const data = new Uint8Array( size * size * 4 );

    if (this.renderer.hitmapMode > 2) {
        this.renderer.hitmapData = data;
    }

    renderer.hitmapTexture = new WebGLTexture(this.gpu);
    renderer.hitmapTexture.createFromData(size, size, data);
    renderer.hitmapTexture.createFramebuffer(size, size);

    renderer.geoHitmapTexture = new WebGLTexture(this.gpu);
    renderer.geoHitmapTexture.createFromData(size, size, data);
    renderer.geoHitmapTexture.createFramebuffer(size, size);

    renderer.geoHitmapTexture2 = new WebGLTexture(this.gpu);
    renderer.geoHitmapTexture2.createFromData(size, size, data);
    renderer.geoHitmapTexture2.createFramebuffer(size, size);
};


WebGLInit.prototype.initTestMap = function() {
    const gpu = this.gpu;

   // create red texture
    const size = 16;
    let i, j, index;
    let data = new Uint8Array( size * size * 4 );

    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            index = (i*size+j)*4;
            data[index] = 255;
            data[index + 1] = 0;
            data[index + 2] = 0;
            data[index + 3] = 255;
        }
    }

    gpu.redTexture = new WebGLTexture(gpu);
    gpu.redTexture.createFromData(size, size, data);

    data = new Uint8Array( size * size * 4 );

    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            index = (i*size+j)*4;
            data[index] = 255;
            data[index + 1] = 255;
            data[index + 2] = 255;
            data[index + 3] = 255;
        }
    }

    gpu.whiteTexture = new WebGLTexture(gpu);
    gpu.whiteTexture.createFromData(size, size, data);

    data = new Uint8Array( size * size * 4 );

    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            index = (i*size+j)*4;
            data[index] = 0;
            data[index + 1] = 0;
            data[index + 2] = 0;
            data[index + 3] = 255;
        }
    }

    gpu.blackTexture = new WebGLTexture(gpu);
    gpu.blackTexture.createFromData(size, size, data);
};


WebGLInit.prototype.initTextMap = function() {
    //font texture
    const texture = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAACACAMAAADTa0c4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAZQTFRFAAAA////pdmf3QAABIFJREFUeNrsnNuyqzAIhsP7v/Se6Yxra0L4OUVNCzetVqP5DAQItrVOiLg95739NnfOaR99RDj6esBw+CKZXiMK4PiuBkAcANoHAP3J5fzzAV2jePQIt6f4Ndb/MIChlVcCEFpAACZPfN4KUAF0/ufboDW3AuBMFgBwHTCfg2ftYgDUKBuA1ABuHKvA2P+5XdONIEt7BO2o2MdlAJoTQOsV6GEAswt0Zq/bsBhdeQQkqEDMwmIAnJHzA8i3ASkWRFKBbADyLGB3mlYD6DyhA4DfBlgsBDtirUPcBgC5woStYMgVtgKATWcB6DskKUEkGFLYrGw3+l3ydR16wKbbPDlWp4Xfo9vZwR1jtOMA6GkABrdvNmt1Vluy6pyvxu4Xt62fquyTggCTsIkCoIuv8gAA08w+ATBXAdSRY56xPDFPx/VPWFZp5v65kFMPgFjP70YASMfRsDn01xLPcwkRq1HLMoK647hR8v+nId74MQBjvIbUQePra42ZVXVcBCR3mIY89mYAlNGLflqA0V1seosCQNMg80B0bsLGAIDNwvFyiqu66ngVGGMGVBwyWwIwpty2DqEr/qf0Bq+DbjYkkcr4VUoOxiRjrYn3YY5SC4BQB/cF0Lq4kD1RCJ+tN4g6Jps5zfWu+QmSz9sUABkA0BIAXocmBwCJ99MDIASATkmtLQAIft4IgE/ZDStZ59yQbOQQAGZWYMbZ3FFCAGRHnwHQznegGAE+zwxNi8kALCOgS9tzAC4jYG1Qo0myRm0Ae/z8eleqewBoZLwfUswCsbT1KgBZD6QAzAEoXUe3K+xxVf2uLf5U3nBeMPRyACW/LtrwVX989id3PRQOG5Io6vh9XwC6stHIdGdJozun03lxNlwvH4u6UgDM8/LmJyx7ak12feEebaXmUwCOYJWk1JcYKsl74HL74wAaH93NqkE1FSKXc4cv0AjaPEEPgE4ru/ieWdvzVq/4psG3AYDFHlEAioQCuEgMgPjK1VDrqlkbTABAiQBGK38B0BlBSf9xtiAJQDM4NtDqMlaeyduTtkDjHgAtEQBj5ZGK2QE0aCcMAIxLSw0WVYlGDgOQXWE+afouAM0S398O4Nej3wIQf4cIHSfz9pbWugyep4MFIAFARvspbm8BcE2DOdvWnCJQAWFhJ/hKzh4AaB2A7NxedKmLPc+6PN4cL2S8GYC1QMIEQJvmFsJfxdvkEQAoLV4AogBS8/kNvdXlWe5GKhABvQUAZASDALJffY1XfsrToFXFbvYD1gBo6wC8LR7/uvj9CwHcfWuoUJItsVl5nwWAnhxxqsXatUq0OYCcaS/fkbK61u5H8jwAuUIEZXHNL1Jmub5oSKZWiDR9FttM4HEAigqRpn8TeB2AuWNiByAXSHCGbB7/3qYCfgCgPgADEEskbjCCaJDB/+kR6wP4P1Obl8jsBwDUB4yAxqKkthaATjX0KmCtDyCxm+yIMLjCbwBgrg94FYC3h8vLPPmfAVBSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlLy9fJPgAEAvWMULbGsSjwAAAAASUVORK5CYII=';
    this.gpu.textTexture2 = new WebGLTexture(this.gpu, texture, this.core, null, true);
};


WebGLInit.prototype.initImage = function() {
    const gl = this.gpu.gl;
    const gpu = this.gpu;

    //create vertices buffer for rect
    gpu.rectVerticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gpu.rectVerticesBuffer);

    const vertices = [ 0, 0, 0, 1,   1, 0, 0, 1,   2, 0, 0, 1,   3, 0, 0, 1 ];

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gpu.rectVerticesBuffer.itemSize = 4;
    gpu.rectVerticesBuffer.numItems = 4;

    //create indices buffer for rect
    gpu.rectIndicesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpu.rectIndicesBuffer);

    const indices = [ 0, 2, 1,    0, 3, 2 ];

    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    gpu.rectIndicesBuffer.itemSize = 1;
    gpu.rectIndicesBuffer.numItems = 6;

    gpu.textBuff16 = new Float32Array(16 * 4);
    gpu.textBuff32 = new Float32Array(32 * 4);
    gpu.textBuff48 = new Float32Array(48 * 4);
    gpu.textBuff64 = new Float32Array(64 * 4);

    gpu.textQuads16 = this.generateTextQuads(16);
    gpu.textQuads32 = this.generateTextQuads(32);
    gpu.textQuads48 = this.generateTextQuads(48);
    gpu.textQuads64 = this.generateTextQuads(64);
    gpu.textQuads96 = this.generateTextQuads(96);
    gpu.textQuads128 = this.generateTextQuads(128);
};


WebGLInit.prototype.generateTextQuads = function(num) {
    const gl = this.gpu.gl;

    const buffer = new Float32Array(num * 2 * 6);
    let index, j;

    for (let i = 0; i < num; i++) {
        index = i * 6 * 2;

        j = 0;
        buffer[index] = i;
        buffer[index+1] = j;

        j = 1;
        buffer[index+2] = i;
        buffer[index+3] = j;

        j = 2;
        buffer[index+4] = i;
        buffer[index+5] = j;

        j = 2;
        buffer[index+6] = i;
        buffer[index+7] = j;

        j = 3;
        buffer[index+8] = i;
        buffer[index+9] = j;

        j = 0;
        buffer[index+10] = i;
        buffer[index+11] = j;
    }

    //create vertices buffer for rect
    const vbuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);

    gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);
    vbuffer.itemSize = 2;
    vbuffer.numItems = num * 6;

    return vbuffer;
};

WebGLInit.prototype.initSkydome = function() {
    const use16Bit = this.renderer.core.config.map16bitMeshes;
    let meshData = RendererGeometry.buildSkydome(32, 64, use16Bit);
    this.gpu.skydomeMesh = new WebGLMesh(this.gpu, meshData, null, this.core, true, use16Bit);
    //this.skydomeTexture = new WebGLTexture(this.gpu, "./skydome.jpg", this.core);

    meshData = RendererGeometry.buildSkydome(128, 256, use16Bit, true);
    this.gpu.atmoMesh = new WebGLMesh(this.gpu, meshData, null, this.core, true, use16Bit);
};


WebGLInit.prototype.initBBox = function() {
    const gpu = this.gpu;
    gpu.bboxMesh = new WebGLBBox(gpu);
    gpu.bboxMesh2 = new WebGLBBox(gpu, true);
};


WebGLInit.prototype.initLines = function() {
    const gpu = this.gpu;
    gpu.plineBuffer = new Float32Array(32*3);
    gpu.plines = new WebGLPixelLine3(gpu, this.core, true, 64, true, 8);
    gpu.plineJoints = new WebGLPixelLine3(gpu, this.core, false, 64, true, 8);

    gpu.stencilLineState = gpu.createState({blend:true, stencil:true, culling: false});
    gpu.lineLabelState = gpu.createState({blend:true, culling: false, zequal: true, zwrite:false});
    gpu.labelState = gpu.createState({blend:true, culling: false, zequal: true});
    gpu.stencilLineHitState = gpu.createState({blend:false, stencil:true, culling: false});
    gpu.lineLabelHitState = gpu.createState({blend:false, culling: false});

    gpu.polygonB1S1C1tate = gpu.createState({blend:true, stencil:true, culling: true, zequal: true});
    gpu.polygonB1S0C1tate = gpu.createState({blend:true, stencil:false, culling: true, zequal: true});
    gpu.polygonB1S1C0tate = gpu.createState({blend:true, stencil:true, culling: false, zequal: true});
    gpu.polygonB1S0C0tate = gpu.createState({blend:true, stencil:false, culling: false, zequal: true});

    gpu.polygonB0S1C1tate = gpu.createState({blend:false, stencil:true, culling: true, zequal: true});
    gpu.polygonB0S0C1tate = gpu.createState({blend:false, stencil:false, culling: true, zequal: true});
    gpu.polygonB0S1C0tate = gpu.createState({blend:false, stencil:true, culling: false, zequal: true});
    gpu.polygonB0S0C0tate = gpu.createState({blend:false, stencil:false, culling: false, zequal: true});

};


WebGLInit.prototype.initBaricentricBuffer = function() {
    const gpu = this.gpu;
    const buffer = new Array(65535*3);

    for (let i = 0; i < 65535*3; i+=9) {
        buffer[i] = 1.0;
        buffer[i+1] = 0;
        buffer[i+2] = 0;

        buffer[i+3] = 0;
        buffer[i+4] = 1.0;
        buffer[i+5] = 0;

        buffer[i+6] = 0;
        buffer[i+7] = 0;
        buffer[i+8] = 1.0;
    }

    const gl = gpu.gl;
    gpu.barycentricBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gpu.barycentricBuffer);

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer), gl.STATIC_DRAW);
    gpu.barycentricBuffer.itemSize = 3;
    gpu.barycentricBuffer.numItems = buffer.length / 3;
};


/* harmony default export */ __webpack_exports__["default"] = (WebGLInit);


/***/ }),

/***/ "./src/core/renderer/devices/webgl/mesh.js":
/*!*************************************************!*\
  !*** ./src/core/renderer/devices/webgl/mesh.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const WebGLMesh = function(gpu, meshData, fileSize, core, direct, use16bit, verticesUnnormalized) {
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.bbox = meshData.bbox; //< bbox copy from Mesh
    this.fileSize = fileSize; //used for stats
    this.core = core;
    this.vertexBuffer = null;
    this.uvBuffer = null;
    this.uv2Buffer = null;
    this.use16bit = use16bit ? true : false;
    this.verticesUnnormalized = verticesUnnormalized ? true : false;
    this.size = 0;
    this.gpuSize = 0;

    const vertices = meshData.vertices;
    const uvs = meshData.uvs;
    const uvs2 = meshData.uvs2;
    const indices = meshData.indices;
    const vertexSize = meshData.vertexSize || 3;
    const uvSize = meshData.uvSize || 2;
    const uv2Size = meshData.uv2Size || 2;

    const gl = this.gl;

    if (!vertices || !gl) {
        return;
    }

    //create vertex buffer
    this.vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

    //when direct mode is used vertices can be also unit16
    gl.bufferData(gl.ARRAY_BUFFER, direct ? vertices : (new Float32Array(vertices)), gl.STATIC_DRAW);
    this.vertexBuffer.itemSize = vertexSize;
    this.vertexBuffer.numItems = vertices.length / vertexSize;

    if (uvs != null) {
        //create texture coords buffer
        this.uvBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);

        gl.bufferData(gl.ARRAY_BUFFER, direct ? uvs : (new Float32Array(uvs)), gl.STATIC_DRAW);
        this.uvBuffer.itemSize = uvSize;
        this.uvBuffer.numItems = uvs.length / uvSize;
    }

    if (uvs2 != null) {
        //create texture coords buffer
        this.uv2Buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);

        gl.bufferData(gl.ARRAY_BUFFER, direct ? uvs2 : (new Float32Array(uvs2)), gl.STATIC_DRAW);
        this.uv2Buffer.itemSize = uv2Size;
        this.uv2Buffer.numItems = uvs2.length / uv2Size;
    }

    if (indices != null) {
        //create index buffer
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, direct ? indices : (new Uint16Array(indices)), gl.STATIC_DRAW);
        this.indexBuffer.itemSize = 1;
        this.indexBuffer.numItems = indices.length;
    }

    const varSize = this.use16bit ? 2 : 4;
    this.size = this.vertexBuffer.numItems * vertexSize * varSize;
    this.size += (uvs) ? this.uvBuffer.numItems * uvSize * varSize : 0;
    this.size += (uvs2) ? this.uv2Buffer.numItems * uv2Size * varSize : 0;
    this.size += (indices) ? indices.length * 2 : 0;
    this.gpuSize = this.size;
    this.polygons = (indices) ? indices.length / 3 : this.vertexBuffer.numItems / 3;

    this.valid = true;
};

//destructor
WebGLMesh.prototype.kill = function() {
    if (!this.gl || !this.valid) {
        return;
    }

    if (this.vertexBuffer) {
        this.gl.deleteBuffer(this.vertexBuffer);
    }

    if (this.uvBuffer) {
        this.gl.deleteBuffer(this.uvBuffer);
    }

    if (this.uv2Buffer) {
        this.gl.deleteBuffer(this.uv2Buffer);
    }

    if (this.indexBuffer) {
        this.gl.deleteBuffer(this.indexBuffer);
    }

    this.vertexBuffer = null;
    this.uvBuffer = null;
    this.uv2Buffer = null;
    this.indexBuffer = null;
};

// Draws the mesh, given the two vertex shader attributes locations.
WebGLMesh.prototype.draw = function(program, attrVertex, attrUV, attrUV2, attrBarycenteric, skipDraw) {
    const gl = this.gl;
    if (gl == null || !this.valid) {
        return;
    }

    if (this.use16bit) {
        //bind vetex positions
        const vertexAttribute = program.getAttribute(attrVertex);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(vertexAttribute, this.vertexBuffer.itemSize, gl.UNSIGNED_SHORT, !this.verticesUnnormalized, 0, 0);

        //bind texture coords
        if (this.uvBuffer && attrUV) {
            const uvAttribute = program.getAttribute(attrUV);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
            gl.vertexAttribPointer(uvAttribute, this.uvBuffer.itemSize, gl.UNSIGNED_SHORT, true, 0, 0);
        }

        if (this.uv2Buffer && attrUV2) {
            const uv2Attribute = program.getAttribute(attrUV2);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);
            gl.vertexAttribPointer(uv2Attribute, this.uv2Buffer.itemSize, gl.UNSIGNED_SHORT, true, 0, 0);
        }
    } else {
        //bind vetex positions
        const vertexAttribute = program.getAttribute(attrVertex);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(vertexAttribute, this.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //bind texture coords
        if (this.uvBuffer && attrUV) {
            const uvAttribute = program.getAttribute(attrUV);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
            gl.vertexAttribPointer(uvAttribute, this.uvBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        if (this.uv2Buffer && attrUV2) {
            const uv2Attribute = program.getAttribute(attrUV2);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);
            gl.vertexAttribPointer(uv2Attribute, this.uv2Buffer.itemSize, gl.FLOAT, false, 0, 0);
        }
    }

    if (attrBarycenteric && attrBarycenteric) {
        const barycentericAttribute = program.getAttribute(attrBarycenteric);

        if (barycentericAttribute != -1) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.gpu.barycentricBuffer);
            gl.vertexAttribPointer(barycentericAttribute, this.gpu.barycentricBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }
    }

    //draw polygons
    if (this.indexBuffer) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

        if (!skipDraw) gl.drawElements(gl.TRIANGLES, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }  else {
        if (!skipDraw) gl.drawArrays(gl.TRIANGLES, 0, this.vertexBuffer.numItems);
    }
};


// Returns GPU RAM used, in bytes.
WebGLMesh.prototype.getSize = function(){ return this.size; };


WebGLMesh.prototype.getBBox = function(){ return this.bbox; };


WebGLMesh.prototype.getPolygons = function(){ return this.polygons; };


/* harmony default export */ __webpack_exports__["default"] = (WebGLMesh);


/***/ }),

/***/ "./src/core/renderer/devices/webgl/pixel-line3.js":
/*!********************************************************!*\
  !*** ./src/core/renderer/devices/webgl/pixel-line3.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const WebGLPixelLine3 = function(gpu, core, lines, maxLines, joins, joinSides) {
    this.bbox = null;
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.core = core;

    const gl = this.gl;

    if (gl == null){
        return;
    }

    this.vertices = [];
    this.normals = [];
    this.vertexBuffer = null;
    this.lines = lines;
    this.joins = joins;
    this.joinSides = joinSides;
    this.maxLines = maxLines;

    this.init();
};

//destructor
WebGLPixelLine3.prototype.kill = function() {
    this.gl.deleteBuffer(this.vertexBuffer);
};


WebGLPixelLine3.prototype.init = function() {
    let i;
    if (this.lines) {
        if (this.joins) {
            this.addCircle(0, this.joinSides);
        }

        for (i = 0; i < this.maxLines; i++) {
            this.addLine(i, i+1);

            if (this.joins) {
                this.addCircle(i+1, this.joinSides);
            }
        }
    } else if (this.joins) {
        for (i = 0; i <= this.maxLines; i++) {
            this.addCircle(i, this.joinSides);
        }
    }

    this.compile();
};

//add line to vertices buffer
WebGLPixelLine3.prototype.addLine = function(i1, i2) {
    const index = this.vertices.length;

    //first polygon
    this.vertices[index] = i1;
    this.vertices[index+1] = i2;
    this.vertices[index+2] = 1;

    this.vertices[index+3] = i1;
    this.vertices[index+4] = i2;
    this.vertices[index+5] = -1;

    this.vertices[index+6] = i2;
    this.vertices[index+7] = i1;
    this.vertices[index+8] = 1;

    //next polygon
    this.vertices[index+9] = i1;
    this.vertices[index+10] = i2;
    this.vertices[index+11] = 1;

    this.vertices[index+12] = i2;
    this.vertices[index+13] = i1;
    this.vertices[index+14] = 1;

    this.vertices[index+15] = i2;
    this.vertices[index+16] = i1;
    this.vertices[index+17] = -1;

    this.polygons += 2;
};

//add circle to vertices buffer
WebGLPixelLine3.prototype.addCircle = function(i1, sides) {
    let index = this.vertices.length;
    const step = (2.0*Math.PI) / sides;

    for (let i = 0; i < sides; i++) {
        this.vertices[index] = i1;
        this.vertices[index+1] = -1;
        this.vertices[index+2] = 0;

        this.vertices[index+3] = i1;
        this.vertices[index+4] = -2;
        this.vertices[index+5] = step * i;

        this.vertices[index+6] = i1;
        this.vertices[index+7] = -2;
        this.vertices[index+8] = step * (i+1);

        index += 9;
    }

    this.polygons += sides;
};

//compile content of vertices buffer into gpu buffer
WebGLPixelLine3.prototype.compile = function() {
    const gl = this.gl;

    //create vertex buffer
    this.vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
    this.vertexBuffer.itemSize = 3;
    this.vertexBuffer.numItems = this.vertices.length / 3;

    this.size = this.vertexBuffer.numItems * 3 * 4 * 2;
    this.polygons = this.vertexBuffer.numItems / 3;
};

// Draws the mesh, given the two vertex shader attributes locations.
WebGLPixelLine3.prototype.draw = function(program, attrPosition, points) {
    const gl = this.gl;
    if (gl == null || this.vertexBuffer == null || points > this.maxLines){
        return;
    }

    const vertexPositionAttribute = program.getAttribute(attrPosition);

    //bind vetex positions
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(vertexPositionAttribute, this.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

    let size = 0;

    if (this.lines) {
        size += ((points-1) * 3 * 2);
    }

    if (this.joins) {
        size += points * (this.joinSides * 3);
    }

    //draw polygons
    gl.drawArrays(gl.TRIANGLES, 0, size);
};

// Returns GPU RAM used, in bytes.
WebGLPixelLine3.prototype.getSize = function(){ return this.size; };


WebGLPixelLine3.prototype.getBbox = function(){ return this.bbox; };


WebGLPixelLine3.prototype.getPolygons = function(){ return this.polygons; };


/* harmony default export */ __webpack_exports__["default"] = (WebGLPixelLine3);


/***/ }),

/***/ "./src/core/renderer/devices/webgl/program.js":
/*!****************************************************!*\
  !*** ./src/core/renderer/devices/webgl/program.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const WebGLProgram = function(gpu, vertex, fragment, variants) {
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.vertex = vertex;
    this.fragment = fragment;
    this.program = null;
    this.uniformLocationCache = [];
    this.attributeLocationCache = [];
    this.m = new Float32Array(16);
    this.ready = false;
    this.createProgram(vertex, fragment);
    this.variants = variants || [];
    this.programs = {};
};


WebGLProgram.prototype.createShader = function(source, vertexShader) {
    const gl = this.gl;

    if (!source || !gl) {
        return null;
    }

    let shader;

    if (vertexShader !== true) {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else {
        shader = gl.createShader(gl.VERTEX_SHADER);
    }

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        console.log('An error occurred compiling the ' + ((vertexShader !== true) ? 'fragment' : 'vertex') + ' shaders: ' + info);
        this.gpu.renderer.core.callListener('renderer-shader-error', { 'where':'compilation', 'info' : info });
        return null;
    }

    return shader;
};


WebGLProgram.prototype.createProgram = function(vertex, fragment) {
    const gl = this.gl;
    if (gl == null) return;

    const vertexShader = this.createShader(vertex, true);
    const fragmentShader = this.createShader(fragment, false);

    if (!vertexShader ||  !fragmentShader) {
        return;
    }

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.log('Unable to initialize the shader program.');
        this.gpu.renderer.core.callListener('renderer-shader-error', { 'where':'linking' });
    }

    gl.useProgram(program);

    this.program = program;
    this.ready = true;
};


WebGLProgram.prototype.setSampler = function(name, index) {
    const gl = this.gl;
    if (gl == null || this.program == null) return;

    const key = this.getUniform(name);
    if (key != null) {
        gl.uniform1i(key, index);
    }
};


WebGLProgram.prototype.isReady = function() {
    return this.ready;
};


WebGLProgram.prototype.setMat4 = function(name, m, zoffset) {
    const gl = this.gl;
    if (gl == null || this.program == null) return;

    const key = this.getUniform(name);
    if (key != null) {
        if (zoffset) {
            zoffset = ((1+zoffset)*2)-1;

            const m3 = this.m;

            m3[0] = m[0];
            m3[1] = m[1];
            m3[2] = m[2] * zoffset;
            m3[3] = m[3];

            m3[4] = m[4];
            m3[5] = m[5];
            m3[6] = m[6] * zoffset;
            m3[7] = m[7];

            m3[8] = m[8];
            m3[9] = m[9];
            m3[10] = m[10] * zoffset;
            m3[11] = m[11];

            m3[12] = m[12];
            m3[13] = m[13];
            m3[14] = m[14] * zoffset;
            m3[15] = m[15];

            gl.uniformMatrix4fv(key, false, m3);

        } else {
            gl.uniformMatrix4fv(key, false, m);
        }
    }
};


WebGLProgram.prototype.setMat3 = function(name, m) {
    const gl = this.gl;
    if (gl == null || this.program == null) return;

    const key = this.getUniform(name);
    if (key != null) {
        gl.uniformMatrix3fv(key, false, m);
    }
};


WebGLProgram.prototype.setVec2 = function(name, m) {
    const gl = this.gl;
    if (gl == null || this.program == null) return;

    const key = this.getUniform(name);
    if (key != null) {
        gl.uniform2fv(key, m);
    }
};


WebGLProgram.prototype.setVec3 = function(name, m) {
    const gl = this.gl;
    if (gl == null || this.program == null) return;

    const key = this.getUniform(name);
    if (key != null) {
        gl.uniform3fv(key, m);
    }
};


WebGLProgram.prototype.setVec4 = function(name, m) {
    const gl = this.gl;
    if (gl == null || this.program == null) return;

    const key = this.getUniform(name);
    if (key != null) {
        gl.uniform4fv(key, m);
    }
};


WebGLProgram.prototype.setFloat = function(name, value) {
    const gl = this.gl;
    if (gl == null || this.program == null) return;

    const key = this.getUniform(name);
    if (key != null) {
        gl.uniform1f(key, value);
    }
};


WebGLProgram.prototype.setFloatArray = function(name, array) {
    const gl = this.gl;
    if (gl == null || this.program == null) return;

    const key = this.getUniform(name);
    if (key != null) {
        gl.uniform1fv(key, array);
    }
};


WebGLProgram.prototype.getAttribute = function(name) {
    const gl = this.gl;
    if (gl == null || this.program == null) return;

    let location = this.attributeLocationCache[name];

    if (location == null) {
        location = gl.getAttribLocation(this.program, name);
        this.attributeLocationCache[name] = location;
    }

    return location;
};


WebGLProgram.prototype.getUniform = function(name) {
    const gl = this.gl;
    if (gl == null || this.program == null) return;

    let location = this.uniformLocationCache[name];

    if (location == null) {
        location = gl.getUniformLocation(this.program, name);
        this.uniformLocationCache[name] = location;
    }

    return location;
};


/* harmony default export */ __webpack_exports__["default"] = (WebGLProgram);


/***/ }),

/***/ "./src/core/renderer/devices/webgl/shaders.js":
/*!****************************************************!*\
  !*** ./src/core/renderer/devices/webgl/shaders.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const WebGLShaders = {};

WebGLShaders.bboxVertexShader =
    'attribute vec3 aPosition;\n'+
    'uniform mat4 uMVP;\n'+
    'void main(){ \n'+
        'gl_Position = uMVP * vec4(aPosition, 1.0);\n'+
    '}';


WebGLShaders.bbox2VertexShader =
    'attribute vec3 aPosition;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform float uPoints[8*3];\n'+
    'void main(){ \n'+
        'int index = int(aPosition.z) * 3; \n'+
        'gl_Position = uMVP * vec4(uPoints[index], uPoints[index+1], uPoints[index+2], 1.0);\n'+
    '}';


WebGLShaders.bboxFragmentShader = 'precision mediump float;\n'+
    'void main() {\n'+
        'gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n'+
    '}';


WebGLShaders.text2VertexShader =
    'attribute vec4 aPosition;\n'+
    'void main(){ \n'+
    '}';


WebGLShaders.pointsVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec3 aColor;\n'+
    'varying vec3 vColor;\n'+
    'uniform mat4 uMVP;\n'+
    'void main(){ \n'+
        'vColor= aColor;\n'+
        'gl_Position = uMVP * vec4(aPosition, 1.0);\n'+
    '}';


WebGLShaders.pointsFragmentShader = 'precision mediump float;\n'+
    'varying vec3 vColor;\n'+
    'void main() {\n'+
        'gl_FragColor = vec4(vColor.x, vColor.y, vColor.z, 1.0);\n'+
    '}';


WebGLShaders.lineVertexShader = //line
    '#ifndef dataPoints2\n'+
        'uniform mat4 uMVP;\n'+
    '#else\n'+
        'uniform mat4 uMV, uProj;\n'+
    '#endif\n'+

    '#ifdef pixelLine\n'+
        '#ifdef dataPoints2\n'+
            'attribute vec3 aPosition;\n'+
        '#else\n'+
            'attribute vec4 aPosition;\n'+
            'attribute vec4 aNormal;\n'+
        '#endif\n'+

        '#ifdef dataPoints\n'+
            'uniform vec3 uScale;\n'+
            'uniform vec3 uPoints[32];\n'+
        '#else\n'+
            'uniform vec2 uScale;\n'+
        '#endif\n'+

        '#ifdef dataPoints2\n'+

        'vec4 getClippedPixelLinePoint(vec3 p1, vec3 p2, vec3 params) {\n'+
            'vec2 pp1, pp2, n;\n'+
            'vec4 wp0 = (uMV * vec4(p1.xyz, 1.0)), pp0, pp3;\n'+
            'float near = gl_DepthRange.near + 0.1;\n'+
            //'float near = gl_DepthRange.near + 0.1 + 30000.0;\n'+
            'if (params.y < 0.0) {\n'+
                //'return vec4(8.0, 0.0, 0.0, 1.0);\n'+
                'if (wp0.z > -near) return vec4(8.0, 0.0, 0.0, 1.0);\n'+
                'pp0 = uProj * wp0;\n'+
                'if (params.y == -1.0) return pp0;\n'+
                'return pp0 + vec4((vec3(-sin(params.z)*uScale.x*uScale.z*pp0.w, cos(params.z)*uScale.y*uScale.z*pp0.w, 0.0)), 0.0);\n'+
            '} else {\n'+
                'vec3 p2 = uPoints[int(params.y)];\n'+
                'vec4 wp3 = (uMV * vec4(p2.xyz, 1.0));\n'+
                'if (wp0.z > -near) {\n'+
                    'vec3 dir = (wp3.xyz - wp0.xyz);\n'+
                    'float l = length(dir);\n'+
                    'dir = normalize(dir);\n'+
                    'float denominator = -dir.z;\n'+
                    'if (abs(denominator) < 0.0000001) return vec4(8.0, 0.0, 0.0, 1.0);\n'+
                    'float t = (near + wp0.z) / denominator;\n'+
                    'if (t < 0.0 || t > l) return vec4(8.0, 0.0, 0.0, 1.0);\n'+
                    'wp0.xyz = wp0.xyz + (dir * t);\n'+
                '}\n'+
                'pp0 = uProj * wp0;\n'+
                'pp3 = uProj * wp3;\n'+
                'pp1 = pp0.xy / pp0.w;\n'+
                'pp2 = pp3.xy / pp3.w;\n'+
                //'pp1 = pp0.xy;\n'+
                //'pp2 = pp3.xy;\n'+
                'n = normalize(pp2 - pp1);\n'+
                'return pp0 + vec4((vec3(-n.y*uScale.x*params.z*uScale.z*pp0.w, n.x*uScale.y*params.z*uScale.z*pp0.w, 0.0)), 0.0);\n'+
            '}\n'+
        '}\n'+

        '#endif\n'+

    '#else\n'+

        '#ifdef lineLabel2\n'+

            'attribute vec2 aPosition;\n'+
            'uniform vec4 uData[DSIZE];\n'+
            'uniform float uFile;\n'+
            'varying vec2 vTexCoord;\n'+

        '#else\n'+

            '#ifdef lineLabel\n'+
                'attribute vec4 aPosition;\n'+
                'attribute vec4 aTexCoord;\n'+
                'uniform vec4 uVec;\n'+
                'uniform float uFile;\n'+
                'varying vec2 vTexCoord;\n'+
            '#else\n'+
                'attribute vec3 aPosition;\n'+
            '#endif\n'+

            '#ifdef dynamicWidth\n'+
                'attribute vec4 aNormal;\n'+
                'uniform vec4 uParams;\n'+
            '#endif\n'+

        '#endif\n'+

    '#endif\n'+

    '#ifdef applySE\n'+
        'uniform mat4 uParamsSE;\n'+
    '#endif\n'+

    '#ifdef withElements\n'+
        'attribute float aElement;\n'+
        'varying float vElement;\n'+
    '#endif\n'+


    'void main() {\n'+

        '#ifdef withElements\n'+
            'vElement = aElement;\n'+
        '#endif\n'+

        '#ifdef dataPoints\n'+
            'vec3 p1 = uPoints[int(aPosition.x)];\n'+
        '#else \n'+
            '#ifndef lineLabel2\n'+
                'vec3 p1 = aPosition.xyz;\n'+
            '#endif\n'+
        '#endif\n'+

        '#ifdef pixelLine\n'+
            '#ifndef dataPoints\n'+
                'vec3 p2 = aNormal.xyz;\n'+
            '#endif\n'+
        '#endif\n'+

        '#ifdef applySE\n'+
            'vec3 geoPos2 = p1.xyz*vec3(uParamsSE[0][3],uParamsSE[1][0],uParamsSE[1][1]);\n'+
            'vec3 geoPos = geoPos2+vec3(uParamsSE[0][0],uParamsSE[0][1],uParamsSE[0][2]);\n'+
            'geoPos.z *= uParamsSE[3][3];\n'+
            'float ll = length(geoPos);\n'+
            'vec3 v = geoPos * (1.0/(ll+0.0001));\n'+
            'float h = ll - uParamsSE[3][2];\n'+
            'float h2 = clamp(h, uParamsSE[2][1], uParamsSE[2][3]);\n'+
            'float h3 = h;\n'+
            'h *= (uParamsSE[2][2] + ((h2 - uParamsSE[2][1]) * uParamsSE[3][0]) * uParamsSE[3][1]);\n'+
            'geoPos2.xyz += v * (h - h3);\n'+

            '#ifdef pixelLine\n'+

                'vec4 pp0 = uMVP * vec4(geoPos2, 1.0);\n'+

                'if (aNormal.w == 0.0) {\n'+
                    'gl_Position = pp0 + vec4((vec3(aNormal.x*uScale.x*pp0.w, aNormal.y*uScale.y*pp0.w, 0.0)), 0.0);\n'+
                '} else {\n'+
                    'geoPos2 = p2.xyz*vec3(uParamsSE[0][3],uParamsSE[1][0],uParamsSE[1][1]);\n'+
                    'geoPos = geoPos2+vec3(uParamsSE[0][0],uParamsSE[0][1],uParamsSE[0][2]);\n'+
                    'geoPos.z *= uParamsSE[3][3];\n'+
                    'll = length(geoPos);\n'+
                    'v = geoPos * (1.0/(ll+0.0001));\n'+
                    'h = ll - uParamsSE[3][2];\n'+
                    'h2 = clamp(h, uParamsSE[2][1], uParamsSE[2][3]);\n'+
                    'h3 = h;\n'+
                    'h *= (uParamsSE[2][2] + ((h2 - uParamsSE[2][1]) * uParamsSE[3][0]) * uParamsSE[3][1]);\n'+
                    'geoPos2.xyz += v * (h - h3);\n'+

                    'vec4 pp3 = uMVP * vec4(geoPos2, 1.0);\n'+
                    'vec2 pp1 = pp0.xy / pp0.w;\n'+
                    'vec2 pp2 = pp3.xy / pp3.w;\n'+
                    'vec2 n = normalize(pp2 - pp1);\n'+
                    'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aNormal.w*pp0.w, n.x*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\n'+
                '}\n'+

            '#else\n'+

                '#ifdef lineLabel\n'+

                    'vTexCoord = aTexCoord.xy;\n'+
                    'if (dot(uVec.xyz, vec3(aTexCoord.z, aTexCoord.w, aPosition.w)) < 0.0) {\n'+
                        'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
                    '}else{\n'+
                        'float file = floor(aTexCoord.y/4.0);\n'+
                        'vTexCoord.y = mod(aTexCoord.y,4.0);\n'+
                        'if (file != floor(uFile)) {\n'+
                            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
                        '}else{\n'+
                            'gl_Position = uMVP * vec4(geoPos2, 1.0);\n'+
                        '}\n'+
                    '}\n'+

                '#else\n'+

                    'gl_Position = uMVP * vec4(geoPos2, 1.0);\n'+

                '#endif\n'+

            '#endif\n'+

        '#else\n'+

            '#ifdef pixelLine\n'+

                '#ifdef dataPoints2\n'+

                    'vec3 p2 = uPoints[int(aPosition.y)];\n'+
                    'gl_Position = getClippedPixelLinePoint(p1.xyz, p2.xyz, aPosition.xyz);\n'+

                '#else\n'+

                    'vec4 pp0 = (uMVP * vec4(p1.xyz, 1.0));\n'+

                    '#ifdef dataPoints\n'+

                        'if (aPosition.y < 0.0) {\n'+
                            'if (aPosition.y == -1.0) {\n'+
                                'gl_Position = pp0;\n'+
                            '} else {\n'+
                                'gl_Position = pp0 + vec4((vec3(-sin(aPosition.z)*uScale.x*uScale.z, cos(aPosition.z)*uScale.y*uScale.z, 0.0)), 0.0);\n'+
                            '}\n'+
                        '} else {\n'+
                            'vec3 p2 = uPoints[int(aPosition.y)];\n'+
                            'vec4 pp3 = (uMVP * vec4(p2.xyz, 1.0));\n'+
                            'vec2 pp1 = pp0.xy / pp0.w;\n'+
                            'vec2 pp2 = pp3.xy / pp3.w;\n'+
                            'vec2 n = normalize(pp2 - pp1);\n'+
                            'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aPosition.z*uScale.z, n.x*uScale.y*aPosition.z*uScale.z, 0.0)), 0.0);\n'+
                        '}\n'+

                    '#else\n'+

                        'if (aNormal.w == 0.0) {\n'+
                            'gl_Position = pp0 + vec4((vec3(aNormal.x*uScale.x*pp0.w, aNormal.y*uScale.y*pp0.w, 0.0)), 0.0);\n'+
                        '} else {\n'+
                            'vec4 pp3 = (uMVP * vec4(p2.xyz, 1.0));\n'+
                            'vec2 pp1 = pp0.xy / pp0.w;\n'+
                            'vec2 pp2 = pp3.xy / pp3.w;\n'+
                            'vec2 n = normalize(pp2 - pp1);\n'+
                            'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aNormal.w*pp0.w, n.x*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\n'+
                        '}\n'+

                    '#endif\n'+

                '#endif\n'+

            '#else\n'+

                '#ifdef lineLabel2\n'+

                    'int index = int(aPosition.x) * 3;\n'+
                    'vec4 data = uData[index];\n'+
                    'vec4 data2 = uData[index+1];\n'+
                    'vec4 data3 = uData[index+2];\n'+

                    'vec3 pos = vec3(data[0],data[1],data[2]);\n'+
                    'vec4 q = vec4(data[3],data2[0],data2[1],data2[2]);\n'+
                    'vec2 factor = vec2(data2[3],data3[0]);\n'+
                    'vec2 uv = vec2(data3[1],data3[2]);\n'+
                    'float duv = data3[3];\n'+
//                    'vec3 up = vec3(1.0,0.0,0.0);\n'+
  //                  'vec3 right = vec3(0.0,1.0,0.0);\n'+

                    //get up, right vectors from quaternion
                    'float x=q[0], y=q[1], z=q[2], w=q[3];\n'+
                    'float x2=x+x, y2=y+y, z2=z+z, xx=x*x2, yx=y*x2, yy=y*y2;\n'+
                    'float zx=z*x2, zy=z*y2, zz=z*z2, wx=w*x2, wy=w*y2, wz=w*z2;\n'+

                    'vec3 right = vec3(1.0-yy-zz, yx-wz, zx+wy) * factor.x;\n'+
                    'vec3 up = vec3(yx+wz, 1.0-xx-zz, zy-wx) * (-factor.y);\n'+

                    /*
                      out[0] = 1 - yy - zz;
                      out[3] = yx - wz;
                      out[6] = zx + wy;
                      out[1] = yx + wz;
                      out[4] = 1 - xx - zz;
                      out[7] = zy - wx;
                      out[2] = zx - wy;
                      out[5] = zy + wx;
                      out[8] = 1 - xx - yy;
                    */

                    'float file = floor(uv.y/4.0);\n'+
                    'uv.y = (uv.y-file*4.0);\n'+

                    'int corner = int(aPosition.y);\n'+
                    'if (corner==1){ pos+=right; uv.x+=floor(duv)*(1.0/1024.0);  }\n'+
                    'if (corner==2){ pos+=right; pos+=up; uv.x+=floor(duv)*(1.0/1024.0); uv.y+=fract(duv); }\n'+
                    'if (corner==3){ pos+=up; uv.y+=fract(duv); }\n'+

                    'vTexCoord = uv;\n'+

                    'if (file != floor(uFile)) {\n'+
                        'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
                    '}else{\n'+
                        'gl_Position = uMVP * vec4(pos.xyz, 1.0);\n'+
                    '}\n'+

                '#else\n'+

                    '#ifdef lineLabel\n'+

                        'vTexCoord = aTexCoord.xy;\n'+
                        'if (dot(uVec.xyz, vec3(aTexCoord.z, aTexCoord.w, aPosition.w)) < 0.0) {\n'+
                            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
                        '}else{\n'+
                            'float file = floor(aTexCoord.y/4.0);\n'+
                            'vTexCoord.y = mod(aTexCoord.y,4.0);\n'+
                            'if (file != floor(uFile)) {\n'+
                                'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
                            '}else{\n'+
                                'gl_Position = uMVP * vec4(aPosition.xyz, 1.0);\n'+
                            '}\n'+
                        '}\n'+

                    '#else\n'+

                        '#ifdef dynamicWidth\n'+
                            'gl_Position = uMVP * vec4(aPosition.xyz + aNormal.xyz*(abs(aNormal.w)*uParams[3]), 1.0);\n'+
                        '#else\n'+
                            'gl_Position = uMVP * vec4(aPosition, 1.0);\n'+
                        '#endif\n'+

                    '#endif\n'+

                '#endif\n'+

            '#endif\n'+

        '#endif\n'+

    '}';


WebGLShaders.lineFragmentShader = 'precision mediump float;\n'+ //line

    'uniform vec4 uColor;\n'+

    '#ifdef withElements\n'+
        'varying float vElement;\n'+
    '#endif\n'+

    'void main() {\n'+

        '#ifdef withElements\n'+
            //'gl_FragColor.xyz = fract(vec3(1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vElement) + (-0.5/255.0);\n'+ // + (-0.5/255.0);\n'+
            //'gl_FragColor.xyz = fract(vec3(1.0/255.0, 1.0/65535.0, 1.0/16581375.0) * vElement) + (-0.5/255.0);\n'+ // + (-0.5/255.0);\n'+
            //'gl_FragColor.xyz = fract(vec3(1.0/255.0, 0.0, 0.0) * vElement);\n'+ // + (-0.5/255.0);\n'+

            //'float ez =  (floor(vElement / 65536.0)*65536.0);\n'+ // + (-0.5/255.0);\n'+
            'float ey =  floor((vElement) / 256.0);\n'+ // + (-0.5/255.0);\n'+

            'gl_FragColor.xyz =  vec3((vElement - ey*256.0), ey, 0.0) * (1.0/255.0); \n'+ // + (-0.5/255.0);\n'+

            'gl_FragColor.w = 1.0;\n'+
        '#else\n'+
            'gl_FragColor = uColor;\n'+
        '#endif\n'+

    '}';

WebGLShaders.tlineVertexShader = // textured line
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aNormal;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec2 uScale;\n'+
    'uniform vec4 uParams;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main(){ \n'+
        'vec4 p=vec4(aPosition.xyz, 1.0);\n'+
        'p.xyz+=aNormal.xyz*(abs(aNormal.w)*uParams[3]);\n'+
        'if (aNormal.w < 0.0){\n'+
            'vTexCoord=vec2(abs(aPosition.w)*uParams[0], (uParams[1]+uParams[2])*0.5);\n'+
        '} else {\n'+
            'vTexCoord=vec2(abs(aPosition.w)*uParams[0], aPosition.w < 0.0 ? uParams[1] : uParams[2]);\n'+
        '}\n'+

        'gl_Position = uMVP * p;\n'+
    '}';


WebGLShaders.etlineVertexShader = // textured line elements
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aNormal;\n'+
    'attribute float aElement;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec2 uScale;\n'+
    'uniform vec4 uParams;\n'+
    'varying float vElement;\n'+
    'void main(){ \n'+
        'vec4 p=vec4(aPosition.xyz, 1.0);\n'+
        'p.xyz+=aNormal.xyz*(abs(aNormal.w)*uParams[3]);\n'+
        'vElement = aElement;\n'+
        'gl_Position = uMVP * p;\n'+
    '}';

WebGLShaders.tplineVertexShader = // textured pixel line
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aNormal;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec2 uScale;\n'+
    'uniform vec4 uParams;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main(){ \n'+
        'vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\n'+
        'vTexCoord=vec2(abs(aPosition.w)*uParams[0], aPosition.w < 0.0 ? uParams[1] : uParams[2]);\n'+
        'if (aNormal.w == 0.0) {\n'+
            'gl_Position = pp0 + vec4((vec3(aNormal.x*uParams[3]*uScale.x*pp0.w, aNormal.y*uParams[3]*uScale.y*pp0.w, 0.0)), 0.0);\n'+
        '} else {\n'+
            'vec2 pp1 = pp0.xy / pp0.w;\n'+
            'vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\n'+
            'vec2 pp2 = pp3.xy / pp3.w;\n'+
            'vec2 n = normalize(pp2 - pp1);\n'+
            'gl_Position = pp0 + vec4((vec3(-n.y*uParams[3]*uScale.x*aNormal.w*pp0.w, n.x*uParams[3]*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\n'+
        '}\n'+
    '}';

WebGLShaders.etplineVertexShader = // textured pixel line elements
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aNormal;\n'+
    'attribute float aElement;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec2 uScale;\n'+
    'uniform vec4 uParams;\n'+
    'varying float vElement;\n'+
    'void main(){ \n'+
        'vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\n'+
        'vElement = aElement;\n'+
        'if (aNormal.w == 0.0) {\n'+
            'gl_Position = pp0 + vec4((vec3(aNormal.x*uParams[3]*uScale.x*pp0.w, aNormal.y*uParams[3]*uScale.y*pp0.w, 0.0)), 0.0);\n'+
        '} else {\n'+
            'vec2 pp1 = pp0.xy / pp0.w;\n'+
            'vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\n'+
            'vec2 pp2 = pp3.xy / pp3.w;\n'+
            'vec2 n = normalize(pp2 - pp1);\n'+
            'gl_Position = pp0 + vec4((vec3(-n.y*uParams[3]*uScale.x*aNormal.w*pp0.w, n.x*uParams[3]*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\n'+
        '}\n'+
    '}';

WebGLShaders.tlineFragmentShader = 'precision mediump float;\n'+ // textured line
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uColor;\n'+
    'uniform vec4 uColor2;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main() {\n'+
        'vec4 c=texture2D(uSampler, vTexCoord)*uColor;\n'+
        'gl_FragColor = c;\n'+
    '}';


WebGLShaders.tblineFragmentShader = 'precision mediump float;\n'+  // textured line with background color
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uColor;\n'+
    'uniform vec4 uColor2;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main() {\n'+
        'vec4 c1=texture2D(uSampler, vTexCoord)*uColor;\n'+
        'vec4 c2=uColor2,c=c1;\n'+
        'c.xyz*=c.w; c2.xyz*=c2.w;\n'+
        'c=mix(c,c2,1.0-c.w);\n'+
        'c.xyz/=(c.w+0.00001);\n'+
        'c.w=max(c1.w,c2.w);\n'+
        'gl_FragColor = c;\n'+
    '}';


WebGLShaders.polygonVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec3 aNormal;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform mat4 uRot;\n'+
    'uniform vec4 uColor;\n'+
    'varying vec4 vColor;\n'+
    'void main(){ \n'+
        'float l = dot((uRot*vec4(aNormal,1.0)).xyz, vec3(0.0,0.0,1.0)) * 0.5;\n'+
        'vec3 c = uColor.xyz;\n'+
        'c = (l > 0.0) ? mix(c,vec3(1.0,1.0,1.0),l) : mix(vec3(0.0,0.0,0.0),c,1.0+l);\n'+
        'vColor = vec4(c, uColor.w);\n'+
        'gl_Position = uMVP * vec4(aPosition, 1.0);\n'+
    '}';


WebGLShaders.polygonFragmentShader = 'precision mediump float;\n'+
    'varying vec4 vColor;\n'+
    'void main() {\n'+
        'gl_FragColor = vColor;\n'+
    '}';


WebGLShaders.iconVertexShader =
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aTexCoord;\n'+
    'attribute vec3 aOrigin;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec4 uScale;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main(){ \n'+
        'vTexCoord = aTexCoord.xy * uScale[2];\n'+
        'vec4 pos = (uMVP * vec4(aOrigin, 1.0));\n'+
        'gl_Position = pos + vec4(aPosition.x*uScale.x*pos.w, (aPosition.y+uScale.w)*uScale.y*pos.w, 0.0, 0.0);\n'+
    '}';

WebGLShaders.icon2VertexShader =
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aTexCoord;\n'+
    'attribute vec3 aOrigin;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec4 uScale;\n'+
    'uniform float uFile;\n'+
    'varying vec2 vTexCoord;\n'+
    //'float round(float x) { return floor(x + 0.5); }\n'+
    'void main(){ \n'+
        'vTexCoord = aTexCoord.xy * uScale[2];\n'+
        'float file = floor(aTexCoord.y/4.0);\n'+
        'vTexCoord.y = mod(aTexCoord.y,4.0);\n'+
        'if (file != floor(uFile)) {\n'+
            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
        '}else{\n'+
            'vec4 pos = (uMVP * vec4(aOrigin, 1.0));\n'+
            //'pos.x = (floor((pos.x/pos.w)*800.0+0.5)/800.0)*pos.w;\n'+
            //'pos.y = (floor((pos.y/pos.w)*410.0+0.5)/410.0)*pos.w;\n'+
            'gl_Position = pos + vec4(aPosition.x*uScale.x*pos.w, (aPosition.y+uScale.w)*uScale.y*pos.w, 0.0, 0.0);\n'+
        '}'+
    '}';


WebGLShaders.icon3VertexShader =
    'attribute vec2 aPosition;\n'+
    'uniform mat4 uProjectionMatrix;\n'+
    'uniform vec4 uScale;\n'+
    'uniform vec3 uOrigin;\n'+
    'uniform vec4 uData[DSIZE];\n'+
    'uniform float uFile;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main(){ \n'+
        'int index = int(aPosition.x);\n'+
        'vec4 data = uData[index];\n'+
        'vec4 data2 = uData[index+1];\n'+
        'vec4 v;\n'+
        'int corner = int(aPosition.y);\n'+
        'if (corner==0) v = vec4(data.x, data.y, data2.x, data2.y);\n'+
        'if (corner==1) v = vec4(data.z, data.y, data2.z, data2.y);\n'+
        'if (corner==2) v = vec4(data.z, data.w, data2.z, data2.w);\n'+
        'if (corner==3) v = vec4(data.x, data.w, data2.x, data2.w);\n'+
        'vTexCoord = vec2(v.z, v.w);\n'+
        'float file = floor(v.w/4.0);\n'+
        //'vTexCoord.y = mod(v.w,4.0);\n'+
        'vTexCoord.y = (v.w-file*4.0);\n'+

        'if (file != floor(uFile)) {\n'+
            'gl_Position = uProjectionMatrix * vec4(2.0, 0.0, 0.0, 2.0);\n'+
        '}else{\n'+
            'vec4 pos = (uProjectionMatrix * vec4(uOrigin.xyz, 1.0));\n'+
            'gl_Position = pos + vec4(v.x*uScale.x*pos.w, v.y*uScale.y*pos.w, 0.0, 0.0);\n'+
        '}'+
    '}';

WebGLShaders.textFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uColor;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main() {\n'+
        'vec4 c=texture2D(uSampler, vTexCoord);\n'+
        'if(c.w < 0.01){ discard; }\n'+
        'gl_FragColor = c*uColor;\n'+
    '}';

WebGLShaders.text2FragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uColor;\n'+
    'uniform vec2 uParams;\n'+
    'varying vec2 vTexCoord;\n'+
    'float round(float x) { return floor(x + 0.5); }\n'+

    'void main() {\n'+
        'vec2 uv=(vTexCoord);\n'+
        'uv.y=fract(uv.y);\n'+
        'vec4 c=texture2D(uSampler, uv);\n'+

        'float r = 0.0;\n'+
        'int i=int(floor(vTexCoord.y));\n'+

        'if (i == 0) r=c.x;else\n'+
        'if (i == 1) r=c.y;else\n'+
        'if (i == 2) r=c.z;else\n'+
        'if (i == 3) r=c.w;\n'+

        'float u_buffer = uParams[0];\n'+
        'float u_gamma = uParams[1];\n'+
        'float alpha = uColor.a * smoothstep(u_buffer - u_gamma, u_buffer + u_gamma, r);\n'+

        //'gl_FragColor = vec4(0.0,0.0,1.0,1.0);\n'+

        'if(alpha < 0.01){ discard; }\n'+
        'gl_FragColor = vec4(uColor.rgb, alpha);\n'+
    '}';

WebGLShaders.skydomeVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMVP;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main(){ \n'+
        'gl_Position = uMVP * vec4(aPosition, 1.0);\n'+
        'vTexCoord = aTexCoord;\n'+
    '}';


WebGLShaders.skydomeFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'varying vec2 vTexCoord;\n'+
    'const vec4 gray = vec4(0.125, 0.125, 0.125, 1.0);\n'+
    'void main() {\n'+
        'float fade = smoothstep(0.51, 0.55, vTexCoord.t);\n'+
        'gl_FragColor = mix(texture2D(uSampler, vTexCoord), gray, fade);\n'+
    '}';


WebGLShaders.stardomeFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main() {\n'+
        'gl_FragColor = texture2D(uSampler, vTexCoord);\n'+
    '}';


WebGLShaders.atmoVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform mat3 uNorm;\n'+
    'varying vec3 vNormal;\n'+
    'varying vec4 vPosition;\n'+
    'void main(){ \n'+
        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'vec4 c = uMV * vec4(aPosition, 1.0);\n'+
        'vNormal = (aPosition.xyz - vec3(0.5));\n'+
        'vPosition = camSpacePos;\n'+
    '}';


WebGLShaders.atmoFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uParams;\n'+       //[radius, atmoSize, 0 ,0]
    'uniform vec4 uParams2;\n'+       //[radius, atmoSize, 0 ,0]
    'varying vec4 vPosition;\n'+
    'varying vec3 vNormal;\n'+
    'uniform vec4 uFogColor;\n'+ //= vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'uniform vec4 uFogColor2;\n'+ //= vec4(72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0);\n'+
    'void main() {\n'+
        'float l = dot(normalize(vNormal),-uParams2.xyz);\n'+
        'l = (1.0-pow(abs(l),uParams.x));\n'+
        'vec4 c = mix(uFogColor2, uFogColor, l);\n'+
        'gl_FragColor = vec4(c.xyz, c.w*l);\n'+
    '}';


WebGLShaders.atmoFragmentShader2 = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform float uNFactor;\n'+
    'uniform vec2 uRadius;\n'+
    'uniform vec3 uPos;\n'+
    'varying vec4 vPosition;\n'+
    'varying vec3 vNormal;\n'+
    'uniform vec4 uFogColor;\n'+ //= vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'void main() {\n'+
        'vec3 ldir = normalize(-vPosition.xyz);\n'+
        'vec3 diff = uPos;\n'+
        'float a = dot(ldir, ldir);\n'+
        'float b = 2 * dot(ldir, diff);\n'+
        'float c = dot(diff, diff) - (uRadius[0] * uRadius[0]);\n'+
        'float i = 0;\n'+
        'float discr = b * b - 4 * a * c;\n'+
        'if (discr > 0.0) {}\n'+

        '}\n'+
        'gl_FragColor = uFogColor;\n'+
    '}';


WebGLShaders.atmoVertexShader3 =
    'attribute vec3 aPosition;\n'+
    //'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMV, uProj;\n'+
    //"uniform mat3 uNorm;\n"+
    'uniform vec4 uParams;\n'+       //[surfaceRadius, surfaceRadius, strech ,safetyfactor]
    'uniform vec4 uParams2;\n'+       //[cameraPos, 1]

    'varying vec2 vTexcoords;\n'+

    'void main(){ \n'+
        'gl_Position = uProj * (uMV * vec4(aPosition, 1.0));\n'+

        'vec3 position = (aPosition.xyz - vec3(0.5)) * vec3(uParams.w * 2.0);\n'+
        'vec4 camPos = uParams2;\n'+
        'float SurfaceRadius = uParams.x;\n'+
        'float AtmosphereRadius = uParams.y;\n'+
        'float StretchAmt = uParams.z;\n'+

        'float camHeight = length(camPos.xyz);\n'+
        'vec3 camToPos = position - camPos.xyz;\n'+
        'float farDist = length(camToPos);\n'+

        // get distance to surface horizon
        'float altitude = max(0.0,camHeight - SurfaceRadius);\n'+
        'float horizonDist = sqrt((altitude*altitude) + (2.0 * SurfaceRadius * altitude));\n'+
        'float maxDot = horizonDist / camHeight;\n'+

        // get distance to atmosphere horizon - use max(0,...) because we can go into the atmosphere
        'altitude = max(0.0,camHeight - AtmosphereRadius);\n'+
        'horizonDist = sqrt((altitude*altitude) + (2.0 * AtmosphereRadius * altitude));\n'+

        // without this, the shift between inside and outside atmosphere is  jarring
        'float tweakAmount = 0.1;\n'+
        'float minDot = max(tweakAmount,horizonDist / camHeight);\n'+

        // scale minDot from 0 to -1 as we enter the atmosphere
        'float minDot2 = ((camHeight - SurfaceRadius) * (1.0 / (AtmosphereRadius  - SurfaceRadius))) - (1.0 - tweakAmount);\n'+
        'minDot = min(minDot, minDot2);\n'+

        // get dot product of the vertex we're looking out
        'float posDot = dot(camToPos / farDist,-camPos.xyz / camHeight) - minDot;\n'+

        // calculate the height from surface in range 0..1
        'float height = posDot * (1.0 / (maxDot - minDot));\n'+

        'vTexcoords.y = height;\n'+

        'height -= min(0.0,minDot2 + ((1.0 + StretchAmt) * minDot2));\n'+
        'vTexcoords.x = height;\n'+
    '}';


WebGLShaders.atmoFragmentShader3 = 'precision mediump float;\n'+
    'varying vec2 vTexcoords;\n'+
    'uniform vec4 uParams3;\n'+       //[treshold, mutiplier, 0,0]
    'uniform vec4 uFogColor;\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'uniform vec4 uFogColor2;\n'+ // = vec4(72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0);\n'+
    'const vec4 fogColor3 = vec4(0.0/255.0, 0.0/255.0, 0.0/255.0, 1.0);\n'+

    'void main() {\n'+
        'float l = vTexcoords.y;\n'+
        'if (l > uParams3.z){ discard; } else {\n'+
            'float l2 = clamp((l*l)*0.9+0.1, 0.0, 1.5);\n'+
            'vec4 c = mix(uFogColor2, uFogColor, l2);\n'+
            'gl_FragColor = vec4(c.xyz, c.w*l);\n'+

            'if (l > uParams3.x){ gl_FragColor.xyz = mix(gl_FragColor.xyz, fogColor3.xyz, (l-uParams3.x)*uParams3.y); }\n'+
        '}'+

    '}';


//heightmap tile
WebGLShaders.heightmapVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform float uFogDensity;\n'+
    'uniform mat4 uGridMat;\n'+
    'uniform float uGridStep1, uGridStep2;\n'+
    'const int HMSize = 5;\n'+
    'const float HMSize1 = float(HMSize-1);\n'+
    'uniform float uHeight[HMSize*HMSize];\n'+
    'varying vec2 vTexCoord1;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying float vFogFactor;\n'+
    'float round(float x) { return floor(x + 0.5); }\n'+
    'void main() {\n'+
        'vec3 pos = aPosition;\n'+
        'float z = uHeight[int(round(pos.y*HMSize1)*float(HMSize) + round(pos.x*HMSize1))];\n'+
        'vec4 camSpacePos = uMV * vec4(pos.xy, z, 1.0);\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+
        'vFogFactor = exp(uFogDensity * camDist);\n'+
        'vec4 gridCoord = uGridMat * vec4(pos, 1.0);\n'+
        'vTexCoord1 = aTexCoord;\n'+
        'vTexCoord1 = gridCoord.xy * vec2(uGridStep1);\n'+
        'vTexCoord2 = gridCoord.xy * vec2(uGridStep2);\n'+
    '}';


WebGLShaders.heightmapFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform float uGridBlend;\n'+
    'varying vec2 vTexCoord1;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying float vFogFactor;\n'+
    'uniform vec4 uFogColor;\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'void main() {\n'+
        'vec4 gridColor = mix(texture2D(uSampler, vTexCoord1), texture2D(uSampler, vTexCoord2), uGridBlend);\n'+
        'gl_FragColor = mix(uFogColor, gridColor, vFogFactor);\n'+
    '}';


//depth encoded heightmap tile
WebGLShaders.heightmapDepthVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform float uFogDensity;\n'+
    'uniform mat4 uGridMat;\n'+
    'uniform float uGridStep1, uGridStep2;\n'+
    'const int HMSize = 5;\n'+
    'const float HMSize1 = float(HMSize-1);\n'+
    'uniform float uHeight[HMSize*HMSize];\n'+
    'varying vec2 vTexCoord1;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying float vDepth;\n'+
    'float round(float x) { return floor(x + 0.5); }\n'+
    'void main() {\n'+
        'vec3 pos = aPosition;\n'+
        'float z = uHeight[int(round(pos.y*HMSize1)*float(HMSize) + round(pos.x*HMSize1))];\n'+
        'vec4 camSpacePos = uMV * vec4(pos.xy, z, 1.0);\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+
        'vDepth = camDist;\n'+
        'vec4 gridCoord = uGridMat * vec4(pos, 1.0);\n'+
        'vTexCoord1 = aTexCoord;\n'+
        'vTexCoord1 = gridCoord.xy * vec2(uGridStep1);\n'+
        'vTexCoord2 = gridCoord.xy * vec2(uGridStep2);\n'+
    '}';


WebGLShaders.heightmapDepthFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform float uGridBlend;\n'+
    'varying vec2 vTexCoord1;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying float vDepth;\n'+
    'void main() {\n'+
        'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\n'+
    '}';

WebGLShaders.quadPoint =
    'vec3 quadPoint(int i1, int i2, int i3, float t, float t2) {\n'+
        'float p1x = uPoints[i1], p1y = uPoints[i1+1], p1z = uPoints[i1+2];\n'+
        'float p3x = uPoints[i3], p3y = uPoints[i3+1], p3z = uPoints[i3+2];\n'+
        'float p2x = 2.0*uPoints[i2]-p1x*0.5-p3x*0.5;\n'+
        'float p2y = 2.0*uPoints[i2+1]-p1y*0.5-p3y*0.5;\n'+
        'float p2z = 2.0*uPoints[i2+2]-p1z*0.5-p3z*0.5;\n'+
        'return vec3(t2*t2*p1x+2.0*t2*t*p2x+t*t*p3x, t2*t2*p1y+2.0*t2*t*p2y+t*t*p3y, t2*t2*p1z+2.0*t2*t*p2z+t*t*p3z); }\n';

WebGLShaders.planeVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform vec4 uParams;\n'+    //[uGridStep1, fogDensity, indexFactor, uGridStep2]
    'uniform vec4 uParams3;\n'+    //[px, py, sx, sy]
    'uniform float uPoints[9*3];\n'+

    '#ifndef poles\n'+
        'uniform vec3 uVector;\n'+
        'uniform float uHeights[9];\n'+
    '#endif\n'+

    'varying vec2 vTexCoord;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying float vFogFactor;\n'+ WebGLShaders.quadPoint +

    '#ifndef poles\n'+
        'float linearHeight(float x, float y) {\n'+
            'int ix = int(x);\n'+
            'int iy = int(y);\n'+
            'int index = (2-iy)*3+ix;\n'+
            'int index2 = (2-(iy+1))*3+ix;\n'+
            'float fx = fract(x);\n'+
            'float fy = fract(y);\n'+
            'float w0 = (uHeights[index] + (uHeights[index+1] - uHeights[index])*fx);\n'+
            'float w1 = (uHeights[index2] + (uHeights[index2+1] - uHeights[index2])*fx);\n'+
            'return (w0 + (w1 - w0)*fy);\n'+
        '}\n'+
    '#endif\n'+

    'void main() {\n'+
        'vec3 indices = aPosition;\n'+
        'float t = aPosition.y * uParams[2];\n'+  //vertical index
        'float tt = t;\n'+
        'float t2 = (1.0-t);\n'+
        'vec3 p1 = quadPoint(0, 3, 6, t, t2);\n'+
        'vec3 p2 = quadPoint(9, 9+3, 9+6, t, t2);\n'+
        'vec3 p3 = quadPoint(18, 18+3, 18+6, t, t2);\n'+
        't = aPosition.x * uParams[2];\n'+  //horizontal index
        'float tt2 = t;\n'+
        't2 = (1.0-t);\n'+
        'float p2x = 2.0*p2.x-p1.x*0.5-p3.x*0.5;\n'+
        'float p2y = 2.0*p2.y-p1.y*0.5-p3.y*0.5;\n'+
        'float p2z = 2.0*p2.z-p1.z*0.5-p3.z*0.5;\n'+
        'vec4 p = vec4(t2*t2*p1.x+2.0*t2*t*p2x+t*t*p3.x, t2*t2*p1.y+2.0*t2*t*p2y+t*t*p3.y, t2*t2*p1.z+2.0*t2*t*p2z+t*t*p3.z, 1);\n'+

        '#ifndef poles\n'+
            '#ifndef flat\n'+
                'p.xyz += uVector * linearHeight(tt*2.0, tt2*2.0);\n'+
            '#endif\n'+
        '#endif\n'+

        'vec4 camSpacePos = uMV * p;\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+

        '#ifdef depth\n'+
            'vFogFactor = camDist;\n'+
        '#else\n'+
            'vFogFactor = exp(uParams[1] * camDist);\n'+
        '#endif\n'+

        'vec2 uv;\n'+
        'uv.x = aTexCoord.y * uParams3[2] + uParams3[0];\n'+
        'uv.y = (1.0-aTexCoord.x) * uParams3[3] + uParams3[1];\n'+
        'vTexCoord = uv;\n'+
        'vTexCoord2 = p.xy;\n'+
    '}';

WebGLShaders.planeFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uParams2;\n'+    //[uGridStep1, uGridStep2, uGridBlend, 0]

    '#ifdef poles\n'+
        'uniform vec4 uParams4;\n'+    //[pole-x, pole-y, pole-radius, 0]
        'varying vec2 vTexCoord2;\n'+
    '#endif\n'+

    'varying vec2 vTexCoord;\n'+
    'varying float vFogFactor;\n'+
    'uniform vec4 uFogColor;\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'void main() {\n'+
        '#ifdef poles\n'+
            'if (length(uParams4.xy - vTexCoord2.xy) > uParams4.z){ discard; }\n'+
        '#endif\n'+

        '#ifdef depth\n'+
            'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vFogFactor) + (-0.5/255.0);\n'+
        '#else\n'+
            'vec4 c = mix(texture2D(uSampler, vTexCoord), texture2D(uSampler, vTexCoord*8.0), uParams2[2]);\n'+
            'gl_FragColor = mix(uFogColor, c, vFogFactor);\n'+
        '#endif\n'+
    '}';

WebGLShaders.getHFNormal =
    'vec3 getHFNormal(vec2 uv, float texelSize, float heightDelta) {\n'+
        'vec4 h;\n'+
        'h[0] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0,-1.0))).r * heightDelta;\n'+
        'h[1] = texture2D(uSampler2, uv + (texelSize * vec2(-1.0, 0.0))).r * heightDelta;\n'+
        'h[2] = texture2D(uSampler2, uv + (texelSize * vec2( 1.0, 0.0))).r * heightDelta;\n'+
        'h[3] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0, 1.0))).r * heightDelta;\n'+
        'return normalize(vec3(h[1] - h[2], h[3] - h[0], 2.0));}\n';

WebGLShaders.getHFNormal2 =
    'vec2 getHFNormal2(vec2 uv, float texelSize, float heightDelta) {\n'+
        'vec4 h;\n'+
        'h[0] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0,-1.0))).r * heightDelta;\n'+
        'h[1] = texture2D(uSampler2, uv + (texelSize * vec2(-1.0, 0.0))).r * heightDelta;\n'+
        'h[2] = texture2D(uSampler2, uv + (texelSize * vec2( 1.0, 0.0))).r * heightDelta;\n'+
        'h[3] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0, 1.0))).r * heightDelta;\n'+
        'return vec2(h[1] - h[2], h[3] - h[0]);}\n';

WebGLShaders.planeVertex4Shader =
    '#define newspace\n'+
    'uniform sampler2D uSampler2;\n'+
    'attribute vec3 aPosition;\n'+
    //'attribute vec2 aTexCoord;\n'+
    //'attribute vec3 aBarycentric;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform vec4 uParams;\n'+    //[uGridStep1, fogDensity, indexFactor, uGridStep2]
    'uniform vec4 uParams3;\n'+    //[px, py, sx, sy]
    'uniform float uPoints[9*3];\n'+
    'uniform vec3 uVector;\n'+
    'uniform vec3 uHeights;\n'+   //[hmin, hmax]
    'uniform vec4 uTransform;\n'+
    //'uniform vec4 uTransform2;\n'+
    'varying vec2 vTexCoord;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying vec3 vBarycentric;\n'+

    '#ifdef newspace\n'+
        'varying mat3 vTBN;\n'+
    '#else\n'+
        'varying vec3 vNormal;\n'+
    '#endif\n'+

    'varying float vFogFactor;\n'+ WebGLShaders.quadPoint +  WebGLShaders.getHFNormal + WebGLShaders.getHFNormal2 +
    //'float random(vec2 p) { return fract(cos(dot(p,vec2( 23.14069263277926, 2.665144142690225)))*12345.6789);}\n'+

    'void main() {\n'+
        'vec3 indices = aPosition;\n'+
        'float t = aPosition.y * uParams[2];\n'+  //vertical index
        'float tt = t;\n'+
        'float t2 = (1.0-t);\n'+
        'vec3 p1 = quadPoint(0, 3, 6, t, t2);\n'+
        'vec3 p2 = quadPoint(9, 9+3, 9+6, t, t2);\n'+
        'vec3 p3 = quadPoint(18, 18+3, 18+6, t, t2);\n'+
        't = aPosition.x * uParams[2];\n'+  //horizontal index
        'float tt2 = t;\n'+
        't2 = (1.0-t);\n'+
        'float p2x = 2.0*p2.x-p1.x*0.5-p3.x*0.5;\n'+
        'float p2y = 2.0*p2.y-p1.y*0.5-p3.y*0.5;\n'+
        'float p2z = 2.0*p2.z-p1.z*0.5-p3.z*0.5;\n'+
        'vec4 p = vec4(t2*t2*p1.x+2.0*t2*t*p2x+t*t*p3.x, t2*t2*p1.y+2.0*t2*t*p2y+t*t*p3.y, t2*t2*p1.z+2.0*t2*t*p2z+t*t*p3.z, 1);\n'+
        'vec2 uv2 = vec2(tt, 1.0-tt2);\n'+
        'uv2 = vec2(uTransform[0] * uv2[0] + uTransform[2], uTransform[1] * uv2[1] + uTransform[3]);\n'+

        'p.xyz += uVector * (uHeights[0] + (uHeights[1]-uHeights[0])*texture2D(uSampler2, uv2).x);\n'+

        'vec4 camSpacePos = uMV * p;\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+
        'vFogFactor = exp(uParams[1] * camDist);\n'+

        'vec2 uv = vec2(tt, 1.0-tt2);\n'+
        'uv.x = uv.x * uParams3[0] + uParams3[2];\n'+
        'uv.y = uv.y * uParams3[1] + uParams3[3];\n'+
        'vTexCoord = uv;\n'+

        'vBarycentric = camSpacePos.xyz;\n'+

        '#ifdef newspace\n'+
            'vec2 d = getHFNormal2(uv2, 1.0/(128.0), (uHeights[1]-uHeights[0]) * uHeights[2]);\n'+
            'vec3 T = vec3(2.0,0.0,-d.x); vec3 B = vec3(0.0,2.0,-d.y);\n'+
            'vTBN = mat3(normalize(T), normalize(B), cross(T,B));\n'+
        '#else\n'+
            'vec3 n = getHFNormal(uv2, 1.0/(128.0), (uHeights[1]-uHeights[0]) * uHeights[2]);\n'+
            'vNormal = normalize(n);\n'+
        '#endif\n'+

    '}';

WebGLShaders.planeFragmentShader2 = 'precision mediump float;\n'+
    '#extension GL_OES_standard_derivatives : enable\n'+
    '#define newspace\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uParams2;\n'+    //[uGridStep1, uGridStep2, uGridBlend, 0]
    'uniform mat3 uSpace;\n'+
    'varying vec2 vTexCoord;\n'+
    'varying float vFogFactor;\n'+
    'varying vec3 vBarycentric;\n'+

    '#ifdef newspace\n'+
        'varying mat3 vTBN;\n'+
    '#else\n'+
        'varying vec3 vNormal;\n'+
    '#endif\n'+

    'uniform vec4 uFogColor;\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'void main() {\n'+
        'vec3 ldir = normalize(-vBarycentric);\n'+

        '#ifdef flat\n'+
            'vec3 nx = dFdx(vBarycentric);\n'+
            'vec3 ny = dFdy(vBarycentric);\n'+
            'vec3 normal2 = normalize(cross(nx,ny));\n'+
            'vec4 c2 = vec4(vec3(max(0.0,normal2.z*(204.0/255.0))+(32.0/255.0)),1.0);\n'+
        '#else\n'+

            '#ifdef newspace\n'+
                //'vec3 normal = cross(normalize(vTangent), normalize(vBitangent));\n'+

                '#ifdef nmix\n'+
                    'vec3 normal = vTBN * normalize((texture2D(uSampler, vTexCoord).xyz-0.5)*2.0);\n'+
                '#else\n'+
                    'vec3 normal = vTBN * vec3(0.0,0.0,1.0);\n'+
                '#endif\n'+

            '#else\n'+
                'vec3 normal = vNormal;\n'+
            '#endif\n'+

            'normal = normalize(uSpace * normal);\n'+

            'vec3 eyeDir = ldir;\n'+
            'vec3 refDir = reflect(-ldir, normal);\n'+
            'float specW = min(1.0, pow(max(dot(refDir, eyeDir), 0.0), 90.0));\n'+
            'float diffW = min(1.0, max(dot(normal, ldir), 0.0));\n'+
            'float lcolor = (dot(normal, ldir) + 1.0) * 0.5;\n'+
            //'float lcolor = 0.25+(0.5*diffW)+(0.25*specW);\n'+
            //'float lcolor = 0.25+(0.75*diffW);\n'+

            '#ifdef normals\n'+
                'vec4 c2 = vec4(normal*0.5+0.5,1.0);\n'+
            '#else\n'+
                'vec4 c2 = vec4(vec3(dot(vec3(0.0,0.0,1.0), normal)),1.0);\n'+
            '#endif\n'+
            //'vec4 c2 = vec4(normalize(ldir)*0.5+0.5,1.0);\n'+
            //'vec4 c2 = vec4(vec3(lcolor),1.0);\n'+
        '#endif\n'+

        '#ifdef grid\n'+
            'vec4 c = mix(texture2D(uSampler, vTexCoord), texture2D(uSampler, vTexCoord*8.0), uParams2[2]);\n'+
            'c = mix(c, c2, 0.5);\n'+
        '#else\n'+
            '#ifdef exmap\n'+

                'vec4 c = texture2D(uSampler, vTexCoord);\n'+

                '#ifdef classmap\n'+
                    'int i = int(c.x*255.0);\n'+

                    /*
                    'if (i == 0) c = vec4(0.3, 0.44, 0.64, 1.0);\n'+
                    'if (i == 1) c = vec4(0.0, 0.24, 0.0, 1.0);\n'+
                    'if (i == 2) c = vec4(0.58, 0.61, 0.44, 1.0);\n'+
                    'if (i == 3) c = vec4(0.0, 0.39, 0.0, 1.0);\n'+
                    'if (i == 4) c = vec4(0.12, 0.67, 0.02, 1.0);\n'+
                    'if (i == 5) c = vec4(0.08, 0.55, 0.24, 1.0);\n'+
                    'if (i == 6) c = vec4(0.36, 0.46, 0.17, 1.0);\n'+
                    'if (i == 7) c = vec4(0.7, 0.62, 0.18, 1.0);\n'+
                    'if (i == 8) c = vec4(0.7, 0.54, 0.2, 1.0);\n'+
                    'if (i == 9) c = vec4(0.91, 0.86, 0.37, 1.0);\n'+
                    'if (i == 10) c = vec4(0.88, 0.81, 0.54, 1.0);\n'+
                    'if (i == 11) c = vec4(0.61, 0.46, 0.33, 1.0);\n'+
                    'if (i == 12) c = vec4(0.73, 0.83, 0.56, 1.0);\n'+
                    'if (i == 13) c = vec4(0.25, 0.54, 0.45, 1.0);\n'+
                    'if (i == 14) c = vec4(0.42, 0.64, 0.54, 1.0);\n'+
                    'if (i == 15) c = vec4(0.9, 0.68, 0.4, 1.0);\n'+
                    'if (i == 16) c = vec4(0.66, 0.67, 0.68, 1.0);\n'+
                    'if (i == 17) c = vec4(0.86, 0.13, 0.15, 1.0);\n'+
                    'if (i == 18) c = vec4(0.3, 0.44, 0.64, 1.0);\n'+
                    'if (i == 19) c = vec4(1.0, 0.98, 1.0, 1.0);\n'+
                    'c = c * c2;\n'+
                    */

                    'if (i == 1 || i == 2 || i == 5 || i == 6) c = vec4(146.0, 178.0, 144.0, 255.0);\n'+
                    'if (i == 3 || i == 4) c = vec4(94.0, 169.0, 133.0, 255.0);\n'+
                    'if (i == 8 || i == 11) c = vec4(238.0, 221.0, 185.0, 255.0);\n'+
                    'if (i == 7) c = vec4(226.0, 192.0, 154.0, 255.0);\n'+
                    'if (i == 9 || i == 10 || i == 12) c = vec4(250.0, 246.0, 167.0, 255.0);\n'+
                    'if (i == 13 || i == 16) c = vec4(245.0, 236.0, 211.0, 255.0);\n'+
                    'if (i == 14) c = vec4(139.0, 185.0, 166.0, 255.0);\n'+
                    'if (i == 15) c = vec4(199.0, 219.0, 155.0, 255.0);\n'+
                    'if (i == 17) c = vec4(149.0, 132.0, 162.0, 255.0);\n'+
                    'if (i == 18 || i == 0) c = vec4(188.0, 221.0, 255.0, 255.0);\n'+
                    'if (i == 19) c = vec4(255.0, 255.0, 255.0, 255.0);\n'+
                    'c = (c*(1.0/255.0)) * c2;\n'+
                '#endif\n'+

            '#else\n'+
                'vec4 c = c2;\n'+
            '#endif\n'+
        '#endif\n'+

        '#ifdef fog\n'+
            'gl_FragColor = mix(uFogColor, c, vFogFactor);\n'+
        '#else\n'+
            'gl_FragColor = c;\n'+
        '#endif\n'+
    '}';


//textured tile mesh
WebGLShaders.tileVertexShader =
    'attribute vec3 aPosition;\n'+

    '#ifdef onlyFog\n'+
        'varying float vFogFactor;\n'+
    '#else\n'+

        '#ifdef externalTex\n'+
            'attribute vec2 aTexCoord2;\n'+
        '#else\n'+
            'attribute vec2 aTexCoord;\n'+
        '#endif\n'+

        'varying vec3 vTexCoord;\n'+  //u,v,fogFactor

    '#endif\n'+

    '#ifdef clip4\n'+
        '#ifndef externalTex\n'+
            'attribute vec2 aTexCoord2;\n'+
        '#endif\n'+

        'varying vec2 vClipCoord;\n'+
    '#endif\n'+

    '#ifdef clip8\n'+
        '#ifndef externalTex\n'+
            'attribute vec2 aTexCoord2;\n'+
        '#endif\n'+

        'varying vec3 vClipCoord;\n'+

        'uniform mat4 uParamsC8;\n'+  //c,x,y,z

        'float getLinePointParametricDist(vec3 c, vec3 v, vec3 p) {\n'+
            'vec3 w = p - c;\n'+
            'float c1 = dot(w,v);\n'+
            'if (c1 <= 0.0) return 0.0;\n'+
            'float c2 = dot(v,v);\n'+
            'if (c2 <= c1) return 1.0;\n'+
            'return c1 / c2;\n'+
        '}\n'+

    '#endif\n'+

    '#ifdef depth\n'+
        'varying float vDepth;\n'+
    '#endif\n'+

    '#ifdef flatShadeVar\n'+
        ///'attribute vec3 aBarycentric;\n'+
        'varying vec3 vBarycentric;\n'+
    '#endif\n'+

                                             //0-3                            4-7          8-11            12-15
    'uniform mat4 uMV, uProj, uParams;\n'+  //[zfactor, fogDensity, scale.xy][camVec.xyzw][transform.xyzw][scale.z, trans.xyz]

    '#ifdef applySE\n'+
        'uniform mat4 uParamsSE;\n'+
    '#endif\n'+

    'void main() {\n'+

        '#ifdef applySE\n'+
            'vec3 geoPos2 = aPosition*vec3(uParamsSE[0][3],uParamsSE[1][0],uParamsSE[1][1]);\n'+
            'vec3 geoPos = geoPos2+vec3(uParamsSE[0][0],uParamsSE[0][1],uParamsSE[0][2]);\n'+
            'geoPos.z *= uParamsSE[3][3];\n'+
            'float ll = length(geoPos);\n'+
            'vec3 v = geoPos * (1.0/(ll+0.0001));\n'+
            'float h = ll - uParamsSE[3][2];\n'+
            'float h2 = clamp(h, uParamsSE[2][1], uParamsSE[2][3]);\n'+
            'float h3 = h;\n'+
            'h *= (uParamsSE[2][2] + ((h2 - uParamsSE[2][1]) * uParamsSE[3][0]) * uParamsSE[3][1]);\n'+
            'geoPos2.xyz += v * (h - h3);\n'+
            'vec4 camSpacePos = uMV * vec4(geoPos2, 1.0);\n'+
            'float l = dot(v, vec3(uParams[1][0],uParams[1][1],uParams[1][2]));\n'+
        '#else\n'+
            'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\n'+
            'vec3 worldPos = vec3(aPosition.x * uParams[0][2] + uParams[3][1], aPosition.y * uParams[0][3] + uParams[3][2], aPosition.z * uParams[3][0] + uParams[3][3]);\n'+
            'float l = dot(normalize(worldPos.xyz), vec3(uParams[1][0],uParams[1][1],uParams[1][2]));\n'+
        '#endif\n'+

        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+

        '#ifdef depth\n'+
            'vDepth = camDist;\n'+
        '#endif\n'+

        '#ifdef flatShadeVar\n'+
            'vBarycentric = camSpacePos.xyz;\n'+
        '#endif\n'+

        'float fogFactor = 1.0-exp(uParams[0][1] * camDist);\n'+
        'fogFactor = clamp((1.0-abs(l))*uParams[1][3] + fogFactor, 0.0, 1.0);\n'+

        '#ifdef onlyFog\n'+
            'vFogFactor = fogFactor;\n'+
        '#else\n'+
            'vTexCoord.z = fogFactor;\n'+

            '#ifdef externalTex\n'+
                'vTexCoord.xy = vec2(uParams[2][0] * aTexCoord2[0] + uParams[2][2], uParams[2][1] * aTexCoord2[1] + uParams[2][3]);\n'+
            '#else\n'+
                'vTexCoord.xy = aTexCoord;\n'+
            '#endif\n'+

        '#endif\n'+

        '#ifdef clip4\n'+
            'vClipCoord.xy = aTexCoord2.xy;\n'+
        '#endif\n'+

        '#ifdef clip8\n'+
            //'vClipCoord.x = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[1][0],uParamsC8[1][1],uParamsC8[1][2]), camSpacePos.xyz);\n'+
            //'vClipCoord.y = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[2][0],uParamsC8[2][1],uParamsC8[2][2]), camSpacePos.xyz);\n'+
            //'vClipCoord.z = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[3][0],uParamsC8[3][1],uParamsC8[3][2]), camSpacePos.xyz);\n'+

            'vec3 worldPos2 = vec3(aPosition.x * uParams[0][2] + uParamsC8[0][3], aPosition.y * uParams[0][3] + uParamsC8[1][3], aPosition.z * uParams[3][0] + uParamsC8[2][3]);\n'+

            'vClipCoord.x = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[1][0],uParamsC8[1][1],uParamsC8[1][2]), worldPos2.xyz);\n'+
            'vClipCoord.y = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[2][0],uParamsC8[2][1],uParamsC8[2][2]), worldPos2.xyz);\n'+
            'vClipCoord.z = 1.0-getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[3][0],uParamsC8[3][1],uParamsC8[3][2]), worldPos2.xyz);\n'+
            //'vClipCoord.xyz = vec3(0.0, 0.0, 1.0);\n'+
        '#endif\n'+
    '}';

WebGLShaders.tileFragmentShader = 'precision mediump float;\n'+

    '#ifdef clip4\n'+
        'uniform float uClip[4];\n'+
        'varying vec2 vClipCoord;\n'+
    '#endif\n'+

    '#ifdef clip8\n'+
        'uniform float uClip[8];\n'+
        'varying vec3 vClipCoord;\n'+
    '#endif\n'+


    '#ifdef onlyFog\n'+
        'varying float vFogFactor;\n'+
    '#else\n'+

        'varying vec3 vTexCoord;\n'+
        'uniform sampler2D uSampler;\n'+

        '#ifdef mask\n'+
            'uniform sampler2D uSampler2;\n'+
        '#endif\n'+

    '#endif\n'+

    '#ifdef depth\n'+
        'varying float vDepth;\n'+
    '#endif\n'+

    '#ifdef flatShadeVar\n'+
        'varying vec3 vBarycentric;\n'+

        '#ifdef fogAndColor\n'+
            'uniform vec4 uColor;\n'+
        '#endif\n'+

    '#endif\n'+

    'uniform vec4 uParams2;\n'+
    'void main() {\n'+

        '#ifdef clip4_nomargin\n'+
            'if (vClipCoord.y > 0.5){\n'+
                'if (vClipCoord.x > 0.5){\n'+
                    'if (uClip[3] == 0.0) discard;\n'+
                '} else {\n'+
                    'if (uClip[2] == 0.0) discard;\n'+
                '}\n'+
            '} else {\n'+
                'if (vClipCoord.x > 0.5){\n'+
                    'if (uClip[1] == 0.0) discard;\n'+
                '} else {\n'+
                    'if (uClip[0] == 0.0) discard;\n'+
                '}\n'+
            '}\n'+
        '#endif\n'+

        '#ifdef clip4\n'+
            'if (vClipCoord.y > 0.5){\n'+
                'if (vClipCoord.x > 0.5){\n'+
                    'if (uClip[3] == 0.0 && !(vClipCoord.x < TMAX && uClip[2] != 0.0) && !(vClipCoord.y < TMAX && uClip[1] != 0.0)) discard;\n'+
                '} else {\n'+
                    'if (uClip[2] == 0.0 && !(vClipCoord.x > TMIN && uClip[3] != 0.0) && !(vClipCoord.y < TMAX && uClip[0] != 0.0)) discard;\n'+
                '}\n'+
            '} else {\n'+
                'if (vClipCoord.x > 0.5){\n'+
                    'if (uClip[1] == 0.0 && !(vClipCoord.x < TMAX && uClip[0] != 0.0) && !(vClipCoord.y > TMIN && uClip[3] != 0.0)) discard;\n'+
                '} else {\n'+
                    'if (uClip[0] == 0.0 && !(vClipCoord.x > TMIN && uClip[1] != 0.0) && !(vClipCoord.y > TMIN && uClip[2] != 0.0)) discard;\n'+
                '}\n'+
            '}\n'+
        '#endif\n'+

        '#ifdef clip8\n'+
            'if (vClipCoord.z <= 0.5){\n'+
                'if (vClipCoord.y <= 0.5){\n'+
                    'if (vClipCoord.x > 0.5){\n'+
                        'if (uClip[5] == 0.0) discard;\n'+
                    '} else {\n'+
                        'if (uClip[4] == 0.0) discard;\n'+
                    '}\n'+
                '} else {\n'+
                    'if (vClipCoord.x > 0.5){\n'+
                        'if (uClip[7] == 0.0) discard;\n'+
                    '} else {\n'+
                        'if (uClip[6] == 0.0) discard;\n'+
                    '}\n'+
                '}\n'+
            '} else {\n'+
                'if (vClipCoord.y <= 0.5){\n'+
                    'if (vClipCoord.x > 0.5){\n'+
                        'if (uClip[1] == 0.0) discard;\n'+
                    '} else {\n'+
                        'if (uClip[0] == 0.0) discard;\n'+
                    '}\n'+
                '} else {\n'+
                    'if (vClipCoord.x > 0.5){\n'+
                        'if (uClip[3] == 0.0) discard;\n'+
                    '} else {\n'+
                        'if (uClip[2] == 0.0) discard;\n'+
                    '}\n'+
                '}\n'+
            '}\n'+
        '#endif\n'+

        '#ifdef flatShadeVar\n'+

            '#ifdef flatShadeVarFallback\n'+
                'vec4 flatShadeData = vec4(1.0);\n'+
            '#else\n'+
                '#ifdef GL_OES_standard_derivatives\n'+
                    'vec3 nx = dFdx(vBarycentric);\n'+
                    'vec3 ny = dFdy(vBarycentric);\n'+
                    'vec3 normal=normalize(cross(nx,ny));\n'+
                    'vec4 flatShadeData = vec4(vec3(max(0.0,normal.z*(204.0/255.0))+(32.0/255.0)),1.0);\n'+
                '#else\n'+
                    'vec4 flatShadeData = vec4(1.0);\n'+
                '#endif\n'+
            '#endif\n'+

        '#endif\n'+

        '#ifdef flatShade\n'+

            '#ifdef flatShadeInner\n'+
                'gl_FragColor.xyz = texture2D(uSampler, vTexCoord.xy).xyz * flatShadeData.xyz;\n'+
                'gl_FragColor.w = 1.0;\n'+
            '#else\n'+
                '#ifdef fogAndColor\n'+
                   // 'gl_FragColor = vec4(mix(uColor.xyz * flatShadeData.xyz, uParams2.xyz, vTexCoord.z), uColor.w);\n'+
                    'gl_FragColor = vec4(uColor.xyz * flatShadeData.xyz, uColor.w);\n'+
                '#else\n'+
                    'gl_FragColor = vec4(flatShadeData.xyz, 1.0);\n'+
                '#endif\n'+
            '#endif\n'+

        '#else\n'+

            'vec4 fogColor = vec4(uParams2.xyz, 1.0);\n'+

            '#ifdef onlyFog\n'+
                'gl_FragColor = vec4(fogColor.xyz, vFogFactor);\n'+
            '#else\n'+

                '#ifdef depth\n'+
                    'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\n'+
                '#else\n'+

                    '#ifdef externalTex\n'+
                        'vec4 c = texture2D(uSampler, vTexCoord.xy);\n'+'__FILTER__' +
                        'vec4 cc = mix(c, fogColor, vTexCoord.z);\n'+
                        '#ifdef mask\n'+
                            'vec4 c2 = texture2D(uSampler2, vTexCoord.xy);\n'+
                            'cc.w = c.w * uParams2.w * c2.x;\n'+
                        '#else\n'+
                            'cc.w = c.w * uParams2.w;\n'+
                        '#endif\n'+

                        'gl_FragColor = cc;\n'+
                    '#else\n'+
                        'gl_FragColor = mix(texture2D(uSampler, vTexCoord.xy), fogColor, vTexCoord.z);\n'+
                    '#endif\n'+

                '#endif\n'+

            '#endif\n'+

        '#endif\n'+

        // '#ifdef clip8\n'+
          //  'gl_FragColor = vec4(vClipCoord.x, vClipCoord.y, vClipCoord.z, 1.0);\n'+
        // '#endif\n'+
    '}';


WebGLShaders.shadedMeshVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'attribute vec3 aNormal;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform mat3 uNorm;\n'+
    'uniform float uFogDensity;\n'+
    'varying vec2 vTexCoord;\n'+
    'varying vec4 vPosition;\n'+
    'varying vec3 vNormal;\n'+
    'varying float vFogFactor;\n'+
    'void main() {\n'+
        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+
        'vFogFactor = exp(uFogDensity * camDist);\n'+
        'vTexCoord = aTexCoord;\n'+
        'vPosition = camSpacePos;\n'+
        'vNormal = aNormal * uNorm;\n'+
    '}';


WebGLShaders.shadedMeshFragmentShader = 'precision mediump float;\n'+
    '#ifdef textured\n'+
        'uniform sampler2D uSampler;\n'+
        'varying vec2 vTexCoord;\n'+
    '#endif\n'+
    'varying vec4 vPosition;\n'+
    'varying vec3 vNormal;\n'+
    'uniform mat4 uMaterial;\n'+
    'varying float vFogFactor;\n'+
    'uniform vec4 uFogColor;\n'+
    'void main() {\n'+
        'vec3 ldir = normalize(-vPosition.xyz);\n'+
        'vec3 normal = normalize(vNormal);\n'+
        'vec3 eyeDir = ldir;\n'+
        'vec3 refDir = reflect(-ldir, normal);\n'+
        'float specW = min(1.0, pow(max(dot(refDir, eyeDir), 0.0), uMaterial[3][0]));\n'+
        'float diffW = min(1.0, max(dot(normal, ldir), 0.0));\n'+
        'vec4 lcolor = uMaterial[0]+(uMaterial[1]*diffW)+(uMaterial[2]*specW);\n'+
        '#ifdef textured\n'+
            'vec4 tcolor = texture2D(uSampler, vTexCoord);\n'+
            'gl_FragColor = mix(uFogColor, vec4(lcolor.xyz*(1.0/255.0), 1.0) * tcolor, vFogFactor); gl_FragColor.w *= uMaterial[3][1];\n'+
        '#else\n'+
            'gl_FragColor = mix(uFogColor, vec4(lcolor.xyz*(1.0/255.0), 1.0), vFogFactor);  gl_FragColor.w = uMaterial[3][1];\n'+
        '#endif\n'+

    '}';

WebGLShaders.tileWireFrameBasicShader = 'precision mediump float;\n'+
    'uniform vec4 uColor;\n'+
    'void main() {\n'+
        'gl_FragColor = uColor;\n'+
    '}';


//used for 2d images
WebGLShaders.imageVertexShader = '\n'+
    'attribute vec4 aPosition;\n'+
    'uniform mat4 uProjectionMatrix;\n'+
    'uniform mat4 uData;\n'+
    'uniform vec4 uColor;\n'+
    'uniform float uDepth;\n'+
    'varying vec4 vColor;\n'+
    'varying vec2 vTexcoords;\n'+
    'void main(void){\n'+
        'int i=int(aPosition.x);\n'+
        //"gl_Position=uProjectionMatrix*vec4(floor(uData[i][0]+0.1),floor(uData[i][1]+0.1),0.0,1.0);\n"+
        //IE11 :(

        'vec4 p;\n'+

        'if(i==0) p = vec4(floor(uData[0][0]+0.1),floor(uData[0][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[0][2], uData[0][3]);\n'+
        'if(i==1) p = vec4(floor(uData[1][0]+0.1),floor(uData[1][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[1][2], uData[1][3]);\n'+
        'if(i==2) p = vec4(floor(uData[2][0]+0.1),floor(uData[2][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[2][2], uData[2][3]);\n'+
        'if(i==3) p = vec4(floor(uData[3][0]+0.1),floor(uData[3][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[3][2], uData[3][3]);\n'+

        'gl_Position=uProjectionMatrix*p;\n'+
        'vec4 c=uColor;\n'+
        'c.w*=1.0;\n'+
        'vColor=c;\n'+
    '}';


WebGLShaders.imageFragmentShader = 'precision mediump float;\n'+
    'varying vec4 vColor;\n'+
    'varying vec2 vTexcoords;\n'+
    'uniform sampler2D uSampler;\n'+
    'void main(void){\n'+
        'vec4 c=texture2D(uSampler, vec2(vTexcoords.x, vTexcoords.y) );\n'+
        'c*=vColor;\n'+
        'if(c.w < 0.01){ discard; }\n'+
        'gl_FragColor = c;\n'+
    '}';


/* harmony default export */ __webpack_exports__["default"] = (WebGLShaders);


/***/ }),

/***/ "./src/core/renderer/devices/webgl/texture.js":
/*!****************************************************!*\
  !*** ./src/core/renderer/devices/webgl/texture.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ "./src/core/utils/utils.js");



//get rid of compiler mess
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["utils"];

const WebGLTexture = function(gpu, path, core, fileSize, direct, repeat, filter, keepImage, onLoaded, onError) {
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.texture = null;
    this.framebuffer = null;
    this.size = 0;
    this.gpuSize = 0;
    this.fileSize = fileSize; //used for stats
    this.width = 0;
    this.height = 0;
    this.repeat = repeat || false;
    this.filter = filter || 'linear';

    this.image = null;
    this.loaded = false;
    this.trilinear = false;//true;
    this.core = core;

    if (path != null) {
        this.load(path, onLoaded, onError, direct, keepImage);
    }
};

//destructor
WebGLTexture.prototype.kill = function() {
    this.gl.deleteTexture(this.texture);

    this.texture = null;
};

// Returns GPU RAM used, in bytes.
WebGLTexture.prototype.getSize = function() {
    return this.size;
};


WebGLTexture.prototype.createFromData = function(lx, ly, data, filter, repeat) {
    const gl = this.gl;

    this.texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.texture);

    if (repeat){
        repeat = gl.REPEAT;
        this.repeat = true;
    } else {
        repeat = gl.CLAMP_TO_EDGE;
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, repeat);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, repeat);
    let mipmaps = false;

    switch (filter) {
    case 'linear':
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        break;
    case 'trilinear':
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        mipmaps = true;
        break;
    default:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        break;
    }

    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, lx, ly, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);

    if (mipmaps) {
        gl.generateMipmap(gl.TEXTURE_2D);
    }

    gl.bindTexture(gl.TEXTURE_2D, null);

    this.width = lx;
    this.height = ly;
    this.size = lx * ly * 4;
    this.gpuSize = this.size;
    this.loaded = true;
};

// eslint-disable-next-line
WebGLTexture.prototype.createFromImage = function(image, filter, repeat, aniso) {
    const gl = this.gl;

    //filter = 'trilinear'; aniso = null; this.gpu.anisoLevel = 0;
    let width = image.naturalWidth;
    let height = image.naturalHeight;
    let data = image;

    this.texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.texture);

    if (repeat) {
        repeat = gl.REPEAT;
        this.repeat = true;
    } else {
        repeat = gl.CLAMP_TO_EDGE;
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, repeat);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, repeat);
    let mipmaps = false;
    this.filter = filter;

    switch (filter) {
    case 'linear':
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        break;
    case 'trilinear':
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        mipmaps = true;
        break;
    default:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        break;
    }

    //resize image to nearest power of two
    if ((this.repeat || mipmaps) && (!utils.isPowerOfTwo(width) || !utils.isPowerOfTwo(height))) {
        width = utils.nearestPowerOfTwo(width);
        height = utils.nearestPowerOfTwo(height);
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height);
        data = canvas;
    }

    const gpu = this.gpu;

    if (gpu.anisoLevel) {
        gl.texParameterf(gl.TEXTURE_2D, gpu.anisoExt.TEXTURE_MAX_ANISOTROPY_EXT, gpu.anisoLevel);
    }

    if (gpu.noTextures !== true) { //why is it here and not at the beginig of the code?
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);

        if (mipmaps) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
    }

    gl.bindTexture(gl.TEXTURE_2D, null);

    this.width = width;
    this.height = height;
    this.size = width * height * 4;
    this.gpuSize = this.size;
    this.loaded = true;
};


WebGLTexture.prototype.load = function(path, onLoaded, onError, direct, keepImage) {
    this.image = utils.loadImage(path, (function () {
        if (this.core != null && this.core.killed) {
            return;
        }

        this.createFromImage(this.image, this.filter, this.repeat);
        if (!keepImage) {
            this.image = null;
        }

        if (onLoaded) {
            onLoaded();
        } else {
            if (this.core.map && this.core.map.markDirty) {
                this.core.map.markDirty();
            }
        }

    }).bind(this), (function () {

        if (this.core != null && this.core.killed) {
            return;
        }

        if (onError) {
            onError();
        }
    }).bind(this),

     null, direct

     );

};


WebGLTexture.prototype.createFramebufferFromData = function(lx, ly, data) {
    const gl = this.gl;

    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    framebuffer.width = lx;
    framebuffer.height = ly;

    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, lx, ly, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);


    const renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, lx, ly);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    this.width = lx;
    this.height = ly;
    this.size = lx * ly * 4;
    this.gpuSize = this.size;

    this.texture = texture;
    this.renderbuffer = renderbuffer;
    this.framebuffer = framebuffer;

    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};


WebGLTexture.prototype.createFramebuffer = function(lx, ly) {
    if (this.texture == null){
        return;
    }

    const gl = this.gl;

    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    framebuffer.width = lx;
    framebuffer.height = ly;

    gl.bindTexture(gl.TEXTURE_2D, this.texture);

    const renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, lx, ly);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    this.framebuffer = framebuffer;
    this.renderbuffer = renderbuffer;
};


WebGLTexture.prototype.readFramebufferPixels = function(x, y, lx, ly, fastMode, data) {
    if (this.texture == null) {
        return;
    }

    this.gpu.bindTexture(this);

    if (!fastMode) {
        this.gpu.setFramebuffer(this);
    }

    const gl = this.gl;

    // Read the contents of the framebuffer (data stores the pixel data)
    if (!data) {
        data = new Uint8Array(lx * ly * 4);
    }
    gl.readPixels(x, y, lx, ly, gl.RGBA, gl.UNSIGNED_BYTE, data);

    if (!fastMode) {
        this.gpu.setFramebuffer(null);
    }

    return data;
};

/* harmony default export */ __webpack_exports__["default"] = (WebGLTexture);


/***/ }),

/***/ "./src/core/renderer/font.js":
/*!***********************************!*\
  !*** ./src/core/renderer/font.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./src/core/utils/utils.js");

//import GpuTexture_ from './texture';


//get rid of compiler mess
//const GpuTexture = GpuTexture_;
const utils = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["utils"];


const RendererFont = function(renderer, core, font, size, path) {
    this.bbox = null;
    this.renderer = renderer;
    this.gpu = renderer.gpu;
    this.core = core;

    this.data = null;
    this.path = path;

    this.texture = {width:256, height:256}; //hack

    this.textures = [];
    this.images = [];
    this.ready = false;
    this.version = 1;

    this.load(path);
};


//destructor
RendererFont.prototype.kill = function() {
};

// Returns GPU RAM used, in bytes.
RendererFont.prototype.getSize = function(){ return this.size; };


RendererFont.prototype.load = function(path) {
    utils.loadBinary(path, this.onLoaded.bind(this), this.onError.bind(this));
};

RendererFont.prototype.onLoaded = function(data) {
    this.data = data;
    this.ready = true;
    this.core.markDirty();
};

RendererFont.prototype.isReady = function() {
    return this.ready;
};

RendererFont.prototype.onError = function() {

};

RendererFont.prototype.onFileLoaded = function(index, data) {
    this.core.markDirty();
    //this.textures[index].createFromData(256, 256, new Uint8Array(data), 'linear');
    //this.textures[index] =  this.renderer.createDataTexture({ data: new Uint8Array(data), width: 256, height: 256 });
    this.textures[index] =  this.renderer.gpu.createTexture({ data: new Uint8Array(data), width: 256, height: 256, filter: 'linear' });
};

RendererFont.prototype.onFileLoadError = function() {
};

RendererFont.prototype.areTexturesReady = function(files) {
    let ready = true;
    for (let i = 0, li = files.length; i < li; i++) {
        const index = files[i];//Math.round( (planes[i] - (planes[i] % 3)) );

        if (!this.textures[index]) {
            utils.loadBinary(this.path + (index+2), this.onFileLoaded.bind(this, index), this.onFileLoadError.bind(this));
            this.textures[index] = true;
            ready = false;
        } else {

            if (this.textures[index] === true) {  //loading but not yet loaded
                ready = false;
            }

            //ready = (ready && this.textures[index].loaded);
        }
    }

    return ready;
};

RendererFont.prototype.getTexture = function(file) {
    //if (!this.textures[file]) {
        //debugger;
    //}

    return this.textures[file];
};

/* harmony default export */ __webpack_exports__["default"] = (RendererFont);


/***/ }),

/***/ "./src/core/renderer/geometry.js":
/*!***************************************!*\
  !*** ./src/core/renderer/geometry.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox */ "./src/core/renderer/bbox.js");



//get rid of compiler mess
const BBox = _bbox__WEBPACK_IMPORTED_MODULE_0__["default"];


const RendererGeometry = {};


RendererGeometry.setFaceVertices = function(vertices, a, b, c, index) {
    vertices[index] = a[0];
    vertices[index+1] = a[1];
    vertices[index+2] = a[2];

    vertices[index+3] = b[0];
    vertices[index+4] = b[1];
    vertices[index+5] = b[2];

    vertices[index+6] = c[0];
    vertices[index+7] = c[1];
    vertices[index+8] = c[2];
};


RendererGeometry.setFaceUVs = function(uvs, a, b, c, index) {
    uvs[index] = a[0];
    uvs[index+1] = a[1];

    uvs[index+2] = b[0];
    uvs[index+3] = b[1];

    uvs[index+4] = c[0];
    uvs[index+5] = c[1];
};


// Procedural mesh representing a heightmap block
// Creates a grid of size x size vertices, all coords are [0..1].
RendererGeometry.buildHeightmap = function(size, use16bit) {
    size--;

    const g = RendererGeometry;
    const numFaces = (size* size) * 2;
    const vertices = new Float32Array(numFaces * 3 * 3);//[];
    const uvs = new Float32Array(numFaces * 3 * 2);//[];

    const factor = 1.0 * size;
    let index = 0;
    let index2 = 0;

    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            const x1 = (j) * factor;
            const x2 = (j+1) * factor;

            const y1 = (i) * factor;
            const y2 = (i+1) * factor;

            g.setFaceVertices(vertices, [x1, y1, 0], [x2, y1, 0], [x2, y2, 0], index);
            g.setFaceUVs(uvs, [x1, y1], [x2, y1], [x2, y2], index2);
            index += 9;
            index2 += 6;

            g.setFaceVertices(vertices, [x2, y2, 0], [x1, y2, 0], [x1, y1, 0], index);
            g.setFaceUVs(uvs, [x2, y2], [x1, y2], [x1, y1], index2);
            index += 9;
            index2 += 6;
        }
    }

    const bbox = new BBox(0,0,0,1,1,1);

    if (use16bit) {
        return { bbox:bbox, vertices:this.covnetTo16Bit(vertices), uvs: this.covnetTo16Bit(uvs)};
    } else {
        return { bbox:bbox, vertices:vertices, uvs: uvs};
    }
};


RendererGeometry.buildPlane = function(size, use16bit) {
    size--;

    const g = RendererGeometry;
    const numFaces = (size* size) * 2;
    const vertices = (use16bit) ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));
    const uvs = new Float32Array(numFaces * 3 * 2);//[];

    const factor = 1.0 / (size);
    let index = 0, index2 = 0;
    let x1, y1, x2, y2, xx1, xx2, yy1, yy2;

    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            x1 = j;
            x2 = j+1;
            y1 = i;
            y2 = i+1;

            xx1 = j * factor;
            xx2 = (j+1) * factor;
            yy1 = (i) * factor;
            yy2 = (i+1) * factor;

            g.setFaceVertices(vertices, [x1, y1, 0], [x1, y2, 0], [x2, y2, 0], index);
            g.setFaceUVs(uvs, [xx1, yy1], [xx1, yy2], [xx2, yy2], index2);
            index += 9;
            index2 += 6;

            g.setFaceVertices(vertices, [x2, y2, 0], [x2, y1, 0], [x1, y1, 0], index);
            g.setFaceUVs(uvs, [xx2, yy2], [xx2, yy1], [xx1, yy1], index2);
            index += 9;
            index2 += 6;
        }
    }

    const bbox = new BBox(0,0,0,1,1,1);

    if (use16bit) {
        return { bbox:bbox, vertices:vertices, uvs: this.covnetTo16Bit(uvs)};
    } else {
        return { bbox:bbox, vertices:vertices, uvs: uvs};
    }
};

RendererGeometry.spherePos = function(lon, lat) {
    lat *= Math.PI;
    lon *= 2*Math.PI;

    return [Math.cos(lon)*Math.sin(lat)*0.5 + 0.5,
        Math.sin(lon)*Math.sin(lat)*0.5 + 0.5,
        Math.cos(lat) * 0.5 + 0.5];
};


// Creates an approximation of a unit sphere, note that all coords are
// in the range [0..1] and the center is in (0.5, 0.5). Triangle "normals"
// are oriented inwards.
RendererGeometry.buildSkydome = function(latitudeBands, longitudeBands, use16bit, useIndices) {
    const g = RendererGeometry;
    const numFaces = (latitudeBands * longitudeBands) * 2;
    const numVertices = (latitudeBands * longitudeBands) * (useIndices ? 1 : 3);
    const vertices = new Float32Array(numVertices * 3);
    const uvs = new Float32Array(numVertices * 2);
    const indices = useIndices ? (new Uint16Array(numFaces * 3)) : null;
    let index = 0, index2 = 0;
    let lat, lon, lon2, lat2, v, flon, flat;

    if (useIndices) {

        for (lat = 0; lat < latitudeBands; lat++) {
            for (lon = 0; lon < longitudeBands; lon++) {

                flon = lon / longitudeBands;
                flat = lat / latitudeBands;
                v = g.spherePos(flon, flat);

                vertices[index] = v[0];
                vertices[index+1] = v[1];
                vertices[index+2] = v[2];

                uvs[index2] = flon;
                uvs[index2+1] = flat;

                index += 3;
                index2 += 2;
            }
        }

        index = 0;

        for (lat = 0; lat < (latitudeBands - 1); lat++) {
            for (lon = 0; lon < longitudeBands; lon++) {

                lat2 = lat + 1;
                lon2 = lon + 1;

                if (lon2 >= longitudeBands) {
                    lon2 = 0;
                }

                indices[index] = (lat2 * longitudeBands) + lon;
                indices[index+1] = (lat * longitudeBands) + lon;
                indices[index+2] = (lat * longitudeBands) + lon2;

                indices[index+3] = (lat * longitudeBands) + lon2;
                indices[index+4] = (lat2 * longitudeBands) + lon2;
                indices[index+5] = (lat2 * longitudeBands) + lon;

                index += 6;
            }
        }

    } else {

        for (let lat = 0; lat < latitudeBands; lat++) {
            for (let lon = 0; lon < longitudeBands; lon++) {

                const lon1 = ((lon) / longitudeBands);
                const lon2 = ((lon+1) / longitudeBands);

                const lat1 = ((lat) / latitudeBands);
                const lat2 = ((lat+1) / latitudeBands);

                g.makeQuad(lon1, lat1, lon2, lat2, vertices, index, uvs, index2);
                index += 9*2;
                index2 += 6*2;
            }
        }

    }

    const bbox = new BBox(0,0,0,1,1,1);

    if (use16bit) {
        return { bbox:bbox, vertices:this.covnetTo16Bit(vertices), uvs: this.covnetTo16Bit(uvs), indices:indices};
    } else {
        return { bbox:bbox, vertices:vertices, uvs: uvs, indices:indices};
    }
};

RendererGeometry.covnetTo16Bit = function(array) {
    const array2 = new Uint16Array(array.length);

    for (let i = 0, li = array.length; i < li; i++) {
        let t = array[i] * 65535;
        if (t < 0) t = 0; if (t > 65535) t = 65535;
        array2[i] = t;
    }

    return array2;
}


RendererGeometry.makeQuad = function(lon1, lat1, lon2, lat2, vertices, index, uvs, index2) {
    const g = RendererGeometry;
    const a = g.spherePos(lon1, lat1), ta = [lon1, lat1];
    const b = g.spherePos(lon1, lat2), tb = [lon1, lat2];
    const c = g.spherePos(lon2, lat1), tc = [lon2, lat1];
    const d = g.spherePos(lon2, lat2), td = [lon2, lat2];
    g.setFaceVertices(vertices, b, a, c, index);
    g.setFaceUVs(uvs, tb, ta, tc, index2);
    g.setFaceVertices(vertices, c, d, b, index+9);
    g.setFaceUVs(uvs, tc, td, tb, index2+6);
};


/* harmony default export */ __webpack_exports__["default"] = (RendererGeometry);


/***/ }),

/***/ "./src/core/renderer/gmap.js":
/*!***********************************!*\
  !*** ./src/core/renderer/gmap.js ***!
  \***********************************/
/*! exports provided: processGMap, processGMap4, processGMap5, processGMap6, processGMap7, radixDepthSortFeatures */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processGMap", function() { return processGMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processGMap4", function() { return processGMap4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processGMap5", function() { return processGMap5; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processGMap6", function() { return processGMap6; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processGMap7", function() { return processGMap7; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radixDepthSortFeatures", function() { return radixDepthSortFeatures; });


function processGMap(gpu, gl, renderer, screenPixelSize, draw) {
    if (!renderer.config.mapFeaturesReduceParams) {
        return;
    }

    const featuresPerSquareInch = renderer.config.mapFeaturesReduceParams[0]; //0.6614; //labelsPerSquareInch
    const ppi = 96 * (window.devicePixelRatio || 1);
    const screenLX = renderer.curSize[0];
    const screenLY = renderer.curSize[1];
    let tileCount = renderer.config.mapFeaturesReduceParams[1]; //31; //labelGridCells
    let featureCount = Math.ceil((screenLX/ppi)*(screenLY/ppi)*featuresPerSquareInch);
    let i, li, top = renderer.config.mapFeaturesSortByTop;

    if (tileCount <= 0) {
        tileCount = featureCount * 2; //31; //labelGridCells
    }

    //renderer.debugStr = '<br>featuresPerScr: ' + featureCount + '<br>gridCells: ' + tileCount + '';

    //get top features
    const featureCache = renderer.gmap;
    const featureCacheSize = renderer.gmapIndex;
    const topFeatures = renderer.gmapTop;
    let featureCount2 = featureCount;

    if (featureCount > featureCacheSize) {
        featureCount2 = featureCacheSize;
    }

    //distribute top features
    const drawAllLabels = renderer.drawAllLabels;
    let tileSize = Math.floor(Math.sqrt((screenLX*screenLY) / tileCount));
    let tileFeatures, count, feature, job, usedFeatures = 0;

    const colors = [
        [0, 0, 255, 255],
        [128, 0, 255, 255],
        [255, 0, 0, 255],
        [255, 128, 0, 255],
        [0, 255, 0, 255],
        [0, 255, 128, 255],
        [128, 255, 128, 255]
    ];

    let colorIndex = 0;

    do {
        let a,b,c,d,ix,iy,is,pp,tx,ty,mx,my,v,index,o,j;

        ix = screenLX / tileSize;
        iy = screenLY / tileSize;
        is = ix * iy;
        mx = Math.floor(ix);
        my = Math.floor(iy);
        ix = ix - mx;
        iy = iy - my;

        a = 1 / is;
        b = ix / is;
        c = iy / is;
        d = (ix*iy) / is;

        a = Math.floor(a * featureCount);
        b = Math.floor(b * featureCount);
        c = Math.floor(c * featureCount);
        d = Math.floor(d * featureCount);

        const hitMap = renderer.gmapStore;
        const hitMapCount = renderer.gmapHit;

        if (renderer.drawGridCells) {
            gpu.setState(renderer.lineLabelState);

            let x = 0, y = 0, j, lj;

            for (j = 0, lj = (my + 1); j < lj; j++) {
                for (i = 0, li = (mx + 1); i < li; i++) {
                    x = tileSize * i;
                    y = tileSize * j;

                    v = a;

                    if (i >= mx) {
                        if (j >= my) {
                            v =d;
                        } else {
                            v = b;
                        }

                    } else {
                        if (j >= my) {
                            v = b;
                        }
                    }

                    draw.drawLineString([[x, y, 0.5], [x+tileSize, y, 0.5],
                                         [x+tileSize, y+tileSize, 0.5], [x, y+tileSize, 0.5]], true, 1, colors[colorIndex], null, true, null, null, null);

                    draw.drawText(Math.round(x+5), Math.round(y + 5 + colorIndex * 15), 10, '' + v, colors[colorIndex], 0.5);
                }
            }

        }


        //clear hit-map
        for (i = 0, li = (mx+1) * (my+1); i < li; i++) {
            hitMap[i] = null;
        }

        for (i = 0, li = featureCacheSize; i < li; i++) {
            feature = featureCache[i];
            if (!feature) {
                continue;
            }

            pp = feature[5];

            if (pp[0] < 30 || pp[0] >= (screenLX-30) || pp[1] < 30 || pp[1] >= (screenLY-30)) {
                featureCache[i] = null;
                continue;
            }

            tx = pp[0] / tileSize;
            ty = pp[1] / tileSize;

            if (tx > mx) {
                if (ty > my) {
                    v = d;
                } else {
                    v = b;
                }
            } else if (ty > my) {
                v = c;
            } else {
                v = a;
            }

            if (v > 0) {
                index = Math.floor(tx) + Math.floor(ty) * (mx + 1);

                tileFeatures = hitMap[index];

                if (tileFeatures) {
                    hitMap[index].push(i);
                } else {
                    hitMap[index] = [i];
                    hitMapCount[index] = v;
                }
            }
        }

        for (i = 0, li = (mx+1) * (my+1); i < li; i++) {
            tileFeatures = hitMap[i];

            if (tileFeatures && tileFeatures.length) {
                count = hitMapCount[i];

                if (count > tileFeatures.length) {
                    count = tileFeatures.length;
                }

                sortFeatures(tileFeatures, top, count, renderer);

                for (j = 0; j < count; j++){
                    index = topFeatures[j]
                    feature = featureCache[index];
                    topFeatures[j] = null;
                    featureCache[index] = null;
                    job = feature[0];

                    //render job
                    if (!drawAllLabels && feature[6]) { //no-overlap
                        pp = feature[5];
                        o = feature[8];

                        //if (!
                            renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob)
                        //) {}

                        if (job.type == 6) {
                            if (renderer.rmap.addLineLabel(job.lastSubJob, null /*depthParams*/)) {
                                //renderer.rmap.storeRemovedLineLabel(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob);
                            }
                        } else {
                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, null /*depthParams*/)) {
                                renderer.rmap.storeRemovedRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob);
                            }
                        }

                    } else {
                        if (job.hysteresis) {
                            renderer.jobHBuffer[job.id] = job;
                        } else {
                            renderer.drawnJobs++;

                            if (job.type == 6) {
                                draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                            } else {
                                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                            }
                        }
                    }
                }

            }
        }

        a *= mx * my;
        b *= mx;
        c *= my;

        usedFeatures += a + b + c + d;
        featureCount -= a + b + c + d;
        tileSize *= 2;

        colorIndex++;

    } while(usedFeatures < featureCount2);

}


function sortFeatures(features, top, count, renderer) {
    let value, feature, index;
    let currentIndex = 0;
    let currentValue2 = top ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    let topFeaturesIndex = 0;
    let topFeaturesIndex2 = 0;

    //remove feature from cache
    const featureCache = renderer.gmap;
    const topFeatures = renderer.gmapTop;

    do {
        let currentValue = top ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
        topFeaturesIndex2 = topFeaturesIndex;

        for (let i = 0, li = features.length; i < li; i++) {
            index = features[i];
            feature = featureCache[index];
            value = feature[0].reduce[1];

            if (((top && value >= currentValue && value < currentValue2) || (value <= currentValue && value > currentValue2)) ) {
                if (currentValue != value) {
                    topFeaturesIndex = topFeaturesIndex2;
                }

                topFeatures[topFeaturesIndex] = index;
                topFeaturesIndex++;
                currentValue = value;
            }
        }

        currentValue2 = currentValue;
        currentIndex++;

    } while(currentIndex < count);

}

function storeFeatureToHitmap(id, feature, ix, iy, mx, my, hitMap, hcache, hcacheSize) {
    let x1 = ix - 1, y1 = iy - 1, x,
        x2 = ix + 1, y2 = iy + 1, index;//, blockFeatures;

    if (x1 < 0) x1 = 0;
    if (y1 < 0) y1 = 0;
    if (x2 > mx) x2 = mx;
    if (y2 > my) y2 = my;

    for (; y1 <= y2; y1++) {
        for (x = x1; x <= x2; x++) {
            index = (y1 * mx + x) * 2;
            //blockFeatures = hitMap[index];

            if (!hitMap[index]) {
                hitMap[index] = hcacheSize;
                hitMap[index+1] = hcacheSize+1;
                hcache[hcacheSize] = feature;
                hcache[hcacheSize+1] = 0;
                hcacheSize +=2;
            } else {
                hcache[hitMap[index+1]] = hcacheSize;
                hitMap[index+1] = hcacheSize+1;
                hcache[hcacheSize] = feature;
                hcache[hcacheSize+1] = 0;
                hcacheSize +=2;
            }
        }
    }

    return hcacheSize;
}


function processGMap4(gpu, gl, renderer, screenPixelSize, draw) {
    if (!renderer.config.mapFeaturesReduceParams) {
        return;
    }

    const ppi = 96 * (window.devicePixelRatio || 1);

    let maxRadius = renderer.config.mapFeaturesReduceParams[0] * ppi; //mapFeatureRadius
    const maxHitcount = renderer.config.mapFeaturesReduceParams[1]; //0.6614; //mapFeatureMaxOverlays

    const screenLX = renderer.curSize[0];
    const screenLY = renderer.curSize[1];
    //const top = renderer.config.mapFeaturesSortByTop;
    const drawAllLabels = renderer.drawAllLabels;

    let i, li;
    let feature, feature2, pp, pp2, o, job;

    //get top features
    const featureCache = renderer.gmap;
    const featureCacheSize = renderer.gmapIndex;

    const hcache = renderer.gmap2;
    const hmap = renderer.gmap3;
    let hcacheSize = 1;
    let hmapSize = renderer.gmap3Size;


    let hmin = 10000;
    let hmax = 0, h, r, ub, lb;

    const divByDist = (renderer.config.mapFeaturesReduceFactor >= 1);

    if (divByDist) { // imp / dists
        if (renderer.fmaxDist == Number.NEGATIVE_INFINITY || renderer.fminDist == Number.POSITIVE_INFINITY) {
            return;
        }

        ub = 1 - Math.log(renderer.fminDist) / Math.log(101);
        lb = -Math.log(renderer.fmaxDist) / Math.log(101);
    }

    //filter features and sort them by importance
    for (i = 0, li = featureCacheSize; i < li; i++) {
        feature = featureCache[i];
        if (!feature) {
            continue;
        }

        pp = feature[5];

        if (divByDist) {
            r = feature[0].reduce;
            h = Math.round(-5000 + ( ( Math.log(r[1]+1) - Math.log(r[4]) ) / Math.log(101) - lb ) / ( ub-lb ) * 10000) + 5000;
            r[5] = h; //for debug
        } else {
            h = Math.round(feature[0].reduce[1]);
        }

        if (h < 0) h = 0;
        if (h >= 10000) h = 9999;
        if (h < hmin) hmin = h;
        if (h > hmax) hmax = h;

        hmap[h][hmapSize[h]++] = feature;
    }

    const invMaxRadius = 1 / maxRadius;
    const mx = Math.floor(screenLX * invMaxRadius);
    const my = Math.floor(screenLY * invMaxRadius);
    const hitMap = renderer.gmapStore;
    //const hitMapCount = renderer.gmapHit;
    let index, ix, iy;

    //clear hit-map
    for (i = 0, li = (mx+1) * (my+1) * 2; i < li; i+=2) {
        hitMap[i] = 0;
    }

    let hitCacheSize = 0, j, lj, hitCount, dx, dy;

    maxRadius *= maxRadius;

    for (i = hmax, li = hmin; i >= 0; i--) {

        if (hmapSize[i] > 0) {
            const features = hmap[i];

            for (j = 0, lj = hmapSize[i]; j < lj; j++) {
                feature = features[j];
                job = feature[0];

                hitCount = 0;
                pp = feature[5];

                //check area
                ix = Math.floor(pp[0] * invMaxRadius);
                iy = Math.floor(pp[1] * invMaxRadius);
                index = ((iy * mx) + ix) * 2;
                //blockFeatures = hitMap[index];

                //check
                if (hitMap[index]) {
                    index = hitMap[index];
                    do {
                        feature2 = hcache[index];
                        pp2 = feature2[5];

                        dx = pp[0] - pp2[0];
                        dy = pp[1] - pp2[1];

                        if ((dx*dx+dy*dy) < maxRadius) {
                            hitCount++;
                            if (hitCount > maxHitcount) {
                                break;
                            }
                        }

                        index = hcache[index+1];
                    } while (index);
                }

                // check
                if (hitCount <= maxHitcount) {
                    index = hitCacheSize;

                    //render job
                    if (!drawAllLabels && feature[6]) { //no-overlap
                        pp = feature[5];
                        o = feature[8];

                        if (job.type == 6) {
                            if (renderer.rmap.addLineLabel(job.lastSubJob, null)) {
                                hitCacheSize++;
                            }
                        } else {
                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, null)) {
                                hitCacheSize++;
                            }
                        }

                    } else {
                        if (job.hysteresis) {
                            renderer.jobHBuffer[job.id] = job;
                        } else {
                            renderer.drawnJobs++;

                            if (job.type == 6) {
                                draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                            } else {
                                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                            }
                        }

                        //hitCache[hitCacheSize] = feature;
                        hitCacheSize++;
                    }

                    //store to hitmap
                    if (index != hitCacheSize) {
                        hcacheSize = storeFeatureToHitmap(index, feature, ix, iy, mx, my, hitMap, hcache, hcacheSize);
                    }
                }

            }

            hmapSize[i] = 0;  //zero size
        }
    }
}

function processGMap5(gpu, gl, renderer, screenPixelSize, draw) {
    if (!renderer.config.mapFeaturesReduceParams) {
        return;
    }

    //const ppi = 96 * (window.devicePixelRatio || 1);
    //const screenLX = renderer.curSize[0];
    //const screenLY = renderer.curSize[1];
    //const top = renderer.config.mapFeaturesSortByTop;
    const drawAllLabels = renderer.drawAllLabels;
    let i, li;
    let feature, pp, o, job;

    //get top features
    const featureCache = renderer.gmap;
    const featureCacheSize = renderer.gmapIndex;

    //const hcache = renderer.gmap2;
    const hmap = renderer.gmap3;
    //let hcacheSize = 1;
    let hmapSize = renderer.gmap3Size;

    let hmin = 10000;
    let hmax = 0, h, r, ub, lb;

    const divByDist = (renderer.config.mapFeaturesReduceFactor >= 1);

    if (divByDist) { // imp / dists
        if (renderer.fmaxDist == Number.NEGATIVE_INFINITY || renderer.fminDist == Number.POSITIVE_INFINITY) {
            return;
        }

        ub = 1 - Math.log(renderer.fminDist) / Math.log(101);
        lb = -Math.log(renderer.fmaxDist) / Math.log(101);
    }

    //filter features and sort them by importance
    for (i = 0, li = featureCacheSize; i < li; i++) {
        feature = featureCache[i];
        if (!feature) {
            continue;
        }

        pp = feature[5];

        if (divByDist) {
            r = feature[0].reduce;
            h = Math.round(-5000 + ( ( Math.log(r[1]+1) - Math.log(r[4]) ) / Math.log(101) - lb ) / ( ub-lb ) * 10000) + 5000;
            r[5] = h; //for debug
        } else {
            h = Math.round(feature[0].reduce[1]);
        }

        if (h < 0) h = 0;
        if (h >= 10000) h = 9999;
        if (h < hmin) hmin = h;
        if (h > hmax) hmax = h;

        hmap[h][hmapSize[h]++] = feature;
    }

    let j, lj;

    for (i = hmax, li = hmin; i >= 0; i--) {

        if (hmapSize[i] > 0) {
            const features = hmap[i];

            for (j = 0, lj = hmapSize[i]; j < lj; j++) {
                feature = features[j];
                job = feature[0];
                pp = feature[5];

                // check

                //render job
                if (!drawAllLabels && feature[6]) { //no-overlap is always enabled
                    pp = feature[5];
                    o = feature[8];

                    if (job.type == 6) {
                        if (renderer.rmap.addLineLabel(job.lastSubJob, null)) {
                            //hitCache[hitCacheSize] = feature;
                        }
                    } else {
                        if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, null)) {
                            //hitCache[hitCacheSize] = feature;
                        }
                    }

                } else {
                    if (job.hysteresis) {
                        renderer.jobHBuffer[job.id] = job;
                    } else {
                        renderer.drawnJobs++;

                        if (job.type == 6) {
                            draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                        } else {
                            draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                        }
                    }
                }
            }

            hmapSize[i] = 0;  //zero size
        }
    }
}


// eslint-disable-next-line
function radixSortFeatures(renderer, input, inputSize, tmp, depthOnly) {
    const count = inputSize < (1 << 16) ? renderer.radixCountBuffer16 : renderer.radixCountBuffer32;
    const distanceFactor = renderer.config.mapFeaturesReduceFactor;
    const bunit32 = renderer.buffUint32, bfloat32 = renderer.buffFloat32;
    let item, val, i, r;

    //const sx = renderer.curSize[0], sy = renderer.curSize[1];
    //const cx = sx * 0.5, cy = sy * 0.5;
    //const invcx = 1.0 / (cx+0.0001), invcy = 1.0 / (cy+0.0001);
    //const invsy = 1.0 / (sy+0.0001);

    if (count.fill) {
        count.fill(0);
    } else { //IE fallback
        for (i = 0; i < (256*4); i++) {
            count[i] = 0;
        }
    }

    // count all bytes in one pass
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        r = item[0].reduce;

        // optical center
        //pp = item[5];
        //yy = Math.pow(pp[1] * invsy, centerOffset) * sy;
        //dx = (cx - pp[0]) * invcx;
        //dy = (cy - yy) * invcx;

        val = r[3] - distanceFactor * Math.log(r[4]); // - screenDistanceFactor * Math.log(dx*dx + dy*dy + e100);
        r[6] = val;
        val += 10000;
        if (val < 0) val = 0;
        bfloat32[0] = val;
        val = bunit32[0];
        r[5] = val;
        count[val & 0xFF]++;
        count[((val >> 8) & 0xFF) + 256]++;
        count[((val >> 16) & 0xFF) + 512]++;
        count[((val >> 24) & 0xFF) + 768]++;
    }

    // create summed array
    for (let j = 0; j < 4; j++) {
        let t = 0, sum = 0, offset = j * 256;

        for (i = 0; i < 256; i++) {
            t = count[i + offset];
            count[i + offset] = sum;
            sum += t;
        }
    }

    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item[0].reduce[5];
        tmp[count[val & 0xFF]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item[0].reduce[5];
        input[count[((val >> 8) & 0xFF) + 256]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item[0].reduce[5];
        tmp[count[((val >> 16) & 0xFF) + 512]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item[0].reduce[5];
        input[count[((val >> 24) & 0xFF) + 768]++] = item;
    }

    if (i == -123) { //debug
        for (i = 0; i < inputSize; i++) {
            val = input[i][0].reduce[5];
            console.log('' + val +  ' ' + input[i][0].id);
        }
    }

    return input;
}

//used for scr-count7
function processGMap6(gpu, gl, renderer, screenPixelSize, draw) {
    if (!renderer.config.mapFeaturesReduceParams) {
        return;
    }

    const featuresPerSquareInch = renderer.config.mapFeaturesReduceParams[1]; //0.6614; //labelsPerSquareInch
    const ppi = 96 * (window.devicePixelRatio || 1);
    const screenLX = renderer.curSize[0];
    const screenLY = renderer.curSize[1];
    let maxFeatures = Math.ceil((screenLX/ppi)*(screenLY/ppi)*featuresPerSquareInch);
    //const top = renderer.config.mapFeaturesSortByTop;
    const drawAllLabels = renderer.drawAllLabels;
    let i, job;
    let feature, pp, o, featureCount = 0;

    const depthTest = (renderer.config.mapFeaturesReduceFactor2 != 0);
    const depthOffset = -renderer.config.mapFeaturesReduceFactor3;
    let depthParams = null;

    renderer.debugStr = '<br>featuresPerScr: ' + maxFeatures;

    //get top features
    const featureCache = renderer.gmap;
    const featureCacheSize = renderer.gmapIndex;
    const featureCache2 = renderer.gmap2;

    if (drawAllLabels) {
        maxFeatures = featureCacheSize;
    }

    //filter features and sort them by importance
    radixSortFeatures(renderer, featureCache, featureCacheSize, featureCache2);

    for (i = featureCacheSize - 1; i >= 0; i--) {
        feature = featureCache[i];
        job = feature[0];

        // check

        //render job
        if (!drawAllLabels && feature[6]) { //no-overlap is always enabled
            pp = feature[5];
            o = feature[8];

            depthParams = depthTest ? [pp[0],pp[1]+feature[1],job.reduce,depthOffset] : null;

            if (job.type == 6) {
                if (renderer.rmap.addLineLabel(job.lastSubJob, depthParams)) {
                    featureCount++;
                }
            } else {
                if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, depthParams)) {
                    featureCount++;
                }
            }

            if (featureCount >= maxFeatures) {
                return;
            }

        } else {
            if (job.hysteresis) {
                renderer.jobHBuffer[job.id] = job;
            } else {
                renderer.drawnJobs++;

                if (job.type == 6) {
                    draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                } else {
                    draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                }
            }
        }
    }

}


function radixDepthSortFeatures(renderer, input, inputSize, tmp) {
    const count = inputSize < (1 << 16) ? renderer.radixCountBuffer16 : renderer.radixCountBuffer32;
    //const distanceFactor = renderer.config.mapFeaturesReduceFactor;
    const bunit32 = renderer.buffUint32, bfloat32 = renderer.buffFloat32;
    let item, val, i;
    //const screenDistanceFactor = renderer.config.mapFeaturesReduceFactor2 * 0.5, e100 = 1.0/Math.exp(100);
    //const centerOffset = renderer.config.mapFeaturesReduceFactor3;

    //const depthTest = true;

    if (count.fill) {
        count.fill(0);
    } else { //IE fallback
        for (i = 0; i < (256*4); i++) {
            count[i] = 0;
        }
    }

    // count all bytes in one pass
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = 1 - item.lastSubJob[5][2];
        bfloat32[0] = val;
        val = bunit32[0];
        item.depth = val;
        count[val & 0xFF]++;
        count[((val >> 8) & 0xFF) + 256]++;
        count[((val >> 16) & 0xFF) + 512]++;
        count[((val >> 24) & 0xFF) + 768]++;
    }

    // create summed array
    for (let j = 0; j < 4; j++) {
        let t = 0, sum = 0, offset = j * 256;

        for (i = 0; i < 256; i++) {
            t = count[i + offset];
            count[i + offset] = sum;
            sum += t;
        }
    }

    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item.depth;
        tmp[count[val & 0xFF]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item.depth;
        input[count[((val >> 8) & 0xFF) + 256]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item.depth;
        tmp[count[((val >> 16) & 0xFF) + 512]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item.depth;
        input[count[((val >> 24) & 0xFF) + 768]++] = item;
    }

    /*if (i == -123) { //debug
        for (i = 0; i < inputSize; i++) {
            item = input[i];
            val = item.depth;
            console.log('' + val +  ' ' + item.lastSubJob[0].id);
        }
    }*/

    return input;
}


function fillVMapHoles(vmap, mx, my) {
    let holesCount = 0, v;
    let x0, y0, x1, y1, x2, y2;
    let maxX = mx - 1;
    let maxY = my - 1;

    for (let j = 0, lj = my; j < lj; j++) {
        for (let i = 0, li = mx; i < li; i++) {

            v = vmap[j*mx+i];

            if (v === null) {

                //find
                x0 = i - 1;
                y0 = j - 1;

                x1 = i;
                y1 = j;

                x2 = i + 1;
                y2 = j + 1;

                if (x0 < 0) x0 = 0;
                if (y0 < 0) y0 = 0;

                if (x2 > maxX) x2 = maxX;
                if (y2 > maxY) y2 = maxY;

                const vv = [vmap[y0*mx+x0],
                          vmap[y0*mx+x1],
                          vmap[y0*mx+x2],
                          vmap[y1*mx+x0],
                          vmap[y1*mx+x2],
                          vmap[y2*mx+x0],
                          vmap[y2*mx+x1],
                          vmap[y2*mx+x2]];

                let vcount = 0;
                let vsum = 0;

                for (let k= 0; k < 8; k++) {
                    if (vv[k] !== null) {
                        vcount++;
                        vsum += vv[k];
                    }
                }

                if (vcount != 0) {
                    vmap[j*mx+i] = vsum / vcount;
                } else {
                    holesCount++;
                }
            }
        }
    }

    if (holesCount != 0 && holesCount != (mx * my)) {
        fillVMapHoles(vmap, mx, my);
    }
}


function getVMapValue(vmap, x, y, mx, my) {
    x -= 0.5;
    y -= 0.5;

    const maxX = mx - 1;
    const maxY = my - 1;

    if (x < 0) { x = 0; }
    if (y < 0) { y = 0; }
    if (x > maxX) { x = maxX; }
    if (y > maxY) { y = maxY; }

    const ix = Math.floor(x);
    const iy = Math.floor(y);
    const fx = x - ix;
    const fy = y - iy;

    const index = iy * mx;
    const index2 = (iy == maxY) ? index : index + mx;
    const ix2 = (ix == maxX) ? ix : ix + 1;
    const v00 = vmap[index + ix];
    const v01 = vmap[index + ix2];
    const v10 = vmap[index2 + ix];
    const v11 = vmap[index2 + ix2];
    const w0 = (v00 + (v01 - v00)*fx);
    const w1 = (v10 + (v11 - v10)*fx);

    return (w0 + (w1 - w0)*fy);
}


function radixDeltaSortFeatures(renderer, input, inputSize, tmp) {
    const count = inputSize < (1 << 16) ? renderer.radixCountBuffer16 : renderer.radixCountBuffer32;
    const bunit32 = renderer.buffUint32, bfloat32 = renderer.buffFloat32;
    let item, val, i;

    if (count.fill) {
        count.fill(0);
    } else { //IE fallback
        for (i = 0; i < (256*4); i++) {
            count[i] = 0;
        }
    }

    // count all bytes in one pass
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        //val = 1 - item.lastSubJob[5][2];
        bfloat32[0] = item[0].delta;
        val = bunit32[0];
        item[0].delta = val;
        count[val & 0xFF]++;
        count[((val >> 8) & 0xFF) + 256]++;
        count[((val >> 16) & 0xFF) + 512]++;
        count[((val >> 24) & 0xFF) + 768]++;
    }

    // create summed array
    for (let j = 0; j < 4; j++) {
        let t = 0, sum = 0, offset = j * 256;

        for (i = 0; i < 256; i++) {
            t = count[i + offset];
            count[i + offset] = sum;
            sum += t;
        }
    }

    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item[0].delta;
        tmp[count[val & 0xFF]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item[0].delta;
        input[count[((val >> 8) & 0xFF) + 256]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item[0].delta;
        tmp[count[((val >> 16) & 0xFF) + 512]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item[0].delta;
        input[count[((val >> 24) & 0xFF) + 768]++] = item;
    }

    /*if (i == -123) { //debug
        for (i = 0; i < inputSize; i++) {
            item = input[i];
            val = item.depth;
            console.log('' + val +  ' ' + item.lastSubJob[0].id);
        }
    }*/

    return input;
}


//used for scr-count8
function processGMap7(gpu, gl, renderer, screenPixelSize, draw) {
    if (!renderer.config.mapFeaturesReduceParams) {
        return;
    }

    const tileCount = renderer.config.mapFeaturesReduceParams[5];
    const featuresPerSquareInch = renderer.config.mapFeaturesReduceParams[1];
    const ppi = 96 * (window.devicePixelRatio || 1);
    const screenLX = renderer.curSize[0];
    const screenLY = renderer.curSize[1];

    let maxFeatures = Math.ceil((screenLX/ppi)*(screenLY/ppi)*featuresPerSquareInch);
    const featuresPerTile = maxFeatures / (tileCount * tileCount);
    const featuresPerTileInt = Math.floor(featuresPerTile);
    const featuresPerTileFract = featuresPerTile - featuresPerTileInt;
    const tileSizeX = screenLX / tileCount;
    const tileSizeY = screenLY / tileCount;

    renderer.debugStr = '<br>featuresPerScr: ' + maxFeatures + '<br>featuresPerTile: ' + featuresPerTile.toFixed(2);

    let i, li, job, feature, featureCount = 0, mx, my;
    //const feature, feature2, pp, pp2, o, featureCount = 0;
    //const drawAllLabels = renderer.drawAllLabels;

    const depthTest = (renderer.config.mapFeaturesReduceFactor2 != 0);
    const depthOffset = -renderer.config.mapFeaturesReduceFactor3;
    let depthParams = null;

    //get top features
    const featureCache = renderer.gmap;
    const featureCacheSize = renderer.gmapIndex;
    const featureCache2 = renderer.gmap2;
    let featureCacheSize2 = 0;
    const vmap = renderer.gmap4;
    const drawAllLabels = renderer.drawAllLabels;

    if (drawAllLabels) {
        maxFeatures = featureCacheSize;
    }

    if (featureCacheSize > 0) {

        //filter features and sort them by importance
        radixSortFeatures(renderer, featureCache, featureCacheSize, featureCache2);

        if (drawAllLabels) {

            for (i = featureCacheSize - 1; i >= 0; i--) {
                feature = featureCache[i];
                job = feature[0];

                if (feature[0].hysteresis) {
                    renderer.jobHBuffer[feature[0].id] = job;
                } else {
                    renderer.drawnJobs++;
                    job = feature[0];
                    if (job.type == 6) {
                        draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                    } else {
                        draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                    }
                }
            }

        } else {

            //distribute top features
            const hitMap = renderer.gmapHit;
            //const hitMapCount = renderer.gmapHit;

            let tileFeatures, count;
            let ix,iy,pp,tx,ty,mx,my,v,v2,index,o;

            ix = screenLX / tileSizeX;
            iy = screenLY / tileSizeY;
            mx = Math.round(ix);
            my = Math.round(iy);

            //clear hit-map
            for (i = 0, li = mx * my; i < li; i++) {
                hitMap[i] = null;
                vmap[i] = null;
            }

            for (i = featureCacheSize - 1; i >= 0; i--) {

                feature = featureCache[i];
                if (!feature) {
                    continue;
                }

                pp = feature[5];

                if (pp[0] < 30 || pp[0] >= (screenLX-30) || pp[1] < 30 || pp[1] >= (screenLY-30)) {
                    featureCache[i] = null;
                    continue;
                }

                tx = pp[0] / tileSizeX;
                ty = pp[1] / tileSizeY;

                index = Math.floor(tx) + Math.floor(ty) * (mx);

                tileFeatures = hitMap[index];

                if (tileFeatures) {
                    hitMap[index].push(i);
                } else {
                    hitMap[index] = [i];
                    //hitMapCount[index] = v;
                }
            }


            for (i = 0, li = (mx) * (my); i < li; i++) {
                tileFeatures = hitMap[i];

                if (tileFeatures && tileFeatures.length) {
                    count = tileFeatures.length;

                    if (count == 0) {
                        vmap[i] = null;
                    } else {
                        if (count > featuresPerTileInt) {
                            count = featuresPerTileInt;

                            index = tileFeatures[count];
                            feature = featureCache[index];
                            v = feature[0].reduce[6];

                            if (tileFeatures.length > count+1) {
                                index = tileFeatures[count+1];
                                feature = featureCache[index];
                                v2 = feature[0].reduce[6];
                                v = v + (v2 - v) * featuresPerTileFract;
                            }
                        } else {
                            index = tileFeatures[count - 1];
                            feature = featureCache[index];
                            v = feature[0].reduce[6];
                        }

                        vmap[i] = v;
                    }
                }
            }

            fillVMapHoles(vmap, mx, my);

            for (i = featureCacheSize - 1; i >= 0; i--) {
                feature = featureCache[i];
                if (!feature) {
                    continue;
                }

                job = feature[0];
                v = job.reduce[6];
                pp = feature[5];

                const vmax = getVMapValue(vmap, pp[0] / tileSizeX, pp[1] / tileSizeY, mx, my);

                if (v >= vmax) {

                    //render job
                    if (/*!drawAllLabels &&*/ feature[6]) { //no-overlap is always enabled
                        pp = feature[5];
                        o = feature[8];

                        depthParams = depthTest ? [pp[0],pp[1]+feature[1],job.reduce,depthOffset] : null;

                        if (job.type == 6) {
                            if (renderer.rmap.addLineLabel(job.lastSubJob, depthParams)) {
                                featureCount++;
                            }
                        } else {
                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, depthParams)) {
                                featureCount++;
                            }
                        }


                    } else {
                        if (job.hysteresis) {
                            renderer.jobHBuffer[job.id] = job;
                        } else {
                            renderer.drawnJobs++;

                            if (job.type == 6) {
                                draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                            } else {
                                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                            }
                        }
                    }
                } else {
                    //store v delta
                    feature[0].delta = Math.abs(vmax - v);
                    featureCache2[featureCacheSize2] = feature;
                    featureCacheSize2++;
                }
            }

            if (featureCount < maxFeatures && featureCacheSize2 > 0) {
                //sort deltas
                radixDeltaSortFeatures(renderer, featureCache2, featureCacheSize2, featureCache);

                for (i = featureCacheSize2 - 1; i >= 0; i--) {
                    feature = featureCache2[i];
                    job = feature[0];

                    //render job
                    if (/*!drawAllLabels &&*/ feature[6]) { //no-overlap is always enabled
                        pp = feature[5];
                        o = feature[8];

                        depthParams = depthTest ? [pp[0],pp[1]+feature[1],job.reduce,depthOffset] : null;

                        if (job.type == 6) {
                            if (renderer.rmap.addLineLabel(job.lastSubJob, depthParams)) {
                                featureCount++;
                            }
                        } else {
                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, depthParams)) {
                                featureCount++;
                            }
                        }

                    } else {
                        if (job.hysteresis) {
                            renderer.jobHBuffer[job.id] = job;
                        } else {
                            renderer.drawnJobs++;

                            if (job.type == 6) {
                                draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                            } else {
                                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);
                            }
                        }
                    }

                    if (featureCount >= maxFeatures) {
                        break;
                    }
                }
            }
        }
    }


    if (renderer.drawGridCells) {
        gpu.setState(renderer.lineLabelState);

        let x = 0, y = 0, j, lj;

        for (j = 0, lj = my; j < lj; j++) {
            for (i = 0, li = mx; i < li; i++) {
                x = tileSizeX * i;
                y = tileSizeY * j;

                const v = vmap[j*mx+i];

                draw.drawLineString([[x, y, 0.5], [x+tileSizeX, y, 0.5],
                                     [x+tileSizeX, y+tileSizeY, 0.5], [x, y+tileSizeY, 0.5]], true, 1, [0,0,255,255], null, true, null, null, null);

                if (v) {
                    draw.drawText(Math.round(x+5), Math.round(y + 5), 11, '' + v.toFixed(2), [255,255,255,255], 0.5);
                }
            }
        }
    }

}





/***/ }),

/***/ "./src/core/renderer/interface.js":
/*!****************************************!*\
  !*** ./src/core/renderer/interface.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _raycaster_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raycaster.js */ "./src/core/renderer/raycaster.js");

//import GpuTexture_ from './gpu/texture';
//import GpuMesh_ from './gpu/mesh';
//import GpuProgram_ from './gpu/program';


//get rid of compiler mess
//const GpuTexture = GpuTexture_;
//const GpuMesh = GpuMesh_;
//const GpuProgram = GpuProgram_;
const Octree = _raycaster_js__WEBPACK_IMPORTED_MODULE_0__["Octree"];
const OctreeRaycaster = _raycaster_js__WEBPACK_IMPORTED_MODULE_0__["OctreeRaycaster"];

const RendererInterface = function(renderer) {
    this.renderer = renderer;
    this.gpu = renderer.gpu;
};

RendererInterface.prototype.getRaw = function() {
    return this.renderer;
};

RendererInterface.prototype.clear = function(options) {
    if (options != null) {
        this.gpu.clear((options['clearDepth'] || true),
                        (options['clearColor'] || false),
                        (options['color'] || [255,255,255,255]),
                        ((options['depth'] != null) ? options['depth'] : 1.0) );
    }
    return this;
};


RendererInterface.prototype.createState = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;
    }

    const stateOptions = {
        blend : (options['blend'] != null) ? options['blend'] : false,
        stencil : (options['stencil'] != null) ? options['stencil'] : false,
        zoffset : (options['zoffset'] != null) ? options['zoffset'] : 0,
        zwrite : (options['zwrite'] != null) ? options['zwrite'] : true,
        ztest : (options['ztest'] != null) ? options['ztest'] : true,
        zequal : (options['zequal'] != null) ? options['zequal'] : true,
        culling : (options['culling'] != null) ? options['culling'] : true
    };

    return this.gpu.createState(stateOptions);
};


RendererInterface.prototype.setState = function(state) {
    if (state != null) {
        this.gpu.setState(state);
    }
    return this;
};


RendererInterface.prototype.createTexture = function(options) {
    if (options == null || typeof options !== 'object') {
        return null;
    }

    const source = options['source'];
    if (source == null) {
        return null;
    }

    const filter = options['filter'] || 'linear';
    const repeat = options['repeat'] || false;

    if (source instanceof Uint8Array) {
        const width = options['width'];
        const height = options['height'];

        if (width && height) {
            //const texture = new GpuTexture(this.gpu);
            //texture.createFromData(width, height, source, filter, repeat);
            const texture = this.gpu.createTexture({data:source, width:width, height:height, filter: filter, repeat: repeat });
            return texture;
        }
    }

    if (source instanceof Image) {
        //const texture = new GpuTexture(this.gpu);
        //texture.createFromImage(source, filter, repeat);
        const texture = this.gpu.createTexture({image:source, filter: filter, repeat: repeat });
        return texture;
    }

    return null;
};


RendererInterface.prototype.removeTexture = function(texture) {
    if (texture) {
        texture.kill();
    }
    return this;
};


RendererInterface.prototype.createMesh = function(options) {
    if (options == null || typeof options !== 'object') {
        return null;
    }

    const data = {
        vertices : options['vertices'],
        uvs : options['uvs'],
        uvs2 : options['normals'],
        vertexSize : options['vertexSize'],
        uvSize : options['uvSize'],
        uv2Size : options['normalSize'] || 3,
        vertexAttr : options['vertexAttr'],
        uvAttr : options['uvAttr'],
        uv2Attr : options['normalAttr'],
        bbox : options['bbox']
    };

//    return new GpuMesh(this.gpu, data, 0, this.renderer.core);
    return this.gpu.createMesh(data);
};


RendererInterface.prototype.removeMesh = function(mesh) {
    if (mesh) {
        mesh.kill();
    }
    return this;
};


RendererInterface.prototype.createShader = function(options) {
    if (!options || typeof options !== 'object') {
        return null;
    }

    const vertexShader = options['vertexShader'];
    const fragmentShader = options['fragmentShader'];

    if (vertexShader && fragmentShader) {
        //return new GpuProgram(this.gpu, vertexShader, fragmentShader);
        return this.gpu.createShader({ vertexShader: vertexShader, fragmentShader: fragmentShader});
    }
};


RendererInterface.prototype.removeResource = function(resource) {
    if (resource && resource.kill != null) {
        resource.kill();
    }

    return this;
};


RendererInterface.prototype.addJob = function(/*options*/) {
    return this;
};


RendererInterface.prototype.clearJobs = function(/*options*/) {
    return this;
};


RendererInterface.prototype.drawMesh = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;
    }

    if (!options['mesh'] == null || !options['shaderVariables']) {
        return this;
    }

    //const shaderAttributes = options['shaderAttributes'];
    const vertexAttr = options['vertex'] || 'aPosition';
    const depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;
    const shaderVariables = options['shaderVariables'];

    let shader = options['shader'] || 'textured';
    let uvAttr = options['uv'] || 'aTexCoord';
    let uv2Attr = options['normal'] || 'aNormal';
    let texture = options['texture'];

    const renderer = this.renderer;
    const mesh = options['mesh'];
    const mv = renderer.camera.getModelviewMatrix();
    const proj = renderer.camera.getProjectionMatrix();
    const fogDensity = renderer.fogDensity;

    if (typeof shader === 'string') {
        switch(shader) {
        case 'hit':

            if (!shaderVariables['uMV']) {
                shaderVariables['uMV'] = ['mat4', mv];
            }

            if (!shaderVariables['uProj']) {
                shaderVariables['uProj'] = ['mat4', proj];
            }

            uvAttr = null;
            uv2Attr = null;
            texture = null;
            shader = renderer.gpu.progDepthTile[0];
            break;

        case 'shaded':
            uvAttr = null;

        // eslint-disable-next-line
        case 'textured':
        case 'textured-and-shaded':

            if (!shaderVariables['uMV']) {
                shaderVariables['uMV'] = ['mat4', mv];
            }

            if (!shaderVariables['uProj']) {
                shaderVariables['uProj'] = ['mat4', proj];
            }

            if (!shaderVariables['uFogDensity']) {
                shaderVariables['uFogDensity'] = ['float', fogDensity];
            }

            uv2Attr = (shader == 'textured') ? null : 'aNormal';
            shader = (shader == 'textured') ? renderer.gpu.progTile[0] : ((shader == 'shaded') ? renderer.gpu.progShadedTile : renderer.gpu.progTShadedTile);
            break;
        }
    }

    if (!shader || !shader.isReady()) {
        return;
    }

    const attributes = [vertexAttr];
    if (uvAttr){
        attributes.push(uvAttr);
    }
    if (uv2Attr){
        attributes.push(uv2Attr);
    }

    renderer.gpu.useProgram(shader, attributes);

    for (let key in shaderVariables) {
        const item = shaderVariables[key];

        if (item.length == 2) {
            switch(item[0]){
            case 'floatArray':
                shader.setFloatArray(key, item[1]);
                break;
            case 'float':
                shader.setFloat(key, item[1]);
                break;
            case 'mat3':
                shader.setMat3(key, item[1]);
                break;
            case 'mat4':
                if (depthOffset && key == 'uProj') {
                    shader.setMat4(key, item[1], renderer.getZoffsetFactor(depthOffset));
                } else {
                    shader.setMat4(key, item[1]);
                }
                break;
            case 'vec2':
                shader.setVec2(key, item[1]);
                break;
            case 'vec3':
                shader.setVec3(key, item[1]);
                break;
            case 'vec4':
                shader.setVec4(key, item[1]);
                break;
            case 'sampler':
                shader.setSampler(key, item[1]);
                break;
            }
        }
    }

    if (texture) {
        renderer.gpu.bindTexture(texture);
    }

    //mesh.draw(shader, vertexAttr, texture ? uvAttr : null, uv2Attr, null);
    mesh.draw(shader, vertexAttr, uvAttr, uv2Attr, null);
    return this;
};


RendererInterface.prototype.drawImage = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;
    }

    if (options['texture'] == null || options['rect'] == null) {
        return this;
    }

    const rect = options['rect'];
    const depth = (options['depth'] != null) ? options['depth'] : 0;
    const depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;
    const depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;
    const blend = (options['blend'] != null) ? options['blend'] : false;
    const writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;
    const useState = (options['useState'] != null) ? options['useState'] : false;
    let color = options['color'] || [255,255,255,255];
    color = [ color[0] * (1.0/255), color[1] * (1.0/255), color[2] * (1.0/255), color[3] * (1.0/255) ];

    this.renderer.gpu.draw.drawImage(rect[0], rect[1], rect[2], rect[3], options['texture'], color, depth, depthOffset, depthTest, blend, writeDepth, useState);
    return this;
};


RendererInterface.prototype.drawBillboard = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;
    }

    if (options['texture'] == null || options['mvp'] == null) {
        return this;
    }

    const mvp = options['mvp'];
    const depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;
    const depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;
    const blend = (options['blend'] != null) ? options['blend'] : false;
    const writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;
    const useState = (options['useState'] != null) ? options['useState'] : false;
    let color = options['color'] || [255,255,255,255];
    color[0] *= 1.0/255;
    color[1] *= 1.0/255;
    color[2] *= 1.0/255;
    color[3] *= 1.0/255;

    this.renderer.gpu.draw.drawBillboard(mvp, options['texture'], color, depthOffset, depthTest, blend, writeDepth, useState);
    return this;
};


RendererInterface.prototype.drawLineString = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;
    }

    if (options['points'] == null) {
        return this;
    }

    const points = options['points'];
    const depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;
    const size = options['size'] || 2;
    const screenSpace = (options['screenSpace'] != null) ? options['screenSpace'] : true;
    const depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;
    const blend = (options['blend'] != null) ? options['blend'] : false;
    const writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;
    const useState = (options['useState'] != null) ? options['useState'] : false;
    let color = options['color'] || [255,255,255,255];
    color[0] *= 1.0/255;
    color[1] *= 1.0/255;
    color[2] *= 1.0/255;
    color[3] *= 1.0/255;

    this.renderer.gpu.draw.drawLineString(points, screenSpace, size, color, depthOffset, depthTest, blend, writeDepth, useState);
    return this;
};


RendererInterface.prototype.drawJobs = function(/*options*/) {
    return this;
};


RendererInterface.prototype.drawBBox = function(/*options*/) {
    return this;
};


RendererInterface.prototype.drawDebugText = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;
    }

    const text = options['text'];
    const coords = options['coords'];

    if (!text || !coords) {
        return this;
    }

    const size = options['size'] || 16;
    const depth = options['depth'];
    const useState = options['useState'] || false;
    let color = options['color'] || [255,255,255,255];
    color[0] *= 1.0/255;
    color[1] *= 1.0/255;
    color[2] *= 1.0/255;
    color[3] *= 1.0/255;

    const lx = this.renderer.gpu.draw.getTextSize(size, text);

    this.renderer.gpu.draw.drawText(coords[0] - (lx * 0.5), coords[1], size, text, color, depth, useState);

    return this;
};


RendererInterface.prototype.buildOctreeFromGeometry = function(geometry) {
    const octree = new Octree();
    octree.buildFromGeometry(geometry);
    return octree;
};


RendererInterface.prototype.raycastOctreeGeometry = function(octree, rayPos, rayDir) {
    const raycaster = new OctreeRaycaster(), intersects = [];
    raycaster.intersectOctree(rayPos, rayDir, octree, intersects);
    return raycaster.intersectOctants(rayPos, rayDir, intersects);
};


RendererInterface.prototype.saveScreenshot = function(output, filename, filetype) {
    return this.renderer.saveScreenshot(output, filename, filetype);
};


RendererInterface.prototype.getCanvasCoords = function(point, mvp) {
    return this.renderer.project2(point, mvp);
};


RendererInterface.prototype.getCanvasSize = function() {
    return this.renderer.curSize.slice();
};


RendererInterface.prototype.setConfigParams = function(params) {
    this.renderer.setConfigParams(params);
    return this;
};


RendererInterface.prototype.setConfigParam = function(key, value) {
    this.renderer.setConfigParam(key, value);
    return this;
};


RendererInterface.prototype.getConfigParam = function(key) {
    return this.renderer.getConfigParam(key);
};


RendererInterface.prototype.getGLInterface = function() {
    return {
        canvas : this.gpu.canvas,
        gl : this.gpu.gl
    };
};


RendererInterface.prototype.setSuperElevation = function(h1, f1, h2, f2) {
    return this.renderer.setSuperElevation(h1, f1, h2, f2);
};


RendererInterface.prototype.setMarginFlags = function(flags) {
    return this.renderer.marginFlags = flags;
};


RendererInterface.prototype.getMarginFlags = function() {
    return this.renderer.marginFlags;
};


/* harmony default export */ __webpack_exports__["default"] = (RendererInterface);


/***/ }),

/***/ "./src/core/renderer/raycaster.js":
/*!****************************************!*\
  !*** ./src/core/renderer/raycaster.js ***!
  \****************************************/
/*! exports provided: Octree, OctreeRaycaster */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Octree", function() { return Octree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctreeRaycaster", function() { return OctreeRaycaster; });
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");



//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"];


const Octree = function() {
    this.root = null;
    this.maxItemsPerNode = 20;
    this.maxDepth = 20;

    this.depthCount = [];
    for (let i = 0; i < 1000; i++) {
        this.depthCount[i] = 0;
    }

    /**
     * A binary pattern that describes the standard octant layout:
     *
     * ```text
     *    3____7
     *  2/___6/|
     *  | 1__|_5
     *  0/___4/
     * ```
     *
     * This common layout is crucial for positional assumptions.
     *
     */

    this.pattern = [
        new Uint8Array([0, 0, 0]),
        new Uint8Array([0, 0, 1]),
        new Uint8Array([0, 1, 0]),
        new Uint8Array([0, 1, 1]),

        new Uint8Array([1, 0, 0]),
        new Uint8Array([1, 0, 1]),
        new Uint8Array([1, 1, 0]),
        new Uint8Array([1, 1, 1])
    ];
};


Octree.prototype.clear = function() {
};


Octree.prototype.buildFromGeometry = function(data) {
    if (!data) {
        return;
    }

    let i, li, j, lj, k, lk, v, submeshes, submesh, bbox, index,
        minX, minY, minZ, maxX, maxY, maxZ, geometry, vertices;

    minX = minY = minZ = Number.POSITIVE_INFINITY;
    maxX = maxY = maxZ = Number.NEGATIVE_INFINITY;

    //get gemetery bbox
    for (i = 0, li = data.length; i < li; i++) {
        geometry = data[i];
        if (geometry["type"] == "mesh") {
            submeshes = geometry["submeshes"];

            for (j = 0, lj = submeshes.length; j < lj; j++) {
                submesh = submeshes[j];
                bbox = submesh["bbox"];

                if (bbox[0][0] < minX) minX = bbox[0][0];
                if (bbox[0][1] < minY) minY = bbox[0][1];
                if (bbox[0][2] < minZ) minZ = bbox[0][2];

                if (bbox[1][0] > maxX) maxX = bbox[1][0];
                if (bbox[1][1] > maxY) maxY = bbox[1][1];
                if (bbox[1][2] > maxZ) maxZ = bbox[1][2];
            }
        }
    }

    this.root = new OctreeNode([minX, minY, minZ], [maxX, maxY, maxZ]);

    //get gemetery bbox
    for (i = 0, li = data.length; i < li; i++) {
        geometry = data[i];
        if (geometry["type"] == "mesh") {
            submeshes = geometry["submeshes"];

            for (j = 0, lj = submeshes.length; j < lj; j++) {
                submesh = submeshes[j];

                vertices = submesh["vertices"];

                for (k = 0, lk = vertices.length; k < lk; k += 9) {

                    minX = minY = minZ = Number.POSITIVE_INFINITY;
                    maxX = maxY = maxZ = Number.NEGATIVE_INFINITY;

                    for (v = 0; v < 3; v ++) {
                        index = k + v * 3;

                        if (vertices[index] < minX) minX = vertices[index];
                        if (vertices[index+1] < minY) minY = vertices[index+1];
                        if (vertices[index+2] < minZ) minZ = vertices[index+2];

                        if (vertices[index] > maxX) maxX = vertices[index];
                        if (vertices[index+1] > maxY) maxY = vertices[index+1];
                        if (vertices[index+2] > maxZ) maxZ = vertices[index+2];
                    }

                    //this.root.add([minX, minY, minZ], [maxX, maxY, maxZ], [vertices, k])
                    this.root.add([minX, minY, minZ, maxX, maxY, maxZ, vertices, k], this)
                }

            }
        }
    }


};


const OctreeNode = function(min, max) {
    this.min = min;
    this.max = max;
    this.children = null;
    this.items = null;
};

OctreeNode.prototype.add = function(item, octree, depth) {
    if (this.children) {
        if (!depth) {
            depth = 0;
        }

        for (let i = 0; i < 8; i++) {
            const  child = this.children[i],
                   min = child.min,
                   max = child.max;

            if (item[0] < max[0] && item[3] > min[0] &&
                item[1] < max[1] && item[4] > min[1] &&
                item[2] < max[2] && item[5] > min[2]) {

                //collision detected, add item
                child.add(item, octree, depth + 1);
            }
        }

        return;
    }

    if (!this.items) {
        this.items = [];
    }

    this.items.push(item);

    if (depth < octree.maxDepth && this.items.length >= octree.maxItemsPerNode) {
        this.split(octree, depth + 1);
    }
};

OctreeNode.prototype.split = function(octree, depth) {
    let min = this.min,
        max = this.max,
        mid = [(max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5],
        i, li, j;

    this.children = [
        null, null,
        null, null,
        null, null,
        null, null
    ];

    this.depthCount[depth]++;

    for (i = 0; i < 8; i++) {
        const combination = octree.pattern[i];

        this.children[i] = new OctreeNode(
            [
                (combination[0] === 0) ? min[0] : mid[0],
                (combination[1] === 0) ? min[1] : mid[1],
                (combination[2] === 0) ? min[2] : mid[2]
            ],

            [
                (combination[0] === 0) ? mid[0] : max[0],
                (combination[1] === 0) ? mid[1] : max[1],
                (combination[2] === 0) ? mid[2] : max[2]
            ]
        );
    }

    const items = this.items;

    //distribute items
    if (items) {
        for (i = 0, li = items.length; i < li; i++) {
            const item = items[i];

            for (j = 0; j < 8; j++) {
                const child = this.children[j];
                min = child.min;
                max = child.max;

                if (item[0] < max[0] && item[3] > min[0] &&
                    item[1] < max[1] && item[4] > min[1] &&
                    item[2] < max[2] && item[5] > min[2]) {

                    //collision detected, add item
                    child.add(item, octree);
                }
            }
        }
    }

    this.items = null;
};


const OctreeRaycaster = function() {

    // A lookup-table containing octant ids. Used to determine the exit plane from an octant.
    this.octantTable = [
        new Uint8Array([4, 2, 1]),
        new Uint8Array([5, 3, 8]),
        new Uint8Array([6, 8, 3]),
        new Uint8Array([7, 8, 8]),
        new Uint8Array([8, 6, 5]),
        new Uint8Array([8, 7, 8]),
        new Uint8Array([8, 8, 7]),
        new Uint8Array([8, 8, 8])
    ];

    // A byte that stores raycasting flags.
    this.flags = 0;
};


/**
 * Finds the entry plane of the first octant that a ray travels through.
 *
 * Determining the first octant requires knowing which of the t0s is the
 * largest. The tms of the other axes must also be compared against that
 * largest t0.
 *
 * tx0, ty0,tz0 - Ray projection parameter.
 * txm, tym, tzm - Ray projection parameter mean.
 * returns - index of the first octant that the ray travels through.
 */

OctreeRaycaster.prototype.findEntryOctant = function(tx0, ty0, tz0, txm, tym, tzm) {
    let entry = 0;

    // Find the entry plane.
    if(tx0 > ty0 && tx0 > tz0) {

        // YZ-plane.
        if (tym < tx0) {
            entry |= 2;
        }

        if (tzm < tx0) {
            entry |= 1;
        }

    } else if (ty0 > tz0) {

        // XZ-plane.
        if (txm < ty0) {
            entry |= 4;
        }

        if (tzm < ty0) {
            entry |= 1;
        }

    } else {

        // XY-plane.
        if (txm < tz0) {
            entry |= 4;
        }

        if (tym < tz0) {
            entry |= 2;
        }
    }

    return entry;
}

/**
 * Finds the next octant that intersects with the ray based on the exit plane of
 * the current one.
 *
 * urrentOctant - The index of the current octant.
 * tx1, ty1, tz1 - Ray projection parameter.
 * returns - index of the next octant that the ray travels through.
 */

OctreeRaycaster.prototype.findNextOctant = function(currentOctant, tx1, ty1, tz1) {
    let min;
    let exit = 0;

    // Find the exit plane.
    if (tx1 < ty1) {
        min = tx1;
        exit = 0; // YZ-plane.
    } else {
        min = ty1;
        exit = 1; // XZ-plane.
    }

    if (tz1 < min) {
        exit = 2; // XY-plane.
    }

    return this.octantTable[currentOctant][exit];
}

/**
 * Finds all octants that intersect with the given ray.
 *
 * octant - The current octant.
 * tx0 - Ray projection parameter. Initial tx0 = (minX - rayOriginX) / rayDirectionX.
 * ty0 - Ray projection parameter. Initial ty0 = (minY - rayOriginY) / rayDirectionY.
 * tz0 - Ray projection parameter. Initial tz0 = (minZ - rayOriginZ) / rayDirectionZ.
 * tx1 - Ray projection parameter. Initial tx1 = (maxX - rayOriginX) / rayDirectionX.
 * ty1 - Ray projection parameter. Initial ty1 = (maxY - rayOriginY) / rayDirectionY.
 * tz1 - Ray projection parameter. Initial tz1 = (maxZ - rayOriginZ) / rayDirectionZ.
 * intersects - An array to be filled with the intersecting octants.
 * returns
 */

OctreeRaycaster.prototype.raycastOctant = function(octant, tx0, ty0, tz0, tx1, ty1, tz1, intersects) {
    const children = octant.children;
    let currentOctant;
    let txm, tym, tzm;

    if (tx1 >= 0.0 && ty1 >= 0.0 && tz1 >= 0.0) {

        if (!children) {

            // Leaf.
            if (octant.items) {
                intersects.push(octant);
            }

        } else {

            // Compute means.
            txm = 0.5 * (tx0 + tx1);
            tym = 0.5 * (ty0 + ty1);
            tzm = 0.5 * (tz0 + tz1);

            currentOctant = this.findEntryOctant(tx0, ty0, tz0, txm, tym, tzm);

            do {

                /* The possibilities for the next node are passed in the same respective
                 * order as the t-values. Hence, if the first value is found to be the
                 * greatest, the fourth one will be returned. If the second value is the
                 * greatest, the fifth one will be returned, etc.
                 */

                switch(currentOctant) {

                    case 0:
                        this.raycastOctant(children[this.flags], tx0, ty0, tz0, txm, tym, tzm, intersects);
                        currentOctant = this.findNextOctant(currentOctant, txm, tym, tzm);
                        break;

                    case 1:
                        this.raycastOctant(children[this.flags ^ 1], tx0, ty0, tzm, txm, tym, tz1, intersects);
                        currentOctant = this.findNextOctant(currentOctant, txm, tym, tz1);
                        break;

                    case 2:
                        this.raycastOctant(children[this.flags ^ 2], tx0, tym, tz0, txm, ty1, tzm, intersects);
                        currentOctant = this.findNextOctant(currentOctant, txm, ty1, tzm);
                        break;

                    case 3:
                        this.raycastOctant(children[this.flags ^ 3], tx0, tym, tzm, txm, ty1, tz1, intersects);
                        currentOctant = this.findNextOctant(currentOctant, txm, ty1, tz1);
                        break;

                    case 4:
                        this.raycastOctant(children[this.flags ^ 4], txm, ty0, tz0, tx1, tym, tzm, intersects);
                        currentOctant = this.findNextOctant(currentOctant, tx1, tym, tzm);
                        break;

                    case 5:
                        this.raycastOctant(children[this.flags ^ 5], txm, ty0, tzm, tx1, tym, tz1, intersects);
                        currentOctant = this.findNextOctant(currentOctant, tx1, tym, tz1);
                        break;

                    case 6:
                        this.raycastOctant(children[this.flags ^ 6], txm, tym, tz0, tx1, ty1, tzm, intersects);
                        currentOctant = this.findNextOctant(currentOctant, tx1, ty1, tzm);
                        break;

                    case 7:
                        this.raycastOctant(children[this.flags ^ 7], txm, tym, tzm, tx1, ty1, tz1, intersects);
                        // Far top right octant. No other octants can be reached from here.
                        currentOctant = 8;
                        break;

                }

            } while(currentOctant < 8);

        }

    }

}

OctreeRaycaster.prototype.hitFace = function(origin, dir, index, vertices) {
    const EPSILON = 0.0000001,
        v1 = [vertices[index], vertices[index+1], vertices[index+2]],
        v2 = [vertices[index+3], vertices[index+4], vertices[index+5]],
        v3 = [vertices[index+6], vertices[index+7], vertices[index+8]],
        edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]],
        edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];

    let h = [0,0,0], q = [0,0,0], s, a, f, u, v;

    vec3.cross(dir, edge2, h);
    a = vec3.dot(edge1, h);

    if (a > -EPSILON && a < EPSILON) {
        return [false];
    }

    f = 1/a;
    s = [origin[0] - v1[0], origin[1] - v1[1], origin[2] - v1[2]];
    u = f * (vec3.dot(s, h));

    if (u < 0.0 || u > 1.0) {
        return [false];
    }

    q = vec3.cross(s, edge1);
    v = f * vec3.dot(dir, q);
    if (v < 0.0 || u + v > 1.0) {
        return [false];
    }

    // At this stage we can compute t to find out where the intersection point is on the line.
    let t = f * vec3.dot(edge2, q);
    //if (t > EPSILON) { // ray intersection
        return [true, t]; //[origin[0] + dir[0] * t, origin[1] + dir[1] * t, origin[2] + dir[2] * t ]];
    //} else { // This means that there is a line intersection but not a ray intersection.
     //   return [false];
    //}
};


/**
 * Finds the octants that intersect with the given ray. The intersecting
 * octants are sorted by distance, closest first.
 *
 * octree - An octree.
 * intersects - A list to be filled with intersecting octants.
 */

// https://github.com/vanruesc/sparse-octree/blob/master/src/core/OctreeRaycaster.js

OctreeRaycaster.prototype.intersectOctree = function(rayPos, rayDir, octree, intersects) {
    // Translate the octree extents to the scene origin.
    const min = [0,0,0];
    const max = [octree.root.max[0] - octree.root.min[0],
               octree.root.max[1] - octree.root.min[1],
               octree.root.max[2] - octree.root.min[2]]

    const dimensions = [max[0], max[1], max[2]];
    const halfDimensions = [dimensions[0]*0.5, dimensions[1]*0.5, dimensions[2]*0.5];

    const origin = [rayPos[0],rayPos[1],rayPos[2]];
    const direction = [rayDir[0], rayDir[1], rayDir[2]];

    let invDirX, invDirY, invDirZ;
    let tx0, tx1, ty0, ty1, tz0, tz1;

    const center = [(octree.root.max[0] + octree.root.min[0]) * 0.5,
                  (octree.root.max[1] + octree.root.min[1]) * 0.5,
                  (octree.root.max[2] + octree.root.min[2]) * 0.5]

    // Translate the ray to the center of the octree.
    //origin.sub(octree.getCenter(v[2])).add(halfDimensions);
    origin[0] = (origin[0] - center[0]) + halfDimensions[0];
    origin[1] = (origin[1] - center[1]) + halfDimensions[1];
    origin[2] = (origin[2] - center[2]) + halfDimensions[2];

    // Reset all flags.
    this.flags = 0;

    // Handle rays with negative directions.
    if (direction[0] < 0.0) {
        origin[0] = dimensions[0] - origin[0];
        direction[0] = -direction[0];
        this.flags |= 4;
    }

    if (direction[1] < 0.0) {
        origin[1] = dimensions[1] - origin[1];
        direction[1] = -direction[1];
        this.flags |= 2;
    }

    if (direction[2] < 0.0) {
        origin[2] = dimensions[2] - origin[2];
        direction[2] = -direction[2];
        this.flags |= 1;
    }

    // Improve IEEE double stability.
    invDirX = 1.0 / direction[0];
    invDirY = 1.0 / direction[1];
    invDirZ = 1.0 / direction[2];

    // Project the ray to the root's boundaries.
    tx0 = (min[0] - origin[0]) * invDirX;
    tx1 = (max[0] - origin[0]) * invDirX;
    ty0 = (min[1] - origin[1]) * invDirY;
    ty1 = (max[1] - origin[1]) * invDirY;
    tz0 = (min[2] - origin[2]) * invDirZ;
    tz1 = (max[2] - origin[2]) * invDirZ;

    // Check if the ray hits the octree.
    if (Math.max(Math.max(tx0, ty0), tz0) < Math.min(Math.min(tx1, ty1), tz1)) {
        // Find the intersecting octants.
        this.raycastOctant(octree.root, tx0, ty0, tz0, tx1, ty1, tz1, intersects);
    }
};

OctreeRaycaster.prototype.intersectOctants = function(rayPos, rayDir, octants) {
    let hits = [];
    let t = Number.POSITIVE_INFINITY;

    for (let i = 0, li = octants.length; i < li; i++) {
        const items = octants[i].items;

        for (let j = 0, lj = items.length; j < lj; j++) {
            const item = items[j];
            const res = this.hitFace(rayPos, rayDir, item[7], item[6]);

            if (res[0] && res[1] < t) {
                t = res[1];
            }
        }
    }

    if (t !== Number.POSITIVE_INFINITY) {
        hits = [t];
    }

    return hits;
};




/***/ }),

/***/ "./src/core/renderer/renderer.js":
/*!***************************************!*\
  !*** ./src/core/renderer/renderer.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");
/* harmony import */ var _devices_three_device__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./devices/three/device */ "./src/core/renderer/devices/three/device.js");
/* harmony import */ var _devices_webgl_device__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./devices/webgl/device */ "./src/core/renderer/devices/webgl/device.js");
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./font */ "./src/core/renderer/font.js");
/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./camera */ "./src/core/renderer/camera.js");
/* harmony import */ var _rmap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rmap */ "./src/core/renderer/rmap.js");


//import GpuTexture_ from './gpu/texture';









//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"], mat4 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];
const RendererFont = _font__WEBPACK_IMPORTED_MODULE_3__["default"];
const Camera = _camera__WEBPACK_IMPORTED_MODULE_4__["default"];
const RenderRMap = _rmap__WEBPACK_IMPORTED_MODULE_5__["default"];
const ThreeDevice = _devices_three_device__WEBPACK_IMPORTED_MODULE_1__["default"];
const WebGLDevice = _devices_webgl_device__WEBPACK_IMPORTED_MODULE_2__["default"];


const Renderer = function(core, div, onUpdate, onResize, config) {
    this.config = config || {};
    this.device = config.rendererDevice === 'three' ? 2 : 1;
    //this.device = VTS_DEVICE_THREE;
    this.core = core;
    this.map = core.map;
    this.marginFlags = 0;
    this.div = div;
    this.onUpdate = onUpdate;
    this.killed = false;
    this.onlyDepth = false;
    this.onlyLayers = false;
    this.onlyHitLayers = false;
    this.onlyAdvancedHitLayers = false;
    this.advancedPassNeeded = false;
    this.hitmapCounter = 0;
    this.geoRenderCounter = 0;
    this.geoHitmapCounter = 0;
    this.frameTime = 0;
    this.geometries = {};
    this.clearStencilPasses = [];
    this.onResizeCall = onResize;
    //this.math = Math;
    this.stencilLineState = null;
    this.drawLabelBoxes = false;
    this.drawGridCells = false;
    this.drawAllLabels = false;
    this.debug = {};
    this.mapHack = null;

    this.geodataSelection = [];
    this.hoverFeatureCounter = 0;
    this.hoverFeatureList = [];

    this.touchSurfaceEvent = [];

    const rect = this.div.getBoundingClientRect();

    this.winSize = [rect.width, rect.height]; //QSize
    this.curSize = [rect.width, rect.height]; //QSize
    this.oldSize = [rect.width, rect.height]; //QSize
    this.dirty = true;
    this.cameraVector = [0,1,0];
    this.viewExtent = 1;
    //this.texelSizeLimit = this.core.mapConfig.texelSize * texelSizeFactor;

    if (this.device === 2) {
        this.gpu = new ThreeDevice(this, div, this.curSize, this.config.rendererAllowScreenshots, this.config.rendererAntialiasing, this.config.rendererAnisotropic);
    } else {
        this.gpu = new WebGLDevice(this, div, this.curSize, this.config.rendererAllowScreenshots, this.config.rendererAntialiasing, this.config.rendererAnisotropic);
    }

    this.draw = this.gpu.draw;

    this.camera = new Camera(this, 45, 2, 1200000.0);

    //reduce garbage collection
    this.drawTileMatrix = mat4.create();
    this.drawTileMatrix2 = mat4.create();
    this.drawTileVec = [0,0,0];
    this.drawTileWorldMatrix = mat4.create();
    this.pixelTileSizeMatrix = mat4.create();

    this.heightmapMesh = null;
    this.heightmapTexture = null;

    this.skydomeMesh = null;
    this.skydomeTexture = null;

    this.hitmapTexture = null;
    this.geoHitmapTexture = null;
    this.hitmapSize = this.config.mapDMapSize;
    this.hitmapMode = this.config.mapDMapMode;
    this.updateHitmap = true;
    this.updateGeoHitmap = true;

    this.redTexture = null;

    this.rectVerticesBuffer = null;
    this.rectIndicesBuffer = null;
    this.imageProjectionMatrix = null;

    this.font = null;
    this.fonts = {};
    this.fogDensity = 0;

    this.gmap = new Array(2048);
    this.gmap2 = new Array(2048);
    this.gmap3 = new Array(10000);
    this.gmap3Size = new Array(10000);
    this.gmap4 = new Array(10000);
    this.gmapIndex = 0;
    this.gmapTop = new Array(512);
    this.gmapHit = new Array(512);
    this.gmapStore = new Array(512);
    this.fmaxDist = 0;
    this.fminDist = 0;

    this.jobZBuffer = new Array(512);
    this.jobZBufferSize = new Array(512);

    this.jobZBuffer2 = new Array(512);
    this.jobZBuffer2Size = new Array(512);

    this.jobHBuffer = {};
    this.jobHBufferSize = 0;
    this.jobHSortBuffer = new Array(2048);


    for (let i = 0, li = this.jobZBuffer.length; i < li; i++) {
        this.jobZBuffer[i] = [];
        this.jobZBufferSize[i] = 0;
        this.jobZBuffer2[i] = {};
        this.jobZBuffer2Size[i] = 0;
    }

    for (let i = 0, li = this.gmap3.length; i < li; i++) {
        this.gmap3[i] = [];
        this.gmap3Size[i] = 0;
    }

    this.radixCountBuffer16 = new Uint16Array(256*4);
    this.radixCountBuffer32 = new Uint32Array(256*4);
    //this.radixOutputBufferUint32 = new Uint32Array(256*256);
    //this.radixOutputBufferFloat32 = new Uint32Array(256*256);

    this.buffFloat32 = new Float32Array(1);
    this.buffUint32 = new Uint32Array(this.buffFloat32.buffer);

    this.layerGroupVisible = [];
    this.bitmaps = {};

    this.cameraPosition = [0,0,0];
    this.cameraOrientation = [0,0,0];
    this.cameraTiltFator = 1;
    this.cameraViewExtent = 1;
    this.distanceFactor = 1;
    this.tiltFactor = 1;
    this.localViewExtentFactor = 1;
    this.cameraVector = [0,0,0];
    this.labelVector = [0,0,0];
    this.drawnGeodataTiles = 0;
    this.drawnGeodataTilesFactor = 0;
    this.drawnGeodataTilesUsed = false;
    this.progMap = {};
    this.gridHmax = 0;
    this.gridHmin = 0;
    this.seCounter = 0;

    //hack for vts maps
    //this.vtsHack = true;
    //this.vtsHack = false;

    //reduce garbage collection
    this.updateCameraMatrix = mat4.create();

    this.seTmpVec = [0,0,0];
    this.seTmpVec2 = [0,0,0];
    this.seTmpVec3 = [0,0,0];

    //debug
    this.lastHitPosition = [0,0,100];
    this.logTilePos = null;
    this.setSuperElevation(0,2,4000,1.5);

    window.addEventListener('resize', (this.onResize).bind(this), false);

    //intit resources
    // eslint-disable-next-line
    this.rmap = new RenderRMap(this, 50);

    this.gpu.init();

    const factor = 1;
    this.resizeGL(Math.floor(this.curSize[0]*factor), Math.floor(this.curSize[1]*factor));
};


Renderer.prototype.initProceduralShaders = function() {
    this.init.initProceduralShaders();
};


Renderer.prototype.onResize = function() {
    if (this.killed){
        return;
    }

    const rect = this.div.getBoundingClientRect();
    this.resizeGL(Math.floor(rect.width), Math.floor(rect.height));

    if (this.onResizeCall) {
        this.onResizeCall();
    }
};


Renderer.prototype.kill = function() {
    if (this.killed){
        return;
    }

    this.killed = true;

    this.gpu.kill();
};


// eslint-disable-next-line
Renderer.prototype.resizeGL = function(width, height, skipCanvas, skipPaint) {
    this.camera.setAspect(width / height);
    this.curSize = [width, height];
    this.oldSize = [width, height];
    //this.gpu.resize(this.curSize, skipCanvas);

    //if (skipPaint !== true) { //remove this??
       // this.draw.paintGL();
    //}

    const m = new Float32Array(16);
    m[0] = 2.0/width; m[1] = 0; m[2] = 0; m[3] = 0;
    m[4] = 0; m[5] = -2.0/height; m[6] = 0; m[7] = 0;
    m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
    m[12] = -width*0.5*m[0]; m[13] = -height*0.5*m[5]; m[14] = 0; m[15] = 1;

    this.imageProjectionMatrix = m;

    this.gpu.setSize( width, height );
};


Renderer.prototype.project2 = function(point, mvp, cameraPos, includeDistance) {
    let p = [0, 0, 0, 1];

    if (cameraPos) {
        p = mat4.multiplyVec4(mvp, [point[0] - cameraPos[0], point[1] - cameraPos[1], point[2] - cameraPos[2], 1 ]);
    } else {
        p = mat4.multiplyVec4(mvp, [point[0], point[1], point[2], 1 ]);
    }

    //project point coords to screen
    if (p[3] != 0) {
        const sp = [0,0,0];

        //x and y are in screen pixels
        sp[0] = ((p[0]/p[3])+1.0)*0.5*this.curSize[0];
        sp[1] = (-(p[1]/p[3])+1.0)*0.5*this.curSize[1];

        //depth in meters
        sp[2] = p[2]/p[3];

        if (includeDistance) {
            sp[3] = p[2];
        }

        return sp;
    } else {
        return [0, 0, 0];
    }
};


Renderer.prototype.setSuperElevationState = function(state) {
    if (this.useSuperElevation != state) {
        this.useSuperElevation = state;
        this.seCounter++;
    }
};


Renderer.prototype.getSuperElevationState = function() {
    return this.useSuperElevation;
};


Renderer.prototype.setSuperElevation = function(h1, f1, h2, f2) {
    if (f1 == 1 && f2 == 1) {
        if (this.useSuperElevation != false) {
            this.useSuperElevation = false;
            this.seCounter++;
        }

        if (h1 == h2) { h2 = h1 + 1; }
        this.superElevation = [h1, f1, h2, f2, h2-h1, f2-f1, 1.0 / (h2-h1)];
        return;
    }

    if (h1 == h2) { h2 = h1 + 1; }
    this.superElevation = [h1, f1, h2, f2, h2-h1, f2-f1, 1.0 / (h2-h1)];
    this.seCounter++;
};


Renderer.prototype.getSuperElevation = function() {
    return this.superElevation.slice();
};


Renderer.prototype.getSuperElevatedHeight = function(height) {
    const se = this.superElevation;
    let h = height;

    if (h < se[0]) {  // 0 - h1, 1 - f1, 2 - h2, 3 - f2, 4 - dh, 5 - df, 6 - invdh
        h = se[0];
    }

    if (h > se[2]) {
        h = se[2];
    }

    return height * (se[1] + ((h - se[0]) * se[6]) * se[5]);
};

Renderer.prototype.getUnsuperElevatedHeight = function(height) {
    const se = this.superElevation, s = height;

    if (se[1] == se[3]) {
        return s / se[1];
    }

    if (s <= se[0] * se[1]) {  // 0 - h1, 1 - f1, 2 - h2, 3 - f2, 4 - dh, 5 - df, 6 - invdh
        return s / se[1];
    }

    if (s >= se[2] * se[3]) {
        return s / se[3];
    }

    const h1 = se[0], f1 = se[1], h2 = se[2], f2 = se[3];

    // and f1!=f2 and h1!=h2

    return -(Math.sqrt(-2*f2*(f1*h1*h2 + 2*h1*s - 2*h2*s) + f1*(f1*h2*h2 + 4*h1*s - 4*h2*s) + f2*f2*h1*h1) - f1*h2 + f2*h1)/(2*(f1 - f2));
};


Renderer.prototype.getEllipsoidHeight = function(pos, shift) {
    let p, p2;
    this.seTmpVec3 = [0,0,0];

    if (shift) {
        p = this.seTmpVec;
        p2 = [pos[0] + shift[0], pos[1] + shift[1], (pos[2] + shift[2]) * this.earthERatio];
    } else {
        p = pos;
        p2 = [p[0], p[1], p[2] * this.earthERatio];
    }

    const l = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1] + p2[2] * p2[2]);

    return l - this.earthRadius;
};


Renderer.prototype.transformPointBySE = function(pos, shift) {
    let p = pos, p2;
    this.seTmpVec3 = [0,0,0];

    if (shift) {
        p2 = [pos[0] + shift[0], pos[1] + shift[1], (pos[2] + shift[2]) * this.earthERatio];
    } else {
        p2 = [p[0], p[1], p[2] * this.earthERatio];
    }

    const l = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1] + p2[2] * p2[2]);
    const v = this.seTmpVec2;

    let m = (1.0/(l+0.0001));
    v[0] = p2[0] * m;
    v[1] = p2[1] * m;
    v[2] = p2[2] * m;

    const h = l - this.earthRadius;
    const h2 = this.getSuperElevatedHeight(h);
    m = (h2 - h);

    p2[0] = p[0] + v[0] * m;
    p2[1] = p[1] + v[1] * m;
    p2[2] = p[2] + v[2] * m;

    return p2;
};


Renderer.prototype.transformPointBySE2 = function(pos, shift) {
    let p = pos, p2;
    this.seTmpVec3 = [0,0,0];

    if (shift) {
        p2 = [pos[0] + shift[0], pos[1] + shift[1], (pos[2] + shift[2]) * this.earthERatio];
    } else {
        p2 = [p[0], p[1], p[2] * this.earthERatio];
    }

    const l = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1] + p2[2] * p2[2]);
    const v = this.seTmpVec2;

    let m = (1.0/(l+0.0001));
    v[0] = p2[0] * m;
    v[1] = p2[1] * m;
    v[2] = p2[2] * m;

    const h = l - this.earthRadius;
    const h2 = this.getSuperElevatedHeight(h);
    m = (h2 - h);// * 10;

    pos = pos.slice();

    pos[0] = p[0] + v[0] * m;
    pos[1] = p[1] + v[1] * m;
    pos[2] = p[2] + v[2] * m;

    pos[13] = v[0] * m;
    pos[14] = v[1] * m;
    pos[15] = v[2] * m;

    return pos;
};


Renderer.prototype.project = function(point) {
    //get mode-view-projection matrix
    const mvp = this.camera.getMvpMatrix();

    //get camera position relative to position
    const cameraPos2 = this.camera.getPosition();

    //get global camera position
    const cameraPos = this.cameraPosition();

    //get point coords relative to camera
    const p = [point[0] - cameraPos[0] + cameraPos2[0], point[1] - cameraPos[1] + cameraPos2[1], point[2] - cameraPos[2] + cameraPos2[2], 1 ];

    //project point coords to screen
    let p2 = [0, 0, 0, 1];
    p2 = mat4.multiplyVec4(mvp, p);

    if (p2[3] != 0) {

        const sp = [0,0,0];

        //x and y are in screen pixels
        sp[0] = ((p2[0]/p2[3])+1.0)*0.5*this.curSize[0];
        sp[1] = (-(p2[1]/p2[3])+1.0)*0.5*this.curSize[1];

        //depth in meters
        sp[2] = p2[2]/p2[3];

        return sp;
    } else {
        return [0, 0, 0];
    }
};


Renderer.prototype.getScreenRay = function(screenX, screenY) {
    if (this.camera == null) {
        return [0,0,1.0];
    }

    this.camera.dirty = true; //???? why is projection matrix distored so I have to refresh

    //convert screen coords
    const x = (2.0 * screenX) / this.curSize[0] - 1.0;
    const y = 1.0 - (2.0 * screenY) / this.curSize[1];

    const rayNormalizeDeviceSpace = [x, y, 1.0];

    const rayClipCoords = [rayNormalizeDeviceSpace[0], rayNormalizeDeviceSpace[1], -1.0, 1.0];

    let invProjection = mat4.create();
    invProjection = mat4.inverse(this.camera.getProjectionMatrix());

    //console.log("--" + JSON.stringify(rayClipCoords));
    //console.log("----" + JSON.stringify(invProjection));

    const rayEye = [0,0,0,0];
    mat4.multiplyVec4(invProjection, rayClipCoords, rayEye); //inverse (projectionmatrix) * rayClipCoords;
    rayEye[2] = -1.0;
    rayEye[3] = 0.0;

    let invView = mat4.create();
    invView = mat4.inverse(this.camera.getModelviewMatrix());

    let rayWorld = [0,0,0,0];
    mat4.multiplyVec4(invView, rayEye, rayWorld); //inverse (projectionmatrix) * rayClipCoords;

    // don't forget to normalise the vector at some point
    rayWorld = vec3.normalize([rayWorld[0], rayWorld[1], rayWorld[2]]); //normalise (raywor);

    return rayWorld;
};


Renderer.prototype.hitTestGeoLayers = function(screenX, screenY, secondTexture) {
    //const gl = this.gpu.gl;

    //probably not needed
    //if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
      //  return [false, 0,0,0,0];
    //}

    let surfaceHit = false, pixel;

    if (screenX >= 0 && screenX < this.curSize[0] &&
        screenY >= 0 && screenY < this.curSize[1]) {

        //convert screen coords to texture coords
        const x = Math.floor(screenX * (this.hitmapSize / this.curSize[0]));
        const y = Math.floor(screenY * (this.hitmapSize / this.curSize[1]));

        //get pixel value from framebuffer

        if (secondTexture) {
            pixel = this.geoHitmapTexture2.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);
        } else {
            pixel = this.geoHitmapTexture.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);
        }

        surfaceHit = !(pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255 && pixel[3] == 255);
    }

    if (surfaceHit) {
        return [true, pixel[0], pixel[1], pixel[2], pixel[3]];
    }

    return [false, 0,0,0,0];
};


Renderer.prototype.switchToFramebuffer = function(type, texture) {

    if (this.device === 2) {
        return;
    }

    const gl = this.gpu.gl;
    let size, width, height;

    switch(type) {
    case 'base':
        width = this.oldSize[0];
        height = this.oldSize[1];

        gl.clearColor(0.0, 0.0, 0.0, 1.0);

        gl.viewport(0, 0, width, height);
        this.gpu.setFramebuffer(null);

        this.camera.setAspect(width / height);
        this.curSize = [width, height];
        this.gpu.resize(this.curSize, true);
        this.camera.update();
            //this.updateCamera();
        this.onlyDepth = false;
        this.onlyHitLayers = false;
        this.onlyAdvancedHitLayers = false;
        this.advancedPassNeeded = false;
        break;

    case 'depth':
        //set texture framebuffer
        this.gpu.setFramebuffer(this.hitmapTexture);

        this.oldSize = [ this.curSize[0], this.curSize[1] ];

        gl.clearColor(1.0,1.0, 1.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        size = this.hitmapSize;

        //clear screen
        gl.viewport(0, 0, size, size);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        this.curSize = [size, size];

        //this.gpu.clear();
        this.camera.update();
        this.onlyDepth = true;
        this.onlyHitLayers = false;
        this.onlyAdvancedHitLayers = false;
        this.advancedPassNeeded = false;
        break;

    case 'geo':
    case 'geo2':

        this.hoverFeatureCounter = 0;
        size = this.hitmapSize;

        //set texture framebuffer
        this.gpu.setFramebuffer(type == 'geo' ? this.geoHitmapTexture : this.geoHitmapTexture2);

        width = size;
        height = size;

        gl.clearColor(1.0,1.0, 1.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        //clear screen
        gl.viewport(0, 0, size, size);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        this.curSize = [width, height];

        //render scene
        this.onlyHitLayers = true;
        this.advancedPassNeeded = false;
        this.onlyAdvancedHitLayers = (type == 'geo2');

        //this.gpu.clear();
        this.camera.update();
        break;

    case 'texture':
        //set texture framebuffer
        this.gpu.setFramebuffer(texture);

        this.oldSize = [ this.curSize[0], this.curSize[1] ];

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        //clear screen
        gl.viewport(0, 0, this.gpu.canvas.width, this.gpu.canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        this.curSize = [this.gpu.canvas.width, this.gpu.canvas.height];

        //this.gpu.clear();
        this.camera.update();
        this.onlyDepth = false;
        this.onlyHitLayers = false;
        this.onlyAdvancedHitLayers = false;
        this.advancedPassNeeded = false;
        break;
    }
};


Renderer.prototype.hitTest = function(screenX, screenY) {
    //const gl = this.gpu.gl;

    //get screen ray
    const screenRay = this.getScreenRay(screenX, screenY);
    const cameraPos = this.camera.getPosition();

    //probably not needed
    //if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
      //  return [0, 0, 0, null, screenRay, Number.MAX_VALUE, cameraPos];
    //}

    //convert screen coords to texture coords

    //get screen coords
    const x = Math.floor(screenX * (this.hitmapSize / this.curSize[0]));
    const y = Math.floor(screenY * (this.hitmapSize / this.curSize[1]));

    let pixel;

    //get pixel value from framebuffer
    if (this.device === 2) {
        pixel = new Uint8Array( 4 );
        this.gpu.gpu2.readRenderTargetPixels( this.gpu.textureRenderTarget, x, this.hitmapSize - y - 1, 1, 1, pixel );
    } else {
        pixel = this.hitmapTexture.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);
    }

    //convert rgb values into depth
    const depth = (pixel[0] * (1.0/255)) + (pixel[1]) + (pixel[2]*255.0) + (pixel[3]*65025.0);// + (pixel[3]*16581375.0);

    //console.log('' + pixel[0] + ' ' + pixel[1] + ' ' + pixel[2]);

    const surfaceHit = !(pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255 && pixel[3] == 255);

    //compute hit postion
    this.lastHitPosition = [cameraPos[0] + screenRay[0]*depth, cameraPos[1] + screenRay[1]*depth, cameraPos[2] + screenRay[2]*depth];

    return [this.lastHitPosition[0], this.lastHitPosition[1], this.lastHitPosition[2], surfaceHit, screenRay, depth, cameraPos];
};


Renderer.prototype.copyHitmap = function() {
    if (this.device === 2) {
        this.gpu.gpu2.readRenderTargetPixels( this.gpu.textureRenderTarget, 0,0,this.hitmapSize,this.hitmapSize, false, this.hitmapData);
    } else {
        this.hitmapTexture.readFramebufferPixels(0,0,this.hitmapSize,this.hitmapSize, false, this.hitmapData);
    }
};


Renderer.prototype.getDepth = function(screenX, screenY) {
    const x = Math.floor(screenX * (this.hitmapSize / this.curSize[0]));
    const y = Math.floor(screenY * (this.hitmapSize / this.curSize[1]));
    let depth, surfaceHit, pixel;

    if (this.hitmapMode <= 2) {
        //get pixel value from framebuffer

        if (this.device === 2) {
            pixel = new Uint8Array( 4 );
            this.gpu.readRenderTargetPixels( this.textureRenderTarget, x, this.hitmapSize - y - 1, 1, 1, pixel );
        } else {
            pixel = this.hitmapTexture.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1, (this.hitmapMode == 2));
        }

        //convert rgb values into depth
        depth = (pixel[0] * (1.0/255)) + (pixel[1]) + (pixel[2]*255.0) + (pixel[3]*65025.0);// + (pixel[3]*16581375.0);
        surfaceHit = !(pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255 && pixel[3] == 255);

    } else {
        const pixels = this.hitmapData;
        const index = (x + (this.hitmapSize - y - 1) * this.hitmapSize) * 4;
        const r = pixels[index], g = pixels[index+1], b = pixels[index+2], a = pixels[index+3];

        depth = (r * (1.0/255)) + (g) + (b*255.0) + (a*65025.0);// + (pixel[3]*16581375.0);
        surfaceHit = !(r == 255 && g == 255 && b == 255 && a == 255);
    }

    return [surfaceHit, depth];
};


Renderer.prototype.getZoffsetFactor = function(params) {
    return (params[0] + params[1]*this.distanceFactor + params[2]*this.tiltFactor)*0.0001;
};


Renderer.prototype.saveScreenshot = function(output, filename, filetype) {
    const gl = this.gpu.gl;

    //get current screen size
    const width = this.curSize[0];
    const height = this.curSize[1];

    //read rgba data from frame buffer
    //works only when webgl context is initialized with preserveDrawingBuffer: true
    const data2 = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data2);

    //flip image vertically
    const data = new Uint8Array(width * height * 4);
    let index = 0;

    for (let y = 0; y < height; y++) {

        let index2 = ((height-1) - y) * width * 4;

        for (let x = 0; x < width; x++) {
            data[index] = data2[index2];
            data[index+1] = data2[index2+1];
            data[index+2] = data2[index2+2];
            data[index+3] = data2[index2+3];
            index+=4;
            index2+=4;
        }
    }

    // Create a 2D canvas to store the result
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext('2d');

    // Copy the pixels to a 2D canvas
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);

    filetype = filetype || 'jpg';

    if (output == 'file') {
        const a = document.createElement('a');
        const dataURI= canvas.toDataURL('image/' + filetype);
        const byteString = atob(dataURI.split(',')[1]);

        // write the bytes of the string to an ArrayBuffer
        const ab = new ArrayBuffer(byteString.length);
        const ia = new Uint8Array(ab);
        for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }

        const file = new Blob([ab], {type: filetype});

        const url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 0);
    } if (output == 'tab') {
        //open image in new window
        window.open(canvas.toDataURL('image/' + filetype));
    }

    return imageData;
};


Renderer.prototype.getBitmap = function(url, filter, tiled, hash, useHash) {
    const id = (useHash ? hash : url) + '*' + filter + '*' + tiled;

    let texture = this.bitmaps[id];
    if (!texture && url) {
        //texture = new GpuTexture(this.gpu, url, this.core, null, null, tiled, filter);
        texture = this.gpu.createTexture({ path: url, tiled: tiled, filter: filter});
        this.bitmaps[id] = texture;
    }

    return texture;
};


Renderer.prototype.getFont = function(url) {
    let font = this.fonts[url];
    if (!font) {
        font = new RendererFont(this, this.core, null, null, url);
        this.fonts[url] = font;
    }

    return font;
};


/* harmony default export */ __webpack_exports__["default"] = (Renderer);


/***/ }),

/***/ "./src/core/renderer/rmap.js":
/*!***********************************!*\
  !*** ./src/core/renderer/rmap.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/matrix */ "./src/core/utils/matrix.js");



//get rid of compiler mess
const vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"];


const RendererRMap = function(renderer, blockSize, maxBlockRectangles) {
    this.renderer = renderer;
    this.drawAllLabels = false;
    this.maxBlockRectangles = maxBlockRectangles || 500;
    this.blockSize = blockSize;
    this.blockSizeFactor = 1/blockSize;
    this.blocks = [];
    this.blocks2 = [];
    this.blocksRCount = [];
    this.blocks2RCount = [];
    this.allocatedBlocks = 0;
    this.lx = 1;
    this.ly = 1;
    this.counter = 0;
    this.rectangles = null;
    this.rectanglesCount = 0;
    this.rectangles2 = null;
    this.rectangles2Count = 0;
    this.rectanglesR = null;
    this.rectanglesRCount = 0;
    this.benevolentMargins = false;
    this.positionsBuffer = new Float64Array(256*4);
};


RendererRMap.prototype.clear = function() {
    const renderer = this.renderer;

    this.sx2 = renderer.curSize[0];
    this.sy2 = renderer.curSize[1];

    //reduce by credits
    this.sy2 = Math.max(1, this.sy2 - 55);
    this.sy1 = 1;
    this.sx1 = 1;

    //compass size
    this.cx2 = 135;
    this.cy1 = renderer.curSize[1] - 145;

    //search bar size
    this.bx2 = 245;
    this.by2 = 45;

    this.lx = Math.floor(renderer.curSize[0] * this.blockSizeFactor) + 1;
    this.ly = Math.floor(renderer.curSize[1] * this.blockSizeFactor) + 1;

    if (renderer.marginFlags & 4096) {
        this.sx1 = Math.min(34, this.sx2);
        this.sx2 = Math.max(1, renderer.curSize[0] - 34);
        this.sy1 = Math.min(50, this.sy2);
        this.sy2 = Math.max(1, renderer.curSize[1] - 68);
    }

    const totalNeeded = this.ly * this.lx;

    if (!this.rectangles) {
        this.rectangles = new Array(totalNeeded * this.maxBlockRectangles * 6); //preallocate empty rectangles
    }

    if (!this.rectangles2) {
        this.rectangles2 = new Array(totalNeeded * this.maxBlockRectangles * 6); //preallocate empty rectangles
    }

    if (!this.rectanglesR) {
        this.rectanglesR = new Array(totalNeeded * this.maxBlockRectangles * 6); //preallocate empty rectangles
    }

    if (this.rectanglesCount > 0 || this.allocatedBlocks != totalNeeded) {

        for (let i = 0; i < totalNeeded; i++) { //check if all rectangles are preallocated and reset coutner
            if (!this.blocks[i]) {
                this.blocks[i] = [];
            }

            this.blocksRCount[i] = 0;
        }
    }

    if (this.rectangles2Count > 0 || this.allocatedBlocks != totalNeeded) {

        for (let i = 0; i < totalNeeded; i++) { //check if all rectangles are preallocated and reset coutner
            if (!this.blocks2[i]) {
                this.blocks2[i] = [];
            }

            this.blocks2RCount[i] = 0;
        }
    }

    this.allocatedBlocks = totalNeeded;
    this.drawAllLabels = renderer.debug.drawAllLabels;
    this.benevolentMargins = renderer.benevolentMargins;

    this.rectanglesCount = 0;
    this.rectangles2Count = 0;
    this.rectanglesRCount = 0;
    this.counter = renderer.geoRenderCounter;
};


RendererRMap.prototype.storeRemovedRectangle = function(x1, y1, x2, y2, z, subjob) {
    const rectangles2 = this.rectanglesR;
    const rectangles2Count = this.rectanglesRCount;

    rectangles2[rectangles2Count] = x1;
    rectangles2[rectangles2Count+1] = y1;
    rectangles2[rectangles2Count+2] = x2;
    rectangles2[rectangles2Count+3] = y2;
    rectangles2[rectangles2Count+4] = z;
    rectangles2[rectangles2Count+5] = subjob;
    this.rectanglesRCount += 6;
};


//aabbox circle
//http://www.firenibbler.com/2016/04/27/how-to-js-collision-detection-cheat-sheets-learn-aabb-box-circle-and-point-detection/
RendererRMap.prototype.circleAABBoxCollide = function(x1, y1, x2, y2, cx, cy, cr){
    // Get the distance between the two objects
    const hwidth = (x2 - x1) * 0.5;
    const hheight = (y2 - y1) * 0.5;
    const distX = Math.abs(cx - x1 - hwidth);
    const distY = Math.abs(cy - y2 - hheight);

    // Check to make sure it is definitely not overlapping
    if (distX > (hwidth + cr) || distY > (hheight + cr)) {
        return false;
    }
    // Check to see if it is definitely overlapping
    if (distX <= hwidth || distY <= hheight) {
        return true;
    }

    // Last Resort to see if they are overlapping
    const dx = distX - hwidth;
    const dy = distY - hheight;
    return (dx * dx + dy * dy <= (cr * cr));
};


//aabbox line
//https://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms
RendererRMap.prototype.lineAABBoxCollide = function(x1, y1, x2, y2, rx1, ry1, rx2, ry2) {
    const dx = 1 / ( (rx2 != rx1) ? (rx2 - rx1) : 0.00001);
    const tx1 = (x1 - rx1)*dx;
    const tx2 = (x2 - rx1)*dx;

    let tmin = Math.min(tx1, tx2);
    let tmax = Math.max(tx1, tx2);

    const dy = 1 / ( (ry2 != ry1) ? (ry2 - ry1) : 0.00001);
    const ty1 = (y1 - ry1)*dy;
    const ty2 = (y2 - ry1)*dy;

    tmin = Math.max(tmin, Math.min(ty1, ty2));
    tmax = Math.min(tmax, Math.max(ty1, ty2));

    return tmax >= tmin;
};


RendererRMap.prototype.checkRectangle = function(x1, y1, x2, y2, y3) {
    let t;

    if (x1 > x2) { t = x1; x1 = x2; x2 = t; }
    if (y1 > y2) { t = y1; y1 = y2; y2 = t; }

    y3 += y2;

    if (this.benevolentMargins) {
        //screen including credits
        return !(x2 < this.sx1 || x1 > this.sx2 || y3 < this.sy1 || y1 > this.sy2);
    }

    //screen including credits
    if (x1 < this.sx1 || x2 > this.sx2 || y1 < this.sy1 || y3 > this.sy2) {
        return false;
    }

    //compass
    if ((this.renderer.marginFlags & 1) && x1 < this.cx2 && x2 > 0 && y1 <= this.sx2 && y3 > this.cy1) {
        return false;
    }

    //search bar
    if ((this.renderer.marginFlags & 2) && x1 < this.bx2 && x2 > 0 && y1 <= this.by2 && y3 > 0) {
        return false;
    }

    return true;
}

RendererRMap.prototype.addRectangle = function(x1, y1, x2, y2, z, subjob, any, checkDepthMap) {
    let x, y, i, index, blockRectangles, blockRectanglesCount,
        rectangleIndex, t, renderer = this.renderer;

    if (this.drawAllLabels) {
        return true;
    }

    if (x1 > x2) { t = x1; x1 = x2; x2 = t; }
    if (y1 > y2) { t = y1; y1 = y2; y2 = t; }

    const y3 = y2 + subjob[1]; //add stick shift

    if (this.benevolentMargins) {
        //screen including credits
        if (x2 < this.sx1 || x1 > this.sx2 || y3 < this.sy1 || y1 > this.sy2) {
            return false;
        }
    } else {
        //screen including credits
        if (x1 < this.sx1 || x2 > this.sx2 || y1 < this.sy1 || y3 > this.sy2) {
            return false;
        }

        //compass
        if ((renderer.marginFlags & 1) && x1 < this.cx2 && x2 > 0 && y1 <= this.sx2 && y3 > this.cy1) {
            return false;
        }

        //search bar
        if ((renderer.marginFlags & 2) && x1 < this.bx2 && x2 > 0 && y1 <= this.by2 && y3 > 0) {
            return false;
        }
    }

    let xx1 = Math.floor(x1 * this.blockSizeFactor);
    let yy1 = Math.floor(y1 * this.blockSizeFactor);
    let xx2 = Math.floor(x2 * this.blockSizeFactor);
    let yy2 = Math.floor(y2 * this.blockSizeFactor);

    if (xx2 < 0 || yy2 < 0 || xx1 >= this.lx || yy1 >= this.ly) {
        return false;
    }

    if (xx1 < 0) xx1 = 0;
    if (xx2 >= this.lx) xx2 = this.lx - 1;

    if (yy1 < 0) yy1 = 0;
    if (yy2 >= this.ly) yy2 = this.ly - 1;

    const lx = (xx2 - xx1) + 1;
    const ly = (yy2 - yy1) + 1;
    const removeList = {};
    //let exit = false;

    const top = renderer.config.mapFeaturesSortByTop,
          rectangles = this.rectangles, rectangles2 = this.rectangles2;

    //test collision
    for (y = 0; y < ly; y++) {
        for (x = 0; x < lx; x++) {
            index = (yy1 + y)*this.lx + (xx1 + x);

            blockRectangles = this.blocks[index];
            blockRectanglesCount = this.blocksRCount[index];

            //test rectangles
            for (i = 0; i < blockRectanglesCount; i++) {
                rectangleIndex = blockRectangles[i];

                if (x1 < rectangles[rectangleIndex + 2] && x2 > rectangles[rectangleIndex + 0] &&
                    y1 < rectangles[rectangleIndex + 3] && y2 > rectangles[rectangleIndex + 1]) {

                    if (any) {
                        return false;
                    }

                    if (top) {
                        if (z < rectangles[rectangleIndex + 4]) {
                            return false;
                        }
                    } else {
                        if (z > rectangles[rectangleIndex + 4]) {
                            return false;
                        }
                    }

                    removeList[rectangleIndex] = true;
                }
            }

            if ((blockRectanglesCount + 1) >= this.maxBlockRectangles) {
                return false;
            }

            blockRectangles = this.blocks2[index];
            blockRectanglesCount = this.blocks2RCount[index];

            //test circles
            for (i = 0; i < blockRectanglesCount; i++) {
                rectangleIndex = blockRectangles[i];

//                if (this.circleAABBoxCollide(rectangles2[rectangleIndex + 0], rectangles2[rectangleIndex + 1], rectangles[rectangleIndex + 2], rectangles[rectangleIndex + 3], x, y, r)) {
                if (this.circleAABBoxCollide(x1, y1, x2, y2, rectangles2[rectangleIndex + 0], rectangles2[rectangleIndex + 1], rectangles[rectangleIndex + 3])) {

                 //   if (any) {
                        return false;
                  //  }
                }
            }


        }
    }

    //remove rectangles
    for (let key in removeList) {
        this.removeRectangle(parseInt(key));
    }

    if (checkDepthMap) {

        const reduce = checkDepthMap[2];
        const depth = renderer.mapHack.getScreenDepth(checkDepthMap[0], checkDepthMap[1], (reduce[4] > 10000000));

        if (depth[0]) {
            const delta = depth[1] - reduce[4];
            reduce[7] = delta;

            if (!renderer.drawHiddenLabels && delta < checkDepthMap[3]) {
                return false;
            }
        }
    }

    //there is no collision so we can store rectangle
    rectangleIndex = this.rectanglesCount;
    rectangles[rectangleIndex] = x1;
    rectangles[rectangleIndex+1] = y1;
    rectangles[rectangleIndex+2] = x2;
    rectangles[rectangleIndex+3] = y2;
    rectangles[rectangleIndex+4] = z;
    rectangles[rectangleIndex+5] = subjob;
    this.rectanglesCount += 6;

    for (y = 0; y < ly; y++) {
        for (x = 0; x < lx; x++) {
            index = (yy1 + y)*this.lx + (xx1 + x);
            this.blocks[index][this.blocksRCount[index]] = rectangleIndex;
            this.blocksRCount[index]++;
        }
    }

    return true;
};


// eslint-disable-next-line
RendererRMap.prototype.addLineLabel = function(subjob, checkDepthMap) {
    const pbuff = this.positionsBuffer;
    const job = subjob[0], renderer = this.renderer;
    const margin = job.noOverlap ? job.noOverlap[0] : 1;

    let blockRectangles, blockRectanglesCount, rectangleIndex;
    let x1 = Number.POSITIVE_INFINITY, x2 = Number.NEGATIVE_INFINITY,
        y1 = Number.POSITIVE_INFINITY, y2 = Number.NEGATIVE_INFINITY;
    let x, y, r, rr = 0, xx, yy, i, li, pp = [0,0,0,0];
    let index = 0, pindex = 0;

    const targetSize = job.labelSize * 0.5;
    const sizeFactor = renderer.camera.scaleFactor2(subjob[5][3])*0.5*renderer.curSize[1]*(renderer.curSize[0]/renderer.curSize[1]);
    const labelPoints = job.labelPoints;
    let pointsIndex = subjob[9];
    let labelIndex = job.labelIndex;
    let labelMorph = 0;

    li = labelPoints.length;

    if (li <= 1 || labelPoints[li -1][0]*sizeFactor < targetSize) {
        return;
    }

    li--;

    for (i = 0; i < li; i++) {
        const s2 = labelPoints[i+1][0] * sizeFactor;

        if (s2 > targetSize) {
            const s1 = labelPoints[i][0] * sizeFactor;

            labelIndex = i;
            labelMorph = (targetSize - s1) / (s2 - s1);
            break;
        }
    }

    pointsIndex = (vec3.dot(labelPoints[labelIndex][1], renderer.labelVector) >= 0) ? 3 : 2;

    let points = labelPoints[labelIndex][pointsIndex];
    let points2 = (labelPoints[labelIndex+1]) ? labelPoints[labelIndex+1][pointsIndex] : points;
    let p, p2, buffer, benevolentMargins = this.benevolentMargins;

    if (renderer.useSuperElevation) {
        buffer = job.labelPointsBuffer;

        if (buffer.id != (labelIndex * 1024 + pointsIndex)) {
            buffer.id = (labelIndex * 1024 + pointsIndex);
            if (buffer.points.length != points.length) {
                buffer.points = new Array(points.length);
                buffer.points2 = new Array(points.length);
            }

            const sePoints = buffer.points;
            const sePoints2 = buffer.points2;

            for(i = 0, li = points.length; i < li; i++) {
                sePoints[i] = renderer.transformPointBySE2(points[i]);
                sePoints2[i] = renderer.transformPointBySE2(points2[i]);
            }

            points = sePoints;
            points2 = sePoints2;

        } else {
            points = buffer.points;
            points2 = buffer.points2;
        }
    }

    if (!points.length || !points2.length) {
        return false;
    }

    for (i = 0, li = points.length; i < li; i++) {

        p = points[i];
        p2 = points2[i];

        pp[0] = p[0] + (p2[0] - p[0]) * labelMorph;
        pp[1] = p[1] + (p2[1] - p[1]) * labelMorph;
        pp[2] = p[2] + (p2[2] - p[2]) * labelMorph;
        r = (p[3] + (p2[3] - p[3]) * labelMorph)*sizeFactor*margin;

        pp = renderer.project2(pp, renderer.camera.mvp, renderer.cameraPosition, true);

        if (pp[0] > x2) x2 = pp[0];
        if (pp[1] > y2) y2 = pp[1];
        if (pp[0] < x1) x1 = pp[0];
        if (pp[1] < y1) y1 = pp[1];

        //minX, maxX, minY, maxY;
        pbuff[pindex] = pp[0];
        pbuff[pindex+1] = pp[1];
        pbuff[pindex+2] = pp[2];
        pbuff[pindex+3] = r;

        if (r > rr) {
            rr = r;
        }

        pindex += 4;
    }

    x1 -= rr, x2 += rr, y1 -= rr, y2 += rr;

    if (benevolentMargins) {
        //screen including credits
        if (x2 < this.sx1 || x1 > this.sx2 || y2 < this.sy1 || y1 > this.sy2) {
            return false;
        }
    } else {
        //screen including credits
        if (x1 < this.sx1 || x2 > this.sx2 || y1 < this.sy1 || y2 > this.sy2) {
            return false;
        }

        //compass
        if ((renderer.marginFlags & 1) && x1 < this.cx2 && x2 > 0 && y1 <= this.sx2 && y2 > this.cy1) {
            return false;
        }

        //search bar
        if ((renderer.marginFlags & 2) && x1 < this.bx2 && x2 > 0 && y1 <= this.by2 && y2 > 0) {
            return false;
        }
    }

    const blockSizeFactor = this.blockSizeFactor;
    const /*top = renderer.config.mapFeaturesSortByTop,*/
          rectangles = this.rectangles, rectangles2 = this.rectangles2;
    let xx1, yy1, xx2, yy2, dx, dy, llx = this.lx, lly = this.ly, j;

    pindex = 0;

    for (i = 0, li = points.length; i < li; i++) {

        xx = pbuff[pindex];
        yy = pbuff[pindex+1];
        r = pbuff[pindex+3];

        xx1 = Math.floor((xx-r) * blockSizeFactor);
        yy1 = Math.floor((yy-r) * blockSizeFactor);
        xx2 = Math.floor((xx+r) * blockSizeFactor);
        yy2 = Math.floor((yy+r) * blockSizeFactor);

        if (benevolentMargins) {
            if (xx2 < 0 || xx1 >= llx || yy2 < 0 || yy1 >= lly) {
              pindex += 4;
              continue;
            }
            if (xx1 < 0) xx1 = 0;
            if (yy1 < 0) yy1 = 0;
            if (xx2 >= llx) xx2 = llx - 1;
            if (yy2 >= lly) yy2 = lly - 1;
        }

        const lx = (xx2 - xx1) + 1;
        const ly = (yy2 - yy1) + 1;

        //test collision
        for (y = 0; y < ly; y++) {
            for (x = 0; x < lx; x++) {
                index = (yy1 + y)*llx + (xx1 + x);

                blockRectangles = this.blocks[index];
                blockRectanglesCount = this.blocksRCount[index];

                //test rectangles
                for (j = 0; j < blockRectanglesCount; j++) {
                    rectangleIndex = blockRectangles[j];

                    if (this.circleAABBoxCollide(x1, y1, x2, y2, rectangles[rectangleIndex + 0], rectangles[rectangleIndex + 1], rectangles[rectangleIndex + 2])) {

                        //if (any) {
                            return false;
                        //}
                    }
                }

                blockRectangles = this.blocks2[index];
                blockRectanglesCount = this.blocks2RCount[index];

                //test circles
                for (j = 0; j < blockRectanglesCount; j++) {
                    rectangleIndex = blockRectangles[j];

                    dx = xx - rectangles2[rectangleIndex + 0];
                    dy = yy - rectangles2[rectangleIndex + 1];
                    rr = rectangles2[rectangleIndex + 2] + r;

                    if ((dx*dx + dy*dy) < (rr * rr)) {

                        //if (any) {
                            return false;
                        //}
                    }
                }
            }
        }

        pindex += 4;
    }

    //there is no collision so we can store line label
    pindex = 0;

    for (i = 0, li = points.length; i < li; i++) {

        xx = pbuff[pindex];
        yy = pbuff[pindex+1];
        r = pbuff[pindex+3];

        xx1 = Math.floor((xx-r) * blockSizeFactor);
        yy1 = Math.floor((yy-r) * blockSizeFactor);
        xx2 = Math.floor((xx+r) * blockSizeFactor);
        yy2 = Math.floor((yy+r) * blockSizeFactor);

        if (benevolentMargins) {
            if (xx2 < 0 || xx1 >= llx || yy2 < 0 || yy1 >= lly) {
              pindex += 4;
              continue;
            }
            if (xx1 < 0) xx1 = 0;
            if (yy1 < 0) yy1 = 0;
            if (xx2 >= llx) xx2 = llx - 1;
            if (yy2 >= lly) yy2 = lly - 1;
        }

        const lx = (xx2 - xx1) + 1;
        const ly = (yy2 - yy1) + 1;

        rectangleIndex = this.rectangles2Count;
        rectangles2[rectangleIndex] = xx;
        rectangles2[rectangleIndex+1] = yy;
        rectangles2[rectangleIndex+2] = r;
        rectangles2[rectangleIndex+3] = subjob;
        this.rectangles2Count += 4;

        //test collision
        for (y = 0; y < ly; y++) {
            for (x = 0; x < lx; x++) {
                index = (yy1 + y)*this.lx + (xx1 + x);

                //console.log('' + index);

                //if (typeof this.blocks2[index][this.blocks2RCount[index]] === 'undefined') {
                  //  debugger
                //}

                this.blocks2[index][this.blocks2RCount[index]] = rectangleIndex;
                this.blocks2RCount[index]++;
            }
        }

        pindex += 4;
    }

    return true;
};


RendererRMap.prototype.removeRectangle = function(rectangleIndex) {
    const rectangles = this.rectangles;
    let x1, y1, x2, y2, x, y, i, index,
        blockRectangles, blockRectanglesCount;

    x1 = rectangles[rectangleIndex];
    y1 = rectangles[rectangleIndex+1];
    x2 = rectangles[rectangleIndex+2];
    y2 = rectangles[rectangleIndex+3];

    //store removed rectangels for second pass
    const rectangles2 = this.rectanglesR;
    const rectangles2Count = this.rectanglesRCount;

    rectangles2[rectangles2Count] = x1;
    rectangles2[rectangles2Count+1] = y1;
    rectangles2[rectangles2Count+2] = x2;
    rectangles2[rectangles2Count+3] = y2;
    rectangles2[rectangles2Count+4] = rectangles[rectangleIndex+4];
    rectangles2[rectangles2Count+5] = rectangles[rectangleIndex+5];
    this.rectanglesRCount += 6;

    //remove subjob
    rectangles[rectangleIndex+5] = null;

    let xx1 = Math.floor(x1 * this.blockSizeFactor);
    let yy1 = Math.floor(y1 * this.blockSizeFactor);
    let xx2 = Math.floor(x2 * this.blockSizeFactor);
    let yy2 = Math.floor(y2 * this.blockSizeFactor);

    if (xx1 < 0) xx1 = 0;
    if (xx2 >= this.lx) xx2 = this.lx - 1;

    if (yy1 < 0) yy1 = 0;
    if (yy2 >= this.ly) yy2 = this.ly - 1;

    const lx = (xx2 - xx1) + 1;
    const ly = (yy2 - yy1) + 1;

    for (y = 0; y < ly; y++) {
        for (x = 0; x < lx; x++) {
            index = (yy1 + y)*this.lx + (xx1 + x);

            blockRectangles = this.blocks[index];
            blockRectanglesCount = this.blocksRCount[index];

            for (i = 0; i < blockRectanglesCount; i++) {
                if (blockRectangles[i] == rectangleIndex) {
                    blockRectangles[i] = blockRectangles[blockRectanglesCount - 1];
                    this.blocksRCount[index]--;
                    break;
                }
            }

        }
    }
};

RendererRMap.prototype.processRectangles = function(gpu, gl, renderer, screenPixelSize) {
    const rectangles = this.rectangles;
    const rectangles2 = this.rectangles2;
    const rectanglesR = this.rectanglesR;
    const draw = renderer.gpu.draw;

    // second pass
    // add removed rectangles
    for (let i = 0, li = this.rectanglesRCount; i < li; i+=6) {
        const x1 = rectanglesR[i],
            y1 = rectanglesR[i+1],
            x2 = rectanglesR[i+2],
            y2 = rectanglesR[i+3],
            z = rectanglesR[i+4],
            subjob = rectanglesR[i+5];

        this.addRectangle(x1, y1, x2, y2, z, subjob);
    }

    this.rectanglesRCount = 0;

    //labels
    for (let i = 0, li = this.rectanglesCount; i < li; i+=6) {
        const subjob = rectangles[i+5];

        if (subjob) {
            if (subjob[0].hysteresis) {
                renderer.jobHBuffer[subjob[0].id] = subjob[0];
            } else {
                renderer.drawnJobs++;
                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, subjob, null);
            }
        }
    }

    //line labels
    for (let i = 0, li = this.rectangles2Count; i < li; i+=4) {
        const subjob = rectangles2[i+3];

        if (subjob) {
            const job = subjob[0];

            if (job.hysteresis) {
                renderer.jobHBuffer[job.id] = job;
            } else {
                renderer.drawnJobs++;
                draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, subjob, null);
            }

            const l = job.labelPoints[0][2].length;

            if (l > 0) {
                i += (4 * (l - 1));
            }
        }
    }

    this.clear();
};

/* harmony default export */ __webpack_exports__["default"] = (RendererRMap);


/***/ }),

/***/ "./src/core/utils/math.js":
/*!********************************!*\
  !*** ./src/core/utils/math.js ***!
  \********************************/
/*! exports provided: math */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "math", function() { return math; });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ "./src/core/utils/matrix.js");



//get rid of compiler mess
const mat4 = _matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"];


const math = {};


math.isEqual = function(value, value2, delta) {
    return (Math.abs(value - value2) < delta);
};


math.clamp = function(value, min, max) {
    if (value < min) value = min;
    else if (value > max) value = max;

    return value;
};


math.radians = function(degrees) {
    return degrees * Math.PI / 180;
};


math.degrees = function(radians) {
    return (radians / Math.PI) * 180;
};


math.mix = function(a, b, c) {
    return a + (b - a) * c;
};


math.frustumMatrix = function(left, right, bottom, top, near, far) {
    const w = (right - left);
    const h = (top - bottom);
    const d = (far - near);

    const m = mat4.create([2*near/w, 0, (right+left)/w, 0,
        0, 2*near/h, (top+bottom)/h, 0,
        0, 0, -(far+near)/d, -2*far*near/d,
        0, 0, -1, 0]);

    mat4.transpose(m);
    return m;
};


math.perspectiveMatrix = function(fovy, aspect, near, far) {
    const ymax = near * Math.tan(fovy * Math.PI / 180.0);
    const xmax = ymax * aspect;
    return math.frustumMatrix(-xmax, xmax, -ymax, ymax, near, far);
};


math.orthographicMatrix = function(vsize, aspect, near, far) {
    //vsize *= 0.020;
    const w = vsize* 0.5 * aspect;
    const h = vsize * 0.5;
    const d = (far - near);

    const m = mat4.create([1/w, 0, 0, 0,
        0, 1/h, 0, 0,
        0, 0, -2/d, -((far+near)/d),
        0, 0, 0, 1]);

    mat4.transpose(m);
    return m;
};


math.rotationMatrix = function(axis, angle) {
    const ca = Math.cos(angle), sa = Math.sin(angle);

    /*    const m;
    switch (axis) {
    case 0:
        m = [
            1,  0,  0, 0,
            0, ca,-sa, 0,
            0, sa, ca, 0,
            0,  0,  0, 1 ];
        break;
    case 1:
        m = [
            ca, 0,-sa, 0,
            0, 1,  0,  0,
            sa, 0, ca, 0,
            0, 0,  0, 1 ];
        break;
    default:
        m = [
            ca,-sa, 0, 0,
            sa, ca, 0, 0,
            0,  0,  1, 0,
            0,  0,  0, 1 ];
        break;
    }
    mat4.transpose(m);
    return m; */

    switch (axis) {
    case 0:
        return [
            1,   0,   0,  0,
            0,  ca,  sa,  0,
            0, -sa,  ca,  0,
            0,   0,   0,  1 ];
    case 1:
        return [
             ca,  0,  sa,  0,
              0,  1,   0,  0,
            -sa,  0,  ca,  0,
              0,  0,   0,  1 ];
    default:
        return [
             ca, sa,  0,  0,
            -sa, ca,  0,  0,
              0,  0,  1,  0,
              0,  0,  0,  1 ];
    }

};


math.scaleMatrix = function(sx, sy, sz) {
    /*const m = [
        sx,  0,  0, 0,
        0, sy,  0, 0,
        0,  0, sz, 0,
        0,  0,  0, 1 ];

    mat4.transpose(m);
    return m;*/
    return [
        sx,   0,   0,   0,
        0,   sy,   0,   0,
        0,    0,  sz,   0,
        0,    0,   0,   1 ];
};


math.scaleMatrixf = function(s) {
    return math.scaleMatrix(s, s, s);
};


math.translationMatrix = function(tx, ty, tz) {
    /*
    const m = [
        1, 0, 0, tx,
        0, 1, 0, ty,
        0, 0, 1, tz,
        0, 0, 0, 1 ];

    mat4.transpose(m);
    */

    return [
        1,   0,  0,  0,
        0,   1,  0,  0,
        0,   0,  1,  0,
        tx, ty, tz,  1 ];
};


math.translationMatrix2f = function(t) {
    return math.translationMatrix(t[0], t[1], 0);
};


math.translationMatrix3f = function(t) {
    return math.translationMatrix(t[0], t[1], t[2]);
};





/***/ }),

/***/ "./src/core/utils/matrix.js":
/*!**********************************!*\
  !*** ./src/core/utils/matrix.js ***!
  \**********************************/
/*! exports provided: vec2, vec3, vec4, mat3, mat4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return vec2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return vec3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return vec4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return mat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return mat4; });

const vec2 = {};


vec2.create = function (a) {
    const b = new Array(2);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
    }
    return b;
};


const vec4 = {};


vec4.create = function (a) {
    const b = new Array(4);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
    }
    return b;
};


vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};


vec4.dot2 = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3];
};


vec4.dot3 = function (a, b, i, x, y, z) {
    return a[0] * (b[i]-x) + a[1] * (b[i+1]-y) + a[2] * (b[i+2]-z) + a[3];
};


const vec3 = {};


vec3.create = function (a) {
    const b = new Array(3);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
    }
    return b;
};


vec3.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    return b;
};


vec3.add = function (a, b, c) {
    if (!c || a == c) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
        return a;
    }
    c[0] = a[0] + b[0];
    c[1] = a[1] + b[1];
    c[2] = a[2] + b[2];
    return c;
};


vec3.subtract = function (a, b, c) {
    if (!c || a == c) {
        a[0] -= b[0];
        a[1] -= b[1];
        a[2] -= b[2];
        return a;
    }
    c[0] = a[0] - b[0];
    c[1] = a[1] - b[1];
    c[2] = a[2] - b[2];
    return c;
};


vec3.negate = function (a, b) {
    b || (b = a);
    b[0] = -a[0];
    b[1] = -a[1];
    b[2] = -a[2];
    return b;
};


vec3.scale = function (a, b, c) {
    if (!c || a == c) {
        a[0] *= b;
        a[1] *= b;
        a[2] *= b;
        return a;
    }
    c[0] = a[0] * b;
    c[1] = a[1] * b;
    c[2] = a[2] * b;
    return c;
};


vec3.normalize = function (a, b) {
    b || (b = a);
    const c = a[0],
        d = a[1],
        e = a[2];
    let g = Math.sqrt(c * c + d * d + e * e);

    if (g) {
        if (g == 1) {
            b[0] = c;
            b[1] = d;
            b[2] = e;
            return b;
        }
    } else {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        return b;
    }
    g = 1 / g;
    b[0] = c * g;
    b[1] = d * g;
    b[2] = e * g;
    return b;
};


vec3.normalize2 = function (a, i, b) {
    const c = a[i],
        d = a[i+1],
        e = a[i+2];
    let g = Math.sqrt(c * c + d * d + e * e);

    if (g) {
        if (g == 1) {
            b[0] = c;
            b[1] = d;
            b[2] = e;
            return b;
        }
    } else {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        return b;
    }
    g = 1 / g;
    b[0] = c * g;
    b[1] = d * g;
    b[2] = e * g;
};


vec3.normalize3 = function (a, i, b, j) {
    const c = a[i],
        d = a[i+1],
        e = a[i+2];
    let g = Math.sqrt(c * c + d * d + e * e);

    if (g) {
        if (g == 1) {
            b[j] = c;
            b[j+1] = d;
            b[j+2] = e;
            return b;
        }
    } else {
        b[j] = 0;
        b[j+1] = 0;
        b[j+2] = 0;
        return b;
    }
    g = 1 / g;
    b[j] = c * g;
    b[j+1] = d * g;
    b[j+2] = e * g;
};


vec3.normalize4 = function (a, b) {
    b || (b = a);
    const c = a[0],
        d = a[1],
        e = a[2];
    let g = Math.sqrt(c * c + d * d + e * e);

    if (g) {
        if (g == 1) {
            b[0] = c;
            b[1] = d;
            b[2] = e;
            return b;
        }
    } else {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        return b;
    }
    const dd = g;
    g = 1 / g;
    b[0] = c * g;
    b[1] = d * g;
    b[2] = e * g;
    return dd;
};


vec3.cross = function (a, b, c) {
    c || (c = a);
    const d = a[0],
        e = a[1];
    a = a[2];
    const g = b[0],
        f = b[1];
    b = b[2];
    c[0] = e * b - a * f;
    c[1] = a * g - d * b;
    c[2] = d * f - e * g;
    return c;
};


vec3.length = function (a) {
    const b = a[0],
        c = a[1];
    a = a[2];
    return Math.sqrt(b * b + c * c + a * a);
};


vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};


vec3.dot2 = function (a, b, i) {
    return a[0] * b[i] + a[1] * b[i+1] + a[2] * b[i+2];
};


vec3.dot3 = function (a, i, b, j) {
    return a[i] * b[j] + a[i+1] * b[j+1] + a[i+2] * b[j+2];
};

vec3.distance = function (a, b) {
    const dx = b[0] - a[0];
    const dy = b[1] - a[1];
    const dz = b[2] - a[2];
    return Math.sqrt(dx*dx + dy*dy + dz*dz);
};

vec3.distance2 = function (a, i, b, j) {
    const dx = b[j] - a[i];
    const dy = b[j+1] - a[i+1];
    const dz = b[j+2] - a[i+2];
    return Math.sqrt(dx*dx + dy*dy + dz*dz);
};


vec3.squareDistance = function (a, b) {
    const dx = b[0] - a[0];
    const dy = b[1] - a[1];
    const dz = b[2] - a[2];
    return dx*dx + dy*dy + dz*dz;
};


vec3.direction = function (a, b, c) {
    c || (c = a);
    const d = a[0] - b[0],
          e = a[1] - b[1];
    a = a[2] - b[2];
    b = Math.sqrt(d * d + e * e + a * a);
    if (!b) {
        c[0] = 0;
        c[1] = 0;
        c[2] = 0;
        return c;
    }
    b = 1 / b;
    c[0] = d * b;
    c[1] = e * b;
    c[2] = a * b;
    return c;
};


vec3.lerp = function (a, b, c, d) {
    d || (d = a);
    d[0] = a[0] + c * (b[0] - a[0]);
    d[1] = a[1] + c * (b[1] - a[1]);
    d[2] = a[2] + c * (b[2] - a[2]);
    return d;
};


vec3.str = function (a) {
    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ']';
};


const mat3 = {};


mat3.create = function (a) {
    const b = new Array(9);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        b[4] = a[4];
        b[5] = a[5];
        b[6] = a[6];
        b[7] = a[7];
        b[8] = a[8];
        b[9] = a[9];
    }
    return b;
};


mat3.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];
    b[6] = a[6];
    b[7] = a[7];
    b[8] = a[8];
    return b;
};


mat3.identity = function (a) {
    a[0] = 1;
    a[1] = 0;
    a[2] = 0;
    a[3] = 0;
    a[4] = 1;
    a[5] = 0;
    a[6] = 0;
    a[7] = 0;
    a[8] = 1;
    return a;
};


mat3.transpose = function (a, b) {
    if (!b || a == b) {
        const c = a[1],
            d = a[2],
            e = a[5];
        a[1] = a[3];
        a[2] = a[6];
        a[3] = c;
        a[5] = a[7];
        a[6] = d;
        a[7] = e;
        return a;
    }
    b[0] = a[0];
    b[1] = a[3];
    b[2] = a[6];
    b[3] = a[1];
    b[4] = a[4];
    b[5] = a[7];
    b[6] = a[2];
    b[7] = a[5];
    b[8] = a[8];
    return b;
};


mat3.toMat4 = function (a, b) {
    b || (b = mat4.create());
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = 0;
    b[4] = a[3];
    b[5] = a[4];
    b[6] = a[5];
    b[7] = 0;
    b[8] = a[6];
    b[9] = a[7];
    b[10] = a[8];
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return b;
};

mat3.multiplyVec3 = function (a, b, c) {
    c || (c = b);
    const d = b[0],
        e = b[1];
    b = b[2];
    c[0] = a[0] * d + a[3] * e + a[6] * b;
    c[1] = a[1] * d + a[4] * e + a[7] * b;
    c[2] = a[2] * d + a[5] * e + a[8] * b;
    return c;
};


mat3.str = function (a) {
    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ']';
};


const mat4 = {};


mat4.create = function (a) {
    const b = new Array(16);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        b[4] = a[4];
        b[5] = a[5];
        b[6] = a[6];
        b[7] = a[7];
        b[8] = a[8];
        b[9] = a[9];
        b[10] = a[10];
        b[11] = a[11];
        b[12] = a[12];
        b[13] = a[13];
        b[14] = a[14];
        b[15] = a[15];
    }
    return b;
};


mat4.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];
    b[6] = a[6];
    b[7] = a[7];
    b[8] = a[8];
    b[9] = a[9];
    b[10] = a[10];
    b[11] = a[11];
    b[12] = a[12];
    b[13] = a[13];
    b[14] = a[14];
    b[15] = a[15];
    return b;
};


mat4.identity = function (a) {
    a[0] = 1;
    a[1] = 0;
    a[2] = 0;
    a[3] = 0;
    a[4] = 0;
    a[5] = 1;
    a[6] = 0;
    a[7] = 0;
    a[8] = 0;
    a[9] = 0;
    a[10] = 1;
    a[11] = 0;
    a[12] = 0;
    a[13] = 0;
    a[14] = 0;
    a[15] = 1;
    return a;
};


mat4.transpose = function (a, b) {
    if (!b || a == b) {
        const c = a[1],
            d = a[2],
            e = a[3],
            g = a[6],
            f = a[7],
            h = a[11];
        a[1] = a[4];
        a[2] = a[8];
        a[3] = a[12];
        a[4] = c;
        a[6] = a[9];
        a[7] = a[13];
        a[8] = d;
        a[9] = g;
        a[11] = a[14];
        a[12] = e;
        a[13] = f;
        a[14] = h;
        return a;
    }
    b[0] = a[0];
    b[1] = a[4];
    b[2] = a[8];
    b[3] = a[12];
    b[4] = a[1];
    b[5] = a[5];
    b[6] = a[9];
    b[7] = a[13];
    b[8] = a[2];
    b[9] = a[6];
    b[10] = a[10];
    b[11] = a[14];
    b[12] = a[3];
    b[13] = a[7];
    b[14] = a[11];
    b[15] = a[15];
    return b;
};


mat4.determinant = function (a) {
    const b = a[0],
        c = a[1],
        d = a[2],
        e = a[3],
        g = a[4],
        f = a[5],
        h = a[6],
        i = a[7],
        j = a[8],
        k = a[9],
        l = a[10],
        o = a[11],
        m = a[12],
        n = a[13],
        p = a[14];
    a = a[15];
    return m * k * h * e - j * n * h * e - m * f * l * e + g * n * l * e + j * f * p * e - g * k * p * e - m * k * d * i + j * n * d * i + m * c * l * i - b * n * l * i - j * c * p * i + b * k * p * i + m * f * d * o - g * n * d * o - m * c * h * o + b * n * h * o + g * c * p * o - b * f * p * o - j * f * d * a + g * k * d * a + j * c * h * a - b * k * h * a - g * c * l * a + b * f * l * a;
};


mat4.inverse = function (a, b) {
    b || (b = a);
    const c = a[0],
        d = a[1],
        e = a[2],
        g = a[3],
        f = a[4],
        h = a[5],
        i = a[6],
        j = a[7],
        k = a[8],
        l = a[9],
        o = a[10],
        m = a[11],
        n = a[12],
        p = a[13],
        r = a[14],
        s = a[15],
        A = c * h - d * f,
        B = c * i - e * f,
        t = c * j - g * f,
        u = d * i - e * h,
        v = d * j - g * h,
        w = e * j - g * i,
        x = k * p - l * n,
        y = k * r - o * n,
        z = k * s - m * n,
        C = l * r - o * p,
        D = l * s - m * p,
        E = o * s - m * r,
        q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x);
    b[0] = (h * E - i * D + j * C) * q;
    b[1] = (-d * E + e * D - g * C) * q;
    b[2] = (p * w - r * v + s * u) * q;
    b[3] = (-l * w + o * v - m * u) * q;
    b[4] = (-f * E + i * z - j * y) * q;
    b[5] = (c * E - e * z + g * y) * q;
    b[6] = (-n * w + r * t - s * B) * q;
    b[7] = (k * w - o * t + m * B) * q;
    b[8] = (f * D - h * z + j * x) * q;
    b[9] = (-c * D + d * z - g * x) * q;
    b[10] = (n * v - p * t + s * A) * q;
    b[11] = (-k * v + l * t - m * A) * q;
    b[12] = (-f * C + h * y - i * x) * q;
    b[13] = (c * C - d * y + e * x) * q;
    b[14] = (-n * u + p * B - r * A) * q;
    b[15] = (k * u - l * B + o * A) * q;
    return b;
};


mat4.toRotationMat = function (a, b) {
    b || (b = mat4.create());
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];
    b[6] = a[6];
    b[7] = a[7];
    b[8] = a[8];
    b[9] = a[9];
    b[10] = a[10];
    b[11] = a[11];
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return b;
};


mat4.toMat3 = function (a, b) {
    b || (b = mat3.create());
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[4];
    b[4] = a[5];
    b[5] = a[6];
    b[6] = a[8];
    b[7] = a[9];
    b[8] = a[10];
    return b;
};


mat4.toInverseMat3 = function (a, b) {
    const c = a[0],
        d = a[1],
        e = a[2],
        g = a[4],
        f = a[5],
        h = a[6],
        i = a[8],
        j = a[9],
        k = a[10],
        l = k * f - h * j,
        o = -k * g + h * i,
        m = j * g - f * i;
    let n = c * l + d * o + e * m;
    if (!n) return null;
    n = 1 / n;
    b || (b = mat3.create());
    b[0] = l * n;
    b[1] = (-k * d + e * j) * n;
    b[2] = (h * d - e * f) * n;
    b[3] = o * n;
    b[4] = (k * c - e * i) * n;
    b[5] = (-h * c + e * g) * n;
    b[6] = m * n;
    b[7] = (-j * c + d * i) * n;
    b[8] = (f * c - d * g) * n;
    return b;
};


mat4.multiply = function (a, b, c) {
    c || (c = a);
    const d = a[0],
        e = a[1],
        g = a[2],
        f = a[3],
        h = a[4],
        i = a[5],
        j = a[6],
        k = a[7],
        l = a[8],
        o = a[9],
        m = a[10],
        n = a[11],
        p = a[12],
        r = a[13],
        s = a[14];
    a = a[15];
    const A = b[0],
        B = b[1],
        t = b[2],
        u = b[3],
        v = b[4],
        w = b[5],
        x = b[6],
        y = b[7],
        z = b[8],
        C = b[9],
        D = b[10],
        E = b[11],
        q = b[12],
        F = b[13],
        G = b[14];
    b = b[15];
    c[0] = A * d + B * h + t * l + u * p;
    c[1] = A * e + B * i + t * o + u * r;
    c[2] = A * g + B * j + t * m + u * s;
    c[3] = A * f + B * k + t * n + u * a;
    c[4] = v * d + w * h + x * l + y * p;
    c[5] = v * e + w * i + x * o + y * r;
    c[6] = v * g + w * j + x * m + y * s;
    c[7] = v * f + w * k + x * n + y * a;
    c[8] = z * d + C * h + D * l + E * p;
    c[9] = z * e + C * i + D * o + E * r;
    c[10] = z * g + C * j + D * m + E * s;
    c[11] = z * f + C * k + D * n + E * a;
    c[12] = q * d + F * h + G * l + b * p;
    c[13] = q * e + F * i + G * o + b * r;
    c[14] = q * g + F * j + G * m + b * s;
    c[15] = q * f + F * k + G * n + b * a;
    return c;
};


mat4.multiplyVec3 = function (a, b, c) {
    c || (c = b);
    const d = b[0],
        e = b[1];
    b = b[2];
    c[0] = a[0] * d + a[4] * e + a[8] * b + a[12];
    c[1] = a[1] * d + a[5] * e + a[9] * b + a[13];
    c[2] = a[2] * d + a[6] * e + a[10] * b + a[14];
    return c;
};


mat4.multiplyVec4 = function (a, b, c) {
    c || (c = b);
    const d = b[0],
        e = b[1],
        g = b[2];
    b = b[3];
    c[0] = a[0] * d + a[4] * e + a[8] * g + a[12] * b;
    c[1] = a[1] * d + a[5] * e + a[9] * g + a[13] * b;
    c[2] = a[2] * d + a[6] * e + a[10] * g + a[14] * b;
    c[3] = a[3] * d + a[7] * e + a[11] * g + a[15] * b;
    return c;
};


mat4.translate = function (a, b, c) {
    const d = b[0],
        e = b[1];
    b = b[2];
    if (!c || a == c) {
        a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];
        a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];
        a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];
        a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];
        return a;
    }
    const g = a[0],
        f = a[1],
        h = a[2],
        i = a[3],
        j = a[4],
        k = a[5],
        l = a[6],
        o = a[7],
        m = a[8],
        n = a[9],
        p = a[10],
        r = a[11];
    c[0] = g;
    c[1] = f;
    c[2] = h;
    c[3] = i;
    c[4] = j;
    c[5] = k;
    c[6] = l;
    c[7] = o;
    c[8] = m;
    c[9] = n;
    c[10] = p;
    c[11] = r;
    c[12] = g * d + j * e + m * b + a[12];
    c[13] = f * d + k * e + n * b + a[13];
    c[14] = h * d + l * e + p * b + a[14];
    c[15] = i * d + o * e + r * b + a[15];
    return c;
};


mat4.scale = function (a, b, c) {
    const d = b[0],
        e = b[1];
    b = b[2];
    if (!c || a == c) {
        a[0] *= d;
        a[1] *= d;
        a[2] *= d;
        a[3] *= d;
        a[4] *= e;
        a[5] *= e;
        a[6] *= e;
        a[7] *= e;
        a[8] *= b;
        a[9] *= b;
        a[10] *= b;
        a[11] *= b;
        return a;
    }
    c[0] = a[0] * d;
    c[1] = a[1] * d;
    c[2] = a[2] * d;
    c[3] = a[3] * d;
    c[4] = a[4] * e;
    c[5] = a[5] * e;
    c[6] = a[6] * e;
    c[7] = a[7] * e;
    c[8] = a[8] * b;
    c[9] = a[9] * b;
    c[10] = a[10] * b;
    c[11] = a[11] * b;
    c[12] = a[12];
    c[13] = a[13];
    c[14] = a[14];
    c[15] = a[15];
    return c;
};


mat4.rotate = function (a, b, c, d) {
    let e = c[0],
        g = c[1];
    c = c[2];
    let f = Math.sqrt(e * e + g * g + c * c);
    if (!f) return null;
    if (f != 1) {
        f = 1 / f;
        e *= f;
        g *= f;
        c *= f;
    }
    const h = Math.sin(b),
        i = Math.cos(b),
        j = 1 - i;
    b = a[0];
    f = a[1];
    const k = a[2],
        l = a[3],
        o = a[4],
        m = a[5],
        n = a[6],
        p = a[7],
        r = a[8],
        s = a[9],
        A = a[10],
        B = a[11],
        t = e * e * j + i,
        u = g * e * j + c * h,
        v = c * e * j - g * h,
        w = e * g * j - c * h,
        x = g * g * j + i,
        y = c * g * j + e * h,
        z = e * c * j + g * h;
    e = g * c * j - e * h;
    g = c * c * j + i;
    if (d) {
        if (a != d) {
            d[12] = a[12];
            d[13] = a[13];
            d[14] = a[14];
            d[15] = a[15];
        }
    } else d = a;
    d[0] = b * t + o * u + r * v;
    d[1] = f * t + m * u + s * v;
    d[2] = k * t + n * u + A * v;
    d[3] = l * t + p * u + B * v;
    d[4] = b * w + o * x + r * y;
    d[5] = f * w + m * x + s * y;
    d[6] = k * w + n * x + A * y;
    d[7] = l * w + p * x + B * y;
    d[8] = b * z + o * e + r * g;
    d[9] = f * z + m * e + s * g;
    d[10] = k * z + n * e + A * g;
    d[11] = l * z + p * e + B * g;
    return d;
};


mat4.rotateX = function (a, b, c) {
    const d = Math.sin(b);
    b = Math.cos(b);
    const e = a[4],
        g = a[5],
        f = a[6],
        h = a[7],
        i = a[8],
        j = a[9],
        k = a[10],
        l = a[11];
    if (c) {
        if (a != c) {
            c[0] = a[0];
            c[1] = a[1];
            c[2] = a[2];
            c[3] = a[3];
            c[12] = a[12];
            c[13] = a[13];
            c[14] = a[14];
            c[15] = a[15];
        }
    } else c = a;
    c[4] = e * b + i * d;
    c[5] = g * b + j * d;
    c[6] = f * b + k * d;
    c[7] = h * b + l * d;
    c[8] = e * -d + i * b;
    c[9] = g * -d + j * b;
    c[10] = f * -d + k * b;
    c[11] = h * -d + l * b;
    return c;
};


mat4.rotateY = function (a, b, c) {
    const d = Math.sin(b);
    b = Math.cos(b);
    const e = a[0],
        g = a[1],
        f = a[2],
        h = a[3],
        i = a[8],
        j = a[9],
        k = a[10],
        l = a[11];
    if (c) {
        if (a != c) {
            c[4] = a[4];
            c[5] = a[5];
            c[6] = a[6];
            c[7] = a[7];
            c[12] = a[12];
            c[13] = a[13];
            c[14] = a[14];
            c[15] = a[15];
        }
    } else c = a;
    c[0] = e * b + i * -d;
    c[1] = g * b + j * -d;
    c[2] = f * b + k * -d;
    c[3] = h * b + l * -d;
    c[8] = e * d + i * b;
    c[9] = g * d + j * b;
    c[10] = f * d + k * b;
    c[11] = h * d + l * b;
    return c;
};


mat4.rotateZ = function (a, b, c) {
    const d = Math.sin(b);
    b = Math.cos(b);
    const e = a[0],
        g = a[1],
        f = a[2],
        h = a[3],
        i = a[4],
        j = a[5],
        k = a[6],
        l = a[7];
    if (c) {
        if (a != c) {
            c[8] = a[8];
            c[9] = a[9];
            c[10] = a[10];
            c[11] = a[11];
            c[12] = a[12];
            c[13] = a[13];
            c[14] = a[14];
            c[15] = a[15];
        }
    } else c = a;
    c[0] = e * b + i * d;
    c[1] = g * b + j * d;
    c[2] = f * b + k * d;
    c[3] = h * b + l * d;
    c[4] = e * -d + i * b;
    c[5] = g * -d + j * b;
    c[6] = f * -d + k * b;
    c[7] = h * -d + l * b;
    return c;
};


mat4.frustum = function (a, b, c, d, e, g, f) {
    f || (f = mat4.create());
    const h = b - a,
        i = d - c,
        j = g - e;
    f[0] = e * 2 / h;
    f[1] = 0;
    f[2] = 0;
    f[3] = 0;
    f[4] = 0;
    f[5] = e * 2 / i;
    f[6] = 0;
    f[7] = 0;
    f[8] = (b + a) / h;
    f[9] = (d + c) / i;
    f[10] = -(g + e) / j;
    f[11] = -1;
    f[12] = 0;
    f[13] = 0;
    f[14] = -(g * e * 2) / j;
    f[15] = 0;
    return f;
};


mat4.perspective = function (a, b, c, d, e) {
    a = c * Math.tan(a * Math.PI / 360);
    b = a * b;
    return mat4.frustum(-b, b, -a, a, c, d, e);
};


mat4.ortho = function (a, b, c, d, e, g, f) {
    f || (f = mat4.create());
    const h = b - a,
        i = d - c,
        j = g - e;
    f[0] = 2 / h;
    f[1] = 0;
    f[2] = 0;
    f[3] = 0;
    f[4] = 0;
    f[5] = 2 / i;
    f[6] = 0;
    f[7] = 0;
    f[8] = 0;
    f[9] = 0;
    f[10] = -2 / j;
    f[11] = 0;
    f[12] = -(a + b) / h;
    f[13] = -(d + c) / i;
    f[14] = -(g + e) / j;
    f[15] = 1;
    return f;
};


mat4.lookAt = function (a, b, c, d) {
    d || (d = mat4.create());
    let e = a[0],
        g = a[1];
    a = a[2];
    let f = c[0],
        h = c[1],
        i = c[2];
    c = b[1];
    let j = b[2];
    if (e == b[0] && g == c && a == j) return mat4.identity(d);
    let k, l, o, m;
    c = e - b[0];
    j = g - b[1];
    b = a - b[2];
    m = 1 / Math.sqrt(c * c + j * j + b * b);
    c *= m;
    j *= m;
    b *= m;
    k = h * b - i * j;
    i = i * c - f * b;
    f = f * j - h * c;
    m = Math.sqrt(k * k + i * i + f * f);
    if (m) {
        m = 1 / m;
        k *= m;
        i *= m;
        f *= m;
    } else f = i = k = 0;
    h = j * f - b * i;
    l = b * k - c * f;
    o = c * i - j * k;
    m = Math.sqrt(h * h + l * l + o * o);
    if (m) {
        m = 1 / m;
        h *= m;
        l *= m;
        o *= m;
    } else o = l = h = 0;
    d[0] = k;
    d[1] = h;
    d[2] = c;
    d[3] = 0;
    d[4] = i;
    d[5] = l;
    d[6] = j;
    d[7] = 0;
    d[8] = f;
    d[9] =
        o;
    d[10] = b;
    d[11] = 0;
    d[12] = -(k * e + i * g + f * a);
    d[13] = -(h * e + l * g + o * a);
    d[14] = -(c * e + j * g + b * a);
    d[15] = 1;
    return d;
};


mat4.str = function (a) {
    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ']';
};


const quat4 = {};


quat4.create = function (a) {
    const b = new Array(4);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
    }
    return b;
};


quat4.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    return b;
};


quat4.calculateW = function (a, b) {
    const c = a[0],
        d = a[1],
        e = a[2];
    if (!b || a == b) {
        a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));
        return a;
    }
    b[0] = c;
    b[1] = d;
    b[2] = e;
    b[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));
    return b;
};


quat4.inverse = function (a, b) {
    if (!b || a == b) {
        a[0] *= 1;
        a[1] *= 1;
        a[2] *= 1;
        return a;
    }
    b[0] = -a[0];
    b[1] = -a[1];
    b[2] = -a[2];
    b[3] = a[3];
    return b;
};


quat4.length = function (a) {
    const b = a[0],
        c = a[1],
        d = a[2];
    a = a[3];
    return Math.sqrt(b * b + c * c + d * d + a * a);
};


quat4.normalize = function (a, b) {
    b || (b = a);
    const c = a[0],
        d = a[1],
        e = a[2],
        g = a[3];
    let f = Math.sqrt(c * c + d * d + e * e + g * g);
    if (f == 0) {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        b[3] = 0;
        return b;
    }
    f = 1 / f;
    b[0] = c * f;
    b[1] = d * f;
    b[2] = e * f;
    b[3] = g * f;
    return b;
};


quat4.multiply = function (a, b, c) {
    c || (c = a);
    const d = a[0],
        e = a[1],
        g = a[2];
    a = a[3];
    const f = b[0],
        h = b[1],
        i = b[2];
    b = b[3];
    c[0] = d * b + a * f + e * i - g * h;
    c[1] = e * b + a * h + g * f - d * i;
    c[2] = g * b + a * i + d * h - e * f;
    c[3] = a * b - d * f - e * h - g * i;
    return c;
};


quat4.multiplyVec3 = function (a, b, c) {
    c || (c = b);
    let d = b[0];
    const e = b[1],
        g = b[2];
    b = a[0];
    const f = a[1],
        h = a[2];
    a = a[3];
    const i = a * d + f * g - h * e,
        j = a * e + h * d - b * g,
        k = a * g + b * e - f * d;
    d = -b * d - f * e - h * g;
    c[0] = i * a + d * -b + j * -h - k * -f;
    c[1] = j * a + d * -f + k * -b - i * -h;
    c[2] = k * a + d * -h + i * -f - j * -b;
    return c;
};


quat4.toMat3 = function (a, b) {
    b || (b = mat3.create());
    let c = a[0],
        d = a[1],
        e = a[2],
        g = a[3],
        f = c + c,
        h = d + d,
        i = e + e,
        j = c * f,
        k = c * h;
    c = c * i;
    const l = d * h;
    d = d * i;
    e = e * i;
    f = g * f;
    h = g * h;
    g = g * i;
    b[0] = 1 - (l + e);
    b[1] = k - g;
    b[2] = c + h;
    b[3] = k + g;
    b[4] = 1 - (j + e);
    b[5] = d - f;
    b[6] = c - h;
    b[7] = d + f;
    b[8] = 1 - (j + l);
    return b;
};


quat4.toMat4 = function (a, b) {
    b || (b = mat4.create());
    let c = a[0],
        d = a[1],
        e = a[2],
        g = a[3],
        f = c + c,
        h = d + d,
        i = e + e,
        j = c * f,
        k = c * h;
    c = c * i;
    const l = d * h;
    d = d * i;
    e = e * i;
    f = g * f;
    h = g * h;
    g = g * i;
    b[0] = 1 - (l + e);
    b[1] = k - g;
    b[2] = c + h;
    b[3] = 0;
    b[4] = k + g;
    b[5] = 1 - (j + e);
    b[6] = d - f;
    b[7] = 0;
    b[8] = c - h;
    b[9] = d + f;
    b[10] = 1 - (j + l);
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return b;
};


quat4.slerp = function (a, b, c, d) {
    d || (d = a);
    let e = c;
    if (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3] < 0) e = -1 * c;
    d[0] = 1 - c * a[0] + e * b[0];
    d[1] = 1 - c * a[1] + e * b[1];
    d[2] = 1 - c * a[2] + e * b[2];
    d[3] = 1 - c * a[3] + e * b[3];
    return d;
};


quat4.str = function (a) {
    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ']';
};




/***/ }),

/***/ "./src/core/utils/platform.js":
/*!************************************!*\
  !*** ./src/core/utils/platform.js ***!
  \************************************/
/*! exports provided: platform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "platform", function() { return platform; });

const platform = {

    initialized : false,

    init: function () {

        const self = platform;

        self.browser = self.searchString(self.dataBrowser) || 'An unknown browser';
        self.version = self.searchVersion(navigator.userAgent.toLowerCase()) || self.searchVersion(navigator.appVersion) || 'an unknown version';
        self.OS = self.searchString(self.dataOS) || 'an unknown os: ua: ' + navigator.userAgent + ' pl: ' + navigator.platform;

        self.mobile = (self.OS == 'iphone/ipod' || self.OS == 'android' || self.OS == 'ipad' || self.OS == 'windows ce'  || self.OS == 'windows phone' || self.OS == 'kindle');
        self.mobileAndroid = (self.OS == 'android');
        self.initialized = true;
    },

    getBrowser : function() {
        if(!platform.initialized) { platform.init(); }
        return platform.browser;
    },

    getBrowserVersion : function() {
        if(!platform.initialized) { platform.init(); }
        return platform.browser;
    },

    getOS : function() {
        if(!platform.initialized) { platform.init(); }
        return platform.OS;
    },

    isMobile : function() {
        if(!platform.initialized) { platform.init(); }
        return platform.mobile;
    },

    isAndroid : function() {
        if(!platform.initialized) { platform.init(); }
        return platform.mobileAndroid;
    },

    searchString: function (data) {
        const self = platform;
        for (let i = 0; i < data.length; i++) {
            const dataString = data[i].string;
            const dataProp = data[i].prop;
            self.versionSearchString = data[i].versionSearch || data[i].identity;

            if (dataString) {
                if (dataString.toLowerCase().indexOf(data[i].subString) != -1) {
                    if (data[i].version != null) {
                        self.version = data[i].version;
                    }
                    return data[i].identity;
                }
            } else if (dataProp) {
                return data[i].identity;
            }
        }
    },

    searchVersion: function (dataString) {
        const self = platform;
        if (self.version != null) {
            return self.version;
        }
        const index = dataString.indexOf(self.versionSearchString);
        if (index == -1) return;
        return parseFloat(dataString.substring(index+self.versionSearchString.length+1));
    },

    dataBrowser: [
        {
            string: navigator.userAgent,
            subString: 'chrome',
            identity: 'chrome'
        },
        {
            string: navigator.userAgent,
            subString: 'firefox',
            identity: 'firefox'
        },
        {
            string: navigator.vendor,
            subString: 'apple',
            identity: 'safari',
            versionSearch: 'version'
        },
        {
            prop: window.opera,
            identity: 'opera',
            versionSearch: 'version'
        },
        {
            string: navigator.vendor,
            subString: 'icab',
            identity: 'icab'
        },
        {
            string: navigator.vendor,
            subString: 'kde',
            identity: 'konqueror'
        },
        {
            string: navigator.vendor,
            subString: 'camino',
            identity: 'camino'
        },
        {       // for newer Netscapes (6+)
            string: navigator.userAgent,
            subString: 'netscape',
            identity: 'netscape'
        },
        {
            string: navigator.userAgent,
            subString: 'msie',
            identity: 'explorer',
            versionSearch: 'msie'
        },
        {
            string: navigator.userAgent,
            subString: 'trident/',
            identity: 'explorer',
            version: '11'
        },
        {
            string: navigator.userAgent,
            subString: 'edge/',
            identity: 'explorer',
            version: '12'
        },
        {   string: navigator.userAgent,
            subString: 'omniweb',
            versionSearch: 'omniweb/',
            identity: 'omniweb'
        },
        {   string: navigator.userAgent,
            subString: 'silk',
            versionSearch: 'silk/',
            identity: 'silk'
        },
        {
            string: navigator.userAgent,
            subString: 'gecko',
            identity: 'mozilla',
            versionSearch: 'rv'
        },
        {       // for older Netscapes (4-)
            string: navigator.userAgent,
            subString: 'mozilla',
            identity: 'netscape',
            versionSearch: 'mozilla'
        }
    ],

    dataOS : [
        {
            string: navigator.userAgent,
            subString: 'windows ce',
            identity: 'windows ce'
        },
        {
            string: navigator.userAgent,
            subString: 'windows phone',
            identity: 'windows phone'
        },
        {
            string: navigator.platform,
            subString: 'win',
            identity: 'windows'
        },
        {
            string: navigator.platform,
            subString: 'mac',
            identity: 'mac'
        },
        {
            string: navigator.userAgent,
            subString: 'iphone',
            identity: 'iphone/ipod'
        },
        {
            string: navigator.userAgent,
            subString: 'ipod',
            identity: 'iphone/ipod'
        },
        {
            string: navigator.userAgent,
            subString: 'ipad',
            identity: 'ipad'
        },
        {
            string: navigator.userAgent,
            subString: 'android',
            identity: 'android'
        },
        {
            string: navigator.userAgent,
            subString: 'silk',
            identity: 'kindle'
        },
        {
            string: navigator.userAgent,
            subString: 'blackberry',
            identity: 'blackberry'
        },
        {
            string: navigator.platform,
            subString: 'linux',
            identity: 'linux'
        }
    ]

};




/***/ }),

/***/ "./src/core/utils/url.js":
/*!*******************************!*\
  !*** ./src/core/utils/url.js ***!
  \*******************************/
/*! exports provided: utilsUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilsUrl", function() { return utilsUrl; });

const utilsUrl = {};


utilsUrl.isSameOrigin = function(url) {
    if (typeof url !== 'string') {
        return false;
    }
    const docHost = document.location.hostname;
    const parser = utilsUrl.parse(url);
    return parser['hostname'] === docHost;
};


utilsUrl.parse = function(url) {
    if (typeof url !== 'string') {
        return null;
    }

    const parser = document.createElement('a');
    parser['href'] = url;
    return parser;
};


utilsUrl.getParamsFromUrl = function(url) {
    const parser = utilsUrl.parse(url);
    const queryString = {};
    const query = parser['search'].substring(1);
    const vars = query.split('&');
    if (!(vars.length == 1 && vars[0] == '')) {
        for (let i = 0; i < vars.length; i++) {
            const pair = vars[i].split('=');
            if (typeof queryString[pair[0]] === 'undefined') {
                queryString[pair[0]] = pair[1];
            } else if (typeof queryString[pair[0]] === 'string') {
                const arr = [ queryString[pair[0]], pair[1] ];
                queryString[pair[0]] = arr;
            } else {
                queryString[pair[0]].push(pair[1]);
            }
        }
    }
    return queryString;
};


utilsUrl.getHost = function(url) {
    const location = document.createElement('a');
    location.href = url;
    return location.hostname;
};


utilsUrl.getSchema = function(url) {
    //if (window.location.href.indexOf("file://") != -1) {
    if (url.indexOf('http://') != -1) {
        return 'http:';
    } else if (url.indexOf('https://') != -1) {
        return 'https:';
    } else {
        const location = document.createElement('a');
        location.href = url;
        return location.protocol;
    }
};


utilsUrl.getOrigin = function(url) {
    const location = document.createElement('a');
    location.href = url;

    if (!location.origin) {  //IE11 hack
      return location.protocol + "//" + location.hostname + (location.port ? ':' + location.port: '');
    }

    return location.origin;
};


utilsUrl.getBase = function(url) {
    return url.split('?')[0].split('/').slice(0, -1).join('/')+'/';
};


utilsUrl.makeAbsolute = function(href) {
    const link = document.createElement("a");
    link.href = href;
    return link.href;
};

utilsUrl.getProcessUrl = function(url, originUrl) {
    if (!url || !originUrl) {
        return url;
    }

    url = url.trim();
    originUrl= originUrl.trim();
    const baseUrl = utilsUrl.getBase(originUrl);
    const baseUrlSchema = utilsUrl.getSchema(originUrl);
    const baseUrlOrigin = utilsUrl.getOrigin(originUrl);

    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return baseUrlOrigin + url;
    } else {  //relative
        return baseUrl + url;
    }
};





/***/ }),

/***/ "./src/core/utils/utils.js":
/*!*********************************!*\
  !*** ./src/core/utils/utils.js ***!
  \*********************************/
/*! exports provided: utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return utils; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./src/core/utils/math.js");
/* harmony import */ var _url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./url */ "./src/core/utils/url.js");




//get rid of compiler mess
const math = _math__WEBPACK_IMPORTED_MODULE_0__["math"];
const utilsUrl = _url__WEBPACK_IMPORTED_MODULE_1__["utilsUrl"];


const utils = {};
utils.useCredentials = false; //
utils.forceCredentials = false;
utils.instanceCounter = 0;


utils.validateBool = function(value, defaultValue) {
    if (typeof value === 'boolean') {
        return value;
    } else {
        return defaultValue;
    }
};


utils.validateNumber = function(value, minValue, maxValue, defaultValue) {
    if (typeof value === 'number') {
        return math.clamp(value, minValue, maxValue);
    } else {
        return defaultValue;
    }
};


utils.validateNumberArray = function(array, arraySize, minValues, maxValues, defaultValues) {
    if (Array.isArray(array) && array.length == arraySize) {
        for (let i = 0; i < arraySize; i++) {
            array[i] = math.clamp(array[i], minValues[i], maxValues[i]);
        }
        return array;
    } else {
        return defaultValues;
    }
};


utils.validateString = function(value, defaultValue) {
    if (typeof value === 'string') {
        return value;
    } else {
        return defaultValue;
    }
};


utils.padNumber = function(n, width) {
    const z = '0';

    if (n < 0) {
        n = (-n) + '';
        width--;     //7
        return n.length >= width ? ('-' + n) : '-' + (new Array(width - n.length + 1).join(z) + n);
    } else {
        n = n + '';
        return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
    }
};


utils.decodeFloat16 = function(binary) {
    const exponent = (binary & 0x7C00) >> 10;
    const fraction = binary & 0x03FF;
    return (binary >> 15 ? -1 : 1) * (
        exponent ?
        (
            exponent === 0x1F ?
            fraction ? NaN : Infinity :
            Math.pow(2, exponent - 15) * (1 + fraction / 0x400)
        ) :
        6.103515625e-5 * (fraction / 0x400)
    );
};


utils.simpleFmtObj = (function obj(str, obj) {
    if (!str || str == '') {
        return '';
    }

    return str.replace(/\{([$a-zA-Z0-9][$a-zA-Z0-9]*)\}/g, function(s, match) {
        return (match in obj ? obj[match] : s);
    });
});


utils.simpleWikiLinks = (function obj(str, plain) {
    if (!str || str == '') {
        return '';
    }

    const str2 = utils.simpleFmtObj(str, {'copy':'&copy;', 'Y': (new Date().getFullYear())});

    return str2.replace(/\[([^\]]*)\]/g, function(s, match) {
        match  = match.trim();
        const urls = match.split(' ');//, 1);

        if (urls[0].indexOf('//') != -1) {
            if (plain) {
                if (urls.length > 1) {
                    return '' + match.substring(urls[0].length);
                } else {
                    return '' + urls[0];
                }
            } else {
                if (urls.length > 1) {
                    return '<a href=' + urls[0] + ' target="blank">' + match.substring(urls[0].length)+'</a>';
                } else {
                    return '<a href=' + urls[0] + ' target="blank">' + urls[0]+'</a>';
                }
            }
        }

        return match;
    });
});


utils.simpleFmtObjOrCall = (function obj(str, obj, call) {
    if (!str || str == '') {
        return '';
    }

    return str.replace(/\{([$a-zA-Z(-9][$a-zA-Z(-9]*)\}/g, function(s, match) {
        return (match in obj ? obj[match] : call(match));
    });
});


utils.getABGRFromHexaCode = (function(code) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(code);

    return result ?
    [ parseInt(result[4], 16),
        parseInt(result[3], 16),
        parseInt(result[2], 16),
        parseInt(result[1], 16)]
    : [0,0,0,255];
});


utils.stringifyFunction = (function(fn) {
    // Stringify the code
    return '(' + fn + ').call(self);';
});


utils.isPowerOfTwo = (function(value) {
    return (value & (value - 1)) === 0 && value !== 0;
});


utils.nearestPowerOfTwo = (function(value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
});


utils.fitToPowerOfTwo = (function(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
});


utils.getHash = function(str) {
    if (!str || str.length === 0) {
        return 0;
    }

    let hash = 0, c;
    for (let i = 0, li = str.length; i < li; i++) {
        c   = str.charCodeAt(i);
        hash  = ((hash << 5) - hash) + c;
        hash |= 0; // Convert to 32bit integer
    }

    return hash;
};


utils.convertRGB2YCbCr = function(r, g, b) {
  return [( .299 * r + .587 * g  +  0.114 * b) + 0,
          ( -.169 * r + -.331 * g +  0.500 * b) + 128,
          ( .500 * r + -.419 * g +  -0.081 * b) + 128];
};


utils.convertYCbCr2RGB = function(y, cb, cr) {
  return [1 * y +  0 * (cb-128)      +  1.4 * (cr-128),
          1 * y +  -.343 * (cb-128)  +  -.711 * (cr-128),
          1 * y +  1.765 * (cb-128)  +  0 * (cr-128)];
};


utils.convertHSL2RGB = function(h, s, l){
   let r, g, b, m, c, x;

    h /= 60;
    if (h < 0) h = 6 - (-h % 6);
    h %= 6;

    s = Math.max(0, Math.min(1, s / 100));
    l = Math.max(0, Math.min(1, l / 100));

    c = (1 - Math.abs((2 * l) - 1)) * s;
    x = c * (1 - Math.abs((h % 2) - 1));

    if (h < 1) {
        r = c, g = x, b = 0;
    } else if (h < 2) {
        r = x, g = c, b = 0;
    } else if (h < 3) {
        r = 0, g = c, b = x;
    } else if (h < 4) {
        r = 0, g = x, b = c;
    } else if (h < 5) {
        r = x, g = 0, b = c;
    } else {
        r = c, g = 0, b = x;
    }

    m = l - c / 2

    return [(r + m),
            (g + m),
            (b + m)];
}


utils.getHashColor = function(str) {
    const h = utils.getHash(str);
    const c = utils.convertRGB2YCbCr(h&255,(h>>8)&255,(h>>16)&255);
    c[0] = math.clamp(c[0], 50, 200);
    return utils.convertRGB2YCbCr(c[0],c[1],c[2]);
};


utils.getHashColor2 = function(counter) {
    let h = Math.floor(counter / 18);
    let l = 50;

    if (h >= 1) {
        if (h % 2) {
            l = 50 + ((l * 10) % 30);
        } else {
            l = 50 - (((l-1) * 10) % 30);
        }
     }

    h = (counter % 18) * 20;

    return utils.convertHSL2RGB(h,100,l);
};


utils.loadText = function(path, onLoaded, onError, withCredentials, xhrParams) {
    utils.loadJSON(path, onLoaded, onError, true, withCredentials, xhrParams);
};


utils.loadXML = function(path, onLoaded, onError, withCredentials, xhrParams) {
    const onLoaded2 = (function(data){
        const parser = new DOMParser();
        data = parser.parseFromString(data, 'text/xml');
        if (onLoaded) {
            onLoaded(data);
        }
    });

    utils.loadJSON(path, onLoaded2, onError, true, withCredentials, xhrParams);
};


utils.loadJSON = function(path, onLoaded, onError, skipParse, withCredentials, xhrParams) {
    const xhr = new XMLHttpRequest();

    //xhr.onload  = (function() {
    xhr.onreadystatechange = (function (){

        switch (xhr.readyState) {
        case 0: // UNINITIALIZED
        case 1: // LOADING
        case 2: // LOADED
        case 3: // INTERACTIVE
            break;
        case 4: // COMPLETED
            {
                if (xhr.status >= 400 || xhr.status == 0) {
                    if (onError) {
                        onError(xhr.status);
                    }
                    break;
                }

                const data = xhr.response;
                let parsedData = data;

                if (!skipParse) {
                    try {
                        parsedData = JSON.parse(data);
                    } catch(e) {
                        // eslint-disable-next-line
                        console.log('JSON Parse Error ('+path+'): ' + (e['message'] ? e['message'] : ''));

                        if (onError ) {
                            onError(xhr.status);
                        }

                        return;
                    }
                }

                if (onLoaded) {
                    onLoaded(parsedData);
                }
            }
            break;
        }

    }).bind(this);

    /*
    xhr.onerror  = (function() {
        if (onError) {
            onError();
        }
    }).bind(this);*/

    xhr.open('GET',  path, true);
    xhr.withCredentials = utils.forceCredentials || withCredentials;

    if (xhrParams && xhrParams['token'] /*&& xhrParams["tokenHeader"]*/) {
        //xhr.setRequestHeader(xhrParams["tokenHeader"], xhrParams["token"]); //old way
        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');
    }

    if (xhrParams && xhrParams['charset']) {
        xhr.overrideMimeType('text/xml; charset=' + xhrParams['charset']);
        //xhr.setRequestHeader('Content-type', xhrParams['Content-type']);
    }

    xhr.send('');
};


utils.loadBinary = function(path, onLoaded, onError, withCredentials, xhrParams, responseType) {
    const xhr = new XMLHttpRequest();

    xhr.onreadystatechange = (function (){

        switch (xhr.readyState) {
        case 0: // UNINITIALIZED
        case 1: // LOADING
        case 2: // LOADED
        case 3: // INTERACTIVE
            break;
        case 4: // COMPLETED
            {
                if (xhr.status >= 400 || xhr.status == 0) {
                    if (onError) {
                        onError(xhr.status);
                    }
                    break;
                }

                const abuffer = xhr.response;

                if (!abuffer) {
                    if (onError) {
                        onError();
                    }
                    break;
                }

                if (onLoaded) {
                    onLoaded(abuffer);
                }
            }
            break;

        default:

            if (onError) {
                onError();
            }

            break;
        }

    }).bind(this);

    /*
    xhr.onerror  = (function() {
        if (onError) {
            onError();
        }
    }).bind(this);*/

    xhr.open('GET', path, true);
    xhr.responseType = responseType ? responseType : 'arraybuffer';
    xhr.withCredentials = utils.forceCredentials || withCredentials;

    if (xhrParams && xhrParams['token'] /*&& xhrParams["tokenHeader"]*/) {
        //xhr.setRequestHeader(xhrParams["tokenHeader"], xhrParams["token"]); //old way
        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');
    }

    xhr.send('');
};


utils.headRequest = function(url, onLoaded, onError, withCredentials, xhrParams) {
    const xhr = new XMLHttpRequest();

    xhr.onreadystatechange = (function (){

        switch (xhr.readyState) {
        case 0 : // UNINITIALIZED
        case 1 : // LOADING
        case 2 : // LOADED
        case 3 : // INTERACTIVE
            break;
        case 4 : // COMPLETED
            if (onLoaded != null) {
                onLoaded(xhr.getAllResponseHeaders(), xhr.status);
                    //onLoaded(xhr.getResponseHeader("X-VE-Tile-Info"), xhr.status);
            }
            break;

        default:

            if (onError != null) {
                onError();
            }

            break;
        }

    }).bind(this);

    xhr.onerror  = (function() {
        if (onError != null) {
            onError();
        }
    }).bind(this);

    xhr.open('HEAD', url, true);
    //xhr.responseType = responseType ? responseType : "arraybuffer";
    xhr.withCredentials = utils.forceCredentials || withCredentials;

    if (xhrParams && xhrParams['token'] /*&& xhrParams["tokenHeader"]*/) {
        //xhr.setRequestHeader(xhrParams["tokenHeader"], xhrParams["token"]); //old way
        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');
    }

    xhr.send('');
};


utils.loadImage = function(url, onload, onerror, withCredentials, direct) {
    const image = new Image();
    image.onerror = onerror;
    image.onload = onload;

    if (!direct){
        image.crossOrigin = withCredentials ? 'use-credentials' : 'anonymous';
    }

    image.src = url;
    return image;
};


utils.getParamsFromUrl = function(url) {
    return utilsUrl.getParamsFromUrl(url);
};


const textDecoderUtf8 = (typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;

utils.unint8ArrayToString = function(array) {
    if (textDecoderUtf8) {
        return textDecoderUtf8.decode(array);
    } else {
//        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));

        /*
        const buff = new Uint16Array(array.buffer, array.byteOffset, array.byteLength);
        const getChar = String.fromCharCode;
        //const buff2 = new Array(buff.length);
        const str = '';

        for (let i = 0, li = buff.length; i < li; i++) {
            //buff2[i] = getChar(buff[i]);
            str += getChar(buff[i]);
        }

        return str;
        //return buff2.join('');
        */

        let s = '';
        //const code_points2 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        const code_points2 = new Uint8Array(array.byteLength);
        code_points2.set(array);
        const code_points = new Uint32Array(code_points2.buffer);

        for (let i = 0, li = code_points.length; i < li; ++i) {
          let cp = code_points[i];
          if (cp <= 0xFFFF) {
            s += String.fromCharCode(cp);
          } else {
            cp -= 0x10000;
            s += String.fromCharCode((cp >> 10) + 0xD800,
                                     (cp & 0x3FF) + 0xDC00);
          }
        }
        return s;

    }
}




// only implement if no native implementation is available
/*
if (typeof Array.isArray === 'undefined') {
  Array.isArray = (function(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  });
}*/


/***/ })

/******/ });
//# sourceMappingURL=vts-browser.js.map